{
  "posts": [
    {
      "content": "\n## 什么是 chassis?\n\n\n   Chassis，是一种微服务模式。在这种模式中，用户并不需要自己去处理构建微服务过程中外部配置、日志、健康检查、分布式追踪等，而是将他们交给专门的框架来处理。用户可以更聚焦业务逻辑本身，简单、快速的开发微服务。\n\n**阅读此文，你可以得到什么？**\n\n> 1. chassis 运行时做了什么\n> 2. chassis 运行时的隐藏操作。\n> 3. chassis 设计思路的一些理解\n\n\n### Go-Chassis 是什么？\n\n   \n\n Go-Chassis 是一个go语言的微服务开发框架，采用插件化设计，原生提供了可插拔的注册发现，加密解密，调用链追踪等组件。协议也是插件化的，支持http和grpc，也支持开发者定制私有协议， 开发者只需要专注于实现云原生应用即可。\n\n   \n\n > 云原生应用，基于云服务开发或者针对云服务开发部署的应用。\n\n   \n\n ![chassis 架构图.png](http://media.gusibi.mobi/nOId8YPFqTTV2Ha8kEB9gVaSG9zAEIBgJe7rp2GK7ZsgyHd4vsX8OMrewCuUb3hs)\n\n   \n\n 上图是go-chassis 的架构图，可以看出配置管理（Archaius）、服务注册（Registry）、Metrics、日志（Logger）都是独立的组件，分布式追踪、负载均衡、限流等都是以中间件（Handler Chain）的方式实现的。一个请求进来后会先通过server 转换成chassis invoker，然后经过Handler Chain，最后由Transport 转换成对应协议的response返回。\n\n   \n\n此篇文章主要关注go-chassis 启动过程时做了什么，以及做这些事情的用途。\n\n\n### 一个例子\n\n   \n\n 首先从 hello world 开始， 目录结构如下：\n\n   \n\n```\n   .\n   ├── conf                       # 配置目录，必须\n   │   ├── chassis.yaml           #\n   │   ├── microservice.yaml      # 微服务相关配置，比如server name，注册中心地址\n   └── rest\n       └── main.go                \n```\n\n   \n\nchassis.yaml 内容为：\n\n   \n\n```\n   ---\n   cse:\n     protocols:\n       rest:\n         listenAddress: \"127.0.0.1:5001\"\n     transport:\n       timeout:\n         rest: 1\n     handler:\n       chain:\n         Provider:\n           default: tracing-provider\n```\n\n   \n\nmicroservice.yaml 内容为：\n\n   \n\n```\n   cse:\n     service:\n       registry:\n           address: http://127.0.0.1:30100\n   \n   service_description:\n     name: test-rest-server\n```\n\n   \n\nmain.go\n\n\n```\npackage main\n   \nimport (\n       rf \"github.com/go-chassis/go-chassis/v2/server/restful\"\n       \"log\"\n       \"net/http\"\n   \n       \"github.com/go-chassis/go-chassis/v2\"\n   )\n   \n//RestFulHello is a struct used for implementation of restfull hello program\ntype RestFulHello struct {\n}\n   \n//Sayhi is a method used to reply user with hello world text\nfunc (r *RestFulHello) Sayhi(b *rf.Context) {\n       b.Write([]byte( \"hello world\"))\n       return\n}\n   \n//URLPatterns helps to respond for corresponding API calls\nfunc (r *RestFulHello) URLPatterns() []rf.Route {\n       return []rf.Route{\n           {Method: http.MethodGet, Path: \"/sayhi\", ResourceFunc: r.Sayhi,\n               Returns: []*rf.Returns{{Code: 200}}},\n       }\n}\n   \nfunc main() {\n   chassis.RegisterSchema(\"rest\", &RestFulHello{})\n   if err := chassis.Init(); err != nil {\n       log.Fatal(\"Init failed.\" + err.Error())\n       return\n   }\n    chassis.Run()\n}\n```\n\n\n先来看一下这段代码具体做了什么。\n\n   \n\n   - 11~27  声明了 一个 RestFulHello struct，这个struct 有两个方法 Sayhi 和 URLPatterns，其中URLPatterns 返回一个 Route 列表。 这段代码声明了一个http handler 和 对应的路由，那具体为什么这么写等下再做说明。\n\n\n```\ntype Schema struct {\n    serverName string\n    schema     interface{}\n    opts       []server.RegisterOption\n}\n```\n\n   \n\n- 30行 `chassis.RegisterSchema(\"rest\", &RestFulHello{})` 将前面声明的 RestFulHello 注册到 \"rest\" 服务。\n\n   这里内部只是简单的使用传入的参数创建一个 `chassis.Schema` 然后append到 `chassis.schemas` 中。\n\n- 31行 chassis运行前的初始化工作。\n- 35行 运行chassis 服务。\n\n   \n\n\n![chassis_start.png](http://media.gusibi.mobi/ti_WF2mI4lC_8F_aeZF7-FxgsBcSkcRMZBrjrKv_vAZ87MV0q3P0Uo7Ukk4d9PW_)\n\n   \n\n执行 `go run rest/main.go` 运行代码，会发现启动失败，日志输出内容为：\n\n   \n\n```\n   INFO: Install client plugin, protocol: rest\n   INFO: Install Provider Plugin, name: default\n   INFO: Installed Server Plugin, protocol:rest\n   \n   ERROR: add file source error [[/var/folders/rr/rzqnl9h10y577rch1nsx_jww0000gp/T/go-build725280265/b001/exe/conf/chassis.yaml] file not exist].\n   file:go-chassis@v1.8.3/chassis_init.go:106,msg:failed to initialize conf: [/var/folders/rr/rzqnl9h10y577rch1nsx_jww0000gp/T/go-build725280265/b001/exe/conf/chassis.yaml] file not exist\n   init chassis fail: [/var/folders/rr/rzqnl9h10y577rch1nsx_jww0000gp/T/go-build725280265/b001/exe/conf/chassis.yaml] file not exist\n   Init failed.[/var/folders/rr/rzqnl9h10y577rch1nsx_jww0000gp/T/go-build725280265/b001/exe/conf/chassis.yaml] file not exist\n```\n\n   \n\n通过日志可以看到两个问题：\n\n\n1. 为什么添加了配置还会提示配置找不到？\n2. 为什么配置没有加载成功插件却可以安装成功？\n\n\n## chassis init\n\n\n下图是chassis init 的执行流程：\n\n![chassis_init.png](http://media.gusibi.mobi/RWJvZfc7AZGccP6ML_wP80QLr1_OQVUCccAoGHpdY3RcD2xqeFTmso34HzIL1_iP)\n\n   \n\n### 配置初始化\n\n\n首先看一下chassis 初始化的过程中配置是如何加载的。\n\n\n\n\n![config_init.png](http://media.gusibi.mobi/BruF3mWEA0c2KEh5wqP92EU_c9d44RVFHfYEIkzb5f0IwJ05xYpM_dd6PKb7y-TG)\n\n   \n\n   查看 config.Init() 代码可以看到 配置目录是通过 `fileutil.RouterConfigPath()` 来获取的，目录初始化方法为：\n\n   \n\n```\n   func initDir() {\n       if h := os.Getenv(ChassisHome); h != \"\" {\n           homeDir = h\n       } else {\n           wd, err := GetWorkDir()\n           if err != nil {\n               panic(err)\n           }\n           homeDir = wd\n       }\n   \n       // set conf dir, CHASSIS_CONF_DIR has highest priority\n       if confDir := os.Getenv(ChassisConfDir); confDir != \"\" {\n           configDir = confDir\n       } else {\n           // CHASSIS_HOME has second most high priority\n           configDir = filepath.Join(homeDir, \"conf\")\n       }\n   }\n```\n\n   \n\n> 如果使用  `ChassisHome`  环境变量指定应用目录，chassis 运行时，会从该目录下的 `ChassisHome/conf/`  目录中读取配置\n>\n> 也可以使用 `ChassisConfDir` 直接指定配置目录，ChassisConfDir 优先级高于 `ChassisHome/conf`\n\n   \n\n\nchassis 使用 archaius 来管理配置，*archaius* 初始化时，会从文件、环境变量、命令行、内存中初始化配置。\n\n   \n\n```\n   // InitArchaius initialize the archaius\n   func InitArchaius() error {\n       var err error\n   \n       requiredFiles := []string{\n           fileutil.GlobalConfigPath(),\n           fileutil.MicroServiceConfigPath(),\n       }\n       optionalFiles := []string{\n           fileutil.CircuitBreakerConfigPath(),\n           fileutil.LoadBalancingConfigPath(),\n           fileutil.RateLimitingFile(),\n           fileutil.TLSConfigPath(),\n           fileutil.MonitoringConfigPath(),\n           fileutil.AuthConfigPath(),\n           fileutil.TracingPath(),\n           fileutil.LogConfigPath(),\n           fileutil.RouterConfigPath(),\n       }\n   \n       err = archaius.Init( // 初始化配置\n           archaius.WithCommandLineSource(),\n           archaius.WithMemorySource(),\n           archaius.WithENVSource(),\n           archaius.WithRequiredFiles(requiredFiles),\n           archaius.WithOptionalFiles(optionalFiles))\n   \n       return err\n```\n\n\n\n从代码可以看出，global config 和 microservice config 是必须要有的，\n\n   \n\n> global config 对应  conf_path/chassis.yaml\n>\n> microservice config 对应 conf_path/microservice.yaml\n\n   \n\n接下来读出配置后，给初始化runtime 的值：\n\n> runtime 中的数据可以认为是运行时的全局变量\n\n\n```\n...\n       // runtime 中的数据可以认为是运行时的全局变量\n       runtime.ServiceName = MicroserviceDefinition.ServiceDescription.Name\n       runtime.Version = MicroserviceDefinition.ServiceDescription.Version\n       runtime.Environment = MicroserviceDefinition.ServiceDescription.Environment\n       runtime.MD = MicroserviceDefinition.ServiceDescription.Properties\n       if MicroserviceDefinition.AppID != \"\" { //microservice.yaml has first priority\n           runtime.App = MicroserviceDefinition.AppID\n       } else if GlobalDefinition.AppID != \"\" { //chassis.yaml has second priority\n           runtime.App = GlobalDefinition.AppID\n       }\n       if runtime.App == \"\" {\n           runtime.App = common.DefaultApp\n       }\n   \n       runtime.HostName = MicroserviceDefinition.ServiceDescription.Hostname\n   ...\n```\n\n   \n\narchaius 也支持从配置中心读取配置，通过这种方式，chassis 也提供了运行时配置热加载的功能。\n\n   \n\n**对于第二个问题，为什么插件会先于配置安装？**\n\n### 插件初始化\n\n![init_plugin.png](http://media.gusibi.mobi/Tx6hEjesBGf6eV5S9Yb-T5RCCqkTqNEllvVIUdOeVG73j6FLz_OFXCsFWHWpYGYA)\n\n\n\n从图中可以看出init 做了预先初始化了很多的插件，比如 client、provider、server、log、router rule、register、load balance、service discover、treporter等，并且chassis init 方法中并没有做显式的初始化调用。通过查看代码会发现，这个步骤是使用各自的init 方法自动执行的，类似这样：\n\n```\n// restful server\nfunc init() {\n    server.InstallPlugin(Name, newRestfulServer)\n}\n\n// route rule plugin\nfunc init() { \n    router.InstallRouterService(\"cse\", newRouter)\n}\n\n// init initialize the plugin of service center registry\nfunc init() {\n    registry.InstallRegistrator(ServiceCenter, NewRegistrator)\n    registry.InstallServiceDiscovery(ServiceCenter, NewServiceDiscovery)\n    registry.InstallContractDiscovery(ServiceCenter, newContractDiscovery)\n\n}\n\n// init install plugin of new file registry\nfunc init() {\n    registry.InstallRegistrator(Name, newFileRegistry)\n    registry.InstallServiceDiscovery(Name, newDiscovery)\n}\n```\n\n\n\n之所以隐式加载是因为 chassis 是插件式设计，使用 init 方式加载插件，可以做到对插件的即插即用，需要使用的插件只需要在代码中添加包的import 即可，比如加载grpc 插件，只需要在main.go 中添加 \n\n```\nimport _ \"github.com/go-chassis/go-chassis-extension/protocol/grpc/server\"\n```\n\n\n> 从这一系列插件安装方式也能看出，对于chassis 来说，注册中心，协议，负载均衡等都是插件，这也就意味着这些插件都是可替换的，方便二次开发。\n\n\n\n以上两个问题现在都解决了，现在执行以下命令运行服务：\n\n\n\n```\nCHASSIS_CONF_DIR=`pwd`/conf go run rest/main.go\n```\n\n\n\n### 初始化handler chain\n\n\n\nHandler是微服务在运行过程中在框架层面里的一个最小处理单元。go chassis通过handler和handler的组装实现组件化的运行模型架构。其基本的使用方式就是实现接口、注册逻辑：\n\n\n\nHandler 定义非常简单，实现了Handler 接口就可以认为创建了一个Handler。\n\n\n```\n// Handler interface for handlers\ntype Handler interface {\n    // handle invocation transportation,and tr response\n    Handle(*Chain, *invocation.Invocation, invocation.ResponseCallBack)\n    Name() string\n}\n```\n\n使用RegisterHandler 函数将添加到HandlerFuncMap 中即可在CreateHandler 调用时使用。\n\n```\n// RegisterHandler Let developer custom handler\nfunc RegisterHandler(name string, f func() Handler) error {\n    if stringutil.StringInSlice(name, buildIn) {\n        return errViolateBuildIn\n    }\n    _, ok := HandlerFuncMap[name]\n    if ok {\n        return ErrDuplicatedHandler\n    }\n    HandlerFuncMap[name] = f\n    return nil\n}\n```\n\n对于chassis 来说，协议转换，权限验证，全链路追踪等都可以认为是一个handler（中间件），这里会从配置中读取声明的handler，并且初始化。请求调用时，会按照配置文件中的定义的顺序进入handler进行处理。\n\n\n\n![handler_chain_init.png](http://media.gusibi.mobi/wxzssdKUklFg3Z1mY7QH_9cfBPIfBT3JwGb99ZwfBYcMQ_Rw_TILJWCD0rUPDh99)\n\n\n\n在服务初始化的过程中，go-chassis 会根据配置文件中的定义加载需要的handler，handler 分为provider、consumer和 default 三种，配置内容示例如下：\n\n```\nhandler:\n    chain:\n      Provider:\n        default: tracing-provider\n        rest: jwt\n```\n\n\n\n> **如果配置了非default 的type，服务启动的时候只会执行此特定的handler，比如上述配置，handler 只会执行 jwt，而忽略tracing-provider**\n\n\n\n\n\n这是因为chassis 使用map存储 handler chain，map 的key 为 chainType+chainName， `default` 也是一种chainType，如果name(即chain type)有值则使用对应的 chain，否则使用default。\n\n\n```\ntype Chain struct {\n    ServiceType string\n    Name string\n    Handlers []Handler\n}\n\n// GetChain is to get chain\nfunc GetChain(serviceType string, name string) (*Chain, error) {\n    if name == \"\" {\n        name = common.DefaultChainName\n    }\n    origin, ok := ChainMap[serviceType+name]\n    if !ok {\n        return nil, fmt.Errorf(\"get chain [%s] failed\", serviceType+name)\n    }\n    return origin, nil\n}\n\n// \nchainMap := chaninMap[strint]*Chain{\n    \"Provider+rest\":  &Chain{\n          ServiceType: \"Provider\",\n          Name: \"rest\",\n          Handlers: []Handler{jwt},},\n    \"Provider+default\": &Chain{\n          ServiceType: \"Provider\",\n          Name: \"default\",\n          Handlers: []Handler{tracing-provider}},,\n}\n```\n\n\n\n\n\n### 初始化 server\n\n\n\n![init_server.png](http://media.gusibi.mobi/ilHWFRDKFGZBxP7BCpvqHoDGaiYco4M6Rbzi5kDvyNQBtx5X7nRK1Hz9rv9fMulU)\n\n\n初始化的前提是服务已经加载，加载的步骤在init 之前就已经通过 init 方法载入了。\n\n\n\n```\n//Init initializes\nfunc Init() error {\n    var err error\n    for k, v := range config.GlobalDefinition.Cse.Protocols {\n        if err = initialServer(config.GlobalDefinition.Cse.Handler.Chain.Provider, v, k); err != nil {\n            log.Println(err)\n            return err\n        }\n    }\n    return nil\n}\n```\n\n\n\n这里初始化的是配置文件中 `protocols` 指定的服务。\n\n\n```\n//获取服务的方法\nfunc GetServerFunc(protocol string) (NewFunc, error) {\n    f, ok := serverPlugins[protocol]\n    if !ok {\n        return nil, fmt.Errorf(\"unknown protocol server [%s]\", protocol)\n    }\n    return f, nil\n}\n```\n\n> 这里会从 `*var* serverPlugins = make(*map*[string]NewFunc)`  读取server，所以在初始化时需要先安装server 对应的插件\n>\n> chassis 会 默认安装rest 插件，对于grpc 需要首先指定\n\n\n\n```\n// p 对应 protocal 中的配置\nif p.Listen == \"\" {\n        if p.Advertise != \"\" {\n            p.Listen = p.Advertise\n        } else {\n            p.Listen = iputil.DefaultEndpoint4Protocol(name)\n        }\n    }\n```\n\n\n\n> 服务的Listen Advertise 优先级最高，如果 Advertise 和 Listen 都没有配置，使用默认配置。\n\n初始化 server options，其中chainName 如果Provider 配置了对应 protocol  name 的值，则使用protocol name。\n\n```\nchainName := common.DefaultChainName\n    if _, ok := providerMap[name]; ok {\n        chainName = name\n    }\n\no := Options{\n        Address:            p.Listen,  // 配置中监听的端口\n        ProtocolServerName: name,      // protocal provider 中的名字，比如 rest grpc\n        ChainName:          chainName, // protocal provider 中的名字，比如 rest grpc\n        TLSConfig:          tlsConfig,\n        BodyLimit:          config.GlobalDefinition.Cse.Transport.MaxBodyBytes[\"rest\"],\n    }\n```\n\n\n\n### 其它\n\n\n\n几个初始化外，init 还包括 register、configcenter、router、contorl、tracing、metric、reporter、熔断器、事件监听等就不再细说了。\n\n\n\n为止，chassis 所需要的初始化步骤已经结束，接下来就是 服务运行的步骤。\n\n\n\n## chassis run\n\n\n\n首先看一下 chassis.Run() 启动的整体流程\n\n\n\n![chassis_run.png](http://media.gusibi.mobi/DSd1K4nvCFlb-5U-hTfqby7OxsN_wf7uhOP6Xm1qb3zNAYa_Owp1C7YTotwlDW4q)\n\n\n\n\n\n**chassis 运行**主要分为三个动作：\n\n1. 根据schema 找到服务，将对应的handle func 使用 handler chain 封装\n2. 启动服务，将服务注册到服务中心\n3. 监听退出信号\n\n\n\n**这里使用rest 服务作为例子看一下 chassis 启动服务的时候做了哪些操作。**\n\n\n### 服务注册\n\n\n\n首先回顾一下hello world 代码：\n\n```\n//RestFulHello is a struct used for implementation of restfull hello program\ntype RestFulHello struct {\n}\n\n//Sayhi is a method used to reply user with hello world text\nfunc (r *RestFulHello) Sayhi(b *rf.Context) {\n    b.Write([]byte( \"hello world\"))\n    return\n}\n\n//URLPatterns helps to respond for corresponding API calls\nfunc (r *RestFulHello) URLPatterns() []rf.Route {\n    return []rf.Route{\n        {Method: http.MethodGet, Path: \"/sayhi\", ResourceFunc: r.Sayhi,\n            Returns: []*rf.Returns{{Code: 200}}},\n    }\n}\n\nchassis.RegisterSchema(\"rest\", &RestFulHello{}) // 第一个参数即是服务名，第二个参数是 Router\n```\n\n\n\n`RestFulHello` ，其中有一个 `URLPatterns() []Route` 方法，实现了 `Router ` 接口。 \n\n\n\n**Router 定义**\n\n\n\n```\n//Router is to define how route the request\ntype Router interface {\n    //URLPatterns returns route\n    URLPatterns() []Route\n}\n```\n\n\n\n![chassis_restful_register.png](http://media.gusibi.mobi/diDeLEpGlaS-hEyv60YQc2s6jb5AmxfMBLIqiAsAU7W72KQ94umSLJpr7U_sMH1n)\n\n\n```\n// HTTPRequest2Invocation convert http request to uniform invocation data format\nfunc HTTPRequest2Invocation(req *restful.Request, schema, operation string, resp *restful.Response) (*invocation.Invocation, error) {\n    inv := &invocation.Invocation{\n        MicroServiceName:   runtime.ServiceName,\n        SourceMicroService: common.GetXCSEContext(common.HeaderSourceName, req.Request),\n        Args:               req,\n        Reply:              resp,\n        Protocol:           common.ProtocolRest,\n        SchemaID:           schema,\n        OperationID:        operation,\n        URLPathFormat:      req.Request.URL.Path,\n        Metadata: map[string]interface{}{\n            common.RestMethod: req.Request.Method,\n        },\n    }\n    //set headers to Ctx, then user do not  need to consider about protocol in handlers\n    m := make(map[string]string)\n    inv.Ctx = context.WithValue(context.Background(), common.ContextHeaderKey{}, m)\n    for k := range req.Request.Header {\n        m[k] = req.Request.Header.Get(k)\n    }\n    return inv, nil\n}\n```\n\n\n启动的服务注册流程中包含了将schemas 中所有Router 取出遍历，调用 `WrapHandlerChain()` 函数，这个函数主要做了以下工作：\n\n1. 取出 Route 中 ResourceFunc （即real handler func）\n2. 将 HttpRequest 转换成 chassis Invocation，\n3. 将Invocation 再添加回 request 中添加到 handler chain 中\n4. 返回一个闭包函数。\n\n\n最后会把使用 `WrapHandlerChain` 封装后的handler 注册到go-restful 框架中。\n\n响应请求时，调用关系类似以下操作:\n\n```\nfunc handle(){\n    func handle1(){\n        func handle2(){\n            func handle3(){\n                real_handle_func()\n            }()\n        }()\n    }()\n}\n```\n\n\n**为什么需要转换成统一的invocation？**\n\n\n\n不同协议请求进入到对应的Server，Server将具体的协议请求转换为Invocation统一抽象模型，并传入Handler chain，由于handler根据统一模型Invocation进行处理，不必每个协议开发出来都自己开发一套治理。处理链可通过配置更新，再进入Transport handler，使用目标微服务的协议客户端传输到目标。\n\n这种方式实际上真正提供业务处理的还是各个server 插件，chassis 只是中间商，可以对request 和 response 做它想要的处理，比如限流，熔断，路由更新等。\n\n![server.png](http://media.gusibi.mobi/5RO9xrwmzFuRH1wVtncbC4R3Z9FNr283opNevd5yCeAar0tFDIw_fsTeFUkud1xV)\n\n\n\n1. 接收到协议请求后，由各协议Server转为统一的Invocation模型\n2. Invocation进入处理链处理\n3. 处理结束后，进入具体的业务处理逻辑\n\n\n\n### 信号监听\n\n\n\n当服务需要关闭或重启时，应当处理完当前的请求或者设置为超时，而不是粗暴的断开链接，chassis 这里使用了信号监听的方式来处理关闭信号。\n\n![gracefully_shutdown.png](http://media.gusibi.mobi/qipE63KL-Tjhy6DubK_iyF7W_Rjqae2HrsB3bUFy-FlNVnaAme5qjgyIBEZK1BlB)\n\n```\nfunc waitingSignal() {\n    //Graceful shutdown\n    c := make(chan os.Signal) // 创建一个os.Signal channel\n    // 注册要接收的信号\n    signal.Notify(c, syscall.SIGINT, syscall.SIGHUP, syscall.SIGTERM, syscall.SIGQUIT, syscall.SIGILL, syscall.SIGTRAP, syscall.SIGABRT)\n    select {\n    case s := <-c:\n        openlogging.Info(\"got os signal \" + s.String())\n    case err := <-server.ErrRuntime:\n        openlogging.Info(\"got server error \" + err.Error())\n    }\n\n    // 判断服务是否有注册\n    if !config.GetRegistratorDisable() {\n        registry.HBService.Stop()// 停掉心跳服务\n        openlogging.Info(\"unregister servers ...\")\n        // 从server center 中退出\n        if err := server.UnRegistrySelfInstances(); err != nil {\n            openlogging.GetLogger().Warnf(\"servers failed to unregister: %s\", err)\n        }\n    }\n\n    for name, s := range server.GetServers() {\n        // 遍历服务，调用服务的 stop 方法\n        openlogging.Info(\"stopping server \" + name + \"...\")\n        err := s.Stop()\n        if err != nil {\n            openlogging.GetLogger().Warnf(\"servers failed to stop: %s\", err)\n        }\n        openlogging.Info(name + \" server stop success\")\n    }\n\n    openlogging.Info(\"go chassis server gracefully shutdown\")\n}\n```\n\n\n\n这里使用go信号通知机制通过往一个channel中发送`os.Signal`实现的。创建一个os.Signal channel，然后使用`signal.Notify`注册要接收的信号，chassis 关注以下信号：\n\n\n\n| 信号    | 值   | 动作 | 说明                                         |\n| ------- | ---- | ---- | -------------------------------------------- |\n| SIGHUP  | 1    | Term | 终端控制进程结束(终端连接断开)               |\n| SIGINT  | 2    | Term | 用户发送INTR字符(Ctrl+C)触发                 |\n| SIGQUIT | 3    | Core | 用户发送QUIT字符(Ctrl+/)触发                 |\n| SIGILL  | 4    | Core | 非法指令(程序错误、试图执行数据段、栈溢出等) |\n| SIGTRAP | 5    | Core | Trap指令触发(如断点，在调试器中使用)         |\n| SIGABRT | 6    | Core | 调用abort函数触发                            |\n| SIGTERM | 15   | Term | 结束程序(可以被捕获、阻塞或忽略)             |\n\n\n接收到信号后，首先判断是否注册到服务中心，如果注册，停掉心跳发送，退出注册，然后调用 server.Shutdown() 来优雅退出。\n\n\n\n\n> go http Server 从1.8 之后支持优雅退出。\n\n   \n\n具体实现可以参考此文章：http://xiaorui.cc/archives/5803\n\n   \n\n## 总结\n\n\n这篇文章介绍了 chassis 服务启动的过程，主要介绍了init 中 配置 、插件、handler chain 、server 的初始化流程，然后分析了服务启动时做了哪些操作以及对服务退出的处理。\n\n   \n\n## 参考链接\n\n1. [使用ServiceComb Go-chassis构建微服务](https://www.infoq.cn/article/ServiceComb-Go-chassis-micro-service)\n2. [Pattern: Microservice chassis](http://microservices.io/patterns/microservice-chassis.html)\n3. [Linux Signal及Golang中的信号处理](https://colobu.com/2015/10/09/Linux-Signals/)\n4. [源码分析golang http shutdown优雅退出的原理](http://xiaorui.cc/archives/5803)\n5. [Go语言微服务开发框架实践-go chassis](https://juejin.im/post/6844903682362834952)\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/WDz3v4cU4LQq1oyKX-fYK1LxIThzZ1hK931ZaPRC8CdcB0t2oTYJciMDuAws70FY)",
      "data": {
        "title": "chassis 运行时做了什么？",
        "date": "2020-11-29 14:01:24",
        "tags": [
          "go",
          "golang",
          "development",
          "后端",
          "微服务"
        ],
        "published": true,
        "hideInList": false,
        "feature": "http://media.gusibi.mobi/wfCxiW0ZpOJ81qw83qINP9jrRtAiFGlJ9jw3lko7L0w5eY79ojwhOw0rGhd3BXpk",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "go-chassis-init"
    },
    {
      "content": "> 使用常用模式学习关于go语言可变参数函数的一切\n\n[Ultimate Guide to Go Variadic Functions 原文地址](https://blog.learngoprogramming.com/golang-variadic-funcs-how-to-patterns-369408f19085)\n\n# 什么是可变参数函数？\n\n可变参数函数是指传入参数是可变数量（0到更多）的函数。在输入的变量类型前面的省略号(三点)前缀即构成一个有效的变量。\n\n![2](http://media.gusibi.mobi/-kn_OQyfZYXrKDs4rz2CYh3wtwEQUaEa5gjqqcZd1Db8S-Bm1UtlS3R5Pg_7wT-j)\n\n> 声明一个可变参数名为“ names”，类型为string 的可变参数函数\n\n## 一个简单的可变参数函数\n\n这个 func 以字符串的形式返回传递的参数，字符串之间用空格分隔。\n\n```golang\nfunc toFullname(names ...string) string {\n  return strings.Join(names, \" \")\n}\n```\n\n![Image for post](https://miro.medium.com/max/10000/1*_rdOI_SbL9m07QBcKMqz5Q.png)You can pass zero or more params\n\n## 你可以传入零个或多个参数\n\n```go\ntoFullname(\"carl\", \"sagan\")// output: \"carl sagan\"\ntoFullname(\"carl\")// output: \"carl\"\ntoFullname()// output: \"\"\n```\n\n## 什么时候使用可变参数函数？\n\n- *省略创建仅作为函数参数创建临时 slice 变量*\n- *当输入参数的长度未知时*\n- *表达你增加可读性的意图*\n\n## 例子:\n\n看看 `Go Stdlib` 的 `fmt. Println` 函数，就会明白它是如何使自己变得易于使用的。\n\n它使用可变参数函数接受可选的输入参数数目。\n\n```go\nfunc Println(a ...interface{})\n```\n\n如果它不是一个可变参数函数，它看起来会是这样的:\n\n```go\nfunc Println(params []interface{})\n```\n\n你需要传递一个 slice 才能使用它ーー verbose，是的! :\n\n```go\nfmt.Println([]interface{}{\"hello\", \"world\"})\n```\n\n相比而言，在可变参数函数形式中，它的使用是简单的:\n\n```go\nfmt.Println(\"hello\", \"world\")\nfmt.Println(\"hello\")\nfmt.Println()\n```\n\n> 在这之后的部分，将会介绍一些关于 可变参数函数 的细节和常用模式的例子。\n\n# 切片与可变参数函数\n\n可变参数在函数中会被转换为“新的”切片。可变参数实际上是 slice 类型的参数的语法糖。\n\n![3](http://media.gusibi.mobi/ELkTXYrLqO41gRC0fl7rz971NPHdCcS0yExDtNqgFCNMjNigJGgDik0XI-tXw3wi)\n\n## 不传入参数\n\n如果不向其传递任何值，就相当于向可变参数函数传递了 nil 切片。\n\n![4](http://media.gusibi.mobi/9RBDcXhqLuLBy4oZOANH_3w6Bez2l5vTYpZounxZna8HaWhiaPXtg9o2g_3dYpgC)\n\n所有非空切片都有内建数组，而 nil 片则没有。\n\n```go\nfunc toFullname(names ...string) []string {\n  return names\n}\n\n// names 内建数组为: nil\n```\n\n但是，当你向可变参数函数添加参数时，它将创建一个与你传入参数相关联的数组，而不再是一个空切片。\n\ngo语言内置函数`append` 将参数追加到现有的slice，并返回。`append` 也是一个可变参数函数。\n\n```go\nfunc toFullname(names ...string) []string {\n  return append(names, \"hey\", \"what's up?\")\n}\n\ntoFullname()\n\n// output: [hey what's up?]\n```\n\n## 如何传递一个切片？\n\n通过将可变参数运算符`...` 加在现有切片后，可以将其传递给可变参数运算符。\n\n```go\nnames := []string{\"carl\", \"sagan\")}\n\ntoFullname(names...)// output: \"carl sagan\"\n```\n\n这等同于以下调用:\n\n```go\ntoFullname(\"carl\", \"sagan\")\n```\n\n**但是，有一点不同：** ，在函数中将直接使用传入的切片而不是创建新的切片。关于这一点，请参阅以下内容。\n\n![5](http://media.gusibi.mobi/I78AMp2oauglKBaN-v2vInPqqOddUZSAnsOLwqI-nOQUu1tUZq5E6H2kb_ksQems)\n\n像下面这样，你也可以将数组作为可变参数函数的参数:\n\n```go\nnames := [2]string{\"carl\", \"sagan\"}\ntoFullname(names[:]...)\n```\n\n## Passed slice’s spooky action at a distance\n\n> 标题不知道怎么翻译...\n\n假设你将一个 slice 作为参数传给一个可变参数函数:\n\n```go\ndennis := []string{\"dennis\", \"ritchie\"}\ntoFullname(dennis...)\n```\n\n再假设你修改了函数中变量参数的第一项:\n\n```go\nfunc toFullname(names ...string) string {\n  names[0] = \"guy\"\n  return strings.Join(names, \" \")\n}\n```\n\n修改它也会影响原始的切片。“ dennis”切片现在变成了:\n\n```go\n[]string{\"guy\", \"ritchie\"}\n```\n\n而不是原始值:\n\n```go\n[]string{\"dennis\", \"ritchie\"}\n```\n\n因为传入的 slice 与 func 内部的 slice 共享相同的底层数组，所以在 func 内部改变 slice 的值也会影响传入的 slice:\n\n![6](http://media.gusibi.mobi/AbFuGA5LzxztjxBQ_D7oWHdkh-AZifMm4m1_E-iGRbezqRmO3ZeT-siWIfoYBnWc)\n\n如果你直接传递参数(不使用切片) ，就不会发生这种情况。\n\n## 动态传递多个切片\n\n假设你想在 slice 传递给 func 之前，在 slice 前面添加“ mr. ”。\n\n```go\nnames := []string{\"carl\", \"sagan\"}\n```\n\n首先`append` 函数会创建一个新的切片，然后将names展开， 然后将值依次添加到新创建的切片上，然后再将展开的结果传给 `toFullname` 函数:\n\n```go\ntoFullname(append([]string{\"mr.\"}, names...)...)\n\n// output: \"mr. carl sagan\"\n```\n\n这和下面的代码一样:\n\n```go\nnames = append([]string{\"mr.\"}, \"carl\", \"sagan\")\ntoFullname(names...)\n\n// or with this:\ntoFullname([]string{\"mr.\", \"carl\", \"sagan\"}...)\n\n// or with this—except passing an existing slice:\ntoFullname(\"mr.\", \"carl\", \"sagan\")\n```\n\n## 返回传入的切片\n\n不能使用可变参数作为返回结果类型，但是可以将其作为片返回。\n\n```go\nfunc f(nums ...int) []int {\n  nums[1] = 10\n  return nums\n}\n```\n\n当你将一个 slice 作为参数传入 f 时，它将返回一个相同的新 slice。传入和返回的切片是相关联的。两个中任意一个改变都会影响到另一个。\n\n```go\nnums  := []int{23, 45, 67}\nnums2 := f(nums...)\n```\n\n这里，nums 和 nums2有相同的元素，因为它们都指向相同的底层数组。\n\n```go\nnums  = []int{10, 45, 67}\nnums2 = []int{10, 45, 67}\n```\n\n👉 [这段代码](https://play.golang.org/p/Jun14DYWvq) 包含关于 slice 基础数组的详细说明\n\n## 扩展操作符反模式\n\n如果你有一个 funcs，它们唯一的用途就是接受可变数量的参数，那么最好使用可变参数函数代替使用 slice。\n\n```go\n// Don't do this\ntoFullname([]string{\"rob\", \"pike\"}...)\n\n// Do this\ntoFullname(\"rob\", \"pike\")\n```\n\n[运行代码](https://play.golang.org/p/oKQjwotLC_)\n\n## 使用可变参数的长度\n\n你可以使用可变参数的长度来改变函数的行为。\n\n```go\nfunc ToIP(parts ...byte) string {\n  parts = append(parts, make([]byte, 4-len(parts))...)  \n  \n  return fmt.Sprintf(\"%d.%d.%d.%d\", \n    parts[0], parts[1], parts[2], parts[3])\n}\n```\n\nToIP func 将“ parts”作为可变参数，并使用 parts param 的长度返回默认值为0的字符串形式的 IP 地址。\n\n```go\nToIP(255)   // 255.0.0.0\nToIP(10, 1) // 10.1.0.0\nToIP(127, 0, 0, 1) // 127.0.0.1\n```\n\n[运行代码](https://play.golang.org/p/j9RcLvbs3K)\n\n# ✪ 变量函数的签名\n\n尽管可变参数函数是一种语法糖，但它的签名[类型标识](https://golang.org/ref/spec#Type_identity)与接受切片的函数是不同的。\n\n举个例子看一下字符串切片和 ...字符串的区别是什么？\n\n***一个可变参数函数的签名:***\n\n```go\nfunc PrintVariadic(msgs ...string)// signature: func(msgs ...string)\n```\n\n***非可变参数函数的签名:***\n\n```go\nfunc PrintSlice(msgs []string)// signature: func([]string)\n```\n\n*它们的类型标识不一样，我们把它们赋值给变量:*\n\n```go\nvariadic := PrintVariadic   // variadic is a func(...string)\nslicey := PrintSlice       // slice is a func([]string)\n```\n\n因此，其中一个不能替代另一个:\n\n```go\nslicey = variadic// error: type mismatch\n```\n\n[运行代码](https://play.golang.org/p/fsZYGgTyvF)\n\n# 混合变量和非可变参数\n\n你可以通过把非可变参数放在可变参数之前，将非可变参数与可变参数混合。\n\n```go\nfunc toFullname(id int, names ...string) string {\n  return fmt.Sprintf(\"#%02d: %s\", id, strings.Join(names, \" \"))\n}\n\ntoFullname(1, \"carl\", \"sagan\")// output: \"#01: carl sagan\"\n```\n\n但是，你不能将非可变参数放到可变参数之后:\n\n```go\nfunc toFullname(id int, names ...string, age int) string {}// error\n```\n\n[运行代码](https://play.golang.org/p/TlbDYapOCD)\n\n## 接受变量类型的参数\n\n例如，[*Go Stdlib 的 Printf*](https://golang.org/src/fmt/print.go#L189) 函数，使用空接口类型接受任何类型的输入参数。你还可以使用空接口接受任意类型和任意数量的参数。\n\n```go\nfunc Printf(format string, a ...interface{}) (n int, err error) {\n    /* this is a pass-through with a... */  \n    return Fprintf(os.Stdout, format, a...)\n}\n\nfmt.Printf(\"%d %s %f\", 1, \"string\", 3.14)    // output: \"1 string 3.14\"\n```\n\n## 为什么 Printf 只接受一个变量参数？\n\n查看 Printf 的签名时，会发现它接受一个名为 format 的字符串和一个可变参数。\n\n```go\nfunc Printf(format string, a ...interface{})\n```\n\n这是因为format是必需的参数。Printf 强制您提供它，否则代码将无法编译。\n\n如果它通过一个可变参数接收所有参数，那么调用方可能没有提供必要的格式化程序参数，或者从可读性角度来看，它不会像这个参数那么明确。*它清楚地标明了 Printf 需要什么*。\n\n此外，调用时不传人变量参数“a”，它将防止 *Printf* 在 函数中创建一个不必要的切片，一个值为 nil 切片。*This may not be a clear win for Printf but it can be for you in your own code*。\n\n你也可以在自己的代码中使用相同的模式。\n\n## 注意空接口类型\n\n`interface{}`类型也称为空接口类型，这意味着它绕过了自身的 Go 静态类型语义检查。不必要地使用它会给你带来弊大于利的后果。\n\n例如，它可能强制你使用[*reflection*](https://blog.golang.org/laws-of-reflection)，这是一个运行时特性(*instead of fast and safe — compile-time)*。你可能需要自己查找类型错误，而不是依赖于编译器帮你找到它们。\n\n> 在使用空接口之前要仔细考虑，依靠显式类型和接口来实现所需的行为。\n\n## 将切片传递给具有空接口的可变参数\n\n你不能将一个普通的切片传递给一个具有空接口类型的可变参数。具体原因[请阅读这里](https://golang.org/doc/faq#convert_slice_of_interface)。\n\n```go\nhellos := []string{\"hi\", \"hello\", \"merhaba\"}\n```\n\n*You expect this to work, but it doesn’t:*\n\n你可能期望这能生效，但事实并非如此:\n\n```go\nfmt.Println(hellos...)\n```\n\n因为，hello 是一个字符串，而不是一个空接口切片。可变参数或切片只能属于一种类型。\n\n首先需要将 *hellos* slice 转换为一个空接口 slice:\n\n```go\nvar ihellos []interface{} = make([]interface{}, len(hello))for i, hello := range hellos {\n  ihellos[i] = hello\n}\n```\n\n*Now, the expansion operator will work:*\n\n现在，扩展运算符将开始生效:\n\n```go\nfmt.Println(ihellos...)\n// output: [hi hello merhaba]\n```\n\n[运行代码](https://play.golang.org/p/8uRHsHFKSx)\n\n# 函数式编程方面\n\n你还可以使用可变参数函数接受可变数目的函数。让我们声明一个新的 formatter func 类型。格式化程序 func 获取并返回一个字符串:\n\n```go\ntype formatter func(s string) string\n```\n\n让我们声明一个可变参数函数，它接受一个字符串和数量可选的可格式化的类型，以便使用一些pipeline来格式化字符串。\n\n```go\nfunc format(s string, fmtrs ...formatter) string {\n  for _, fmtr := range fmtrs {\n    s = fmtr(s)\n  }  return s\n}\n\nformat(\" alan turing \", trim, last, strings.ToUpper)// output: TURING\n```\n\n[运行代码](https://play.golang.org/p/kCOP6_5h-t)\n\n您还可以使用channels、structs等来代替这种链式模式的函数。看* [*这里*](https://golang.org/pkg/io/#MultiReader) *或者* [*这里*](https://golang.org/src/text/template/parse/parse.go?s=1642:1753#L41) *查看示例.*\n\n## 使用结果为slice的函数作为可变参数\n\n让我们重复使用上面的“format func”来创建一个可重用的格式化管道构建器:\n\n```go\nfunc build(f string) []formatter {\n  switch f {\n    case \"lastUpper\":\n      return []formatter{trim, last, strings.ToUpper}\n    case \"trimUpper\":\n      return []formatter{trim, strings.ToUpper}\n    // ...etc\n    default:\n      return identityFormatter\n  }\n}\n```\n\n然后使用 expand 运算符运行它，最后将结果提供给格式 func:\n\n```go\nformat(\" alan turing \", build(\"lastUpper\")...)// output: TURING\n```\n\n## 可变参数选项模式\n\n*You may have already been familiar with this pattern from other OOP langs and this has been re-popularized again in Go by Rob Pike* [*here*](https://commandcenter.blogspot.com.tr/2014/01/self-referential-functions-and-design.html) *back in 2014. It’s like the* [*visitor pattern*](https://en.wikipedia.org/wiki/Visitor_pattern)*.*\n\n你可能已经熟悉这种来自其他 OOP 语言的模式，这种[模式](https://commandcenter.blogspot.com.tr/2014/01/self-referential-functions-and-design.html)在2014年 Rob Pike 的 Go 中再次流行起来。这就像是[访客模式](https://en.wikipedia.org/wiki/Visitor_pattern)。\n\n这个例子对你来说可能有点难。如果有不理解的请及时提问<作者不在，查看原文链接提问吧😂>。\n\n让我们创建一个 Logger，可以使用可选模式在运行时更改详细程度和前缀:\n\n```go\ntype Logger struct {\n  verbosity\n  prefix string\n}\n```\n\n使用一个可变的选项参数来改变logger的行为:\n\n```go\nfunc (lo *Logger) SetOptions(opts ...option) {\n  for _, applyOptTo := range opts {\n    applyOptTo(lo)\n  }\n}\n```\n\n我们创建一些返回配置方法的函数，它们在一个闭包中改变 Logger 的操作行为：\n\n```go\nfunc HighVerbosity() option {\n  return func(lo *Logger) {\n    lo.verbosity = High\n  }\n}\n\nfunc Prefix(s string) option {\n  return func(lo *Logger) {\n    lo.prefix = s\n  }\n}\n```\n\n现在，让我们用默认选项创建一个新的 Logger:\n\n```go\nlogger := &Logger{}\n```\n\n然后通过变量参数向记录器提供选项:\n\n```go\nlogger.SetOptions(\n  HighVerbosity(), \n  Prefix(\"ZOMBIE CONTROL\"),\n)\n```\n\n现在让我们检查一下输出:\n\n```go\nlogger.Critical(\"zombie outbreak!\")\n// [ZOMBIE CONTROL] CRITICAL: zombie outbreak!\n\nlogger.Info(\"1 second passed\")\n// [ZOMBIE CONTROL] INFO: 1 second passed\n```\n\n[运行代码](https://play.golang.org/p/X2XHSdYgdq)\n\n# ✪ 无穷无尽的精神食粮！\n\n- 在 Go 2中，有一些可变函数的行为的计划*[*这里*](https://github.com/golang/go/issues/15209)*,* [*here 这里*](https://github.com/golang/go/issues/18605)*,及*[*这里*](https://github.com/golang/go/issues/19218)*.*\n- *你可以在 Go 语言标准文档里找到更正式的可变参数函数指南,*[*这里*](https://golang.org/ref/spec#Passing_arguments_to_..._parameters)*,* [*这里*](https://golang.org/ref/spec#Appending_and_copying_slices)*,* [*这里*](https://golang.org/ref/spec#Appending_and_copying_slices) *及*[*这里*](https://golang.org/ref/spec#Type_identity)*.*\n- [*使用来自 c 的可变函数*](https://sunzenshen.github.io/tutorials/2015/05/09/cgotchas-intro.html)*.*\n- *你可以找到很多语言的可变参数函数声明*[*这里*](https://rosettacode.org/wiki/Variadic_function)*.自由探索吧*\n\n好了，就到这了。谢谢你们的阅读。",
      "data": {
        "title": "【译】golang 可变参数函数终极指南",
        "date": "2020-08-16 22:29:38",
        "tags": [
          "golang"
        ],
        "published": true,
        "hideInList": false,
        "feature": "http://media.gusibi.mobi/fOAjbsODtw2AeVd8OagAvADNACJHu1XFE1MKQ_EBauaKHh7K05KruNKG0SHWU82A",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "Ultimate-Guide-to-Go-Variadic-Functions"
    },
    {
      "content": "\n<!-- more -->\n\n\n### 阅读的目的\n\n\n微服务是一种分布式系统解决方案，最近几年工作中使用的是微服务架构来部署服务，但自己接触到的主要是业务开发相关的工作，对微服务的了解主要偏实战方面，而对于构建、集成、分解、测试、部署、监控、架构演进等相关内容没有系统性的了解过，此书内容比较全面，包含了微服务设计的各种主题，读这本书主要希望可以系统性的了解一下微服务的方方面面。\n\n\n\n### 本书的整体框架\n\n\n\n这本书主要基于主题来组织内容，主要包含以下主题：\n\n\n\n1. 微服务基本概念的介绍，\n2. 如何构建微服务，\n3. 什么样的服务集成技术对微服务最有帮助，\n4. 如何把一个大的单块系统分解成微服务，\n5. 如何部署微服务，\n6. 如何测试微服务以确保软件质量，\n7. 对于复杂的分布式系统如何监控，\n8. 如何安全的使用微服务，\n9. 使用康威定律解释开发人员组织结构和系统设计的相互租用，\n10. 介绍规模化后微服务面临的问题以及符合应对问题。\n\n\n\n这篇文章只是选取书中部分观点拿来讨论，不是总结和概括。\n\n### 本书的目录\n\n![微服务设计.png](http://media.gusibi.mobi/B2JeYMCE2L_M5LZb_lJIODgQWBBKZluLNgop3BeRuQ0wD5xs07hdDYAdtYxcCfI3)\n\n\n\n### 微服务定义\n\n\n对于微服务，作者定义为一些协同工作的小而自治的服务，“小而自治”可以使用单一职责原则来解释：把因相同原因而变化的东西聚合在一起，而把因不同原因而变化的东西分离开。这个原则也可以用来指导单个服务的微服务拆分。\n\n**多小算小**：\n\n澳大利亚RealEstate.com.au的Jon Eaves认为，一个微服务应该可以在两周内完全重写。服务是否够小，作者认为需要考虑以下因素：\n\n1. 服务越小，微服务架构的优点和缺点也就越明显\n2. 微服务越小，独立性带来的好处就越多，但也就越复杂\n3. 如果开发者不再觉得代码库过大，那就可以认为足够小了。\n\n**自治：**\n\n一个微服务是一个独立的实体，独立部署，服务之间通过网络调用进行通信，从而加强服务之间的隔离性，避免耦合。\n\n\n**微服务的优点：**\n\n1. 技术异构性：因为单个微服务力度足够小，在由多个微服务组成的系统中，可以在不同的微服务中使用不同的技术，比如使用不同的语言、框架、不同的数据库等。\n2. 弹性：微服务可以部署在多个机器上来降低功能完全不可用的概率，这样当一个服务不可用时也可以避免级联故障的产生。\n3. 扩展：可以对特定的模块进行扩展或缩容，比如性能要求高的部署在性能好的机器上，性能要求低的部署在性能稍差的机器上\n4. 简化部署：部署时只需要部署修改的部分而不是把整个大的服务。\n5. 与组织架构相匹配：不同模块由不同的人员维护开发\n6. 可替代性：对于大的服务，重构替代比较难，但是微服务就相对简单，可能只需要几天就能完成。\n\n\n微服务虽然好处很多，但是微服务并不是没有缺点，更不是银弹，使用微服务之前需要考虑清除。\n\n### 架构师\n\n架构师的一个重要职责是确保团队有共同的技术愿景，以帮助我们向客户交付他们想要的系统。\n\n作者有一个观点特别有意思，他认为架构师是参考其它行业比如建筑师来命名的，但是“架构师”并不需要像“建筑师”那样需要对设计保证足够的精确，且对产物负有不可推卸的责任，但是软件“架构师”却需要保证软件有足够的灵活性和适应性，并且能够根据用户的需求进行演化。这么看来，软件设计师更像是城市规划师，只需要保证大方向上的正确，对于模块内的具体设计可以随机应变。\n\n\n### 指导原则\n\n软件设计的关键是取舍，而哪些取哪些舍就需要满足一些原则，而原则本身也需要取舍，最好不要超过10条，否则当原则太多可能会产生冲突也不便记忆，可以参考【1】 https://www.12factor.net/zh_cn/ 的12项原则:\n\n#### [I. 基准代码](https://www.12factor.net/zh_cn/codebase)\n\n一份基准代码，多份部署\n\n#### [II. 依赖](https://www.12factor.net/zh_cn/dependencies)\n\n显式声明依赖关系\n\n#### [III. 配置](https://www.12factor.net/zh_cn/config)\n\n在环境中存储配置\n\n#### [IV. 后端服务](https://www.12factor.net/zh_cn/backing-services)\n\n把后端服务当作附加资源\n\n#### [V. 构建，发布，运行](https://www.12factor.net/zh_cn/build-release-run)\n\n严格分离构建和运行\n\n#### [VI. 进程](https://www.12factor.net/zh_cn/processes)\n\n以一个或多个无状态进程运行应用\n\n#### [VII. 端口绑定](https://www.12factor.net/zh_cn/port-binding)\n\n通过端口绑定提供服务\n\n#### [VIII. 并发](https://www.12factor.net/zh_cn/concurrency)\n\n通过进程模型进行扩展\n\n#### [IX. 易处理](https://www.12factor.net/zh_cn/disposability)\n\n快速启动和优雅终止可最大化健壮性\n\n#### [X. 开发环境与线上环境等价](https://www.12factor.net/zh_cn/dev-prod-parity)\n\n尽可能的保持开发，预发布，线上环境相同\n\n#### [XI. 日志](https://www.12factor.net/zh_cn/logs)\n\n把日志当作事件流\n\n#### [XII. 管理进程](https://www.12factor.net/zh_cn/admin-processes)\n\n后台管理任务当作一次性进程运行\n\n\n列原则简单，但要和实践相结合才好。\n\n\n### 什么样的服务是好服务\n\n\n作者给出的两个概念是：1、松耦合；2、高内聚。这两个概念也不仅仅是微服务的设计理念，而是所有系统设计的基本要求。\n\n做到松耦合，在修改一个服务的时候就不需要修改另一个服务，这样就能够做到独立部署一个服务而不需要修改系统的其它部分。\n\n做到高内聚，也就能在需要修改一个功能时只需要修改一个服务就能实现需求。\n\n\n可见，松耦合和高内聚本质上可以达到相同的目标。\n\n\n### 不要过早划分服务\n\n\n在服务有明确的边界之前，最好不要划分服务。毕竟拆分服务比把服务合并起来更容易一些。当一个服务业务边界逐渐明确时，再根据业务边界逐步拆分服务。\n\n对于单个大服务的分解，也建议从分解数据库开始，将杂乱的依赖理清。\n\n\n### 服务的集成\n\n\n多个服务的集成有多种方式，比如共享数据库、REST调用、远程过程调用。同时服务间调用也有同步调用和异步调用两种方式。这两种方式各有各的好处，不同场景可能需要选择不同的调用方式。\n\n如果使用同步服务，发起一个调用后调用方会阻塞自己并等待整个操作的完成；如果使用异步通信，调用方不需要等待操作完成后就可以返回，甚至可能不需要关心这个操作是否完成。采用异步的方式就需要保证异步调用的可靠性（比如失败了怎么处理，异步任务需要保证幂等）。\n\n\n### 服务部署\n\n\n服务拆分后，服务的数量可能会是原来的几倍、几十倍，可能一个需求的改动会设计几个或者更多的服务部署，这时服务的部署就会变成一个无法避免的问题。一个比较好的做法是将持续集成映射到服务，在代码修改后通过配置自动部署。这里有一个需要注意的点就是可能需要对不同的服务定制化不同的镜像，docker是一个很好的选择。\n\n\n### 测试\n\n\n《敏捷软件测试》一书曾把测试分为以下四个象限。\n\n![测试的象限.jpeg](http://media.gusibi.mobi/F3T-K3q0Y0Ncv10AZyODaMFBHaGj1F4DHL84CMGX4stcm_2p0VB-Y2y4iE-X5zNe)\n\n处于象限底部的是面向技术的测试，即那些首先能够帮助开发人员构建系统的测试。这个象限中的测试通常是可以自动化的，比如性能测试和单元测试（关于单元测试可以参考这篇文章《学习单元测试，告别祈祷式编程》【2】https://mp.weixin.qq.com/s/oD96OEv92oX0ypAYLbYFyA）。\n\n处于象限上方的测试则是帮助非技术背景的相关人群，了解系统是如何工作的。这种测试包括象限左上角的大范围、端到端的验收测试，还有象限右上角的由用户来进行的在UAT系统上进行手工验证的探索性测试。\n\n测试是微服务系统的一个关键步骤，如果在微服务系统中还有大量的手工测试，可能让系统稳定运行会变成一个挑战。\n\n\n《Scrum敏捷软件开发》中提到了测试金字塔的概念，测试金字塔如下所示\n\n\n![测试的范围.jpeg](http://media.gusibi.mobi/48bhFMXZNQ3CGiz3p6lK7SUKBMj-WBgSx1owQG7ccJ7oCyR53hz1yxy7g6Hwkt9_)\n\n主要由单元测试、服务测试和用户界面测试三层。这张图和上一张象限图有异曲同工的作用，都是将测试分为多个层。\n\n\n### 监控\n\n\n\n有过bug修复经验的人都知道，在只有一个服务的时候，监控是相对简单的，遇到问题只需要到服务所在容器或者机器查看错误即可。但如果系统是微服务架构，特别是调用链有多个节点时，定位错误就变成了一个不可能完成的任务。此时，监控工具就变得尤为重要。\n\n\n\n日志、全链路追踪工具是一个好的选择。\n\n\n\n### 安全\n\n\n\n对于微服务的安全，完全同意作者的观点\n\n1. **不要实现自己的加密算法。不要发明自己的安全协议。**\n2. **不要实现自己的加密算法。不要发明自己的安全协议。**\n3. **不要实现自己的加密算法。不要发明自己的安全协议。**\n\n重要的事情说三遍。\n\n\n\n### 康威定律\n\n\n\n梅尔 ·康威于1968年4月在Datamation杂志上发表了一篇名为“How Do Committees Invent”的论文，文中指出：\n\n**任何组织在设计一套系统（广义概念上的系统）时，所交付的设计方案在结构上都与该组织的沟通结构保持一致。**\n\n这句话被称为康威定律。可以用埃里克 · S．雷蒙德在《新黑客字典》中定义总结：“如果你有四个小组开发一个编译器，那你会得到一个四步编译器。”\n\n\n\n比如，如果一个组织的耦合度非常低，其创建的系统的模块化就越好，耦合也越低；组织的耦合度越高，其创建的系统的模块化也越差。\n\n\n\n康威定律主要强调系统设计和组织结构不匹配可能会导致危险，这引导组织将服务所有权与团队相匹配。\n\n\n\n### 规模化\n\n\n\n一旦规模化之后，服务就会不可避免的出现问题，现在没有任何一个服务敢保证自己的服务100%可用， 99.999%可用性 已经是一个了不起的数据（但即使这样当服务超过10w时，也总有一台机器是不可用的）。所以，规模化后，即使你买最好的工具，最昂贵的硬件，也无法避免它们会发生故障的事实。\n\n与其把时间放到如何避免服务出错还不如把时间放到如何快速修复系统上。\n\n\n\n### CAP定理\n\n\n\n分布式系统中有三方面需要彼此权衡：一致性（consistency）、可用性（availability）和分区容忍性（partition tolerance）。具体地说，这个定理告诉我们最多只能保证三个中的两个。\n\n\n\n具体参考：阮一峰《CAP 定理的含义》【3】https://ruanyifeng.com/blog/2018/07/cap.html\n\n\n\n### 其它有意思的事情\n\n\n\n“两个披萨团队”（没有一个团队应该大到两个比萨不够吃）。\n\n如果不知道怎么拆分微服务，就先构建单个服务吧。\n\n\n\n\n\n### 总结\n\n![微服务的原则.jpeg](http://media.gusibi.mobi/ClNFWVAh-uvMAYNfA-KHgoqvQW0ati71dUxJTcT8uocm4Sm9vglmSPYxXgPGv5cT)\n\n\n\n不要实现自己的加密算法库。也不应该实现自己的分布式协调系统。使用已有的可工作的选择是非常明智的。\n\n\n\n### 参考链接\n\n\n\n- 【1】https://www.12factor.net/zh_cn/\n- 【2】《学习单元测试，告别祈祷式编程》【https://mp.weixin.qq.com/s/oD96OEv92oX0ypAYLbYFyA\n- 【3】《CAP 定理的含义》https://ruanyifeng.com/blog/2018/07/cap.html\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/WDz3v4cU4LQq1oyKX-fYK1LxIThzZ1hK931ZaPRC8CdcB0t2oTYJciMDuAws70FY)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)\n",
      "data": {
        "title": "《微服务设计》读书笔记",
        "date": "2020-06-26 09:23:49",
        "tags": [
          "微服务",
          "读书笔记"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "microservices_design"
    },
    {
      "content": "\n\n> 上一篇介绍了Flutter 安装配置 相关内容，接下来这一篇先新来一个示例介绍一下Flutter项目的基本结构。\n\n\n### 新建项目\n\n\n\n1. 打开编辑器（这里以IntelliJ IDEA为例，Android Studio基本一致）\n2. File>New>Project，选择Flutter 项目\n\n\n\n![截屏2020-06-21 上午9.27.06.png](http://media.gusibi.mobi/dGPyk4Ns6SXdcofOPiVnCFFQVB_5KDhmH2Sve9aJVqSKMM4L4wKYNMrA9WEqryKr)\n\nNext 填写项目相关内容，Organization 这里通常建议是域倒写.\n\n![截屏2020-06-21 上午9.29.01.png](http://media.gusibi.mobi/i_IjC0yQntSYtqBN_T3IZrIVHJvdrE270FBIQv4efgVrKydlwabV-mVYhlDBorzg)\n\n填写完毕点击FINISH，将会自动生成一个示例项目。\n\n![截屏2020-06-21 上午9.29.24.png](http://media.gusibi.mobi/A5sMHWavEsRD58OpTp1Wm4St-nhW4Llfq3f0wny9HjRu6sep9NHIj0iyWs50hOYY)\n\n1. 打开模拟器：点击上方菜单栏，选择模拟器（这里选择iOS 模拟器）\n\n![截屏2020-06-21 上午9.30.00.png](http://media.gusibi.mobi/jxTB2M2NfYI4Xv7RjUYbDcbFa-CSb_1RV7b-0Aw-6_ZwIlWqIei1uA54ZLIg9zPE)\n\n点击后，iOS模拟器会启动，但是还需要再选择设备\n\n![截屏2020-06-21 上午9.33.37.png](http://media.gusibi.mobi/IBuKm-DNtEapZpYbnGRu2JKD0kuXm3jHqyMOB1OGom5H_c84U9wmQdadz0ZC47MS)\n\n\n启动后界面如下：\n\n\n![截屏2020-06-21 上午9.33.50.png](http://media.gusibi.mobi/pkkAFSa4UBv7xqRPgs2Yp4-o0whml1MKlbl53C0msalQGPoRQb2ublKnVH8tM0xZ)\n\n\n\n\n\n现在可以点击菜单栏上方运行项目，输出结果如下\n\n\n\n```shell\nLaunching lib/main.dart on iPhone 11 in debug mode...\nRunning Xcode build...\nXcode build done.                                           46.6s\nDebug service listening on ws://127.0.0.1:61858/TQG1yn-Cjq0=/ws\nSyncing files to device iPhone 11...\n```\n\n现在一个简单的项目就启动完毕。\n\n![Simulator Screen Shot - iPhone 11 - 2020-06-21 at 09.35.48.png](http://media.gusibi.mobi/UXwr5FZ8T9BH1ZyT4rqcGb6F3uJrSf0_5MVjL4Pm_OpxhB9N4BxvIfxuVmm0a-Yh)\n\n\n\n第一次真机运行的时候可能会需要更多的等待时间，但是接下来你就可以使用热重载（hot reload）功能，热重载可以在运行时更新预览。\n\n\n\n### 项目目录\n\n\n\n```shell\n├── README.md\n├── android\n├── build\n├── hello_world.iml\n├── ios\n├── lib\n├── pubspec.lock\n├── pubspec.yaml\n└── test\n```\n\n主要关注以下几个文件/目录：\n\n| **文件/目录** | **描述**                                                  |\n| ------------- | --------------------------------------------------------- |\n| android       | android 平台相关代码                                      |\n| ios           | iOS平台相关代码                                           |\n| lib           | flutter 应用代码，编写的代码在此目录                      |\n| test          | 测试相关代码                                              |\n| pubspec.yaml  | 管理 Flutter 应用程序的 assets（资源，如图片、package等） |\n\n\n\n### 代码介绍\n\n\n\n```javascript\nimport 'package:flutter/material.dart';\n\nvoid main() => runApp(MyApp());\n\n// MyApp 不需要做状态管处理，此组件继承StatelessWidget 即可\nclass MyApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Flutter Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n        visualDensity: VisualDensity.adaptivePlatformDensity,\n      ),\n      home: MyHomePage(title: 'Flutter Demo Home Page'),\n    );\n  }\n}\n\nclass MyHomePage extends StatefulWidget {\n  MyHomePage({Key key, this.title}) : super(key: key);\n\n  final String title;\n\n  @override\n  _MyHomePageState createState() => _MyHomePageState(); // 重写\n}\n\n// 状态类必须继承自 State类\nclass _MyHomePageState extends State<MyHomePage> {\n  int _counter = 0; // 定义一个变量 _counter 作为计数器变量，调用 setState 方法来控制这个变量的值变化\n\n  void _incrementCounter() {\n    setState(() {\n      _counter++;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        // Here we take the value from the MyHomePage object that was created by\n        // the App.build method, and use it to set our appbar title.\n        title: Text(widget.title),\n      ),\n      body: Center(\n        // Center is a layout widget. It takes a single child and positions it\n        // in the middle of the parent.\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text(\n              'You have clicked the button this many times:',\n            ),\n            Text(\n              '$_counter',\n              style: Theme.of(context).textTheme.headline4,\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _incrementCounter,\n        tooltip: 'Increment',\n        child: Icon(Icons.add),\n      ), // This trailing comma makes auto-formatting nicer for build methods.\n    );\n  }\n}\n```\n\n\n\n- 代码第一行引入了 material.dart 包，使用此包，模板代码创建了一个具有 Material Design 风格的应用（ [Material](https://material-io.cn/guidelines) 是一种移动端和网页端通用的视觉设计语言， Flutter 提供了丰富的 Material 风格的 widgets。\n- `void main() => runApp(MyApp());` 主函数（main）使用了 (`=>`) 符号，这是 Dart 中单行函数或方法的简写，等同于下属代码\n\n```dart\nvoid main() {\n  runApp(MyApp());\n}\n```\n\nflutter 项目都需要在开始的时候执行main 函数，使用runApp() 函数可以讲给定的根组件填满整个屏幕。（如果不调用runApp() 函数，项目也可以正常运行，但是屏幕上什么都不会显示。\n\n\n\n#### 状态管理\n\n\n\n\n\n- 该应用程序继承了 `StatelessWidget`，这将会使应用本身也成为一个 widget。在 Flutter 中，几乎所有都是 widget，包括对齐 (alignment)、填充 (padding) 和布局 (layout)。\n- **State*****less\\*** **widgets 是不可变的，这意味着它们的属性不能改变 —— 所有的值都是 final。**\n- **State*****ful\\*** **widgets 持有的状态可能在 widget 生命周期中发生变化，实现一个 stateful widget 至少需要两个类：**\n\n- -  1）一个 StatefulWidget 类，本身是不可变的\n  - 2）一个 State 类，但是 State 类在 widget 生命周期中始终存在。\n\n\n\n- MyHomePage 类是一个Stateful widgets（有状态的 widget）\n\n- - 必须继承自**StatefulWidget**\n  - 它创建自己的状态类 —— _MyHomePageState，并将 MyHomePage 内嵌到已有的无状态的 `MyApp` widget。\n  - 需要重写createState 方法，代码如下：\n\n```dart\n@override\n_MyHomePageState createState() => _MyHomePageState();\n```\n\n\n\n\n\n- `Scaffold` 是 Material 库中提供的一个 widget，它提供了默认的导航栏、标题和包含主屏幕 widget 树的 body 属性。\n\n- - 现在在Scaffold 中添加 backgroundColor: Colors.amber\n\n```dart\nWidget build(BuildContext context) {\n    return Scaffold(\n      ...\n      backgroundColor: Colors.amber,\n      ...\n    );\n  }\n```\n\n保存代码后，页面应该会自动刷新，结果如下：\n\n\n![Simulator Screen Shot - iPhone 11 - 2020-06-21 at 17.41.29.png](http://media.gusibi.mobi/a5RewdDN10105G5S_vJ0Kc1W9UdEp2MIBit_ALAK6ldckaBix7SlOj3wpR6n1FZz)\n\n如果自动保存后页面没有自动重载，可以点击下图红圈中按钮查看更新后结果。\n\n![截屏2020-06-21 上午9.36.57.png](http://media.gusibi.mobi/NdtaTSTSLDhz4bjlRtATlliCBSKOeBgmFH_1bDKu2lSKYqBQ9FDTMSSpgZhcTdSO)\n\n\n\n- 一个 widget 的主要工作是提供一个 `build()` 方法来描述如何根据其他较低级别的 widgets 来显示自己。\n- 本示例中的 body 的 widget 树中包含了一个 `Center` widget， Center widget 又包含一个 `Text` 子 widget， Center widget 可以将其子 widget 树对齐到屏幕中心。\n\n\n\n### 使用第三方包\n\n\n\n现在这个模板代码比较简单，接下来我们扩展一下，在pubspec.yaml 中，将 english_words（3.1.5 或更高版本）添加到依赖项列表，如下所示：\n\n在 编辑器视图中查看 `pubspec.yaml` 文件时，点击 **Pub get** 会将依赖包安装到你的项目。你应该会在控制台中看到以下内容：\n\n\n\n```shell\nRunning \"flutter pub get\" in hello_world...                         0.6s\nProcess finished with exit code 0\n```\n\n在执行 `Pub get` 命令时会自动生成一个名为 `pubspec.lock` 文件，这里包含了你依赖 packages 的名称和版本。\n\n\n\n然后在lib/main.dart 代码第二行加入 import 'package:english_words/english_words.dart';\n\n\n\n如果你尝试热重载，则可能会看到一条警告，考虑重新启动当前应用：\n\n\n\n```shell\nReloading…\nSome program elements were changed during reload but did not run when the view was reassembled; \nyou might need to restart the app (by pressing “R”) for the changes to have an effect.\n```\n\n\n\n\n\n\n\n因为重启应用之后就可以生效，故这可能是误报。现在只需点击build 按钮重新build。\n\n\n\n修改后的代码如下：\n\n\n\n```dart\nclass _MyHomePageState extends State<MyHomePage> {\n  int _counter = 0;\n\n  void _incrementCounter() {\n    setState(() {\n      _counter++;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final wordPair = WordPair.random();\n    return Scaffold(\n      ...\n      body: Center(\n        // Center is a layout widget. It takes a single child and positions it\n        // in the middle of the parent.\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Text(\n              'You have clicked the button this many times:',\n            ),\n            Text(\n              '$_counter',\n              style: Theme.of(context).textTheme.headline4,\n            ),\n            Text(\n              'Words Pair:' + wordPair.asPascalCase,\n            ),\n          ],\n        ),\n      ),\n      ...\n  }\n}\n```\n\n\n\n### ![Simulator Screen Shot - iPhone 11 - 2020-06-21 at 18.23.27.png](http://media.gusibi.mobi/NvWnrQJRvVTBmWz1S76ZyzyJ9Ey0ANcubkNjw6S9Pmh9bUeQbEb4HvZiL36dnMaU)\n\n\n此时点击右下角的按钮，数字会增加，单词对也会更新。\n\n\n### 参考链接\n\n1. https://flutter.cn/docs/cookbook/design/themes\n2. https://flutter.cn/docs/get-started/codelab\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/WDz3v4cU4LQq1oyKX-fYK1LxIThzZ1hK931ZaPRC8CdcB0t2oTYJciMDuAws70FY)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)\n",
      "data": {
        "title": "Flutter 简明教程：从零创建一个flutter 项目",
        "date": "2020-06-21 09:07:20",
        "tags": [
          "Flutter",
          "前端",
          "教程"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "flutter-01-first-demo"
    },
    {
      "content": "\n## 安装\n\n1. 下载SDK：\n\n1. 1. Windows SDK：[Stable 1.17.3](https://storage.flutter-io.cn/flutter_infra/releases/stable/windows/flutter_windows_1.17.3-stable.zip)\n   2. macOS SDK：[Stable 1.17.3](https://storage.flutter-io.cn/flutter_infra/releases/stable/macos/flutter_macos_1.17.3-stable.zip)\n   3. Linux SDK：[Stable 1.17.3](https://storage.flutter-io.cn/flutter_infra/releases/stable/linux/flutter_linux_1.17.3-stable.tar.xz)\n   4. 其它版本列表：[SDK 版本列表](https://flutter.cn/docs/development/tools/sdk/archive)[2]\n\n\n\n1. 将文件解压到目标路径, 比如:\n\n```shell\ncd ~/flutter\nunzip ~/Downloads/flutter_macos_1.17.3-stable.zip\n```\n\n\n\n也可以从Github上获取源代码：\n\n```shell\ngit clone https://github.com/flutter/flutter.git\n```\n\n\n\n1. 配置 `flutter` 的 PATH 环境变量：\n\n```shell\nexport PATH=\"$PATH:~/flutter/flutter/bin\"\n```\n\n\n\n**`~/flutter/flutter/bin 需要替换成你设置的目录。`**\n\n\n\n如果bash 使用的是 zsh，需要把这行代码写入到 `~/.zsh_rc` 文件，如果是bash，则需要写入 `~/.bash_profile` ，文件更新后需要执行 \n\n```\nsource ~/.zsh_rc\n```\n\n\n\n\n\n1. `flutter` 命令行工具会下载不同平台的开发二进制文件，如果需要一个封闭式的构建环境，或在网络可用性不稳定的情况下使用等情况，你可能需要通过下面这个命令预先下载 iOS 和 Android 的开发二进制文件：\n\n\n\n```shell\nflutter precache\n```\n\n\n\n1. flutter doctor 命令\n\n\n\n运行flutter doctor命令可以查看当前环境是否需要安装其他的依赖，输出结果如下：\n\n\n\n```shell\n➜  ~ flutter doctor\n\nDoctor summary (to see all details, run flutter doctor -v):\n[✓] Flutter (Channel stable, v1.17.1, on Mac OS X 10.15.5 19F96, locale zh-Hans-CN)\n\n[✓] Android toolchain - develop for Android devices (Android SDK version 29.0.3)\n[✓] Xcode - develop for iOS and macOS (Xcode 11.4.1)\n[✓] Android Studio (version 4.0)\n[!] IntelliJ IDEA Ultimate Edition (version 2020.1.1)\n    ✗ Flutter plugin not installed; this adds Flutter specific functionality.\n    ✗ Dart plugin not installed; this adds Dart specific functionality.\n[✓] VS Code (version 1.45.1)\n[✓] Connected device (1 available)\n\n! Doctor found issues in 1 category.\n```\n\n\n\n从上述结果可以看出，IntelliJ IDEA Ultimate Edition 没有安装flutter plugin 和 dart plugin 没有安装。\n\n\n\n1. 配置编辑器\n\n\n\n### 设置 iOS 开发环境\n\n\n\n1. 安装Xocde\n2. 配置 Xcode command-line tools:\n\n```\nsudo xcode-select --switch /Applications/Xcode.app/Contents/Developer\nsudo xcodebuild -runFirstLaunch\n```\n\n1. 运行一次 Xcode 或者通过输入命令 `sudo xcodebuild -license` 来确保已经同意 Xcode 的许可协议\n\n\n\n安装了 Xcode 之后，你就可以在 iOS 真机或者模拟器上运行 Flutter 应用了。\n\n\n\n#### 配置iOS 模拟器\n\n\n\n输入命令运行模拟器\n\n```\nopen -a Simulator\n```\n\n\n\n如果你想把 Flutter 应用部署到 iOS 的真机上，你还需要一个 Apple 开发者账号。另外，你还需要在 Xcode 上针对你的机器做一些设置。\n\n\n\n1. 安装和设置 CocoaPods\n\n```shell\nsudo gem install cocoapods\npod setup\n```\n\n\n\n1. 按照下面 Xcode 签名流程来配置你的项目：\n\n1. 1. 通过在命令行中于你当前 Flutter 项目目录下运行 `open ios/Runner.xcworkspace` 命令来打开默认的 Xcode 工程。\n   2. 在运行按钮的下拉列表里选择你想要部署到的设备；\n   3. 在左侧的导航面板中选择 `Runner` 项目；\n   4. 在 `Runner` 项目的设置页面，请确保勾选你的开发团队。在不同的 Xcode 版本里，这一部分的操作界面不同：\n\n1. 1. 1. 在 Xcode 10 版本中，请在这里设置：General > Signing > Team\n      2. 在 Xcode 11 版本以后，请在这里设置 Signing & Capabilities > Team\n\n1. 1. 在 Runner 项目的设置页面中，确保 General > Signing > Team 选项下的 Development Team 选中状态。\n\n1. 1. 1. 在开始你的第一个 iOS 项目开发之前，你需要先在 Xcode 中登陆你的 Apple 开发者账号\n      2. 任何 Apple ID 都可以进行开发和测试。如果想将应用上架 App Store，你需要加入 Apple Developer Program，你可以在 [Choosing a Membership](https://developer.apple.com/support/compare-memberships) 页面中查看详细的说明。\n\n1. 1. 当你第一次将设备连接到开发机用于开发时，你需要分别在 Mac 和开发机上进行信任设备的操作。当你第一次连接时，会有个弹窗，点击 `Trust` 即可。\n\n1. 1. 1. 然后在 iOS 开发机上进入 Settings 应用，选择 **General > Device Management** 然后信任相应的证书\n\n1. 1. 如果 Xcode 的自动签名失败了，你可以检查以下项目中 **General > Identity > Bundle Identifier** 里的值是否是唯一的。\n\n\n\n1. 执行 `flutter run` 命令来运行你的应用。\n\n\n\n### 设置Android 开发环境\n\n\n\nandroid 开发建议使用 Android Studio，也可以使用其它编辑器。\n\n\n\n1. 下载 Android Studio\n2. 运行Android Studio，安装android SDK， Android SDK Platform-Tools 以及 Android SDK Build-Tools。\n\n\n\n#### 配置 Android 设备\n\n在 Android 设备上运行或测试 Flutter 应用之前，你需要一个运行 Android 4.1（API 版本 16）或者更高的设备。\n\n1. 在设备上打开 **Developer options** 和 **USB debugging** 选项，你可以在 [Android documentation](https://developer.android.google.cn/studio/debug/dev-options) 上查看更详细的方法介绍。\n2. 如果是在 Windows 平台上使用，需要安装 [Google USB Driver](https://developer.android.google.cn/studio/run/win-usb)\n3. 通过 USB 接口连接手机和电脑，如果在设备上弹出需要授权弹窗，允许授权以便让电脑能够访问你的开发设备。\n4. 在命令行中，使用 `flutter devices` 命令来确保 Flutter 能够识别出你所连接的 Android 设备。\n\n默认情况下，Flutter 会使用当前版本 `adb` 工具所依赖的 Android SDK 版本，如果你想让 Flutter 使用别的 Android SDK，你可以通过设置 `ANDROID_HOME` 环境变量来达到这个目的。\n\n####  \n\n#### 配置 Android 模拟器\n\n\n\n根据以下步骤来将 Flutter 应用运行或测试于你的 Android 模拟器上：\n\n1. 激活机器上的 [VM acceleration](https://developer.android.google.cn/studio/run/emulator-acceleration) 选项。\n2. 启动 **Android Studio > Tools > Android > AVD Manager**，然后选择 **Create Virtual Device** 选项。（只有在 Android 项目中才会显示 **Android** 子选项。）\n3. 选择相应的设备并选择 **Next** 选项。\n4. 选择一个或多个你想要模拟的 Android 版本的系统镜像，然后选择 **Next** 选项。推荐选择 **x86** 或者 **x86_64** 镜像。\n5. 在 Emulated Performance 下选择 **Hardware - GLES 2.0** 选项来开启 [硬件加速](https://developer.android.google.cn/studio/run/emulator-acceleration)。\n6. 确保 AVD 选项配置正确，并选择 **Finish** 选项。\n   想要查看上述步骤的更多详细信息，请查看 [Managing AVDs](https://developer.android.google.cn/studio/run/managing-avds) 页面。\n7. 在 Android Virtual Device Manager 中，点击工具栏中的 **Run** 选项，模拟器会启动并为你所选择的系统版本和设备显示出相应的界面。\n\n\n\n## 常见问题\n\n\n\n#### Waiting for another flutter command to release the startup lock\n\n\n\n打开AndroidStudio的时候顶部的模拟器一直是loading状态，运行flutter doctor 提示：\n\n```\nWaiting for another flutter command to release the startup lock\n```\n\n解决方法，如下： \n\n\n\n1. 打开flutter的安装目录/bin/cache/ \n2. 删除lockfile文件 \n3. 重启AndroidStudio\n\n\n\n#### **Flutter 卡在 package get 的解决办法**\n\n运行 flutter run 或者新建flutter 项目时卡在：\n\n\n\n```\nRunning \"flutter packages get\" in project_name...\n```\n\n大概率是遇到了防火墙，解决方案毕竟简单，添加两个环境变量即可，环境变量如下：\n\n```\n# linux mac 添加代理到 　.zsh_rc 或 .bash_profile\nexport PUB_HOSTED_URL=https://pub.flutter-io.cn\nexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn\n```\n\n\n\n官方解决方案文档：[Using Flutter in China](https://links.jianshu.com/go?to=https://github.com/flutter/flutter/wiki/Using-Flutter-in-China) https://flutter.dev/community/china[3]\n\n\n\n### 参考链接\n\n1. [安装和环境配置 https://flutter.cn/docs/get-started/install](https://flutter.cn/docs/get-started/install)\n2. [SDK 版本列表 https://flutter.cn/docs/development/tools/sdk/archive](https://flutter.cn/docs/development/tools/sdk/archive)\n3. [Using Flutter in China](https://links.jianshu.com/go?to=https://github.com/flutter/flutter/wiki/Using-Flutter-in-China) https://flutter.dev/community/china\n\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/WDz3v4cU4LQq1oyKX-fYK1LxIThzZ1hK931ZaPRC8CdcB0t2oTYJciMDuAws70FY)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)\n",
      "data": {
        "title": "Flutter 安装配置",
        "date": "2020-06-06 09:07:20",
        "tags": [
          "Flutter",
          "前端",
          "教程"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "flutter-00-install-and-setting"
    },
    {
      "content": "\n> Google 技术写作课程搬运，原文地址：[https://developers.google.com/tech-writing/overview?hl=zh-cn](https://developers.google.com/tech-writing/overview?hl=zh-cn)\n\n## Facilitating Technical Writing Courses\n\n  This section provides resources for anyone facilitating or considering facilitating technical writing courses. The following table contains links to all relevant material for facilitators:\n\n|                       | for facilitators       | for students  |        |              |              |\n| --------------------- | ---------------------- | ------------- | ------ | ------------ | ------------ |\n| Course                | Facilitator's Guide    | slide deck    | log    | pre-class    | in-class     |\n| Technical Writing One | Facilitator's Guide[1] | slide deck[2] | log[3] | pre-class[4] | in-class[5]  |\n| Technical Writing Two | Facilitator's Guide[6] | slide deck[7] | log[8] | pre-class[9] | in-class[10] |\n\n  If you'd like to facilitate a particular course, please start by reading the course's Facilitator's Guide.\n\n  To access slide decks, please read Gaining access to the slide deck[11].\n\n  ## Technical Writing One: facilitator's guide\n\n  This facilitator's guide helps prepare you to lead Technical Writing One.\n\n  ### Who can facilitate this course?\n\n  Any good facilitator can lead this course; you don't need to be an expert in technical writing to lead this course. We designed this course to have students teach each other. Granted, facilitators with experience in technical writing can provide additional insights during the class.\n\n### Gaining access to the slide deck\n\n  To gain access to the slide deck, you must first become a member of the `technical-writing-instructors@googlegroups.com` group. Joining this group enrolls you in a world-wide **community** of technical writing facilitators. To build that community, use the list to do the following:\n\n  •Share training insights with your peers.•Answer questions respectfully, supportively, and generously.•Advertise any upcoming public technical writing courses.\n\n  Never do the following:\n\n  •Harm, bully, stalk, slander, or belittle anyone on this list.•Send messages not pertaining to technical writing training. Do not spam the list.\n\n  In short, treat others as you wish to be treated. If you treat others poorly, we will remove you from this list.\n\n  Finally, only humans may join this list. Machine learning is remarkable, but it doesn't belong on this list.\n\n  **Note:** We reserve the right to change these guidelines.\n\n  Take the following steps to become a member:\n\n  1.Visit the technical-writing-instructors@googlegroups.com group page[12].2.Click **Apply for membership.**\n\n### Course contents\n\n  The course consists of the sections shown in Table 1.\n\n  **Table 1. Course Sections**\n\n| Section                                            | Length (in hours) | What students do                                             | What facilitators do                               |\n| -------------------------------------------------- | ----------------- | ------------------------------------------------------------ | -------------------------------------------------- |\n| pre-class exercises[13]                            | 2 - 3             | Read short lessons and work through quick exercises.         | Assign pre-class material to your students.        |\n| In-class slide deck[14] and in-class exercises[15] | 2.0 - 2.5         | Work through six writing exercises. Participate in peer reviews and class discussions. | Facilitate the peer reviews and class discussions. |\n\n### Preparing to facilitate\n\n  To prepare to facilitate this class, please do the following:\n\n  •Review the student pre-class work[16].•Review the slide deck[17].•Review the in-class exercises[18].\n\n  As with any class, we recommend the following:\n\n  •Practice the material prior to leading a live class.•If you have teaching assistants, decide what each of you will do during class.\n\n### Why split pre-class work from in-class work?\n\n  The pre-class exercises build **foundational skills**. The in-class exercises help students **integrate** those foundational skills.\n\n  The pre-class exercises provide explicit instructions on discrete foundational topics. For example, one pre-class exercise teaches students to convert passive voice sentences to active voice. Another exercise teaches students to reduce the number of words in a sentence or to convert lengthy sentences into a list.\n\n  The instructions for in-class exercises are less specific than the pre-class exercises. For example, two of the in-class exercises simply tell students to \"improve these sentences.\" Students must integrate lessons learned in pre-class exercises to determine what to do.\n\n  Much of the pre-class and in-class material attempts to unite engineering process and theory with technical writing process and theory. We encourage facilitators to draw parallels between the two worlds whenever possible. (The speaker notes can help you draw those parallels.)\n\n  We've heard people refer to the pre-class content as \"design patterns for technical writing,\" which is a reasonable description. We've aimed to keep these patterns relatively simple to remember and easy to implement. As you facilitate this class, some students will object to a few of these patterns, noting that real-world writing is more nuanced and complex. You can reply that these design patterns are guidelines rather than hard-and-fast rules. You can additionally note that professional technical writers often rely on these patterns.\n\n  If a facilitator is not available (and students can't experience the in-class material), the pre-class material is still valuable.\n\n### Partner discussions\n\n  Consider the following proverb:\n\n  > To learn, read a book. To learn better, take a course. To learn best, teach the course.\n\n  How do you get 20 students to each teach the material simultaneously? If students are accustomed to reviewing their peers' work, then the class will quickly fill with animated conversation as students teach each other the material. However, those students unaccustomed to peer review may feel shy or awkward about defending their answers or offering useful suggestions. Be prepared to assure your students that their feedback helps their partner. For a very shy class, consider role-playing how to give appropriate feedback.\n\n  Encourage students to change their solutions based on feedback.\n\n### Class discussions\n\n  Each unit ends with a slide that asks some conversation-provoking questions. Your job is to incite discussion and then to extinguish that discussion when you are ready to move on. Generally, students will provide ideas, but be prepared with conversation starters should your class get a little shy. We've added a few conversation starter suggestions in the speaker notes.\n\n  The following list contains a few general tips about leading discussions:\n\n  •Be positive. Encourage students whenever possible. \"That's an excellent answer. Can anyone build on that answer?\"•Build a class where students feel comfortable giving answers. To break the ice in a shy class, ask questions that have no right or wrong answers.•Seek opinions. When there are several possible answers to exercises or questions, ask students which answer they prefer and why.\n\n### Pace\n\n  We usually schedule the class for 2.0 or 2.5 hours. If a large percentage of students speak English as a second or third language, then schedule the class for 2.5 hours. Regardless of the overall class length, try to keep a fairly brisk pace.\n\n  Each class has a different personality and pace, so don't expect your class to match Table 2 exactly.\n\n  **Table 2. High-level timing for a 2.0 hour course**\n\n| Time from start | What you'll cover                  |\n| --------------- | ---------------------------------- |\n| 0 - 30          | Exercise 1 and Exercise 2          |\n| 30 - 55         | Exercise 3 and Intermezzo          |\n| 55 - 95         | Exercise 4 and Exercise 5          |\n| 95 - 120        | Exercise 6 and end-of-class slides |\n\n  For a 2.5 hour class, try to follow the schedule in Table 2, but don't be too concerned if some units take longer than shown.\n\n  Each exercise ends with one or more discussion slides, so make sure you factor those slides into your pacing.\n\n### Ideal course size\n\n  An ideal class has somewhere between 12 and 20 students. With too few students, it can sometimes be difficult to get good class discussions going. With too many students, class discussions can become awkward.\n\n  For large classes, we recommend having one teaching assistant for every 20 students (beyond the first 20 students). For example, for a class of 60 students, we recommend one facilitator and two teaching assistants.\n\n### Classroom setup\n\n  You need a way to project the slides in a Google Slides deck. Therefore, you need the following equipment:\n\n  •A laptop that has a network connection and can display Google Slides. Verify that you can project the slides before the class begins.•A projector or screen that can display the images on your laptop clearly to the entire class.•Access to power sockets so that students can charge their laptops. (If power sockets aren't available, email students before class and tell them to charge their laptops before attending.)\n\n  Arrange the tables or desks in the classroom so that students can see the projected slides. Ensure that chairs are arranged so that students can easily talk to and trade laptops with their partners.\n\n  For large classrooms and to help those with hearing issues, we also recommend the following audio equipment:\n\n  •a microphone, preferably wireless so that the facilitator can walk around•speakers, especially for large classes•a hearing loop[19] (also called an audio induction loop)\n\n  When students don't have access to their own laptops, consider also bringing the following to class:\n\n  •paper•pens or pencils\n\n  Though not a requirement, some facilitators bring toothpaste tubes and toothbrushes so that students can act out Exercise 3.\n\n### Course stability\n\n  We will fix bugs in the course and we might make a few additional small changes, but we don't anticipate making any big changes. We'll chronicle all significant changes to the course in the log[20].\n\n### Facilitation tips\n\n  Here are a few tips:\n\n  •When you assign an exercise, be absolutely clear on what students should do. Give students time to ask questions.•Read the room, trying to find the right balance between hurrying students along and giving them just enough time to complete (or nearly complete) the exercises.•Unstick any stuck students.\n\n## Technical Writing Two: facilitator's guide\n\n  This facilitator's guide helps prepare you to lead Technical Writing Two.\n\n### Who can facilitate this course?\n\n  Any good facilitator can lead this course; you don't need to be an expert in technical writing to lead this course. We designed this course to have students teach each other. Granted, facilitators with experience in technical writing can provide additional insights during the class.\n\n### Gaining access to the slide deck\n\n  To gain access to the slide deck, you must first become a member of the `technical-writing-instructors@googlegroups.com` group. Joining this group enrolls you in a world-wide **community** of technical writing facilitators. To build that community, use the list to do the following:\n\n  •Share training insights with your peers.•Answer questions respectfully, supportively, and generously.•Advertise any upcoming public technical writing courses.\n\n  Never do the following:\n\n  •Harm, bully, stalk, slander, or belittle anyone on this list.•Send messages not pertaining to technical writing training. Do not spam the list.\n\n  In short, treat others as you wish to be treated. If you treat others poorly, we will remove you from this list.\n\n  Finally, only humans may join this list. Machine learning is remarkable, but it doesn't belong on this list.\n\n  **Note:** We reserve the right to change these guidelines.\n\n  Take the following steps to become a member:\n\n  1.Visit the technical-writing-instructors@googlegroups.com group page[21].2.Click **Apply for membership.**\n\n### Course contents\n\n  The course consists of the sections shown in Table 1.\n\n  **Table 1. Course Sections**\n\n| Section                                   | Length (in hours) | What students do                                             | What facilitators do                                         |\n| ----------------------------------------- | ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| Pre-class exercises[22]                   | 1.0               | Work through short exercises.                                | Assign pre-class work to your students.                      |\n| In-class slide deck[23] and exercises[24] | 2.0 - 2.5         | Do four writing exercises. Participate in partner discussions. Participate in class discussions. | Facilitate the partner discussions and the class discussions. |\n\n### Preparing to facilitate\n\n  To prepare to facilitate this class, please do the following:\n\n  •Review the pre-class exercises[25].•Review the slide deck[26].•Review the in-class exercises[27].\n\n  As with any class, we recommend the following:\n\n  •Practice the material prior to leading a live class.•If you have teaching assistants, decide what each of you will do during class.\n\n### Why split pre-class work from in-class work?\n\n  The material in this class falls into two categories:\n\n  •Complex material that requires a fair amount of time, so the lesson is split across pre-class and in-class.•More straightforward material that we cover either in pre-class or in-class, but not both.\n\n  The in-class lessons lend themselves to student interaction; the pre-class lessons are good \"solo\" tasks. The pre-class lessons also serve as effective post-class refreshers.\n\n  If a facilitator is not available (and students can't experience the in-class material), the pre-class material is still valuable.\n\n### Partner discussions\n\n  Consider the following proverb:\n\n  > To learn, read a book. To learn better, take a course. To learn best, teach the course.\n\n  How do you get 20 students to each teach the material simultaneously? If students are accustomed to reviewing their peers' work, then the class will quickly fill with animated conversation as students teach each other the material. However, those students unaccustomed to peer review may feel shy or awkward about defending their answers or offering useful suggestions. Be prepared to assure your students that their feedback helps their partner. For a very shy class, consider role-playing how to give appropriate feedback.\n\n  Encourage students to change their solutions based on feedback.\n\n### Class discussions\n\n  Each unit ends with a slide that asks some conversation-provoking questions. Your job is to incite discussion and then to extinguish that discussion when you are ready to move on. Generally, students will provide ideas, but be prepared with conversation starters should your class get a little shy. We've added a few conversation starter suggestions in the speaker notes.\n\n  The following list contains a few general tips about leading discussions:\n\n  •Be positive. Encourage students whenever possible. \"That's an excellent answer. Can anyone build on that answer?\"•Build a class where students feel comfortable giving answers. To break the ice in a shy class, ask questions that have no right or wrong answers.•Seek opinions. When there are several possible answers to exercises or questions, ask students which answer they prefer and why.\n\n### Pace\n\n  We usually schedule the class for 2.0 or 2.5 hours. If a large percentage of students speak English as a second or third language, then schedule the class for 2.5 hours. Regardless of the overall class length, try to keep a fairly brisk pace.\n\n  **Table 2. High-level timing for a 2.0 hour course**\n\n| Time from start | What you'll cover                             |\n| --------------- | --------------------------------------------- |\n| 0 - 30          | Writing is rewriting                          |\n| 30 - 55         | Illustrations                                 |\n| 55 - 60         | Intermezzo: Doc types                         |\n| 60 - 85         | Descriptions                                  |\n| 85 - 90         | Intermezzo 2: How do you write a first draft? |\n| 90 - 117        | Tutorials                                     |\n| 117 - 120       | Last few slides                               |\n\n  For a 2.5 hour class, try to follow the schedule in Table 2, but don't be too concerned if some units take longer than shown.\n\n  Each exercise ends with one or more discussion slides, so make sure you factor those slides into your pacing.\n\n### Ideal course size\n\n  An ideal class has somewhere between 12 and 20 students. With too few students, it can sometimes be difficult to get good class discussions going. With too many students, class discussions can become awkward.\n\n  For large classes, we recommend having one teaching assistant for every 20 students (beyond the first 20 students). For example, for a class of 60 students, we recommend one facilitator and two teaching assistants.\n\n### Classroom setup\n\n  You need a way to project the slides in a Google Slides deck. Therefore, you need the following equipment:\n\n  •A laptop that has a network connection and can display Google Slides. Verify that you can project the slides before the class begins.•A projector or screen that can display the images on your laptop clearly to the entire class.•Access to power sockets so that students can charge their laptops. (If power sockets aren't available, email students before class and tell them to charge their laptops before attending.)\n\n  Arrange the tables or desks in the classroom so that students can see the projected slides. Ensure that chairs are arranged so that students can easily talk to and trade laptops with their partners.\n\n  For large classrooms and to help those with hearing issues, we also recommend the following audio equipment:\n\n  •a microphone, preferably wireless so that the facilitator can walk around•speakers, especially for large classes•a hearing loop[28] (also called an audio induction loop)\n\n  When students don't have access to their own laptops, consider also bringing the following to class:\n\n  •paper•pens or pencils\n\n  Although this is a laptop course, some students prefer to do the Illustrations exercise on paper.\n\n  ### Course stability\n\n  We will fix bugs in the course and we might make a few additional small changes, but we don't anticipate making any big changes. We'll chronicle all significant changes to the course in the log[29].\n\n### Facilitation tips\n\n  Here are a few tips:\n\n  •When you assign an exercise, be absolutely clear on what students should do. Give students time to ask questions.•Read the room, trying to find the right balance between hurrying students along and giving them just enough time to complete (or nearly complete) the exercises.•Unstick any stuck students.\n\n### References\n\n  `[1]` Facilitator's Guide: *https://developers.google.com/tech-writing/for-instructors/one/instructors-guide?hl=zh-cn*\n  `[2]` slide deck: *https://docs.google.com/presentation/d/1Q7mpI2KNuh1kALXYbG-PqA9sRV9M-1IoKxy_PFB2J0E?hl=zh-cn*\n  `[3]` log: *https://developers.google.com/tech-writing/for-instructors/release-notes?hl=zh-cn#One*\n  `[4]` pre-class: *https://developers.google.com/tech-writing/one?hl=zh-cn*\n  `[5]` in-class: *https://developers.google.com/tech-writing/onel?hl=zh-cn*\n  `[6]` Facilitator's Guide: *https://developers.google.com/tech-writing/for-instructors/two/instructors-guide?hl=zh-cn*\n  `[7]` slide deck: *https://docs.google.com/presentation/d/1hsusV5rt34HP4IXOFfdyJGryFJfeuPkee3XoFKp5qgA?hl=zh-cn*\n  `[8]` log: *https://developers.google.com/tech-writing/for-instructors/release-notes?hl=zh-cn#Two*\n  `[9]` pre-class: *https://developers.google.com/tech-writing/two?hl=zh-cn*\n  `[10]` in-class: *https://developers.google.com/tech-writing/twol?hl=zh-cn*\n  `[11]` Gaining access to the slide deck: *https://developers.google.com/tech-writing/for-instructors/one/instructors-guide?hl=zh-cn#gaining-access-to-the-slide-deck*\n  `[12]` technical-writing-instructors@googlegroups.com group page: *https://groups.google.com/d/forum/technical-writing-instructors?hl=zh-cn*\n  `[13]` pre-class exercises: *https://developers.google.com/tech-writing/one?hl=zh-cn*\n  `[14]` In-class slide deck: *https://docs.google.com/presentation/d/1Q7mpI2KNuh1kALXYbG-PqA9sRV9M-1IoKxy_PFB2J0E?hl=zh-cn*\n  `[15]` in-class exercises: *https://developers.google.com/tech-writing/onel?hl=zh-cn*\n  `[16]` pre-class work: *https://developers.google.com/tech-writing/one?hl=zh-cn*\n  `[17]` slide deck: *https://docs.google.com/presentation/d/1Q7mpI2KNuh1kALXYbG-PqA9sRV9M-1IoKxy_PFB2J0E?hl=zh-cn*\n  `[18]` in-class exercises: *https://developers.google.com/tech-writing/onel?hl=zh-cn*\n  `[19]` hearing loop: *https://www.hearinglink.org/living/loops-equipment/hearing-loops/what-is-a-hearing-loop/*\n  `[20]` log: *https://developers.google.com/tech-writing/for-instructors/release-notes?hl=zh-cn*\n  `[21]` technical-writing-instructors@googlegroups.com group page: *https://groups.google.com/d/forum/technical-writing-instructors?hl=zh-cn*\n  `[22]` exercises: *https://developers.google.com/tech-writing/two?hl=zh-cn*\n  `[23]` slide deck: *https://docs.google.com/presentation/d/1hsusV5rt34HP4IXOFfdyJGryFJfeuPkee3XoFKp5qgA?hl=zh-cn*\n  `[24]` exercises: *https://developers.google.com/tech-writing/twol?hl=zh-cn*\n  `[25]` pre-class exercises: *https://developers.google.com/tech-writing/two?hl=zh-cn*\n  `[26]` slide deck: *https://docs.google.com/presentation/d/1hsusV5rt34HP4IXOFfdyJGryFJfeuPkee3XoFKp5qgA?hl=zh-cn*\n  `[27]` in-class exercises: *https://developers.google.com/tech-writing/twol?hl=zh-cn*\n  `[28]` hearing loop: *https://www.hearinglink.org/living/loops-equipment/hearing-loops/what-is-a-hearing-loop/*\n  `[29]` log: *https://developers.google.com/tech-writing/for-instructors/release-notes?hl=zh-cn*\n\n------\n\n\n\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)\n",
      "data": {
        "title": "Facilitating Technical Writing Courses",
        "date": "2020-03-01 12:47:11",
        "tags": [
          "教程",
          "tutorial"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "google-TFacilitating-Technical-Writing-Courses"
    },
    {
      "content": "\n> Google 技术写作课程搬运，原文地址：[https://developers.google.com/tech-writing/overview?hl=zh-cn](https://developers.google.com/tech-writing/overview?hl=zh-cn)\n\n# Technical Writing Courses\n\n\nEvery engineer is also a writer.\n\nThis collection of courses and learning resources aims to improve your technical documentation. Learn how to plan and author technical documents. You can also learn about the role of technical writers at Google.\n\n\n\n# Overview of technical writing courses\n\n\n\nThe following table summarizes the technical writing courses:\n\n| Take this course... | Title                                                        | Focus                                    | Pre-Class | In-Class       |\n| :------------------ | :----------------------------------------------------------- | :--------------------------------------- | :-------- | :------------- |\n| first               | [Technical Writing One](http://blog.gusibi.site/post/google-technical-writing-courses/#technical-writing-one) | the critical basics of technical writing | 2 hours   | 2 to 2.5 hours |\n| second              | [Technical Writing Two](http://blog.gusibi.site/post/google-technical-writing-courses/#technical-writing-two) | intermediate topics in technical writing | 1 hour    | 2 to 2.5 hours |\n\nThe pre-class components introduce topics; the in-class components help students integrate those topics. That said, the pre-class lessons on their own still provide a valuable educational experience.\n\nWe've aimed *Technical Writing One* and *Technical Writing Two* at the following audiences:\n\n- software engineers\n- software engineering students\n\nAdditionally, many people in engineering-adjacent roles (such as product managers) have also benefited from these courses.\n\n# Technical Writing One\n\n## Technical Writing One introduction\n\n\n\nTechnical Writing One teaches you how to write clearer technical documentation.\n\n#### Target audience\n\nYou need at least a little writing proficiency in English, but you don't need to be a strong writer to take this course.\n\nIf you've never taken any technical writing training, this course is perfect for you. If you've taken technical writing training, this class provides an efficient refresher.\n\n#### Learning objectives\n\nThis course teaches you the fundamentals of technical writing. After completing this class, you will know how to do the following:\n\n- Use terminology—including abbreviations and acronyms—consistently.\n- Recognize and disambiguate pesky pronouns.\n- Distinguish active voice from passive voice.\n- Convert passive voice sentences to active voice.\n- Identify three ways in which active voice is superior to passive voice.\n- Develop at least three strategies to make sentences clearer and more engaging.\n- Develop at least four strategies to shorten sentences.\n- Understand the difference between bulleted lists and numbered lists.\n- Create helpful lists.\n- Create effective lead sentences for paragraphs.\n- Focus each paragraph on a single topic.\n- State key points at the start of each document.\n- Identify your target audience.\n- Determine what your target audience already knows and what your target audience needs to learn.\n- Understand the curse of knowledge.\n- Identify and revise idioms.\n- State your document's scope (goals) and audience.\n- Break long topics into appropriate sections.\n- Use commas, parentheses, colons, em-dashes, and semicolons properly.\n- Develop beginner competency in Markdown.\n\nIt takes years of focused practice to become a great engineer or a great technical writer. This course will improve your technical writing but will not instantly transform you into a great technical writer.\n\n#### Pre-class and in-class components\n\nThe course consists of the following two components:\n\n- pre-class\n- in-class\n\nYou are currently viewing the start of the pre-class component.\n\nThe in-class component enhances the lessons taught in the pre-class components. That said, the pre-class lessons on their own still provide a valuable educational experience.\n\n#### Hardware and network requirements\n\nAlthough this course is optimized for a laptop or desktop, you may take the course on a tablet or phone. If you are taking the in-class component, please note that you'll type a lot.\n\nYou need an internet connection to take the course. You cannot download the course. The course is not available on tangible media.\n\nThe course contains a few short videos, all of which are optional viewing. If you want to skip the videos, then you can take the course on a low-bandwidth internet connection.\n\n#### Optional units\n\nWe've marked a few units as **optional**. This material isn't essential, though you'll probably find the material useful.\n\n## Just enough grammar (optional)\n\n\n\nThis unit provides just enough grammar to understand the remainder of the course. If you already know some grammar, move on to [Words](https://developers.google.com/tech-writing/one/words?hl=zh-cn). Otherwise, read on.\n\nFor simplicity's sake, this unit takes a few shortcuts; grammatical topics are actually wildly more complicated than this unit suggests.\n\nGrammarians don't all agree on the number or types of parts of speech. The following table focuses on the parts of speech relevant to this course:\n\n| Part of Speech | Definition                                                   | Example                                                      |\n| :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| Noun           | a person, place, concept, or thing                           | **Sam** runs **races**.                                      |\n| Pronoun        | a noun that substitutes for another noun                     | Sam runs races. **He** likes to compete.                     |\n| Adjective      | a word or phrase that modifies a noun                        | Sam wears **blue** shoes.                                    |\n| Verb           | an action word or phrase                                     | Sam **runs** races.                                          |\n| Adverb         | a word or phrase that modifies a verb, an adjective, or another adverb | Sam runs **slowly**.                                         |\n| Preposition    | a word or phrase specifying the positional relationship of two nouns | Sam's sneakers are seldom **on** his shelf.                  |\n| Conjunction    | a word that connects two nouns or phrases                    | Sam's trophies **and** ribbons live only in his imagination. |\n| Transition     | a word or phrase that connects two sentences                 | Sam runs races weekly. **However**, he finishes races weakly. |\n\n### Nouns\n\nNouns represent people, places, or things. **Judy**, **Antarctica**, and **hammers** are all nouns, but so are intangible concepts like **robustness** and **perfection**. For example, we've highlighted the nouns in the following passage:\n\n> In the **framework**, an **object** must copy any underlying **values** that the **object** wants to change. The **protos** in the **codebase** are huge, so copying the **protos** is unacceptably expensive.\n\nIn programming, you might think of classes and variables as your program's nouns.\n\n#### Exercise\n\nIdentify the six nouns in the following passage:\n\n> C enables programmers to control pointers and memory. Great power brings great responsibility.\n\n\n\n##### Answer\n\nYou can find the nouns in boldface:\n\n> **C** enables **programmers** to control **pointers** and **memory**. Great **power** brings great **responsibility**.\n\nNow suppose the second sentence was the following:\n\n> Great control brings great responsibility.\n\nIs \"control\" a verb or is it a noun?\n\nIn this context, \"control\" is a noun, even though \"to control\" in the first sentence is a verb. Many words in English serve as a noun in some contexts and a verb in others.\n\n### Pronouns\n\nPronouns are an indirection layer—pointers to or substitutions for other nouns or sentences. For example, consider the following two sentences:\n\n> Janet writes great code. **She** is a senior staff engineer.\n\nIn the preceding example, the first sentence establishes **Janet** as a noun. The second sentence substitutes the pronoun **She** for the noun **Janet**.\n\nIn the following example, the pronoun **This** substitutes for the entire sentence that preceded it:\n\n> Most applications aren't sufficiently tested. **This** is poor engineering.\n\n#### Exercise\n\nIdentify the three pronouns in the following passage:\n\n> The cafeteria featured peashew butter and pluot jam on pumperye toast. Employees found it awesome and wished they could eat this every day.\n\n\n\n##### Answer\n\n> The cafeteria featured peashew butter and pluot jam on pumperye toast. Employees found **it** awesome and wished **they** could eat **this** every day.\n\n### Verbs\n\nA verb is an action word or phrase. When you want to represent the relationship between two nouns (an actor and a target), the verb does the work. A verb identifies what the actor does to the target.\n\nEach sentence must contain at least one verb. For example, each of the following sentences contain a single verb:\n\n- Sakai **prefers** pasta.\n- Rick **likes** the ocean.\n- Smurfs **are** blue.\n- Jess **suffers** from allergies.\n\nSome sentences, such as the following, contain multiple verbs:\n\n- Nala **suffers** from allergies and **sneezes** constantly.\n- Chung **likes** snacks **to eat** while **riding** the train.\n\nDepending on the tense and the conjugation, a verb could consist of one word or multiple words. For example:\n\n- Tina **was eating** breakfast a few hours ago.\n- Tina **is eating** lunch right now.\n- Tina **will eat** dinner tonight at 7:00.\n\n#### Exercise\n\nIdentify the verbs in the following passage:\n\n> Samantha is coding Operation Bullwinkle in C++. This project currently consumes over 80,000 lines of code. She previously used Python, but recently gravitated to C++. Samantha leads a team of four software engineers, which will grow to six software engineers next quarter.\n\n\n\n##### Answer\n\n> Samantha **is coding** Operation Bullwinkle in C++. This project currently **consumes** over 80,000 lines of code. She previously **used** Python, but recently **gravitated** to C++. Samantha **leads** a team of four software engineers, which **will grow** to six software engineers next quarter.\n\n### Adjectives and adverbs\n\nAdjectives modify nouns. For example, in the following passage, notice how the adjectives modify the subsequent noun:\n\n- Tom likes **red** balloons. He prepares **delicious** food. He fixed **eight** bugs at work.\n\nMost adverbs modify verbs. For example, notice how the adverb (**efficiently**) in the following sentence modifies the verb (**fixes**):\n\n- Jane **efficiently** fixes bugs.\n\nAdverbs are not necessarily right next to their verb. For example, in the following sentence, the adverb (**efficiently**) is two words away from the verb (**fixes**):\n\n- Jane fixes bugs **efficiently**.\n\nAdverbs can also modify adjectives or other adverbs.\n\n#### Exercise\n\nIdentify the four adjectives in the following passage:\n\n> Engineering is a great career for brilliant minds. I know five engineers who could excel at any intellectual task.\n\n\n\n##### Answer\n\n> Engineering is a **great** career for **brilliant** minds. I know **five** engineers who could excel at any **intellectual** task.\n\n### Conjunctions and transitions\n\nConjunctions connect phrases or nouns *within* a sentence; transitions connect sentences themselves.\n\nThe most important conjunctions are as follows:\n\n- and\n- but\n- or\n\nFor example, in the following sentence, **and** connects \"code\" with \"documentation,\" while **but** connects the first half of the sentence with the second.\n\n> Natasha writes great internal code **and** documentation **but** seldom works on open-source projects.\n\nThe most important transitions in technical writing are as follows:\n\n- however\n- therefore\n- for example\n\nFor example, in the following passage, notice how the transitions connect and contextualize the sentences:\n\n> Juan is a wonderful coder. **However**, he rarely writes sufficient tests. **For example**, Juan coded a 5,000 line FFT package that contained only a single 10-line unit test.\n\n#### Exercise\n\nFill in the most appropriate transition:\n\n> Barbara typically studies problems for a long time before writing the first line of code. _____________, she spontaneously coded a method the other day when she was suddenly inspired.\n\n\n\n##### Answer\n\nThe best transition for this situation is as follows:\n\n> However\n\n\n\n## Words\n\nWe researched documentation extensively, and it turns out that the best sentences in the world consist primarily of words.\n\n### Define new or unfamiliar terms\n\nWhen writing or editing, learn to recognize terms that might be unfamiliar to some or all of your target audience. When you spot such a term, take one of the following two tactics:\n\n- If the term already exists, link to a good existing explanation. (Don't reinvent the wheel.)\n- If your document is introducing the term, define the term. If your document is introducing many terms, collect the definitions into a glossary.\n\nUse terms consistently\n\nIf you change the name of a variable midway through a method, your code won’t compile. Similarly, if you rename a term in the middle of a document, your ideas won’t compile (in your users’ heads).\n\nThe moral: apply the same unambiguous word or term consistently throughout your document. Once you've named a component **thingy**, don't rename it **thingamabob**. For example, the following paragraph mistakenly renames **Protocol Buffers** to **protobufs**:\n\n> Protocol Buffers provide their own definition language. Blah, blah, blah. And that's why protobufs have won so many county fairs.\n\nYes, technical writing is cruel and restrictive, but at least technical writing provides an excellent workaround. Namely, when introducing a long-winded concept name or product name, you may also specify a shortened version of that name. Then, you may use that shortened name throughout the document. For example, the following paragraph is fine:\n\n> **Protocol Buffers** (or **protobufs** for short) provide their own definition language. Blah, blah, blah. And that's why protobufs have won so many county fairs.\n\n### Use acronyms properly\n\nOn the initial use of an unfamiliar acronym within a document or a section, spell out the full term, and then put the acronym in parentheses. Put both the spelled-out version and the acronym in boldface. For example:\n\n> This document is for engineers who are new to the **Telekinetic Tactile Network** (**TTN**) or need to understand how to order TTN replacement parts through finger motions.\n\nYou may then use the acronym going forward, as in the following example:\n\n> If no cache entry exists, the Mixer calls the **OttoGroup Server** (**OGS**) to fetch Ottos for the request. The OGS is a repository that holds all servable Ottos. The OGS is organized in a logical tree structure, with a root node and two levels of leaf nodes. The OGS root forwards the request to the leaves and collects the responses.\n\nDo not cycle back-and-forth between the acronym and the expanded version in the same document.\n\n#### Use the acronym or the full term?\n\nSure, you can introduce and use acronyms properly, but *should* you use acronyms? Well, acronyms do reduce sentence size. For example, *TTN* is two words shorter than *Telekinetic Tactile Network*. However, acronyms are really just a layer of abstraction; readers must mentally expand recently learned acronyms to the full term. For example, readers convert *TTN* to *Telekinetic Tactile Network* in their heads, so the \"shorter\" acronym actually takes a little longer to process than the full term.\n\nHeavily used acronyms develop their own identity. After a number of occurrences, readers generally stop expanding acronyms into the full term. Many Web developers, for example, have forgotten what *HTML* expands to.\n\nHere are the guidelines for acronyms:\n\n- Don't define acronyms that would only be used a few times.\n- Do define acronyms that meet both of the following criteria:\n  - The acronym is significantly shorter than the full term.\n  - The acronym appears many times in the document.\n\n#### Exercise\n\nFix the following passage. Assume that this passage is the initial instance of the term **MapReduce** in the document and that **MR** is the best abbreviation:\n\n> Jeff Dean invented MapReduce in 1693, implementing the algorithm on a silicon-based computer fabricated from beach sand, wax-paper, a quill pen, and a toaster oven. His version of MR held several world performance records until 2014.\n\n##### Answer\n\nYou could take a few different approaches here. One approach is to associate the acronym *MR* with the full term and then use that acronym:\n\n> Jeff Dean invented **MapReduce** (**MR**) in... This version of MR held several...\n\nAlternatively, you could decide that defining an acronym for such a short passage puts too much burden on readers, so you'll simply use the full term *MapReduce* every time:\n\n> Jeff Dean invented **MapReduce** in... This version of MapReduce held several...\n\nIncidentally, a more thorough technical writer would also convert \"beach sand, wax-paper, a quill pen, and a toaster oven\" into a bulleted list. However, that's another story for another lesson.\n\n------\n\n### Disambiguate pronouns\n\nMany pronouns point to a previously introduced noun. Such pronouns are analogous to pointers in programming. Like pointers in programming, pronouns tend to introduce errors. Improperly using pronouns causes the cognitive equivalent of a `nullptr` error in your readers’ heads. In many cases, you should simply avoid the pronoun and just reuse the noun. However, the utility of a pronoun sometimes outweighs its risk (as in this sentence).\n\nConsider the following pronoun guidelines:\n\n- Only use a pronoun *after* you've introduced the noun; never use the pronoun before you've introduced the noun.\n- Place the pronoun as close as possible to the referring noun. As a rule of thumb, if more than five words separate your noun from your pronoun, consider repeating the noun instead of using the pronoun.\n- If you introduce a second noun between your noun and your pronoun, reuse your noun instead of using a pronoun.\n\n#### It and they\n\nThe following pronouns cause the most confusion in technical documentation:\n\n- it\n- they, them, and their\n\nFor example, in the following sentence, does **It** refer to Python or to C++?\n\n> Python is interpreted, while C++ is compiled. **It** has an almost cult-like following.\n\nAs another example, what does **their** refer to in the following sentence?\n\n> Be careful when using Frambus or Carambola with HoobyScooby or BoiseFram because a bug in **their** core may cause accidental mass unfriending.\n\n#### This and that \n\nConsider two additional problem pronouns:\n\n- this\n- that\n\nFor example, in this following ambiguous sentence, **This** could refer to Frambus, to Foo, or to both:\n\n> You may use either Frambus or Foo to calculate derivatives. **This** is not optimal.\n\nUse either of the following tactics to disambiguate **this** and **that**:\n\n- Replace **this** or **that** with the appropriate noun.\n- Place a noun immediately after **this** or **that**.\n\nFor example, either of the following sentences disambiguate the previous example:\n\n> **Overlapping functionality** is not optimal.\n>\n> **This overlapping functionality** is not optimal.\n\n#### Exercise\n\nIdentify all possible meanings for the ambiguous pronouns in each of the following passages:\n\n1. Aparna and Phil share responsibilities with Maysam and Karan and they are the next ones on call.\n2. You may import Carambola data via your configuration file or dynamically at run time. This may be a security risk.\n\n\n\n##### Answer\n\n1. The pronoun **they** could refer to any of the following:\n   - Aparna and Phil\n   - Maysam and Karan\n   - Aparna, Phil, Maysam, and Karan\n2. The pronoun **this** could refer to any of the following: \n   - importing via the configuration file\n   - importing dynamically at run time\n   - both\n\n------\n\n\n\n## Active voice vs. passive voice\n\n\n\nThe vast majority of sentences in technical writing should be in active voice. This unit teaches you how to do the following:\n\n- Distinguish passive voice from active voice.\n- Convert passive voice to active voice because active voice is usually clearer.\n\nFirst, watch this video, just to get the ball rolling[1](https://developers.google.com/tech-writing/one/active-voice?hl=zh-cn#Footnote1):\n\nhttps://youtu.be/nG6DhoFt938\n\n### Distinguish active voice from passive voice in simple sentences\n\nIn an active voice sentence, an actor acts on a target. That is, an active voice sentence follows this formula:\n\n> Active Voice Sentence = actor + verb + target\n\nA passive voice sentence reverses the formula. That is, a passive voice sentence typically follows the following formula:\n\n> Passive Voice Sentence = target + verb + actor\n\n#### Active voice example\n\nFor example, here’s a short, active voice sentence:\n\n> The cat sat on the mat.\n\n- actor: The cat\n- verb: sat\n- target: the mat\n\n#### Passive voice examples\n\nBy contrast, here's that same sentence in passive voice:\n\n> The mat was sat on by the cat.\n\n- target: The mat\n- passive verb: was sat\n- actor: the cat\n\nSome passive voice sentences omit an actor. For example:\n\n> The mat was sat on.\n\n- actor: *unknown*\n- passive verb: was sat\n- target: the mat\n\nWho or what sat on the mat? A cat? A dog? A T-Rex? Readers can only guess. Good sentences in technical documentation identify who is doing what to whom.\n\n### Recognize passive verbs\n\nPassive verbs typically have the following formula:\n\n```\npassive verb = form of be + past participle verb\n```\n\nAlthough the preceding formula looks daunting, it is actually pretty simple:\n\n- A **form of \\*be\\*** in a passive verb is typically one of the following words:\n  - is/are\n  - was/were\n- A **past participle verb** is typically a plain verb plus the suffix *ed*. For example, the following are past participle verbs:\n  - interpreted\n  - generated\n  - formed\n\nUnfortunately, some past participle verbs are irregular; that is, the past participle form does not end with the suffix *ed*. For example:\n\n- sat\n- known\n- frozen\n\nPutting the form of *be* and the past participle together yields passive verbs, such as the following:\n\n- was interpreted\n- is generated\n- was formed\n- is frozen\n\nIf the phrase contains an actor, a preposition ordinarily follows the passive verb. (That preposition is often a key clue to help you spot passive voice.) The following examples combine the passive verb and the preposition:\n\n- was interpreted as\n- is generated by\n- was formed by\n- is frozen by\n\n#### Imperative verbs are typically active\n\nIt is easy to mistakenly classify sentences starting with an imperative verb as passive. An **imperative verb** is a command. Many items in numbered lists start with imperative verbs. For example, *Open* and *Set* in the following list are both imperative verbs:\n\n1. Open the configuration file.\n2. Set the `Frombus` variable to `False`.\n\nSentences that start with an imperative verb are typically in active voice, even though they do not explicitly mention an actor. Instead, sentences that start with an imperative verb *imply* an actor. The implied actor is **you**.\n\n#### Exercise\n\nMark each of the following sentences as either **Passive** or **Active**:\n\n1. `MutableInput` provides read-only access.\n2. Read-only access is provided by `MutableInput`.\n3. Performance was measured.\n4. Python was invented by Guido van Rossum in the twentieth century.\n5. David Korn discovered the KornShell quite by accident.\n6. This information is used by the policy enforcement team.\n7. Click the Submit button.\n8. The orbit was calculated by Katherine Johnson.\n\n\n\n##### Answer\n\n1. **Active**. MutableInput provides read-only access.\n2. **Passive**. Read-only access is provided by MutableInput.\n3. **Passive**. Performance was measured.\n4. **Passive**. Python was invented by Guido van Rossum in the twentieth century.\n5. **Active**. David Korn discovered the KornShell quite by accident.\n6. **Passive**. This information is used by the policy enforcement team.\n7. **Active**. Click the Submit button. (*Click* is an imperative verb.) \n8. **Passive**. The orbit was calculated by Katherine Johnson.\n\n------\n\n### Distinguish active voice from passive voice in more complex sentences\n\nMany sentences contain multiple verbs, some of which are active and some of which are passive. For example, the following sentence contains two verbs, both of which are in passive voice:\n\n![A diagram of the following sentence: Code is interpreted by           Python, but code is compiled by C++.  The first half of the sentence           (Code is interpreted by Python) is in active voice, where a target           (Code) is acted on (is interpreted) by the actor (Python).           The second half of the sentence (code is compiled by C++) is also in           passive voice, where the target (code) is acted on (is compiled)           by the actor (C++).](https://developers.google.com/tech-writing/one/images/passive-passive.svg?hl=zh-cn)\n\n \n\n\n\nHere is that same sentence, partially converted to active voice:\n\n![A diagram of the following sentence: Python interprets code,           but code is compiled by C++.  The first half of the sentence           (Python interprets code) is in active voice, where an actor           (Python) acts on (interprets) a target (code). The second half           of the sentence (code is compiled by C++) is in passive voice,           where the target (code) is acted on (is compiled) by the           actor (C++).](https://developers.google.com/tech-writing/one/images/active-passive.svg?hl=zh-cn)\n\n \n\n\n\nAnd here is that same sentence, now fully converted to active voice:\n\n![A diagram of the following sentence: Python interprets code,           but C++ compiles code.  The first half of the sentence           (Python interprets code) is in active voice, where an actor           (Python) acts on (interprets) a target (code). The second half           of the sentence (C++ compiles code) is also in active voice,           where the actor (C++) acts on (compiles) the target (code).](https://developers.google.com/tech-writing/one/images/all-active.svg?hl=zh-cn)\n\n \n\n\n\n#### Exercise\n\nEach of the following sentences contains two verbs. Categorize each of the verbs in the following sentences as either active or passive. For example, if the first verb is active and the second is passive, write **Active, Passive**.\n\n1. The QA team loves ice cream, but their managers prefer sorbet.\n2. Performance metrics are required by the team, though I prefer wild guesses.\n3. When software engineers attempt something new and innovative, a reward should be given.\n\n\n\n##### Answer.\n\n1. **Active, Active.** The QA team loves ice cream, but their managers prefer sorbet.\n2. **Passive, Active.** Performance metrics are required by the team, though I prefer wild guesses.\n3. **Active, Passive.** When software engineers attempt something new and innovative, a reward should be given.\n\n### Prefer active voice to passive voice\n\nUse the active voice most of the time. Use the passive voice sparingly. Active voice provides the following advantages:\n\n- Most readers mentally convert passive voice to active voice. Why subject your readers to extra processing time? By sticking to active voice, readers can skip the preprocessor stage and go straight to compilation.\n- Passive voice obfuscates your ideas, turning sentences on their head. Passive voice reports action indirectly.\n- Some passive voice sentences omit an actor altogether, which forces the reader to guess the actor's identity.\n- Active voice is generally shorter than passive voice.\n\nBe bold—be active.\n\n#### Scientific research reports (optional material)\n\nThe writing in research reports tends to be understated. Here, for example, is one of the most famous passages in twentieth century science writing, from Crick and Watson's 1953 paper in *Nature* entitled, *Molecular Structure of Nucleic Acids: A Structure for Deoxyribose Nucleic Acid*:\n\n> It has not escaped our notice that the specific pairing we have postulated immediately suggests a possible copying mechanism for the genetic material.\n\nThe authors are so excited about their discovery that they're whispering it from the rooftops.\n\nPassive voice thrives in a tentative landscape. In research reports, experimenters and their equipment often disappear, leading to passive sentences that start off as follows:\n\n- It has been suggested that...\n- Data was taken...\n- Statistics were calculated...\n- Results were evaluated.\n\nDo we know who is doing what to whom? No. Does the passive voice somehow make the information more objective? No.\n\nMany scientific journals have embraced active voice. We encourage the remainder to join the quest for clarity.\n\n#### Exercise\n\nRewrite the following passive voice sentences as active voice. Only part of certain sentences are in passive voice; ensure that all parts end up as active voice:\n\n1. The flags were not parsed by the Mungifier.\n2. A wrapper is generated by the Op registration process.\n3. Only one experiment per layer is selected by the Frombus system.\n4. Quality metrics are identified by asterisks; ampersands identify bad metrics.\n\n\n\n##### Answer.\n\n1. The Mungifier did not parse the flags.\n2. The Op registration process generates a wrapper.\n3. The Frombus system selects only one experiment per layer.\n4. Asterisks identify quality metrics; ampersands identify bad metrics.\n\n\n\n## Clear sentences\n\n>  **Estimated Time:** 10 minutes\n\n\n\nComedy writers seek the funniest results, horror writers strive for the scariest, and technical writers aim for the clearest. In technical writing, clarity takes precedence over all other rules. This unit suggests a few ways to make your sentences beautifully clear.\n\n### Choose strong verbs\n\nMany technical writers believe that the verb is the most important part of a sentence. Pick the right verb and the rest of the sentence will take care of itself. Unfortunately, some writers reuse only a small set of mild verbs, which is like serving your guests stale crackers and soggy lettuce every day. Picking the right verb takes a little more time but produces more satisfying results.\n\nTo engage and educate readers, choose precise, strong, specific verbs. Reduce imprecise, weak, or generic verbs, such as the following:\n\n- forms of *be*: is, are, am, was, were, etc.\n- occur\n- happen\n\nFor example, consider how strengthening the weak verb in the following sentences ignites a more engaging sentence:\n\n| Weak Verb                                             | Strong Verb                                         |\n| :---------------------------------------------------- | :-------------------------------------------------- |\n| The error **occurs** when clicking the Submit button. | Clicking the Submit button **triggers** the error.  |\n| This error message **happens** when...                | The system **generates** this error message when... |\n| We **are** very careful to ensure...                  | We carefully **ensure**...                          |\n\nMany writers rely on forms of *be* as if they were the only spices on the rack. Sprinkle in different verbs and watch your prose become more appetizing. That said, a form of *be* is sometimes the best choice of verb, so don't feel that you have to eliminate every form of *be* from your writing.\n\nNote that generic verbs often signal other ailments, such as:\n\n- an imprecise or missing actor in a sentence\n- a passive voice sentence\n\n#### Exercise\n\nClarify the following sentences by picking more specific verbs. Along the way, feel free to rearrange the sentences and to add, modify, or delete words:\n\n1. When a variable declaration doesn't have a datatype, a compiler error happens.\n2. Compiler errors occur when you leave off a semicolon at the end of a statement.\n\n\n\n##### Answer.\n\n1. A few possible answers:\n   - When a variable declaration doesn't **specify** a datatype, the compiler **generates** an error message.\n   - If you **declare** a variable but don't **specify** a datatype, the compiler **generates** an error message.\n2. A few possible answers:\n   - Compilers **issue** errors when you **omit** a semicolon at the end of a statement.\n   - A missing semicolon at the end of a statement **triggers** compiler errors.\n\n------\n\n### Reduce there is/there are\n\nSentences that start with **There is** or **There are** marry a generic noun to a generic verb. Generic weddings bore readers. Show true love for your readers by providing a real subject and a real verb.\n\nIn the best case scenario, you may simply delete **There is** or **There are** (and possibly another word or two later in the sentence). For example, consider the following sentence:\n\n> There is a variable called `met_trick` that stores the current accuracy.\n\nRemoving **There is** replaces the generic subject with a better subject. For example, either of the following sentences is clearer than the original:\n\n> A variable named `met_trick` stores the current accuracy. The `met_trick` variable stores the current accuracy.\n\nYou can sometimes repair a **There is** or **There are** sentence by moving the true subject and true verb from the end of the sentence to the beginning. For example, notice that the pronoun **you** appears towards the end of the following sentence:\n\n> There are two disturbing facts about Perl you should know.\n\nReplacing **There are** with **You** strengthens the sentence:\n\n> You should know two disturbing facts about Perl.\n\nIn still other situations, writers start sentences with **There is** or **There are** to avoid the hassle of creating true subjects or verbs. If no subject exists, consider creating one. For example, the following **There is** sentence does not identify the receiving entity:\n\n> There is no guarantee that the updates will be received in sequential order.\n\nReplacing \"There is\" with a meaningful subject (such as **clients**) creates a clearer experience for the reader:\n\n> Clients might not receive the updates in sequential order.\n\n#### Exercise\n\nClarify the following sentences by removing **There is**, and possibly rearranging, adding, modifying, or deleting other words:\n\n1. There is a lot of overlap between X and Y.\n2. There is no creator stack for the main thread.\n3. There is a low-level, TensorFlow, Python interface to load a saved model.\n4. There is a sharding function named `distribute` that assigns keys.\n\n\n\n##### Answer.\n\n1. X and Y overlap a lot.\n2. The main thread does not provide a creator stack.\n3. TensorFlow provides a low-level Python interface to load a saved model.\n4. The `distribute` sharding function assigns keys.\n\n------\n\n### Minimize certain adjectives and adverbs (optional)\n\nAdjectives and adverbs perform amazingly well in fiction and poetry. Thanks to adjectives, plain old grass becomes **prodigal** and **verdant**, while lifeless hair transforms into something **silky** and **flowing**. Adverbs push horses to run **madly** and **freely** and dogs to bark **loudly** and **ferociously**. Unfortunately, adjectives and adverbs sometimes make technical readers bark loudly and ferociously. That's because adjectives and adverbs tend to be too loosely defined and subjective for technical readers. Worse, adjectives and adverbs can make technical documentation sound dangerously like marketing material. For example, consider the following passage from a technical document:\n\n> Setting this flag makes the application run screamingly fast.\n\nGranted, **screamingly fast** gets readers attention but not necessarily in a good way. Feed your technical readers factual data instead of marketing speak. Refactor amorphous adverbs and adjectives into objective numerical information. For example:\n\n> Setting this flag makes the application run 225-250% faster.\n\nDoes the preceding change strip the sentence of some of its charm? Yes, a little, but the revamped sentence gains accuracy and believability.\n\n**Note:** Don't confuse educating your readers (technical writing) with publicizing or selling a product (marketing writing). When your readers expect education, provide education; don't intersperse publicity or sales material inside educational material.\n\n\n\n## Short sentences\n\n>  **Estimated Time:** 20 minutes\n\n\n\nSoftware engineers generally try to minimize the number of lines of code in an implementation for the following reasons:\n\n- Shorter code is typically easier for others to read.\n- Shorter code is typically easier to maintain than longer code.\n- Extra lines of code introduce additional points of failure.\n\nIn fact, the same rules apply to technical writing:\n\n- Shorter documentation reads faster than longer documentation.\n- Shorter documentation is typically easier to maintain than longer documentation.\n- Extra lines of documentation introduce additional points of failure.\n\nFinding the shortest documentation implementation takes time but is ultimately worthwhile. Short sentences communicate more powerfully than long sentences, and short sentences are usually easier to understand than long sentences.\n\n### Focus each sentence on a single idea\n\nFocus each sentence on a single idea, thought, or concept. Just as statements in a program execute a single task, sentences should execute a single idea. For example, the following very long sentence contains multiple thoughts:\n\n> The late 1950s was a key era for programming languages because IBM introduced FORTRAN in 1957 and John McCarthy introduced Lisp the following year, which gave programmers both an iterative way of solving problems and a recursive way.\n\nBreaking the long sentence into a succession of single-idea sentences yields the following result:\n\n> The late 1950s was a key era for programming languages. IBM introduced FORTRAN in 1957. John McCarthy invented Lisp the following year. Consequently, by the late 1950s, programmers could solve problems iteratively or recursively.\n\n#### Exercise\n\nConvert the following overly long sentence to a series of shorter sentences. Don't revise too much; just end up with a few sentences instead of only one.\n\n> In bash, use the if, then, and fi statements to implement a simple conditional branching block in which the if statement evaluates an expression, the then statement introduces a block of statements to run when the if expression is true, and the fi statement marks the end of the conditional branching block.\n\n\n\n##### Answer.\n\nIn bash, use an `if`, `then`, and `fi` statement to implement a simple conditional branching block. The `if` statement evaluates an expression. The `then` statement introduces a block of statements to run when the `if` expression is true. The `fi` statement marks the end of the conditional branching block. (The resulting paragraph remains unclear but is still much easier to read than the original sentence.)\n\n------\n\n### Convert some long sentences to lists\n\nInside many long technical sentences is a list yearning to break free. For example, consider the following sentence:\n\n> To alter the usual flow of a loop, you may use either a **break** statement (which hops you out of the current loop) or a **continue** statement (which skips past the remainder of the current iteration of the current loop).\n\nWhen you see the conjunction **or** in a long sentence, consider refactoring that sentence into a bulleted list. When you see an embedded list of items or tasks within a long sentence, consider refactoring that sentence into a bulleted or numbered list. For example, the preceding example contains the conjunction **or**, so let's convert that long sentence to the following bulleted list:\n\n------\n\nTo alter the usual flow of a loop, call one of the following statements:\n\n- `break`, which hops you out of the current loop.\n\n- `continue`, which skips past the remainder of the current iteration of the current loop.\n\n------\n\n#### Exercise\n\nRefactor the following sentences into something shorter and clearer. Make sure that your answer contains a list:\n\n1. To get started with the Frambus app, you must first find the app at a suitable store, pay for it using a valid credit or debit card, download it, configure it by assigning a value for the `Foo` variable in the `/etc/Frambus` file, and then run it by saying the magic word twice.\n2. KornShell was invented by David Korn in 1983, then a computer scientist at Bell Labs, as a superset of features, enhancements, and improvements over the Bourne Shell (which it was backwards compatible with), which was invented by Stephen Bourne in 1977 who was also a computer scientist at Bell Labs.\n\n\n\n##### Answer.\n\nTake the following steps to get started with the Frambus app:\n\n1. Find the app at a suitable store.\n2. Pay for the app using a valid credit or debit card.\n3. Download the app.\n4. Configure the app by assigning a value for the Foo variable in the `/etc/Frambus` file.\n5. Run the app by saying the magic word twice.\n\nThe following two Bell Labs computer scientists invented popular shells:\n\n- Stephen Bourne invented the Bourne Shell in 1977.\n- David Korn invented the KornShell in 1983.\n\nThe KornShell's features are a backwards-compatible superset of the Bourne Shell's.\n\n------\n\n### Eliminate or reduce extraneous words\n\nMany sentences contain filler—textual junk food that consumes space without nourishing the reader. For example, see if you can spot the unnecessary words in the following sentence:\n\n> An input value greater than 100 causes the triggering of logging.\n\nReplacing **causes the triggering of** with the much shorter verb **triggers** yields a shorter sentence:\n\n> An input value greater than 100 triggers logging.\n\nWith practice, you'll spot the extraneous words and take inordinate glee in removing or reducing them. For example, consider the following sentence:\n\n> This design document provides a detailed description of Project Frambus.\n\nThe phrase **provides a detailed description of** reduces to the verb **details**, so the resulting sentence becomes:\n\n> This design document details Project Frambus.\n\nThe following table suggests replacements for a few common bloated phrases:\n\n| Wordy                     | Concise |\n| :------------------------ | :------ |\n| at this point in time     | now     |\n| determine the location of | find    |\n| is able to                | can     |\n\n#### Exercise\n\nShorten the following sentences without changing their meaning:\n\n1. In spite of the fact that Arnold writes buggy code, he writes error-free documentation.\n2. Changing the sentence from passive voice to active voice enhances the clarification of the key points.\n3. Determine whether Rikona is able to write code in COBOL.\n4. Frambus causes the production of bugs, which will be chronicled in logs by the LogGenerator method.\n\n\n\n##### Answer.\n\nHere are some possible solutions:\n\n1. Although Arnold writes buggy code, he writes error-free documentation. \n   **Alternative answer:** Arnold writes buggy code. However, he writes error-free documentation.\n2. Changing the sentence from passive voice to active voice clarifies the key points.\n3. Determine whether Rikona can code in COBOL.\n4. Frambus produces bugs, which the LogGenerator method logs.\n\n------\n\n### Reduce subordinate clauses (optional)\n\nA **clause** is an independent logical fragment of a sentence, which contains an actor and an action. Every sentence contains the following:\n\n- a main clause\n- zero or more subordinate clauses\n\nSubordinate clauses modify the idea in the main clause. As the name implies, subordinate clauses are less important than the main clause. For example, consider the following sentence:\n\n> Python is an interpreted programming language, which was invented in 1991.\n>\n> - main clause: Python is an interpreted programming language\n> - subordinate clause: which was invented in 1991\n\nYou can usually identify subordinate clauses by the words that introduce them. The following list (by no means complete) shows common words that introduce subordinate clauses:\n\n- which\n- that\n- because\n- whose\n- until\n- unless\n- since\n\nSome subordinate clauses begin with a comma and some don't. The highlighted subordinate clause in the following sentence, for example, begins with the word **because** and does not contain a comma:\n\n> I prefer to code in C++ because I like strong data typing.\n\nWhen editing, scrutinize subordinate clauses. Keep the `one sentence = one idea` formula in mind. Do the subordinate clauses in a sentence *extend* the single idea or do they *branch off* into a separate idea? If the latter, consider dividing the offending subordinate clause(s) into separate sentences.\n\n#### Exercise\n\nDetermine which of the sentences contain subordinate clauses that should be branched off into separate sentences. (Don't rewrite the sentences, just identify the sentences that should be rewritten.)\n\n1. Python is an interpreted language, which means that the language can execute source code directly.\n2. Bash is a modern shell scripting language that takes many of its features from KornShell 88, which was developed at Bell Labs.\n3. Lisp is a programming language that relies on Polish prefix notation, which is one of the systems invented by the Polish logician Jan Łukasiewicz.\n4. I don't want to say that FORTRAN is old, but only radiocarbon dating can determine its true age.\n\n\n\n##### Answer.\n\nWe've shaded the subordinate clauses.\n\n1. Python is an interpreted language, which means that the language can execute source code directly. **The subordinate clause in this sentence extends the main idea, so this sentence is fine as is.**\n2. Bash is a modern shell scripting language that takes many of its features from KornShell 88, which was developed at Bell Labs. **The first subordinate clause extends the main idea, but the second subordinate clause goes in another direction. Divide this sentence in two.**\n3. Lisp is a programming language that relies on Polish prefix notation, which is one of the systems invented by the Polish logician Jan Łukasiewicz. **The first subordinate clause is clearly critical to the sentence, but the second subordinate clause takes the reader too far away from the main clause. Divide this sentence in two.**\n4. I don't want to say that Fortran is old, but only radiocarbon dating can determine its true age. **The subordinate clause is critical to the sentence, so this sentence is fine as is.**\n\n------\n\n### Distinguish that from which\n\n**That** and **which** both introduce subordinate clauses. What's the difference between them? Well, in some countries, the two words are pretty much interchangeable. Inevitably though, alert American readers will angrily announce that you confused the two words again.\n\nIn America, reserve **which** for subordinate clauses that are nonessential parts of the sentence, and use **that** for an essential phrase that the sentence can't live without. For example:\n\n> Python is an interpreted language, **which** means the processor runs the program directly.\n>\n> FORTRAN is perfect for mathematical calculations **that** don't involve linear algebra.\n\nWas that explanation useful? Probably not. Try this instead: if you read a sentence aloud and hear a pause just before the subordinate clause, then use **which**. If you don't hear a pause, use **that**. Go back and read the two example sentences. Did you hear the pause in the first sentence?\n\nPlace a comma before **which**; do not place a comma before **that**.\n\n\n\n## Lists and tables\n\n> **Estimated Time:** 15 minutes\n\n\n\nGood lists can transform technical chaos into something orderly. Technical readers generally love lists. Therefore, when writing, seek opportunities to convert prose into lists.\n\n### Choose the correct type of list\n\nThe following types of lists dominate technical writing:\n\n- bulleted lists\n- numbered lists\n- embedded lists\n\nUse a **bulleted list** for *unordered* items; use a **numbered list** for *ordered* items. In other words:\n\n- If you rearrange the items in a *bulleted* list, the list's meaning does not change.\n- If you rearrange the items in a *numbered* list, the list's meaning *changes*.\n\nFor example, we've made the following a bulleted list because rearranging its items does not change the list's meaning:\n\n> Bash provides the following string manipulation mechanisms:\n>\n> - deleting a substring from the start of a string\n> - reading an entire file into one string variable\n\nThe following list, by contrast, must be a numbered list because rearranging its items would change the list's meaning:\n\n> Take the following steps to reconfigure the server:\n>\n> 1. Stop the server.\n> 2. Edit the configuration file.\n> 3. Restart the server.\n\nAn **embedded list** (sometimes called a **run-in** list) contains items stuffed within a sentence. For example, the following sentence contains an embedded list with four items.\n\n> The llamacatcher API enables callers to create and query llamas, analyze alpacas, delete vicugnas, and track dromedaries.\n\nGenerally speaking, embedded lists are a poor way to present technical information. Try to transform embedded lists into either bulleted lists or numbered lists. For example, you should convert the sentence containing the embedded list into the following passage:\n\n> The llamacatcher API enables callers to do the following:\n>\n> - Create and query llamas.\n> - Analyze alpacas.\n> - Delete vicugnas.\n> - Track dromedaries.\n\n#### Exercise\n\nConvert the following paragraph into one or more lists:\n\n> Today at work, I have to code three unit tests, write a design document, and review Janet's latest document. After work, I have to wash my car without using any water and then dry it without using any towels.\n\nDon't forget to introduce your list(s).\n\n\n\n##### Answer.\n\nHere's one possible answer:\n\n> I must do the following at work today:\n>\n> - Code three unit tests.\n> - Write a design document.\n> - Review Janet's latest document.\n>\n> After work, I must do the following:\n>\n> 1. Wash my car without using any water.\n> 2. Dry my car without using any towels.\n\nThe following is an alternative answer:\n\n> I must do the following tasks today:\n>\n> - At work:\n>   - Code three unit tests.\n>   - Write a design document.\n>   - Review Janet's latest document.\n> - After work:\n>   1. Wash my car without using any water.\n>   2. Dry my car without using any towels.\n\n------\n\n### Keep list items parallel\n\nWhat separates effective lists from defective lists? Effective lists are parallel; defective lists tend to be nonparallel. All items in a **parallel** list look like they \"belong\" together. That is, all items in a parallel list match along the following parameters:\n\n- grammar\n- logical category\n- capitalization\n- punctuation\n\nConversely, at least one item in a **nonparallel** list fails at least one of the preceding consistency checks.\n\nFor example, the following list is parallel because all the items are plural nouns (grammar), edible (logical category), lower case (capitalization), and without periods or commas (punctuation).\n\n- carrots\n- potatoes\n- cabbages\n\nBy contrast, the following list is painfully nonparallel along all four parameters:\n\n- carrots\n- potatoes\n- The summer light obscures all memories of winter.\n\nThe following list is parallel because all the items are complete sentences with complete sentence capitalization and punctuation:\n\n- Carrots contain lots of Vitamin A.\n- Potatoes taste delicious.\n- Cabbages provide oodles of Vitamin K.\n\nThe first item in a list establishes a pattern that readers expect to see repeated in subsequent items.\n\n#### Exercise\n\nIs the following list parallel or nonparallel?\n\n- Broccoli inspires feelings of love or hate.\n- Potatoes taste delicious.\n- Cabbages.\n\n\n\n##### Answer.\n\nThe list is nonparallel. The first two items are complete sentences, but the third item is not a sentence. (Don't be fooled by the capitalization and punctuation of the third item.)\n\n------\n\n#### Exercise\n\nIs the following list parallel or nonparallel?\n\n- The red dots represent sick trees.\n- Immature trees are represented by the blue dots.\n- The green dots represent healthy trees.\n\n\n\n##### Answer.\n\nThis is a nonparallel list. The first and third items are in active voice, but the second item is in passive voice.\n\n------\n\n### Start numbered list items with imperative verbs\n\nConsider starting all items in a numbered list with an imperative verb. An **imperative verb** is a command, such as **open** or **start**. For example, notice how all of the items in the following parallel numbered list begin with an imperative verb:\n\n1. Download the Frambus app from Google Play or iTunes.\n2. Configure the Frambus app's settings.\n3. Start the Frambus app.\n\nThe following numbered list is nonparallel because two of the sentences start with an imperative verb, but the third item does not:\n\n1. Instantiate the Froobus class.\n2. Invoke the Froobus.Salmonella() method.\n3. The process stalls.\n\n#### Exercise\n\nMake the following list parallel. Ensure that each element in the result list begins with an imperative verb:\n\n1. Stop Früvous\n2. The key configuration file is `/moxy/fruvous`. Open this file with an ASCII text editor.\n3. In this file, you will see a parameter named Carambola, which is currently set to the default value (32). Change this value to 64.\n4. When you are finished setting this parameter, save and close the configuration file\n5. now, start Früvous again.\n\n\n\n##### Answer.\n\nThe following is one possible answer:\n\n1. Stop Früvous.\n2. Open the key configuration file, `/moxy/fruvous`, with an ASCII text editor.\n3. Change the Carambola parameter from its default value (32) to 64.\n4. Save and close the configuration file.\n5. Restart Früvous.\n\n------\n\nPunctuate items appropriately\n\nIf the list item is a sentence, use sentence capitalization and punctuation. Otherwise, do not use sentence capitalization and punctuation. For example, the following list item is a sentence, so we capitalized the **M** in **Most**and put a period at the end of the sentence:\n\n- Most carambolas have five ridges.\n\nHowever, the following list item is not a sentence, so we left the **t** in **the** in lowercase and omitted a period:\n\n- the color of lemons\n\n###Create useful tables\n\nAnalytic minds tend to love tables. Given a page containing multiple paragraphs and a single table, engineers' eyes zoom towards the table.\n\nConsider the following guidelines when creating tables:\n\n- Label each column with a meaningful header. Don't make readers guess what each column holds.\n- Avoid putting too much text into a table cell. If a table cell holds more than two sentences, ask yourself whether that information belongs in some other format.\n- Although different columns can hold different types of data, strive for parallelism *within* individual columns. For instance, the cells within a particular table column should not be a mixture of numerical data and famous circus elephants.\n\n**Note:** Some tables don't render well across all form factors. For example, a table that looks great on your laptop may look awful on your phone.\n\n### Introduce each list and table\n\nWe recommend introducing each list and table with a sentence that tells readers what the list or table represents. In other words, give the list or table context. Terminate the introductory sentence with a colon rather than a period.\n\nAlthough not a requirement, we recommend putting the word **following** into the introductory sentence. For example, consider the following introductory sentences:\n\n> The following list identifies key performance parameters:\n>\n> Take the following steps to install the Frambus package:\n>\n> The following table summarizes our product's features against our key competitors' features:\n\n#### Exercise\n\nWrite an introductory sentence for the following table:\n\n| Languages | Inventor          | Year Introduced | Key Feature |\n| :-------- | :---------------- | :-------------- | :---------- |\n| Lisp      | John McCarthy     | 1958            | recursion   |\n| C++       | Bjarne Stroustrup | 1979            | OOP         |\n| Python    | Guido van Rossum  | 1994            | simplicity  |\n\n\n\n##### Answer.\n\nHere are a couple of possible introductory sentences for the table:\n\n> The following table contains a few key facts about some popular programming languages:\n\n> The following table identifies the inventor, year of invention, and key feature of three popular programming languages:\n\n------\n\n\n\n## Paragraphs\n\n> **Estimated Time:** 10 minutes\n\n\n\nThis unit provides some guidelines on building cohesive paragraphs. But first, here is an inspirational message:\n\n> The work of writing is *simply* this: untangling the dependencies among the parts of a topic, and presenting those parts in a logical stream that enables the reader to understand you.\n\n### Write a great opening sentence\n\nThe opening sentence is the most important sentence of any paragraph. Busy readers focus on opening sentences and sometimes skip over subsequent sentences. Therefore, focus your writing energy on opening sentences.\n\nGood opening sentences establish the paragraph's central point. For example, the following paragraph features an effective opening sentence:\n\n> A loop runs the same block of code multiple times. For example, suppose you wrote a block of code that detected whether an input line ended with a period. To evaluate a million input lines, create a loop that runs a million times.\n\nThe preceding opening sentence establishes the theme of the paragraph as an introduction to loops. By contrast, the following opening sentence sends readers in the wrong direction:\n\n> A block of code is any set of contiguous code within the same function. For example, suppose you wrote a block of code that detected whether an input line ended with a period. To evaluate a million input lines, create a loop that runs a million times.\n\n#### Exercise\n\nIs the opening sentence of the following paragraph effective or defective?\n\n> The Pythagorean Theorem states that the sum of the squares of both legs of a right triangle is equal to the square of the hypotenuse. The k-means clustering algorithm relies on the Pythagorean Theorem to measure distances. By contrast, the k-median clustering algorithm relies on the Manhattan Distance.\n\n\n\n##### Answer.\n\nThis opening sentence is **defective** because it implies that the paragraph will focus on the Pythagorean Theorem. In fact, the paragraph's focus is actually clustering algorithms. The following would be a more effective opening sentence:\n\n> Different clustering algorithms measure distances differently.\n\n------\n\n \n\n**Note:** Effective opening sentences can take many forms. That is, not all great paragraphs start with a sentence that states the theme. Starting a paragraph with a rhetorical question, for example, can engage readers.\n\n### Focus each paragraph on a single topic\n\nA paragraph should represent an independent unit of logic. Restrict each paragraph to the current topic. Don't describe what will happen in a future topic or what happened in a past topic. When revising, ruthlessly delete (or move to another paragraph) any sentence that doesn't directly relate to the current topic.\n\nFor example, assume that the opening sentence of the following paragraph does focus on the correct topic. Can you spot the sentences that should be removed from the following paragraph?\n\n> The Pythagorean Theorem states that the sum of the squares of both legs of a right triangle is equal to the square of the hypotenuse. The perimeter of a triangle is equal to the sum of the three sides. You can use the Pythagorean Theorem to measure diagonal distances. For example, if you know the length and width of a ping-pong table, you can use the Pythagorean Theorem to determine the diagonal distance. To calculate the perimeter of the ping-pong table, sum the length and the width, and then multiply that sum by 2.\n\nWe've crossed out the second and fifth sentences to yield a paragraph focused exclusively on the Pythagorean Theorem:\n\n> The Pythagorean Theorem states that the sum of the squares of both legs of a right triangle is equal to the square of the hypotenuse. ~~The perimeter of a triangle is equal to the sum of the three sides.~~ You can use the Pythagorean Theorem to measure diagonal distances. For example, if you know the length and width of a ping-pong table, you can use the Pythagorean Theorem to determine the diagonal distance. ~~To calculate the perimeter of the ping-pong table, sum the length and the width, and then multiply that sum by 2.~~\n\n#### Exercise\n\nRemove the extraneous sentence(s) from the following paragraph. Assume that the opening sentence does establish the desired theme for the paragraph:\n\n> **Spreadsheets** provide a great way to organize data. Think of a spreadsheet as a table with rows and columns. Spreadsheets also provide mathematical functions, such as means and standard deviations. Each row holds details about one entity. Each column holds details about a particular parameter. For example, you can create a spreadsheet to organize data about different trees. Each row would represent a different type of tree. Each column would represent a different characteristic, such as the tree's height or the tree's spread.\n\n\n\n##### Answer.\n\nThe paragraph focuses on spreadsheets as a way of organizing data. The third sentence distracts from that theme. Move the third sentence to another paragraph about mathematical operations in spreadsheets.\n\n> **Spreadsheets** provide a great way to organize data. Think of a spreadsheet as a table with rows and columns. ~~Spreadsheets also provide mathematical functions, such as means and standard deviations.~~ Each row holds details about one entity. Each column holds details about a particular parameter. For example, you can create a spreadsheet to organize data about different trees. Each row would represent a different type of tree. Each column would represent a different characteristic, such as the tree's height or the tree's spread.\n\n------\n\n### Don't make paragraphs too long or too short\n\nLong paragraphs are visually intimidating. *Very* long paragraphs form a dreaded \"wall of text\" that readers ignore. Readers generally welcome paragraphs containing three to five sentences, but will avoid paragraphs containing more than about seven sentences. When revising, consider dividing very long paragraphs into two separate paragraphs.\n\nConversely, don't make paragraphs too short. If your document contains plenty of one-sentence paragraphs, your organization is faulty. Seek ways to combine those one-sentence paragraphs into cohesive multi-sentence paragraphs or possibly into lists.\n\n### Answer what, why, and how\n\nGood paragraphs answer the following three questions:\n\n1. **What** are you trying to tell your reader?\n2. **Why** is it important for the reader to know this?\n3. **How** should the reader use this knowledge. Alternatively, how should the reader know your point to be true?\n\nFor example, the following paragraph answers what, why, and how:\n\n\n> `<Start of What>` The `garp()` function returns the delta between a dataset's mean and median.`<End of What>` \n> `<Start of Why>`Many people believe unquestioningly that a mean always holds the truth. However, a mean is easily influenced by a few very large or very small data points. `<End of Why>`\n> `<Start of How>`Call `garp()` to help determine whether a few very large or very small data points are influencing the mean too much. A relatively small `garp()` value suggests that the mean is more meaningful than when the `garp()` value is relatively high.`<End of How>`\n\n\n\n## Audience\n\n> **Estimated Time:** 10 minutes\n\nThe course designers believe that you are probably comfortable with mathematics. Therefore, this unit begins with an equation:\n\n> good documentation = knowledge and skills your audience needs to do a task − your audience's current knowledge and skills\n\nIn other words, make sure your document provides the information your audience needs that your audience doesn't already have. Therefore, this unit explains how to do the following:\n\n- Define your audience.\n- Determine what your audience needs to learn.\n- Fit documentation to your audience.\n\nAs the following video suggests, targeting the *wrong* audience can be messy: https://youtu.be/eFtXIrmsMwI\n\n\n\n### Define your audience\n\nSerious documentation efforts spend considerable time and energy on defining their audience. These efforts might involve surveys, user experience studies, focus groups, and documentation testing. You probably don't have that much time, so this unit takes a simpler approach.\n\nBegin by identifying your audience's **role**(s). Sample roles include:\n\n- software engineers\n- technical, non-engineer roles (such as technical program managers)\n- scientists\n- professionals in scientific fields (for example, physicians)\n- undergraduate engineering students\n- graduate engineering students\n- non-technical positions\n\nWe happily appreciate that many people in non-technical roles have great technical and mathematical skills. However, roles remain an essential first-order approximation in defining your audience. People within the same role*generally* share certain base skills and knowledge. For example:\n\n- Most software engineers know popular sorting algorithms, big O notation, and at least one programming language. Therefore, you can depend on software engineers knowing what O(n) means, but you can't depend on non-technical roles knowing O(n).\n- A research report targeted at physicians should look very different from a newspaper article about the same research aimed at a lay audience.\n- A professor's explanation of a new machine learning approach to graduate students should differ from the explanation to first-year undergraduate students.\n\nWriting would be so much easier if everyone in the same role shared exactly the same knowledge. Unfortunately, knowledge within the same role quickly diverges. Amal is an expert in Python, Sharon's expertise is C++, and Micah's is in Java. Kara loves Linux, but David only knows iOS.\n\nRoles, by themselves, are insufficient for defining an audience. That is, you must also consider your audience's *proximity* to the knowledge. The software engineers in Project Frombus know something about related Project Dingus but nothing about unrelated Project Carambola. The average heart specialist knows more about ear problems than the average software engineer but far less than an audiologist.\n\nTime also affects proximity. Almost all software engineers, for example, studied calculus. However, most software engineers don't use calculus in their jobs, so their knowledge of calculus gradually fades. Conversely, experienced engineers typically know vastly more about their current project than new engineers on the same project.\n\n#### Sample audience analysis\n\nThe following is a sample audience analysis for fictitious Project Zylmon:\n\n> The target audience for Project Zylmon falls into the following roles:\n>\n> - software engineers\n> - technical product managers\n>\n> The target audience has the following proximity to the knowledge:\n>\n> - My target audience already knows the Zyljeune APIs, which are somewhat similar to the Zylmon APIs.\n> - My target audience knows C++, but has not typically built C++ programs in the new Winged Victory development environment.\n> - My target audience took linear algebra in university, but many members of the team need a refresher on matrix multiplication.\n\n### Determine what your audience needs to learn\n\nWrite down a list of everything your target audience needs to learn to accomplish goals. In some cases, the list should hold tasks that the target audience needs to *perform*. For example:\n\n> After reading the documentation, the audience will know how to do the following tasks:\n\n> - Use the Zylmon API to list hotels by price.\n> - Use the Zylmon API to list hotels by location.\n> - Use the Zylmon API to list hotels by user ratings.\n\nNote that your audience must sometimes master tasks in a certain order. For example, your audience might need to learn how to build and execute programs in a new development environment *before* learning how to write particular kinds of programs.\n\nIf you are writing a design spec, then your list should focus on information your target audience should learn rather than on mastering specific tasks: For example:\n\n> After reading the design spec, the audience will learn the following:\n\n> - Three reasons why Zylmon outperforms Zyljeune.\n> - Five reasons why Zylmon consumed 5.25 engineering years to develop.\n\n### Fit documentation to your audience\n\nWriting to meet your audience's needs requires unselfish empathy. You must create explanations that satisfy your audience's curiosity rather than your own. How do you step out of yourself in order to fit documentation to the audience? Unfortunately, we can offer no easy answers. We can, however, offer a few parameters to focus on.\n\n#### Vocabulary and concepts\n\nMatch your vocabulary to your audience. See [Words](https://developers.google.com/tech-writing/one/words?hl=zh-cn) for help.\n\nBe mindful of proximity. The people on your team probably understand your team's abbreviations, but do people on other teams understand those same abbreviations? As your target audience widens, assume that you must explain more.\n\nSimilarly, experienced people on your software team probably understand the implementation details and data structures of your team's project, but nearly everyone else (including new members of your team) does not. Unless you are writing specifically for other experienced members of your team, you typically must explain more than you expect.\n\n####Curse of knowledge\n\nExperts often suffer from **the curse of knowledge**, which means that their expert understanding of a topic ruins their explanations to newcomers. As experts, it is easy to forget that novices don’t know what you already know. Novices might not understand explanations that make passing reference to subtle interactions and deep systems that the expert doesn’t stop to explain.\n\nFrom the novice's point of view, the curse of knowledge is a \"File not found\" linker error due to a module not yet compiled.\n\n#### Exercise\n\n1. Assume that the following paragraph is the start of a paper aimed at physicians who have never programmed before. Identify the aspects of the paragraph that suffer from the curse of knowledge:\n\n   > C is a mid-level language, higher than assembly language but lower than Python and Java. The C language provides programmers fine-grained control over all aspects of a program. For example, using the C Standard Library, it is easy to allocate and free blocks of memory. In C, manipulating pointers directly is mundane.\n\n2. Suppose the preceding paragraph was aimed at undergraduate computer science students new to C but comfortable with Python. Does the paragraph still suffer from the curse of knowledge?\n\n\n\n##### Answer.\n\n1. This paragraph suffers immensely from the curse of knowledge. The target audience has never programmed before, so the following terms are inappropriate or unfamiliar:\n   - language\n   - mid-level language\n   - assembly language\n   - Python\n   - Java\n   - program\n   - C Standard Library\n   - allocate and free blocks of memory\n   - pointers\n2. This paragraph also suffers from the curse of knowledge for the alternative audience. The average Python programmer is unaware of manipulating memory or pointers. A better introductory paragraph would compare and contrast C with Python.\n\n------\n\n#### Simple words\n\nEnglish has become the dominant language for technical communication worldwide. However, English is not the native language of a significant percentage of technical readers. Therefore, prefer simple words over complex words. Avoid using arcane, obsolete, or overly-complex English words; [sesquipedalian](https://www.google.com/search?q=sesquipedalian&hl=zh-cn) and rare words repel most readers.\n\nCultural neutrality and idioms\n\nKeep your writing culturally neutral. Do not require readers to understand the intricacies of NASCAR, cricket, or sumo in order to understand how a piece of software works. For example, the following sentence—packed with baseball metaphors as American as apple pie—might puzzle some Parisian readers:\n\n> If Frambus 5.0 was a solid single, Frambus 6.0 is a stand-up double.\n\n**Idioms** are phrases whose overall meaning differs from the literal meaning of the individual words in that phrase. For example, the following phrases are idioms:\n\n- a piece of cake\n- Bob's your uncle\n\nCake? Bob? Most American readers recognize the first idiom; most British readers recognize the second idiom. If you are writing strictly for a British audience, then *Bob's your uncle* can be fine. However, if you are writing for an international audience, then replace that idiom with *this task is easy*.\n\nIdioms are so deeply ingrained in our speech that the special nonliteral meaning of idioms becomes invisible to us. That is, idioms are another form of the curse of knowledge.\n\nNote that some people in your audience use translation software to read your documentation. Translation software tends to struggle more with cultural references and idioms than with plain, simple English.\n\n#### Exercise\n\nIdentify the problems with the following sentences:\n\n1. As of Version 3.0, it was still kosher to call the Frambus method.\n2. Deciding which BorgResourceSpec constraints/preferences are combinable is a sticky wicket.\n3. Be that as it may, you still have to write unit tests.\n\n\n\n##### Answer.\n\n1. In some places in the world, **kosher** has become slang for \"acceptable usage.\" Many readers, however, will wonder how religious dietary laws pertain to software.\n2. A **sticky wicket** is British slang, which does not travel well. Substituting the phrase **challenging problem** will fix this issue.\n3. **Be that as it may** is an idiom. Substituting the transition **However** will fix this problem.\n\n------\n\n\n\n## Documents\n\n> **Estimated Time:** 10 minutes\n\nYou can write sentences. You can write paragraphs. However, can you organize all those paragraphs into a coherent document?\n\n### State your document's scope\n\nA good document begins by defining its scope. For example:\n\n> This document describes the overall design of Project Frambus.\n\nA better document additionally defines its non-scope, that is, the topics not covered that the target audience might expect your document to cover. For example:\n\n> This document does not describe the design for the related technology, Project Froobus.\n\nThese scope and non-scope statements benefit not only the reader but also the writer (you). While writing, if the contents of your document veer away from the scope statement, then you must either refocus your document or modify your scope statement. When reviewing your first draft, delete (or branch off to another document) any sections that don't help satisfy the scope statement.\n\n### State your audience\n\nA good document explicitly specifies its audience. For example:\n\n> I wrote this document for the test engineers supporting Project Frambus.\n\nBeyond the audience's role, a good audience declaration might also specify any prerequisite knowledge or experience. For example:\n\n> This document assumes that you understand matrix multiplication and how to brew a really good cup of tea.\n\nIn some cases, the audience declaration must also specify prerequisite documents. For example:\n\n> You must read \"Project Froobus: A New Hope\" prior to reading this document.\n\n### Establish your key points up front\n\nEngineers and scientists are busy people who won't necessarily read all 76 pages of your design document. Imagine that your peers might only read the first paragraph of page one. When reviewing your documentation, ensure that the start of your document answers your readers' essential questions.\n\nProfessional writers focus considerable energy on page one to increase the odds of readers making it to page two. However, page one of any long document is the hardest page to write. Therefore, be prepared to revise page one many times.\n\nAlways write an executive summary (a TL;DR) for long engineering documents. Although the executive summary must be very short, expect to spend a lot of time writing it. A boring or confusing executive summary is a red flag warning potential readers to stay away.\n\n### Write for your audience\n\nThis course repeatedly emphasizes the importance of defining your audience. In this section, we focus on audience definition as a means of organizing your document.\n\n#### Define audience\n\nAnswering the following questions helps you determine what your document should contain:\n\n- Who is your target audience?\n- What do your readers already know before they’ve read the document?\n- What should your readers know or be able to do after they’ve read your document?\n\nFor example, suppose you have invented a new sorting algorithm. The following list contains some potential answers to the preceding questions:\n\n- My target audience consists of all the software engineers in my organization.\n- Most of my target audience studied sorting algorithms during school. However, about 25% of my target audience hasn't implemented or evaluated a sorting algorithm in many years.\n- After reading this document:\n  1. Readers know how the algorithm works.\n  2. Readers can implement the algorithm in their desired language.\n  3. Readers know the circumstances in which the algorithm outperforms the popular quicksort algorithm.\n  4. Readers understand performance degradation in certain edge cases.\n\n#### Organize\n\nAfter defining the audience, organize the document to supply what readers should know or be able to do after reading the document. For example, the outline for the document could look as follows:\n\n1. Overview of the algorithm\n   1. Big O\n   2. Implementation in pseudocode\n2. Sample implementation in C\n   1. Tips in implementing in other languages\n3. Deeper analysis of algorithm\n   1. Optimal datasets\n   2. Edge case problems\n\nFurthermore, use the audience definition to help you choose the right approach to writing your document. For example, the target audience studied sorting algorithms but about a quarter of your audience might not remember the details of different algorithms. Therefore, your document should probably insert links to existing tutorials on quicksort rather than trying to explain quicksort.\n\n### Break your topic into sections\n\nYou modularize code into files, classes, and methods. Modular code is easier to read, understand, maintain, and reuse. Making your doc modular gives you the same benefits. You probably have strong intuition about functional modularity in code, but how do you apply those principles to your writing?\n\nImagine that you have an empty jar, which you need to pack with a collection of large rocks, coarse gravel, and sand. How would you pack the jar to ensure that you can get all of your material in the jar? Of course you’d place the large rocks first, then pour in the gravel, and fill in the remaining air space with the sand. If you tried to do this in the opposite order, you would fail.\n\nYour reader’s head is much like an empty jar, and your information generally comes in three sizes: rocks, gravel, and sand. Sections are the rocks. You need to structure the space inside your reader’s jar-head with the rocks to accept the rest of the information.\n\nBut how do you decide what is a big rock versus what is gravel? One strategy is to record yourself talking, or free-write, about your topic for a short amount of time—maybe just 2 to 5 minutes. Yes, this takes discipline. Examine what you produced. Did you do the following?\n\n- Describe concepts in vague, under-specified ways?\n- List the steps that your audience needs to complete to reach a goal?\n- Describe the permutations of properties that a system can express?\n\nThe under-specified things that you referred to are probably the large concepts that structure your topic. If your talk didn’t do this, go back and try this structure.\n\n#### Exercise\n\nThe following passage is the introductory paragraph for a document. List the titles of the sections that you would break this topic into.\n\n> AlienWarez is a large-scale machine learning system. AlienWarez is best at building models for high-dimensional, sparse feature spaces. AlienWarez automatically explores and learns feature crosses that explain your data. AlienWarez refers specifically to the model training system. You train a model by extracting features from your source (log) data, and writing a data source for the training system. The Seti infrastructure team also provides a complete serving system. You are responsible for starting your own serving cluster, and moving your model to serving. The Seti serving system can serve AlienWarez, Seti, and Sibyl models. This guide explains how to train a AlienWarez model, and how to serve the model in production.\n\n\n\n##### Answer.\n\nHere is a possible outline:\n\n1. Training a model\n   1. Developing features\n   2. Creating a data source\n   3. ...\n2. Serving a model\n   1. Starting a serving cluster\n   2. Moving your model into serving\n   3. Retrieving a prediction from serving\n   4. ...\n\n------\n\n## Punctuation (optional)\n\n> **Estimated Time:** 5 minutes\n\nThis optional unit provides a quick refresher on punctuation marks.\n\n### Commas\n\nProgramming languages enforce clear rules about punctuation. In English, by contrast, the rules regarding commas are somewhat hazier. As a guideline, insert a comma wherever a reader would naturally pause somewhere within a sentence. For the musically inclined, if a period is a whole note rest, then a comma is perhaps a half-note or quarter-note rest. In other words, the pause for a comma is shorter than that for a period. For example, if you read the following sentence aloud, you probably rest briefly before the word *just*:\n\n> C behaves as a mid-level language, just a couple of steps up in abstraction from assembly language.\n\nSome situations *require* a comma. For example, use commas to separate items in an embedded list like the following:\n\n> Our company uses C++, Python, Java, and JavaScript.\n\nYou might be wondering about a list's final comma, the one inserted between items N-1 and N. This comma—known as the **serial comma** or **Oxford comma**—is controversial. We recommend supplying that final comma simply because technical writing requires picking the least ambiguous solution. That said, we actually prefer circumventing the controversy by converting embedded lists into bulleted lists.\n\nIn sentences that express a condition, place a comma between the condition and the consequence. For example, both of the following sentences supply the comma in the correct place:\n\n> If the program runs slowly, try the `--perf` flag.\n>\n> If the program runs slowly, then try the `--perf` flag.\n\nYou can also wedge a quick definition or digression between a pair of commas as in the following example:\n\n> Python, an easy-to-use language, has gained significant momentum in recent years.\n\nFinally, avoid using a comma to paste together two independent thoughts. For example, the comma in the following sentence is guilty of a punctuation felony called a **comma splice**:\n\n> Samantha is a wonderful coder, she writes abundant tests.\n\nUse a period rather than a comma to separate two independent thoughts. For example:\n\n> Samantha is a wonderful coder. She writes abundant tests.\n\n#### Exercise\n\nAdd commas where appropriate to the following passage:\n\n> Protocol Buffers sometimes known as protobufs are our team's main structured data format. Use Protocol Buffers to represent store and transfer structured data. Unlike XML Protocol Buffers are compiled. Consequently clients transmit Protocol Buffers efficiently which has led to rapid adoption.\n\nHint: Read the passage aloud and put a comma everywhere you hear a short pause.\n\n##### Answer.\n\n\n\nHere is one possible solution:\n\n> Protocol Buffers**,** sometimes known as protobufs**,** are our team's main structured data format. Use Protocol Buffers to represent**,** store**,** and transfer structured data. Unlike XML**,** Protocol Buffers are compiled. Consequently**,**clients transmit Protocol Buffers efficiently**,** which has led to rapid adoption.\n\n------\n\n### Semicolons\n\nA period separates distinct thoughts; a semicolon unites highly related thoughts. For example, notice how the semicolon in the following sentence unites the first and second thoughts:\n\n> Rerun Frambus after updating your configuration file; don't rerun Frambus after updating existing source code.\n\nThe thoughts preceding and following the semicolon must each be grammatically complete sentences. For example, the following semicolon is *incorrect* because the passage following the semicolon is not a complete sentence:\n\n> Rerun Frambus after updating your configuration file; not after updating existing source code.\n\nBefore using a semicolon, ask yourself whether the sentence would still make sense if you flipped the thoughts to opposite sides of the semicolon. For example, reversing the earlier example still yields a *valid* sentence:\n\n> Don't rerun Frambus after updating existing source code; rerun Frambus after updating your configuration file.\n\nYou should almost always use commas, not semicolons, to separate items in an embedded list. For example, the following use of semicolons is *incorrect*:\n\n> Style guides are bigger than the moon; more essential than oxygen; and completely inscrutable.\n\nMany sentences place a transition word or phrase immediately after the semicolon. In this situation, place a comma after the transition. Note the comma after the transition in the following two examples:\n\n> Frambus provides no official open source package for string manipulation; however**,** subsets of string manipulation packages are available from other open source projects.\n\n> Even seemingly trivial code changes can cause bugs; therefore**,** write abundant unit tests.\n\n#### Exercise\n\nWhich of the following periods or commas could you replace with a semicolon?\n\n1. Python is a popular programming language. The C language was developed long before Python.\n2. Model learning for a low value of X appears in the top illustration. Model learning for a high value of X appears in the bottom illustration.\n3. I'm thankful for my large monitor, powerful CPU, and blazing bandwidth.\n\n##### Answer.\n\n1. You may not convert the period in #1 to a semicolon because the two sentences are only vaguely related.\n2. You may replace the period in #2 with a semicolon because the two sentences are so highly related.\n3. You may not convert the commas in #3 to semicolons. Use commas to separate items in an embedded list.\n\n### Em-Dashes\n\nEm-dashes are compelling punctuation marks, rich with punctuation possibilities. An em-dash represents a longer pause—a bigger break—than a comma. If a comma is a quarter note rest, then an em-dash is a half-note rest. For example:\n\n> C++ is a rich language—one requiring extensive experience to master.\n\nWriters sometimes use a pair of em-dashes to block off a digression, as in the following example:\n\n> **Protocol Buffers**—often nicknamed **protobufs**—encode structured data in an efficient yet extensible format.\n\nCould we have used commas instead of em-dashes in the preceding examples? Sure. Why did we choose an em-dash instead of a comma? Feel. Art. Experience. Remember—punctuation in English is squishy and malleable.\n\n### Parentheses\n\nUse parentheses to hold minor points and digressions. Parentheses inform readers that the enclosed text isn't critical.\n\nThe rules regarding periods and parentheses have tripped up many a writer. Here are the standards:\n\n- If a pair of parentheses holds an entire sentence, the period goes inside the closing parenthesis.\n- If a pair of parentheses ends a sentence but does not hold the entire sentence, the period goes just outside the closing parenthesis.\n\nFor example:\n\n> (Incidentally, Protocol Buffers make great birthday gifts.)\n>\n> Binary mode relies on the more compact native form (described later in this document).\n\n\n\n------\n\n## Markdown (optional)\n\n\n\n> **Estimated Time:** 10 minutes\n\n\n\n**Markdown** is a lightweight markup language that many technical professionals use to create and edit technical documents. With Markdown, you write text in a plain text editor (such as vi or Emacs), inserting special characters to create headers, boldface, bullets, and so on. For example, the following example shows a simple technical document formatted with Markdown:\n\n```\n## bash and ksh\n\n**bash** closely resembles an older shell named **ksh**.  The key\n*practical* difference between the two shells is as follows:\n\n*  More people know bash than ksh, so it is easier to get help for bash\n   problems than ksh problems.\n```\n\nThe rendered version of the preceding technical document looks as follows:\n\n> bash and ksh\n>\n> **bash** closely resembles an older shell named **ksh**. The key *practical* difference between the two shells is as follows:\n>\n> - More people know bash than ksh, so it is easier to get help for bash problems than ksh problems.\n\nA Markdown parser converts Markdown files into HTML. Browsers can then display the resulting HTML to readers.\n\nWe recommend becoming comfortable with Markdown by taking one of the following tutorials:\n\n- [www.markdowntutorial.com](https://www.markdowntutorial.com/)\n- [Mastering Markdown](https://guides.github.com/features/mastering-markdown/)\n\nWhat's next?\n\nCongratulations: you've completed the pre-class work for Technical Writing One.\n\nIf the in-class portion of Technical Writing One is available, please take it.\n\nA quick compilation of the topics covered in Technical Writing One is available on the [Summary](https://developers.google.com/tech-writing/one/summary?hl=zh-cn) page.\n\n-----\n\n## Summary of Technical Writing One\n\n\nTechnical Writing One covered the following basic lessons of technical writing:\n\n- Use terms consistently.\n- Avoid ambiguous pronouns.\n- Prefer active voice to passive voice.\n- Choose strong verbs.\n- Pick specific nouns over vague ones.\n- Focus each sentence on a single idea.\n- Convert some long sentences to lists.\n- Eliminate unneeded words.\n- Use a numbered list when ordering is important and a bulleted list when ordering is irrelevant.\n- Keep list items parallel.\n- Start numbered list items with imperative words.\n- Introduce lists and tables appropriately.\n- Create great opening sentences that establish a paragraph's central point.\n- Focus each paragraph on a single topic.\n- Determine what your audience needs to learn.\n- Fit documentation to your audience.\n- Establish your document's key points at the start of the document.\n\nAs time permits, consider reviewing these additional [technical writing resources](https://developers.google.com/tech-writing/resources?hl=zh-cn).\n\n-----------\n\n# Technical Writing Two\n\n## Technical Writing Two introduction\n\n\n\n*Technical Writing Two* helps technical people improve their technical communication skills.\n\n### Target audience\n\nWe've aimed this course at people who have completed [Technical Writing One](https://developers.google.com/tech-writing/one?hl=zh-cn) and are still hungry for more technical writing training. If you've never taken any technical writing training, we recommend completing *Technical Writing One*before taking this class.\n\n### Learning objectives\n\nThis course focuses on several intermediate topics in technical writing. After completing this class, you will know how to do the following:\n\n- Choose among several different tactics to write first drafts and additional tactics for writing second and third drafts.\n- Leverage several techniques to detect mistakes in your own writing.\n- Organize large documents.\n- Introduce a document's scope and any prerequisites.\n- Write clear figure captions.\n- Pick the proper information density in technical illustrations.\n- Focus the reader's attention in illustrations.\n- Establish context through a \"big picture\" illustration.\n- Revise technical illustrations effectively.\n- Create useful, accurate, concise, clear, reusable, and well-commented sample code that demonstrates a range of complexity.\n- Identify different documentation types.\n- Describe just about anything.\n- Empathize with a beginner audience and write a tutorial for them.\n\nIt takes years of focused practice to become a great engineer or a great technical writer. This course will improve your technical writing but will not instantly transform you into a great technical writer.\n\n### Pre-class and in-class components\n\nThe course consists of the following two components:\n\n- pre-class\n- in-class\n\nYou are currently viewing the start of the pre-class component.\n\nThe in-class component enhances the lessons taught in the pre-class components. That said, the pre-class lessons on their own still provide a valuable educational experience.\n\n### Hardware and network requirements\n\nAlthough this course is optimized for a laptop or desktop, you may take the course on a tablet or phone. If you are taking the in-class component, please note that you'll type a lot.\n\nYou need an internet connection to take the course. You cannot download the course. The course is not available on tangible media.\n\nThe course contains a few short videos, all of which are optional viewing. If you want to skip the videos, then you can take the course on a low-bandwidth internet connection.\n\n\n\n------\n\n\n\n## Self-editing\n\n\n\n>  **Estimated Time:** 10 minutes\n\nImagine that you just wrote the first draft of a document. How do you make it better? In most cases, working towards a final published document is an iterative process. Transforming a blank page into a first draft is often the hardest step. After you write a first draft, make sure you set aside plenty of time to refine your document.\n\nThe editing tips in this unit can help turn your first draft into a document that more clearly communicates the information your audience needs. Use one tip or use them all; the important thing is to find a strategy that works for you, and then make that strategy part of your writing routine.\n\n**Note:** The tips in this unit build on the basic writing and editing skills from Technical Writing One. This unit includes a summary of useful editing techniques from that course. For a more detailed refresher, visit the [self-study units](https://developers.google.com/tech-writing/one?hl=zh-cn) from Technical Writing One.\n\n### Adopt a style guide\n\nCompanies, organizations, and large open source projects frequently either adopt an existing style guide for their documentation or write their own. Many of the documentation projects on the [Google Developers](https://developers.google.com/?hl=zh-cn) site follow the[Google Developer Documentation Style Guide](https://developers.google.com/style?hl=zh-cn). If you've never relied on a style guide before, at first glance the Google Developer Documentation Style Guide might seem a little intimidating, offering detailed guidance on topics such as grammar, punctuation, formatting, and documenting computer interfaces. You might prefer to start by adopting the[style-guide highlights](https://developers.google.com/style/highlights?hl=zh-cn).\n\n**Note:** For smaller projects, such as team documentation or a small open source project, you might find the highlights are all you need.\n\nSome of the guidelines listed in the highlights are covered in Technical Writing One. You might recall some of the following techniques:\n\n- Use [active voice](https://developers.google.com/tech-writing/one/active-voice?hl=zh-cn) to make clear who's performing the action.\n- Format sequential steps as [numbered lists](https://developers.google.com/tech-writing/one/lists-and-tables?hl=zh-cn).\n- Format most other lists as bulleted lists.\n\nThe highlights introduce many other techniques that can be useful when writing technical documentation, such as:\n\n- [Write in the second person](https://developers.google.com/style/person?hl=zh-cn). Refer to your audience as \"you\" rather than \"we\".\n- [Place conditional clauses before an instruction](https://developers.google.com/style/clause-order?hl=zh-cn), rather than after.\n- Format [code-related text as code font](https://developers.google.com/style/code-in-text?hl=zh-cn).\n\n### Think like your audience\n\nWho is your audience? Step back and try to read your draft from their point of view. Make sure the purpose of your document is clear, and provide definitions for any terms or concepts that might be unfamiliar to your readers.\n\nIt can be helpful to outline a persona for your audience. A persona can consist of any of the following attributes:\n\n- A role, such as *Systems Engineer* or *QA Tester*.\n- An end goal, such as *Restore the database*.\n- A set of assumptions about the persona and their knowledge and experience. For example, you might assume that your persona is:\n  - Familiar with Python.\n  - Running a Linux operating system.\n  - Comfortable following instructions for the command line.\n\nYou can then review your draft with your persona in mind. It can be especially useful to tell your audience about any assumptions you've made. You can also provide links to resources where they can learn more if they need to brush up on a specific topic.\n\nNote that relying too heavily on a persona (or two) can result in a document that is too narrowly focused to be useful to the majority of your readers.\n\nFor a refresher and more information on this topic from Technical Writing One, see the [Audience](https://developers.google.com/tech-writing/one/audience?hl=zh-cn) self-study unit.\n\n### Read it out loud\n\nDepending on the context, the style of your writing can alienate, engage, or even bore your audience. The desired style of a given document depends to an extent on the audience. For example, the contributor guide for a new open source project aimed at recruiting volunteers might adopt a more informal and conversational style, while the developer guide for a commercial enterprise application might adopt a more formal style.\n\nTo check your writing is conversational, read it out loud. Listen for awkward phrasing, too-long sentences, or anything else that doesn't feel natural. Alternatively, you can also try asking someone else to read your draft out loud for you.\n\nFor more information on adjusting the style of your writing to suit your audience, see [Style and authorial tone](https://developers.google.com/style/tone?hl=zh-cn).\n\n### Come back to it later\n\nAfter you write your first draft (or second or third), set it aside. Come back to it after an hour (or two or three) and try to read it with fresh eyes. You'll almost always notice something that you could improve.\n\n### Change the context\n\nSome writers like to print their documentation and review a paper copy, red pencil in hand. A change of context when reviewing your own work can help you find things to improve. For a modern take on this classic tip, copy your draft into a different document and change the font, size, and color.\n\n### Find a peer editor\n\nJust as engineers need peers to review their code, writers need editors to give them feedback on docs. Ask someone to review your document and give you specific, constructive comments. Your peer editor doesn't need to be a subject matter expert on the technical topic of your document, but they do need to be familiar with the style guide you follow.\n\n### Exercise\n\nIf you have a document that you're working on, use one or more of the tips on this page to make it better. If you don't have a document in progress, edit the paragraph below.\n\n> Determine whether or not you can simplify your document through the use of terminology that is equivalent but relatively shorter in length and therefore more easily comprehensible by your audience. It's important to make sure your document is edited before it is seen by your audience, which might include people that are less or more familiar with the matter covered by your document. The first thing you need is a rough draft. Some things that can help make your document easier to read are making sure you have links to background information, and also checking for active voice instead of passive voice. If you have long sentences you can consider shortening them or implementing the use of a list to make the information easier to scan.\n\n##### Answer.\n\n\n\nTo help your audience understand your document, apply these basic editing principles:\n\n- Use active voice instead of passive voice.\n- Consider using simpler words that mean the same thing.\n- Include links to background information.\n- Break long sentences into shorter sentences or lists.\n\n\n\n## Organizing large documents\n\n\n\n>  **Estimated Time:** 20 minutes\n\nHow do you organize a large collection of information into a cohesive document or website? Alternatively, how do you reorganize an existing messy document or website into something approachable and useful? The following tactics can help:\n\n- Organizing a document\n- Adding navigation\n- Disclosing information progressively\n\n### When to write large documents\n\nYou can organize a collection of information into longer standalone documents or a set of shorter interconnected documents. A set of shorter interconnected documents is often published as a website, wiki, or similar structured format.\n\nSome readers respond more positively than others to longer documents. Consider the following perspectives from two hypothetical readers you're writing documentation for:\n\n- Hong finds reading long documents difficult and disorientating. He prefers to use site search to find answers to his questions.\n- Rose is comfortable navigating large documents. She often uses the built-in page search feature in her web browser to find useful information on the current page.\n\nSo, should you organize your material into a single document or into a set of documents in a website? Consider the following guidelines:\n\n- How-to guides, introductory overviews, and conceptual guides often work better as shorter documents when aimed at readers who are new to the subject matter. For example, a reader who is completely new to your subject matter might struggle to remember lots of new terms, concepts, and facts. Remember that your audience might be reading your documentation to gain a quick and general overview of the topic.\n- In-depth tutorials, best practice guides, and command-line reference pages can work well as lengthier documents, especially when aimed at readers who already have some experience with the tools and subject matter.\n- A great tutorial can rely on a narrative to lead the reader through a series of related tasks in a longer document. However, even large tutorials can sometimes benefit from being broken up into smaller parts.\n- Many longer documents aren't designed to be read in one sitting. For example, users typically scan through a reference page to search for an explanation of a command or flag.\n\nThe remainder of this unit covers techniques that can be useful for writing longer documents, such as tutorials and some conceptual guides.\n\n### Organize a document\n\nThis section suggests some techniques for planning a longer document, including creating an outline and drafting an introduction. After you've completed the first draft of a document, you can review it against your outline and introduction to make sure you haven't missed anything you originally intended to cover.\n\n#### Outline a document\n\nStarting with a structured, high-level outline can help you group topics and determine where more detail is needed. The outline helps you move topics around before you get down to writing.\n\nYou might find it useful to think of an outline as the narrative for your document. There is no standard approach to writing an outline, but the following guidelines provide practical tips you might find useful:\n\n- Before you ask your reader to perform a task, explain to them why they are doing it. For example, the following bullet points illustrate a section of an outline from a tutorial about auditing and improving the accessibility of web pages:\n  - Introduce the browser plugin; explain that we'll use the results of the audit report to fix several bugs.\n  - List the steps to run the plugin and audit the accessibility of a web page.\n- Limit each step of your outline to describing a concept or completing a specific task.\n- Structure your outline so that your document introduces information when it's most relevant to your reader. For example, your reader probably doesn't need to know (or want to know) about the history of the project in the introductory sections of your document when they're just getting started with the basics. If you feel the history of the project is useful, then include a link to this type of information at the end of your document.\n- Documents that alternate between conceptual information and practical steps can be a particularly engaging way to learn. Consider explaining a concept and then demonstrating how the reader can apply it in either a sample project or in their own work.\n- Outlines are especially useful if you're working with a team of contributors who are going to review and test your document. Before you start drafting, share your outline with your contributors to check if they have any suggestions.\n\n#### Outline exercise\n\nFor this exercise, review and update the following high-level outline of an introduction to a long tutorial. You can rearrange, add, and remove topics.\n\n```markdown\n## The history of the project\n\nDescribes the history of the development of the project.\n\n## Prerequisites\n\nLists concepts the reader should be familiar with prior to starting, as well as\nany software or hardware requirements.\n\n## The design of the system\n\nDescribes how the system works.\n\n## Audience\n\nDescribes who the tutorial is aimed at.\n\n## Setting up the tutorial\n\nExplains how to configure your environment to follow the tutorial.\n\n## Troubleshooting\n\nExplains how to diagnose and solve potential problems that might occur when\nworking through the tutorial.\n\n## Useful terminology\n\nLists definitions of terms that the reader needs to know to follow the\ntutorial.\n```\n\n\n\n##### Answer.\n\nThe following is one possible solution:\n\n```markdown\n## Audience\n\nDescribes who the tutorial is aimed at.\n\n## Prerequisites\n\nLists concepts the reader should be familiar with prior to starting, as well as\nany software or hardware requirements.\n\n## Setting up the tutorial\n\nExplains how to configure your environment to follow the tutorial.\n\n## Useful terminology\n\nLists definitions of terms that the reader needs to know to follow the\ntutorial.\n```\n\n------\n\n#### Introduce a document\n\nIf readers of your documentation can't find relevance in the subject, they are likely to ignore it. To set the ground rules for your users, we recommend providing an introduction that includes the following information:\n\n- What the document covers.\n- What prior knowledge you expect readers to have.\n- What the document doesn't cover.\n\nRemember that you want to keep your documentation easy to maintain, so don't try to cover everything in the introduction.\n\nThe following paragraph demonstrates the ideas from the preceding list as an overview for a hypothetical document publishing platform called Froobus:\n\n```markdown\nThis document explains how to publish Markdown files using the Froobus system.\nFroobus is a publishing system that runs on a Linux server and converts\nMarkdown files into HTML pages. This document is intended for people who are\nfamiliar with Markdown syntax. To learn about the syntax, see the Markdown\nreference. You also need to be comfortable running simple commands in a\nLinux terminal. This document doesn't include information about installing or\nconfiguring a Froobus publishing system. For information on installing Froobus,\nsee Getting started.\n```\n\nAfter you've completed the first draft, check your entire document against the expectations you set in your overview. Does your introduction provide an accurate overview of the topics you cover? You might find it useful to think of this review as a form of documentation quality assurance (QA).\n\n#### Introduction exercise\n\nFor this exercise, review and revise the following introduction for a best practices guide for a hypothetical programming language called F@. Remove any information you feel is irrelevant in this context and add any information you feel is missing.\n\n```markdown\nThis guide lists best practices for working with the F@ programming language.\nF@ was developed in 2011 as an open source community project. This guide\nsupplements the F@ style guide. In addition to the best practices in this guide,\nmake sure you also install and run the F@ command-line linter on your code.  The\nprogramming language is widely adopted in the health industry. If you have\nsuggestions for additions to the list of best practices, file an issue in the\nF@ documentation repository.\n```\n\n\n\n##### Answer.\n\nThe following is one possible solution:\n\n```markdown\nThis guide lists best practices for working with the F@ programming language.\nBefore you review this guide, complete the introductory tutorial for new F@\ndevelopers. This guide supplements the F@ style guide. In addition to the best\npractices in this guide, make sure you also install and run the F@ command-line\nlinter on your code. If you have suggestions for additions to the list of best\npractices, file an issue in the F@ documentation repository.\n```\n\n------\n\n### Add navigation\n\nProviding navigation and signposting for your readers ensures they can find what they are looking for and the information they need to get unstuck.\n\nClear navigation includes:\n\n- introduction and summary sections\n- a clear, logical development of the subject\n- headings and subheadings that help users understand the subject\n- overviews that introduce the tool\n- a table of contents menu that shows users where they are in the document\n- links to related resources or more in-depth information\n- links to what to learn next\n\nThe tips in the following sections can help you plan the headings in your documentation.\n\n#### Prefer task-based headings\n\nChoose a heading that describes the task your reader is working on. Avoid headings that rely on unfamiliar terminology or tools. For example, suppose you are documenting the process for creating a new website. To create the site, the reader must initialize the Froobus framework. To initialize the Froobus framework, the reader must run the `carambola` command-line tool. At first glance, it might seem logical to add either of the following headings to the instructions:\n\n- Running the carambola command\n- Initializing the Froobus framework\n\nUnless your readers are already very experienced with the terminology and concepts for this topic, a more familiar heading might be preferable, such as *Creating the site*.\n\n#### Provide text under each heading\n\nMost readers appreciate at least a brief introduction under each heading to provide some context. Avoid placing a level three heading immediately after a level two heading, as in the following example:\n\n```markdown\n## Creating the site\n### Running the carambola command\n```\n\nIn this example, a brief introduction can help orient the reader:\n\n```markdown\n## Creating the site\n\nTo create the site, you run the `carambola` command-line tool. The command\ndisplays a series of prompts to help you configure the site.\n\n### Running the carambola command\n```\n\n#### Heading exercise\n\nHelping readers navigate through your documentation helps them find the information they need to successfully use your tool. Often, a clear and well-organized table of contents or outline acts like a map that helps your users navigate the functionality of your tool.\n\nFor this exercise, improve the following outline. You can rearrange, add, and delete topics and create secondary entries too.\n\n```markdown\nAbout this tutorial\nAdvanced topics\nBuild the asset navigation tree\nDefine resource paths\nDefining and building projects\nLaunch the development environment\nDefining and building resources\nWhat's next\nDefine image resources\nAudience\nSee also\nBuild an image resource\nDefine an image project\nBuild an image project\nSetting up the tutorial\nSelect the tutorial asset root\nAbout this guide\n```\n\n\n\n##### Answer.\n\nThe following is one possible solution:\n\n```markdown\n## About this tutorial\n\n### Audience\n\n### About this guide\n\n### Advanced topics\n\n## Setting up the tutorial\n\n### Select the tutorial asset root\n\n### Launch the development environment\n\n### Build the asset navigation tree\n\n### Define resource paths\n\n## Defining and building resources\n\n### Define image resources\n\n### Build an image resource\n\n## Defining and building projects\n\n### Define an image project\n\n### Build an image project\n\n## Defining and building databases\n\n### Define a database\n\n### Build a database\n\n## Pushing, publishing, and viewing a database\n\n### Push a database\n\n### Publish a database\n\n### View a database\n\n## Configuring display rules for point data\n\n### Define, configure, and build vector data\n\n## See also\n\n### Sample data files\n\n## What's next\n```\n\n------\n\n### Disclose information progressively\n\nLearning new concepts, ideas, and techniques can be a rewarding experience for many readers who are comfortable reading through documentation at their own pace. However, being confronted with too many new concepts and instructions too quickly can be overwhelming. Readers are more likely to be receptive to longer documents that progressively disclose new information to them when they need it. The following techniques can help you incorporate progressive disclosure in your documents:\n\n- Where possible, try introducing new terminology and concepts near to the instructions that rely on them.\n- Break up large walls of text. To avoid multiple large paragraphs on a single page, aim to introduce tables, diagrams, lists, and headings where appropriate.\n- Break up large series of steps. If you have a particularly long list of complicated steps, try to re-arrange them into shorter lists that explain how to complete sub-tasks.\n- Start with simple examples and instructions, and add progressively more interesting and complicated techniques. For example, in a tutorial for creating forms, start by explaining how to handle text responses, and then introduce other techniques to handle multiple choice, images, and other response types.\n\n\n\n------\n\n## Illustrating\n\n> **Estimated Time:** 10 minutes\n\n\n\nRemember when your teacher assigned you a hefty chapter to read? You flipped through the assigned section of the textbook, desperately hoping for...yes, pictures! Viewing illustrations was so much more fun than reading text. In fact, when it comes to reading technical material, the vast majority of adults are still little kids—still yearning for pictures rather than text.\n\n![Three children read a book while pointing at the pictures.](https://developers.google.com/tech-writing/two/images/book_readers.jpg?hl=zh-cn)\n\n**Figure 1. Good graphics engage readers in ways that text cannot.**\n\n[Nirmal Dulal [CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0)\\]](https://commons.wikimedia.org/wiki/File:Nepalese_Children.JPG)\n\n \n\n\n\nAccording to research by [Sung and Mayer (2012)](https://www.sciencedirect.com/science/article/pii/S0747563212000921), providing any graphics—good or bad—makes readers like the document more; however, only *instructive* graphics help readers learn. This unit suggests a few ways to help you create figures truly worth a thousand words.\n\n### Write the caption first\n\nOften times, it is helpful to write the caption *before* creating the illustration. Then, create the illustration that best represents the caption. This process helps you to check that the illustration matches the goal.\n\nGood captions have the following characteristics:\n\n- They are **brief**. Typically, a caption is just a few words.\n- They explain the **takeaway**. *After viewing this graphic, what should the reader remember?*\n- They **focus** the reader's attention. Focus is particularly important when a photograph or diagram contains a lot of detail.\n\n#### Exercise\n\nTarget Audience: CS undergraduate students taking an \"Introduction to Data Structures\" class.\n\nConsider the following three figures, each of which uses the same caption.\n\n![Multicolored chain](https://developers.google.com/tech-writing/two/images/caption_exercise_chain_a.svg?hl=zh-cn)\n\n**Caption A. A single-linked list holds content and a pointer to the next node.**\n\n \n\n![Four boxes connected by three arrows](https://developers.google.com/tech-writing/two/images/caption_exercise_drawing_b.png?hl=zh-cn)\n\n**Caption B. A single-linked list holds content and a pointer to the next node.**\n\n \n\n![Four boxes (each with content and a pointer) connected by three      arrows.](https://developers.google.com/tech-writing/two/images/caption_exercise_drawing_c.svg?hl=zh-cn)\n\n**Caption C. A single-linked list holds content and a pointer to the next node.**\n\n \n\nWhich of the three preceding figures best illustrates its caption?\n\n\n\nClick the icon to see the answer.\n\n- Figure A is bad. The chain is pretty, but information-free. The chain also erroneously implies that a single-linked list points both backwards and forwards.\n- Figure B is okay. The illustration helps students realize that the first item points to the second item, the second points to the third, and so on. However, although the caption refers to both *content* and a *pointer*, the illustration shows pointers but does not show content.\n- Figure C is the best and most instructive choice. The illustration clearly delineates the content part of each node from the pointer part.\n\n------\n\n### Constrain the amount of information in a single drawing\n\nFew intellectual tasks can be quite as rewarding as studying a fine painting, gradually uncovering layers of insight and meaning. People pay good money to do exactly that in the world's art museums.\n\n![Portrait of Pere Tanguy By Vincent van Gogh - Musée Rodin, Public Domain, https://commons.wikimedia.org/w/index.php?curid=119599](https://developers.google.com/tech-writing/two/images/van_gogh.png?hl=zh-cn)\n\n**Figure 2. You'd happily study this Van Gogh painting.**\n\n[Portrait of Pere Tanguy By Vincent van Gogh - Musée Rodin [Public domain\\]](https://commons.wikimedia.org/wiki/File:Van_Gogh_-_Portrait_of_Pere_Tanguy_1887-8.JPG)\n\n \n\n\n\nBy contrast, highly complex technical illustrations like the following tend to discourage most readers:\n\n![A schematic, filled with lines and small print](https://developers.google.com/tech-writing/two/images/overly_complex_diagram.svg?hl=zh-cn)\n\n**Figure 3. Complex block diagrams overwhelm readers.**\n\n\n\nJust as you avoid overly-long sentences, strive to avoid visual run-ons. As a rule of thumb, don't put more than one paragraph's worth of information in a single diagram. (An alternative rule of thumb is to avoid illustrations that require more than five bulleted items to explain.) I can hear you saying, \"But real-life technical systems can be vastly more complex than the one shown in Figure 3.\" You are correct, but you probably don't feel compelled to explain real-life complex systems in a single paragraph.\n\nThe trick to whittling visual clutter into something coherent and helpful is to organize complex systems into subsystems, like those shown in the following figure:\n\n![Three blocks, each with a simple label](https://developers.google.com/tech-writing/two/images/subsystems.svg?hl=zh-cn)\n\n**Figure 4. A complex system organized into three subsystems.**\n\n \n\nAfter showing the \"big picture,\" provide separate illustrations of each subsystem.\n\n![A zoomed in segment of figure 4 with slightly more detail](https://developers.google.com/tech-writing/two/images/subsystems_zoomed.svg?hl=zh-cn)\n\n**Figure 5. Expanded detail for one subsystem of a complex system.**\n\n \n\nAlternatively, start with a simple \"big picture\" and then gradually expand detail in each subsequent illustration.\n\n### Focus the reader's attention\n\nWhen confronted with a complex screenshot like the following, readers struggle to determine what's relevant:\n\n![Three blocks, each with a simple label](https://developers.google.com/tech-writing/two/images/unfocused_screenshot.png?hl=zh-cn)\n\n**Figure 6. Readers don't know what to focus on.**\n\n \n\nAdding a visual cue, for example, the red ellipse in the following figure, helps readers focus on the relevant section of the screenshot:\n\n![Same screenshot, but with one menu item circled in red](https://developers.google.com/tech-writing/two/images/focused_screenshot.png?hl=zh-cn)\n\n**Figure 7. Readers focus on a shape that breaks the pattern.**\n\n**Callouts** provide another way to focus the reader's attention. For pictures and line art, a callout helps our eyes find just the right spot to land on. Callouts in pictures are often better than paragraph long explanations of the pictures because callouts focus the reader's attention on the most important aspects of the picture. Then, in your explanation, you can focus directly on the relevant part of the diagram, rather than spending time describing what part of the image you are talking about.\n\nIn the example image, the callout and arrow quickly direct the reader to the purpose.\n\n![Three blocks, each with a simple label](https://developers.google.com/tech-writing/two/images/moon_with_callout.svg?hl=zh-cn)\n\n**Figure 8. A callout directs readers' eyes.**\n\n[NASA / JPL-Caltech / University of Arizona [Public domain\\]](https://commons.wikimedia.org/wiki/File:Phobos_colour_2008.jpg)\n\n \n\n\n\n### Illustrating is re-illustrating\n\nAs with writing, the first draft of an illustration is seldom good enough. Revise your illustrations to clarify the content. As you revise, ask yourself the following questions:\n\n- How can I simplify the illustration?\n- Should I split this illustration into two or more simpler illustrations?\n- Is the text in the illustration easy to read? Does text contrast sufficiently with its background?\n- What's the takeaway?\n\nFor instance, consider the [evolution of the London Tube map](https://wikipedia.org/wiki/Tube_map#History). Prior to 1931, the Tube map was drawn to scale, complete with above ground roads and tube lines that curved as the tracks did.\n\n![Complex map of the 1908 London Tube that includes above ground roads](https://developers.google.com/tech-writing/two/images/tube_1908.jpg?hl=zh-cn)\n\n**Figure 9. 1908 to scale map of the London Tube with above ground roads.**\n\n[[Public domain\\]](https://commons.wikimedia.org/wiki/File:Tube_map_1908.jpg)\n\nIn 1931, Harry Beck revolutionized a new type of public transit map that simplified the older map by removing above ground markers and removing scale. His design instead focused on what people using the maps really cared about: getting from station A to station B. Even with the success of his 1931 map, Beck still iterated on the diagram for many years to simplify and clarify the map. Consider now the [modern tube map](https://www.google.com/search?tbm=isch&q=london+tube+map&hl=zh-cn), although new lines and stations have appeared, they still remain close to Beck's design.\n\n#### Exercise\n\nConsider the following original illustration:\n\n![A complex visual of recursion that uses inaccessible colors and           confusing arrows](https://developers.google.com/tech-writing/two/images/recursion1.svg?hl=zh-cn)\n\n**Figure 10. A complex diagram.**\n\n \n\nThe takeaway of the preceding diagram is supposed to be:\n\n> For a recursive solution, call the function itself in the return statement until you reach a base case solution.\n\nIn what ways does the complexity of the diagram hide the takeaway? How might you address these problems?\n\n\n\n##### Answer.\n\nSome possible issues with the diagram include:\n\n- **Issue**: The bright colors pull the reader's attention away from other parts of the diagram.\n  **Solution**: Choose colors carefully so that they do not overpower the diagram.\n- **Issue**: The diagram does not have sufficient color contrast. This makes the diagram inaccessible for some people with low-vision or certain types of color blindness.\n  **Solution**: Remove unnecessary use of color and ensure that colors pass [standard color contrast recommendations](https://material.io/design/color/text-legibility.html#legibility-standards).\n- **Issue**: The arrows currently point in both directions which makes it unclear which way the diagram flows.\n  **Solution**: Separate the arrows into two parts with one set illustrating invoking a function and the other set illustrating returning from the function.\n\nThere are also additional issues in the diagram that are not identified here.\n\n------\n\nHere is an improved illustration:\n\n![Visual of recursion that simplifies colors and adds labels to arrows](https://developers.google.com/tech-writing/two/images/recursion2.svg?hl=zh-cn)\n\n**Figure 11. A simplified version of the preceding diagram.**\n\nWhat flaws do you see in the improved illustration?\n\n\n\n##### Answer.\n\nHere are two of the flaws that still exist:\n\n- This diagram is still too complex. It would take far more than a paragraph to explain this illustration. Consider how removing extra information or adding clarifying labels might simplify the interpretation.\n- While separating the arrows helped display when the functions invoke or return data to each other, the return arrows might benefit from labels that tell the reader what the return values are.\n\n------\n\n### Illustration tools\n\nThere are many options available for creating diagrams. Three options that are free or have free options include:\n\n- [Google Drawings](https://drawings.google.com/?hl=zh-cn)\n- [Draw.IO](https://draw.io/)\n- [LucidChart](https://www.lucidchart.com/pages/)\n\nWhen exporting diagrams from these tools to use in documentation, it is usually best to export the files as SVG or [Scalable Vector Graphics](https://wikipedia.org/wiki/Scalable_Vector_Graphics). Scalable Vector Graphics easily scale diagrams based on space constraints so that no matter the size, you end up with a high quality image.\n\n\n\n------\n\n\n\n## Creating sample code\n\n\n\n> **Estimated Time:** 10 minutes\n\n\nGood sample code is often the best documentation. Even if your paragraphs and lists are as clear as blue water, programmers still prefer good sample code. After all, text is a different language than code, and it is code that the reader ultimately cares about. Trying to describe code with text is like trying to explain an Italian poem in English.\n\nGood samples are **correct** and **concise** code that your readers can **quickly understand** and **easily reuse** with **minimal side effects**.\n\n### Correct\n\nSample code should meet the following criteria:\n\n- Build without errors.\n- Perform the task it claims to perform.\n- Be as production-ready as possible. For example, the code shouldn't contain any security vulnerabilities.\n- Follow language-specific conventions.\n\nSample code is an opportunity to directly influence how your users write code. Therefore, sample code should set the best way to use your product. If there is more than one way to code the task, code it in the manner that your team has decided is best. If your team hasn't considered the pros and cons of each approach, take time to do so.\n\nAlways test your sample code. Over time, systems change and your sample code may break. Be prepared to test and maintain sample code as you would any other code.\n\nMany teams reuse their unit tests as sample programs, which is sometimes a bad idea. The primary goal of a unit test is to test; the only goal of a sample program is to educate.\n\nA **snippet** is a piece of a sample program, possibly only one or a few lines long. Snippet-heavy documentation often degrades over time because teams tend not to test snippets as rigorously as full sample programs.\n\n### Running sample code\n\nGood documents explain how to run sample code. For example, your document might need to tell users to perform activities such as the following prior to running the samples:\n\n- Install a certain library.\n- Adjust the values assigned to certain environment variables.\n- Adjust something in the integrated development environment (IDE).\n\nUsers don't always perform the preceding activities properly. In some situations, users prefer to run or (experiment with) sample code directly in the documentation. (\"Click here to run this code.\")\n\nWriters should consider describing the expected output or result of sample code, especially for sample code that is difficult to run.\n\n### Concise\n\nSample code should be short, including only essential components. When a novice C programmer wants to learn how to call the `malloc` function, give that programmer a brief snippet, not the entire Linux source tree. Irrelevant code can distract and confuse your audience. That said, never use bad practices to shorten your code; always prefer correctness over conciseness.\n\nUnderstandable\n\nFollow these recommendations to create clear sample code:\n\n- Pick descriptive class, method, and variable names.\n- Avoid confusing your readers with hard-to-decipher programming tricks.\n- Avoid deeply nested code.\n- Optional: Use bold or colored font to draw the reader's attention to a specific section of your sample code. However, use highlighting judiciously—too much highlighting means the reader won't focus on anything in particular.\n\n#### Exercise\n\nWhich of the following would be a more helpful line of code in a sample program? Assume that the target audience consists of software engineers new to the `go.so` API.\n\n1. `MyLevel = go.so.Level(5, 28, 48)`\n2. `MyLevel = go.so.Level(rank=5, 28, 48)`\n3. `MyLevel = go.so.Level(rank=5, dimension=28, opacity=48)`\n\n\n\n##### Answer.\n\nAnswer **3** is the best choice here. Although it is tempting to keep sample code as short as possible, omitting parameter names makes it harder for novices to learn.\n\n------\n\n### Commented\n\nConsider the following recommendations about comments in sample code:\n\n- Keep comments short, but always prefer clarity over brevity.\n- Avoid writing comments about *obvious* code, but remember that what is obvious to you (the expert) might not be obvious to newcomers.\n- Focus your commenting energy on anything non-intuitive in the code.\n- When your readers are very experienced with a technology, don't explain *what* the code is doing, explain *why* the code is doing it.\n\nShould you place descriptions of code inside code comments or in text (paragraphs or lists) outside of the sample code? Note that readers who copy-and-paste a snippet gather not only the code but also any embedded comments. So, put any descriptions that belong in the pasted code into the code comments. By contrast, when you must explain a lengthy or tricky concept, you should typically place the text before the sample program.\n\n**Note:** If you must sacrifice production readiness in order to make the code shorter and easier to understand, explain your decisions in the comments.\n\n#### Exercise\n\nWhat problems do you see in the comments within the following snippet? Assume that the code is aimed at programmers who are new to the `br` API but who have some experience with the concept of streams:\n\n```\n/* Create a stream from the text file at pathname /tmp/myfile. */\nmystream = br.openstream(pathname=\"/tmp/myfile\", mode=\"z\")\n```\n\n\n\n##### Answer.\n\nThe comments contain the following flaws:\n\n- The comment elaborates on a fairly obvious part of the code.\n- The snippet doesn't explain the non-obvious portion of the code. Namely, what is the `mode` parameter and what does a value of `z` mean?\n\n------\n\n### Reusable\n\nFor your reader to easily reuse your sample code, provide the following:\n\n- All information necessary to run the sample code, including any dependencies and setup.\n- Code that can be extended or customized in useful ways.\n\nHaving easy-to-understand sample code that's concise and compiles is a great start. If it blows up your reader's app, though, they won't be happy. Therefore, when writing sample code, consider any potential side effects caused by your code being integrated into another program. Nobody wants insecure or grossly inefficient code.\n\n### The example and the anti-example\n\nIn addition to showing readers *what to do*, it is sometimes wise to show readers *what not to do*. For example, many programming languages permit programmers to place white space on either side of the equals sign. Now suppose that you were writing a tutorial on a language (such as bash) that does not permit white space on either side of the equals sign. In this case, showing both a good example and an anti-example will benefit the reader. For example:\n\n\n\nGood\n\n```\n# A valid string assignment.\ns=\"The rain in Maine.\"\n```\n\nBad\n\n```\n# An invalid string assignment because of the white space on either side of the\n# equals sign.\ns = \"The rain in Maine.\"\n```\n\n### Sequenced\n\nA good sample code set demonstrates **a range of complexity**.\n\nReaders completely unfamiliar with a certain technology typically crave simple examples to get started. The first and most basic example in a sample code set is usually termed a [Hello World program](https://wikipedia.org/wiki/\"Hello,_World!\"_program). After mastering the basics, engineers want more complex programs. A good set of sample code provides a healthy range of simple, moderate, and complex sample programs.\n\n#### Exercise\n\nWhich of the following would be a good set of sample functions to support a tutorial introducing newcomers to the concept of functions?\n\n1. The following set of samples:\n   1. A function that takes no parameters and doesn't return anything.\n   2. A function that takes one parameter but doesn't return anything.\n   3. A function that takes one parameter and returns one value.\n   4. A function that takes three parameters and returns one value.\n2. The following set of functions:\n   1. A function that takes three parameters and returns one value.\n3. The following set of functions:\n   1. A function that takes one parameter and returns one value.\n   2. A function that takes three parameters and returns one value.\n\n\n\n##### Answer.\n\nThe best answer is **1**. Providing samples that cover a range of complexity is usually the wisest choice—particularly for newcomers. Resist the temptation to *rush* towards very complex sample programs, bypassing the beginner and intermediate sample programs that newcomers crave.\n\n------\n\n### What's next?\n\nCongratulations: you've completed the pre-class work for Technical Writing Two.\n\nIf the in-class portion of Technical Writing Two is available, please take it.\n\nA quick compilation of the topics covered in Technical Writing Two is available on the [Summary](https://developers.google.com/tech-writing/two/summary?hl=zh-cn) page.\n\n\n\n------\n\n## Summary of Technical Writing Two\n\n\nTechnical Writing Two covered the following intermediate lessons of technical writing:\n\n- Adopt a style guide.\n- Think like your audience.\n- Read documents out loud (to yourself).\n- Return to documents well after you've written the draft.\n- Find a good peer editor.\n- Outline a document. Alternatively, write free form and then organize.\n- Introduce a document's scope and any prerequisites.\n- Prefer task-based headings.\n- Disclose information progressively (in some situations).\n- Consider writing the caption *before* creating the illustration.\n- Constrain the amount of information in a single drawing.\n- Focus the reader's attention through discontinuities.\n- Create concise sample code that is easy to understand.\n- Keep code comments short, but prefer clarity over brevity.\n- Avoid writing comments about *obvious* code.\n- Focus your commenting energy on anything non-intuitive in the code.\n- Provide not only examples but also anti-examples.\n- Provide code samples that demonstrate a range of complexity.\n- Make a practice of continuous revision.\n- Provide different documentation types for different categories of users.\n- Compare and contrast with something that readers are already familiar with.\n- In tutorials, reinforce concepts with examples.\n- In tutorials, point out dragons.\n\nAs time permits, consider reviewing these additional [technical writing resources](https://developers.google.com/tech-writing/resources?hl=zh-cn).\n\n### References\n\n`[1]` Technical Writing One: *https://developers.google.com/tech-writing/one?hl=zh-cn*\n`[2]` Technical Writing Two: *https://developers.google.com/tech-writing/two?hl=zh-cn*\n`[3]` Words: *https://developers.google.com/tech-writing/one/words?hl=zh-cn*\n`[4]` 1: *https://developers.google.com/tech-writing/one/active-voice?hl=zh-cn#Footnote1*\n`[5]` Words: *https://developers.google.com/tech-writing/one/words?hl=zh-cn*\n`[6]` sesquipedalian: *https://www.google.com/search?q=sesquipedalian&hl=zh-cn*\n`[7]` www.markdowntutorial.com: *https://www.markdowntutorial.com/*\n`[8]` Mastering Markdown: *https://guides.github.com/features/mastering-markdown/*\n`[9]` Summary: *https://developers.google.com/tech-writing/one/summary?hl=zh-cn*\n`[10]` technical writing resources: *https://developers.google.com/tech-writing/resources?hl=zh-cn*\n`[11]` Technical Writing One: *https://developers.google.com/tech-writing/one?hl=zh-cn*\n`[12]` self-study units: *https://developers.google.com/tech-writing/one?hl=zh-cn*\n`[13]` Google Developers: *https://developers.google.com/?hl=zh-cn*\n`[14]` Google Developer Documentation Style Guide: *https://developers.google.com/style?hl=zh-cn*\n`[15]` style-guide highlights: *https://developers.google.com/style/highlights?hl=zh-cn*\n`[16]` active voice: *https://developers.google.com/tech-writing/one/active-voice?hl=zh-cn*\n`[17]` numbered lists: *https://developers.google.com/tech-writing/one/lists-and-tables?hl=zh-cn*\n`[18]` Write in the second person: *https://developers.google.com/style/person?hl=zh-cn*\n`[19]` Place conditional clauses before an instruction: *https://developers.google.com/style/clause-order?hl=zh-cn*\n`[20]` code-related text as code font: *https://developers.google.com/style/code-in-text?hl=zh-cn*\n`[21]` Audience: *https://developers.google.com/tech-writing/one/audience?hl=zh-cn*\n`[22]` Style and authorial tone: *https://developers.google.com/style/tone?hl=zh-cn*\n`[23]` Nirmal Dulal [CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0)]: *https://commons.wikimedia.org/wiki/File:Nepalese_Children.JPG*\n`[24]` Sung and Mayer (2012): *https://www.sciencedirect.com/science/article/pii/S0747563212000921*\n`[25]` Portrait of Pere Tanguy By Vincent van Gogh - Musée Rodin [Public domain]: *https://commons.wikimedia.org/wiki/File:Van_Gogh_-_Portrait_of_Pere_Tanguy_1887-8.JPG*\n`[26]` NASA / JPL-Caltech / University of Arizona [Public domain]: *https://commons.wikimedia.org/wiki/File:Phobos_colour_2008.jpg*\n`[27]` evolution of the London Tube map: *https://wikipedia.org/wiki/Tube_map#History*\n`[28]` [Public domain]: *https://commons.wikimedia.org/wiki/File:Tube_map_1908.jpg*\n`[29]` modern tube map: *https://www.google.com/search?tbm=isch&q=london+tube+map&hl=zh-cn*\n`[30]` standard color contrast recommendations: *https://material.io/design/color/text-legibility.html#legibility-standards*\n`[31]` Google Drawings: *https://drawings.google.com/?hl=zh-cn*\n`[32]` Draw.IO: *https://draw.io/*\n`[33]` LucidChart: *https://www.lucidchart.com/pages/*\n`[34]` Scalable Vector Graphics: *https://wikipedia.org/wiki/Scalable_Vector_Graphics*\n`[35]` Hello World program: *https://wikipedia.org/wiki/\"Hello,_World!\"_program*\n`[36]` Summary: *https://developers.google.com/tech-writing/two/summary?hl=zh-cn*\n`[37]` technical writing resources: *https://developers.google.com/tech-writing/resources?hl=zh-cn*\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)\n",
      "data": {
        "title": "Technical Writing Courses",
        "date": "2020-03-01 12:46:40",
        "tags": [
          "教程",
          "tutorial"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "google-Technical-Writing-Courses"
    },
    {
      "content": "\n##  「工具推荐」[go-callvis](https://github.com/TrueFurby/go-callvis)\n\ngo-callvis是相对 以图片的形式展示了go程序的调用关系，这个工具在看复杂项目时尤其有用。\n\n>  亲测，借助它看祖传golang代码，头痛好多了。\n\n\n\n### 安装\n\n```sh\ngo get -u github.com/TrueFurby/go-callvis\n# or\ngit clone https://github.com/TrueFurby/go-callvis.git\ncd go-callvis && make install\n```\n\n\n\n运行依赖\n\n- [Go](https://golang.org/dl/) 1.12+\n- [Graphviz：http://www.graphviz.org/download/](http://www.graphviz.org/download/) Mac 可以直接 brew install graphviz\n\n\n\n[项目地址：https://github.com/TrueFurby/go-callvis](https://github.com/TrueFurby/go-callvis)\n\n\n\n### 使用命令\n\n命令特别简单，只需要简单的输入：\n\n\n```sh\ngo-callvis [OPTIONS] <main package>\n```\n\n\n\n这里 main package 是包含代码的main函数所在的包，比如项目 https://github.com/gusibi/oneplus/tree/master/idgenerator\n\n目录结构为：\n\n```sh\n.\n├── README.md\n└── src\n    ├── dbs\n    ├── go.mod\n    ├── go.sum\n    ├── idg\n    │   ├── area_code.go\n    │   ├── idg.go\n    │   ├── idg_test.go\n    │   ├── index.go\n    │   ├── index_test.go\n    │   ├── sort.go\n    │   ├── sort_test.go\n    │   ├── wr.go\n    │   └── wr_test.go\n    ├── main.go\n    └── sorteDB\n```\n\n其中src目录是一个go package，运行go-callvis 时就需要先**cd src/**，然后再执行命令：\n\n\n\n```sh\ngo-callvis  -group pkg,type md52id\n```\n\n> md52id 是package name，已在go.mod中声明，pakage name是一个必须要带的参数。\n\n \n\n运行命令，默认会打开浏览器加载地址**http://localhost:7878**\n\n> 图片格式为 svg，也可以添加 -format=png，指定以png形式展示\n>\n> 推荐使用svg，svg格式的内容是可交互的，比如这里想查看gin包的内容就可以点击 对应的模块来看详情。\n\n![](http://media.gusibi.mobi/clJZosivjY3n-3G5Bm-kQu6BbuAAV5z_L8iMjR8CoJSknZWRTiF51g9X8hHVq0jk)\n\n结果如果所示，图像展示的结果就是这个包所有的调用关系，按包的调用层级由左向右排列。第二列上边是 gin 框架的代码，如果看代码时不想看这部分，可以使用 ignore 参数排除掉。\n\n命令为：\n\n```sh\ngo-callvis -group pkg,type -ignore github.com/gin-gonic/gin md52id\n```\n\n> 这里 gin 包的名字是 *github.com/gin-gonic/gin*而不是 *gin*\n>\n> 如果要再排出idg 包，可以直接加在gin 包后边，用,（英文逗号）隔开。\n>\n> 使用limit 命令可以得到相同的结果\n>\n> go-callvis  -group pkg,type -limit md52id md52id\n\n得到的结果为：\n\n![](http://media.gusibi.mobi/I8l10FfoYRXYj0VtxMqbTwsz-mpQ7jsgaiq4Exd_8WNglM_mYDbWF6sye9x2uO-c)\n\n如果想看idg包内部的调用关系，可以使用 focus 命令，指定idg 包，命令如下：\n\n```sh\ngo-callvis -focus=md52id/idg -group pkg,type -limit md52id md52id\n```\n\n\n\n结果如图：\t![](http://media.gusibi.mobi/7WYETqHNJ2ShtiLf-rHKyWqLOnGVdLnBzTGiA_JBdzL26WwnwwaTkZ4xFBTh4-D4)\n\n\n\n详细命令可以参考：https://github.com/TrueFurby/go-callvis/tree/master/examples\n\n\n\n使用go-callvis ，直观的展示代码的调用关系，对于大项目的源码尤其有用，比如下图是gin stagic 包的调用关系：\n\n\n\n![](http://media.gusibi.mobi/VjziH07V8r_X33RlnVo2WeEWa0od4OvAnw9eJoCiAd1eLAAC-I3XuniOeWK0OVCW)\n\n\n\n通过图可以直观的看到，\n\n1. static 调用了 staticFS，而staticFS 只使用了 HEAD和GET 方法。\n2. 所有的http method 最终都是通过调用handler来处理响应的。\n\n### ### go-callvis 的另类用法\n\n\n\ngo-callvis 也可以用来评估系统设计是否合理，代码是否清晰，下图是docker 的调用图：\n\n\n\n![](http://media.gusibi.mobi/8vZ7dwD6bLOVUBecbWsC5ZMTDOSUeeLzRw2kfxL44TVO8BM0AFGHGzVO1iHJCFqd)\n\n\n\n> 原图地址：http://media.gusibi.mobi/8vZ7dwD6bLOVUBecbWsC5ZMTDOSUeeLzRw2kfxL44TVO8BM0AFGHGzVO1iHJCFqd\n\n\n\n可以看到，代码结构非常清晰，调用链也比较简单，项目成功果然每一环都做的非常完美。\n\n### References\n\n`[1]` go-callvis: *https://github.com/TrueFurby/go-callvis*\n`[2]` Go: *https://golang.org/dl/*\n`[3]` Graphviz：http://www.graphviz.org/download/: *http://www.graphviz.org/download/*\n`[4]` 项目地址：https://github.com/TrueFurby/go-callvis: *https://github.com/TrueFurby/go-callvis*\n\n------\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推\n\n以下是shopee内推广告，「深圳、新加坡、上海」的职位都有，感兴趣的可以留言或者识别二维码直接投递。\n\n![](http://media.gusibi.mobi/3Z6eP3JKdGQkAdfFm3X9cgV1x46YLwIX8iP8Rvg7_QSwYKYTRjAyt0jVEHKdql3P)\n\n",
      "data": {
        "title": "「工具推荐」golang 代码可视化工具 go-callvis",
        "date": "2020-01-19 15:14:13",
        "tags": [
          "工具",
          "golang"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "go-callvis"
    },
    {
      "content": "\n> **题目**：设计一个身份证查询系统，将身份证号md5 之后存储，输入md5值查询对应的身份证号。 \n> **要求：成本低，查询速度快** \n\n\n### 设计思路： \n\n1. 将所有可能的身份证号做一个简单的统计计算数据量 \n2. 根据数据量选择存储方式 \n3. 查询 \n\n\n### 身份证生成规则： \n\n\n身份号码是特征组合码，由前十七位数字本体码和最后一位数字校验码组成。排列顺序从左至右依次为六位数字地址码，八位数字出生日期码，三位数字顺序码和一位数字校验码。 \n\n**地址码**： 表示编码对象常住户口所在县(市、旗、区)的行政区划代码。对于新生儿，该地址码为户口登记地行政区划代码。需要没说明的是，随着行政区划的调整，同一个地方进行户口登记的可能存在地址码不一致的情况。行政区划代码按GB/T2260的规定执行。 \n\n**出生日期码**：表示编码对象出生的年、月、日，年、月、日代码之间不用分隔符，格式为YYYYMMDD，如19880328。按GB/T 7408的规定执行。原15位身份证号码中出生日期码还有对百岁老人特定的标识，其中999、998、997、996分配给百岁老人。 \n\n**顺序码**： 表示在同一地址码所标识的区域范围内，对同年、同月、同日出生的人编定的顺序号，顺序码的奇数分配给男性，偶数分配给女性。 \n\n**校验码**： 根据本体码，通过采用ISO 7064:1983,MOD 11-2校验码系统计算出校验码。算法可参考下文。前面有提到数字校验码，我们知道校验码也有X的，实质上为罗马字符X，相当于10. \n\n\n#### 校验码算法 \n\n将本体码各位数字乘以对应加权因子并求和，除以11得到余数，根据余数通过校验码对照表查得校验码。 \n\n\n**加权因子表**： \n\n```sh\n+-----------------------------------------------------------+ \n|位置序号|1 |2 |3 |4 |5 |6 |7 |8 |9 |10|11|12|13|14|15|16|17| \n+-----------------------------------------------------------+ \n|加权因子|7 |9 |10|5 |8 |4 |2 |1 |6 |3 |7 |9 |10|5 |8 |4 |2 | \n+-----------------------------------------------------------+ \n```\n\n**校验码表**: \n\n```sh\n+----------------------------------------------------+ \n| 余数  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | \n+----------------------------------------------------+ \n| 校验码| 1 | 0 | X | 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2  | \n+----------------------------------------------------+ \n```\n\n\n#### 算法举例： \n\n\n本体码为11010519491231002 \n\n* 第一步：各位数与对应加权因子乘积求和1* 7+1 * 9+0 * 10+1 * 5+ *** =167 \n* 第二步：对求和进行除11得余数167%11=2 \n* 第三步：根据余数2对照校验码得X \n\n**因此完整身份证号为：11010519491231002X **\n\n\n### 预估数据量： \n\n\n1. 身份证号18位，前六位为地区码，中间八位为日期，日期后三位为顺序码，最后一位为校验位，占32个字节 \n2. md5值为32位，占32个字节 \n3. 计算最近100年数据，大约数据量为：`3465x100x365x999=126346027500 `\n4. 数据以字符串存储，每条数据`32+18=50B` \n5. 则数据量为 `126346027500 x 50=6317301375000B=6169239624k=6024648M=5883G=5.74T ``\n\n\n> 存储方式有文件存储、关系型数据库存储和es存储等。从结果可以看到有接近6T的数据，如果存入数据库或es**成本较高**，这里选择以文件的方式存储。 \n\n\n**那有没有方式压缩存储空间呢？**\n\n\n1. 身份证号最后一位为校验位，可以不存储，省略掉这一位会节约1/50点空间 \n2. 不以字符串的方式存储，将身份证号以uint64存储，md5值也转化成两个uint64存储。uint64占8阁字节空间，这样一条数据的空间由50降为了 24。最终数据量为2.74T，节约一半多的空间。 \n\n\n**那现在有一个问题，每个文件多大合适呢？**\n\n如果文件太大，每次将文件读取到内存中耗时较长，如果文件太小，则会生成太多的文件可能超出系统的文件数限制。 \n\n这里可以参考数据库索引的存储方式，设定每个数据文件的大小（2.8T数据可以设置每个数据文件1G左右。\n\n### 数据生成后如何查询？ \n\n1. 遍历，依次读取文件，查找数据，效率太低\n2. 这里参考数据库索引的查询方式，首先将数据按md5值排序后存储多个文件，记录每个文件中md5值的范围，输入md5值确定文件，再读取文件使用二分查找。 \n3. 这时查找数据只需要读取一个文件，但是每个文件都有几百兆的数据，查询效率还是太低，再参考一下数据库索引，这里将文件内部再分页，记录每页的范围，和文件所自身记录的起始值一起生成索引，索引结构如图所示： \n\n![89b91ea63b15a762099ccc0a6fdaf412.png](http://media.gusibi.mobi/id2md5index.png)\n\n\n索引数据结构为： \n\n\n```python\n# 为了简化存储，这里file1、file2、file3、file4 为该文件第一条数据的md5值，也是对应的文件名\n# 页的大小固定，所以二级索引只需要按顺序记录每页的第一个md5值即可\n\nindexes = { \n    \"file1\": [\"md51\", \"md52\", \"md53\", \"...\"],\n    \"file2\": [\"md51\", \"md52\", \"md53\", \"...\"], \n    \"file3\": [\"md51\", \"md52\", \"md53\", \"...\"], \n    \"file4\": [\"md51\", \"md52\", \"md53\", \"...\"],  \n} \n```\n\n\n第一层索引为文件索引，首先通过md5值判断md5值所在文件，比如输入的 start1 > md5 > start1，可以判断结果可能在file1 中； \n\n第二层为文件内索引，通过md5值判断所在的页，读取根据offset读取该页的全部数据，再通过二分查找找到对应的身份证号。 \n\n\n代码实现源码地址：https://github.com/gusibi/oneplus/tree/master/idgenerator\n\n使用方式：\n```sh\n1. go run main.go\n2. curl http://127.0.0.1:8080/search?md5={id md5}\n```\n\n## 参考链接： \n\n* [源码地址](https://github.com/gusibi/oneplus/tree/master/idgenerator)\n\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "如何通过MD5反查身份证号？",
        "date": "2019-08-18 06:22:26",
        "tags": [
          "教程",
          "工具",
          "golang"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "id-md5-search"
    },
    {
      "content": "\n前几天写了《markdown 生成头条文章的一个思路》，周末就试了试。\n\n先回顾一下思路，大致流程如下：\n\n![](http://media.gusibi.mobi/AeaSby9Zk5mB9lMW2hiZDbSzaQa9VlpRaHomeb_mVndzFIn6oMEKbIKJqk3P59_U)\n\n这里的三个关键点是：\n1. 提取code\n2. 把code 转换为html\n3. 把html 生成图片\n4. code 替换成图片\n\n第一个很简单，只有用正则表达式就可以解决：\n\n```python\n_fenced_code_block_re = re.compile(r'''\n    (?:\\n+|\\A\\n?)\n    ^```\\s*?([\\w+-]+)?\\s*?\\n # opening fence, $1 = optional lang\n    (.*?)                  # $2 = code block content\n    ^```[ \\t]*\\n           # closing fence\n    ''', re.M | re.X | re.S)\n```\n\n> 这个正则来自 python-markdown2: https://github.com/trentm/python-markdown2\n\n这个正则只匹配了 **```** 样式的代码，对于前边有四个空格的并没有做处理（也不想做处理，还是严格一点好）。\n\n第二个也不麻烦，只需要把提取出的code 放到html 中，下面是一个html模板：\n\n```html\n<html>\n<head>\n   <link rel=\"stylesheet\" href=\"http://media.gusibi.mobi/highlight/static/styles/atom-one-dark.css\">\n   <script src=\"http://media.gusibi.mobi/highlight/static/highlight.site.pack.js\"></script>\n   <script>hljs.initHighlightingOnLoad();</script>\n</head>\n<body style=\"width: 640px;\">\n<pre>\n<code class=\"{{.Language}}\">{{.Code}}</code>\n</pre>\n</body>\n</html>`\n```\n\n这里有一个点是渲染html 页面的时候， 由于加载html 页面的工具都是get请求，这里我们需要先把code 数据保存起来。所以请求code 的html 页面分成了两步。\n\n1. 存储code\n2. 请求code 对应的html\n\n在 html-server 服务中，实现了code 的存储和请求，使用方式如下：\n\n```python\ndef code2html(code, language=\"plaintext\"):\n    data = {\n        \"code\": code,\n        \"language\": language\n    }\n    # 先存储代码\n    resp = requests.post(Code2HtmlCreateUrl, json=data)\n    if resp.status_code == 200:\n        content = resp.json()\n    else:\n        content = resp.content\n    return content[\"ID\"]\n\n```\n\n第三个问题比较麻烦一点。\n\n开始的时候是准备使用pyqt5 生成图片，但是它渲染html 的大小和直觉不太一致，API也比较复杂。最坑的是，一次生成多张图片有问题，最后改成了使用 的方式。\n\n图片生成的代码比较简单，\n\n```python\n# -*- coding: utf-8 -*-\n\nfrom selenium import webdriver\nimport time\nimport os.path\nimport multiprocessing as mp\n\ndef webshot(url, height, outfile):\n    driver = webdriver.PhantomJS()\n    driver.set_window_size(660, height)# 这里的宽高是先计算好指定的\n    # driver.maximize_window()\n    # 返回网页的高度的js代码\n    js_height = \"return document.body.clientHeight\"\n    try:\n        driver.get(url)\n        k = 1\n        height = driver.execute_script(js_height)\n        while True:\n            if k*500 < height:\n                js_move = \"window.scrollTo(0,{})\".format(k * 500)\n                driver.execute_script(js_move)\n                time.sleep(0.2)\n                height = driver.execute_script(js_height)\n                k += 1\n            else:\n                break\n        driver.save_screenshot(outfile)\n        print(\"save screenshot to {} success\".format(outfile))\n        time.sleep(0.1)\n    except Exception as e:\n        print(outfile,e)\n```\n\n第四个问题和第一个问题现在是关联的，操作方式是，找出code，处理然后直接替换：\n\n```python\n     def _fenced_code_block_sub(self, match):\n        language = match.group(1)\n        codeblock = match.group(2)\n        image_path = code2img(codeblock, language)\n        image_url, _ = upload27niu(image_path)\n        return \"\\n\\n![](%s)\\n\\n\" % image_url\n\n    def _do_fenced_code_blocks(self, text):\n        \"\"\"Process ```-fenced unindented code blocks \n        ('fenced-code-blocks' extra).\"\"\"\n        return self._fenced_code_block_re.sub(\n            self._fenced_code_block_sub, text)\n```\n\n这么做虽然简单但是弊端也很明显，就是没有使用并发，脚本执行的慢。如果想提高速度，可以先把code 全找出来，然后使用多进程来处理。\n\n代码我上传到了github，使用方式如下\n\n使用方法\n\n```bash\ngit clone git@github.com:gusibi/oneplus.git\n\ncd oneplus\n\npython plus.py -m [markdown_path] -n [outfile_path]\n```\n\n## 转换前后的效果\n\n这是转换前：\n\nhttps://github.com/gusibi/oneplus/blob/master/325.md\n\n这是转换后：\n\nhttps://github.com/gusibi/oneplus/blob/master/new_325.md\n\n\n这个只是一个粗糙的优化方式，也只识别了代码，对于流程图，table 并没有适配，作为一个优化项之后再做吧。\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "markdown中code生成图片的实现",
        "date": "2019-06-15 15:34:53",
        "tags": [
          "python",
          "tutorial",
          "golang",
          "公众号"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "mardown-code-to-image-2"
    },
    {
      "content": "\n最近在头条上写东西，遇到了一个比较烦的事情---**编辑器不支持代码**。这对于一个像我这样使用代码凑字数的人来说实在不是一个好的消息。但是等头条改进编辑器太遥远了，只能自己自足实现一个替代方案了--把代码替换成图片。\n\n一段代码的时候，我随手截图，简单完成了；\n两段代码的时候，我随手随手截图，也完成了；\n三段代码的时候，我随手随手随手截图，强忍着完成了；\n等我发现代码越来越多的时候，不能忍了。\n懒惰是程序员的美德，不能再花费时间干这些事情了。我觉得要写个程序，把markdown 中的代码自动生成图片。\n\n**考虑了一下，大概需要做的工作是：**\n\n1. 把markdown 中 \"``` ```\" 包换的代码提取出来（也可以使用工具先把markdown 转换成html 再解析html 取出code\n2. 把每一段code 分别生成图片\n3. 把图片对应的代码替换掉\n\n\n想想还是很简单的。那就开始吧。\n\n但是到第二步的时候遇到了问题，**code 如何生成图片，生成什么样的图片？**\n\n1. 首先code 需要保持原有的样式，如果能高亮那就更好了（嗯，高亮\n2. 生成图片的时候是把code 作为文字使用PIL（我使用python）写在背景上么，图片大小是多少，高亮怎么实现\n3. 算了，还是先把code 生成html，然后截取html页面吧。（这样html 还能使用 highlight.js 来实现高亮）\n4. 如何动态生成包含code 的html 页面呢？\n5. 如何把截取html 页面呢？\n\n\n**动态生成包含code 的html 页面有两个思路：**\n\n1. 使用post 请求，把code 写入数据库（或者文件），然后返回id，再使用id GET 请求获取页面（需要存储，两次请求）\n2. 压缩code，把code 作为url参数，使用GET请求获取页面（可能会造成url太长的错误）\n\n\n**那如何截取html呢？**\n\n如果是python，可以使用pyqt，渲染html页面，截取webview。\n如果使用node，可以使用 html2canvas。\n\n大致流程如下：\n\n![](http://media.gusibi.mobi/AeaSby9Zk5mB9lMW2hiZDbSzaQa9VlpRaHomeb_mVndzFIn6oMEKbIKJqk3P59_U)\n\n\n**哎，这一篇没有代码，就凑不了多少字。**\n\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "markdown中code生成图片的思路",
        "date": "2019-06-13 15:34:53",
        "tags": [
          "python",
          "tutorial",
          "golang",
          "公众号"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "mardown-code-to-image-1"
    },
    {
      "content": "\n## 面向DynamoDB的NoSQL设计\n\n### 关系数据库设计和NoSQL之间的差异\n\n- 关系型数据库可以灵活的查询数据，但是成本较高，高流量无法扩展\n  - RDBMS 设计灵活，可以随时修改\n- NoSQL查询方式有限\n  - 需要对架构进行专门设计，以尽可能的加快查询速度。数据结构和需求高度相关，需要特制。\n\n### NoSQL设计的两个关键概念\n\n- 需要先了解业务问题和应用程序的使用案例，然后再开始设计\n- 应保留尽可能少的表。\n\n### 了解NoSQL设计\n\n- 三个基本属性\n\n  - 数据大小\n\n    了解一次存储和请求的数据量将有助于确定对数据进行分区的最有效方法。\n\n  - 数据形状\n\n    NoSQL 数据库不会在处理查询时重塑数据（如 RDBMS 系统所做的一样），而是整理数据以便数据在数据库中的形状与查询内容对应。这是加快速度并增强可扩展性的一个关键因素\n\n  - 数据速度\n\n    DynamoDB 通过增加可用于处理查询的物理分区的数量并通过跨这些分区有效分发数据来进行扩展。预先了解峰值查询负载可能有助于确定数据分区方式，从而最高效地使用 I/O 容量。\n\n- 性能的一般准则\n\n  - 将相关数据放在一起\n\n    将相关数据集中放置到一个位置。将相关数据保留在最近位置会对成本和性能产生重大影响。\n    不是跨多个表分发相关数据项目，而是在 NoSQL 系统中尽可能紧密地保留相关项目。\n    作为一般规则，应在 DynamoDB 应用程序中保留尽可能少的表。\n\n    只需要一个表，\n    例外是涉及大量时间序列数据的情况或具有明显不同的访问模式的数据集 — 但这些都是例外。具有反向索引的单个表通常可启用简单查询来创建和检索应用程序所需的复杂层次数据结构。\n\n  - 使用排序顺序\n\n    可将相关项目组织起来并进行有效查询，前提是它们的键设计可促使它们一起排序\n\n  - 分发查询\n\n    您应该设计数据键以跨尽可能多的分区均匀分发流量，从而避免“热点”。\n\n  - 使用全局二级索引\n\n    通过创建特定的全局二级索引，可启用主表支持的查询以外的查询\n\n## 设计并高效使用分区键的最佳实践\n\n项目主键可以是仅分区键\n也可以是分区键+排序键\n\n### 高效使用突增容量\n\nDynamoDB 当前可将未使用的读取和写入容量保留最多五分钟 (300 秒)\n当读取或写入突增导致容量不足时使用。\n\n### DynamoDB适应性容量\n\nDynamoDB 适应性容量 允许您的应用程序继续不受限地对热分区进行读写操作，前提是流量未超出表的配置的总容量或分区最大容量。自适应容量的工作原理是，自动增加分区的吞吐量容量来接收更多流量\n\n示例表配置了 400 个写入容量单位 (WCU)，这些容量单位均匀分布在 4 个分区中，每个分区每秒可以接收最多 100 个 WCU。分区 1、2 和 3 每秒接收的写入流量为 50 个 WCU。分区 4 每秒接收 150 个 WCU。此热分区可以在接受写入流量的同时仍具有未利用的突增容量，但是，它最终会限制每秒超过 100 个 WCU 的流量。\n\nDynamoDB 适应性容量通过增加分区 4 的容量来做出响应，因此分区 4 可以接收 150 WCU/秒的更高工作负载，而不会受到限制。\n\n### 设计分区键以均匀分发工作负载\n\n表的主键的分区键用来确定数据存储在哪个物理分区\n\n每个物理分区均分读取和写入容量\n\n合理设计分区键，避免出现“热点” (请求频率非常高的) 分区键值而导致整体性能降低。\n\n好的\n用户 ID\n\n差的\n状态代码 项目创建日期（时间段）\n\n### 使用写入分片均匀分发工作负载\n\n跨分区键空间写入是一种比较好的方式\n\n比如：分区键是日期，现在有1w条数据，日期均分在100天，不好的方式是按时间插入，这样会在短时间内产生 热键\n\n- 使用随机后缀分区\n\n  将随机数字添加到分区键值的末尾。然后跨更大型的空间随机化写入。\n\n  例如，对于表示当天日期的分区键，可能会选择介于 1 和 200 之间的随机数并将它作为后缀连接到该日期。这将生成分区键值 (如 2014-07-09.1、2014-07-09.2，以此类推，直到 2014-07-09.200)。由于随机化分区键，因此将跨多个分区均匀分布每天对表的写入。这将提高并行度和总体吞吐量。\n\n  问题：读取困难\n\n- 使用计算得出的后缀分区\n\n  不使用随机数在分区间分发项目，而是使用可根据查询内容计算出的数字。\n\n  例如：表在分区键中使用当天日期。现在假设每个项目都有可访问的 OrderId 属性，并且除了日期，还最常需要按订单 ID 查找项目。在应用程序将项目写入表之前，它可根据订单 ID 计算得出一个哈希后缀并将此后缀追加到分区键日期。此计算可能生成一个介于 1 和 200 之间、分发甚是均匀的数字 (类似于随机策略所生成的数字)。\n\n### 在数据上传期间有效分发写入活动\n\n例如，假设要将用户消息上传至使用复合主键（其中 UserID 作为主键，MessageID 作为排序键）的 DynamoDB 表。\n\n在后台，DynamoDB 将跨多台服务器为表数据分区。要充分利用为表配置的所有吞吐容量，必须跨分区键值分发工作负载。\n\n可分发上传工作，方式为使用排序键通过每个分区键值加载一个项目，然后通过每个分区键值加载另一个项目，以此类推\n\n此序列中的每次上传都使用不同的分区键值，以便能够同时使用更多 DynamoDB 服务器，从而提高吞吐量性能\n\n## 使用排序键整理数据的最佳实践\n\n精心设计的排序键具有两个主要好处：\n\n它们将相关信息聚集在一个位置，以便进行高效查询。利用精心设计的排序键，您可以使用带运算符 (如 starts-with、between、>、< 等) 的范围查询检索通常需要的相关项目组。\n利用组合排序键，可以在数据中定义可在任何层次结构级别查询的层次 (一对多) 关系。\n例如，在列出地理位置的表中，可按如下所示构建排序键：\n[country]#[region]#[state]#[county]#[city]#[neighborhood]\n\n### 使用排序键进行版本控制\n\nhttp://docs.amazonaws.cn/amazondynamodb/latest/developerguide/bp-sort-keys.html\n\n请为每个新项目创建两个副本：一个副本在排序键的开头应具有版本号前缀零 (如 v0_)，一个应具有版本号前缀 1 (如 v001_)。\n每次更新项目时，请在已更新版本的排序键中使用下一个更高的版本前缀，并将更新后的内容复制到版本前缀为零的项目中。这意味着，可使用前缀零轻松找到所有项目的最新版本。\n\n## 在DynamoDB中使用二级索引的最佳实践\n\n本地二级索引和表一起创建，不能修改，\n全局二级索引可以在后期更新创建修改，\n上限都是5个\n\n### 索引类型\n\n- 全局二级索引\n\n  - 分区键和排序键可与基表中的这些键不同的索引。\n\n    全局二级索引之所以称为“全局”，这是因为该索引上的查询可跨过所有分区，涵盖基表中的所有数据。全局二级索引没有大小限制且具有其自己的读取和写入活动的预配置吞吐量设置，这些设置独立于表的相应设置。\n\n- 本地二级索引\n\n  - 分区键与基表相同但排序键不同的索引。\n\n    本地二级索引之所以称为“本地”，是因为该索引的每个分区的范围都限定为具有相同分区键值的基表分区。因此，对于任何一个分区键值，索引项目的大小总和不得超过 10GB。此外，本地二级索引与其索引的表共享用于读取和写入活动的预配置吞吐量设置。\n\n### DynamoDB中二级索引的一般准则\n\n- 高效使用索引\n\n  - 最大程度的减少索引数量\n\n    很少使用的索引会增加存储和 I/O 成本，而且无法提高应用程序性能。\n\n  - 对于写入活动工作量大的表，避免使用索引\n\n    在数据捕获应用程序中，要在具有极高写入负载的表上维护索引所需的 I/O 操作，成本非常高。如果您需要为此类表中的数据编制索引，可能更有效的方法是将数据复制到具有必要索引的另外一个表，并对其进行查询。\n\n- 慎重选择投影\n\n  相较于查询整个表，索引越小，性能优势越明显。如果您的查询通常只返回很少一部分属性，并且这些属性的总和远远少于整个项目的大小，那么您应当只投影经常请求的属性。\n\n  - 请尽量减少投影属性的数量，以最大程度减少写入索引的项目大小\n\n    但是，这仅在投影属性的大小大于单个写入容量单位 (1 KB) 时适用。\n\n    例如，如果索引条目的大小仅为 200 字节，则 DynamoDB 会将其向上取整为 1 KB。也就是说，如果索引项目很小的话，您可以投影更多属性，而不会额外增加成本。\n\n  - 避免投影您知道在查询中极少需要的属性。\n\n    每次更新在索引中投影的属性时，也会因更新索引而额外产生成本\n\n  - 只有当您需要让查询返回按不同的排序键排序的整个表项目时，才应指定 ALL。\n\n- 优化频繁查询以避免抓取\n\n  - 频繁使用的属性需要投影，已避免重复抓取\n\n    例如，如果索引只投影了 属性A B，\n    但是查询结果会经常使用属性C\n\n    只能再次查询表来抓取属性C\n\n- 创建本地二级索引时注意项目集合大小限制\n\n  对于任何一个分区键值，索引项目的大小总和不得超过 10GB\n\n  例如表有一个特定的分区键 A，该表有3个本地索引。增加一个新项目时，二级索引也会同步创建，三个二级索引可能会创建3个数据备份。\n\n  最严重的情况是，同一个数据可能会占用4倍数据的空间。\n\n  可能，在分区数据在2.5G大小的时候，索引就已经到达了10G。\n\n### 利用稀疏索引\n\n- 对于表中的任何项目，DynamoDB 仅当项目中存在索引排序键值时才会写入相应的索引条目。如果排序键并未出现在每个表项目中，则这种索引称为稀疏 索引。\n\n  稀疏索引对于查询表的小型子部分非常有用。例如，假设您有一个存储您的所有客户订单的表，该表具有以下键属性：\n\n  分区键：CustomerId\n  排序键: OrderId\n\n  要跟踪未结订单，可以在尚未发运的订单项目中插入一个名为 isOpen 的布尔值。然后，在该订单发运后，您可以删除该属性。然后，如果对 CustomerId (分区键) 和 isOpen (排序键) 创建索引，则只有定义为 isOpen 的订单才显示在其中。如果有数以千计的订单，其中只有少量订单处于未结状态，则查询未结订单的索引要比扫描整个表更快速且更便宜。\n\n  布尔值不能做索引\n\n  可以使用具有在索引中生成有用的排序顺序的值的属性，而不是使用布尔类型的属性，如 isOpen。\n  例如，可以使用 OrderOpenDate 属性设置为下每个订单的日期，然后在订单完成后将其删除。这样，在查询稀疏索引时，会返回按下每个订单的日期排序的项目。\n\n- 全局二级索引应用稀疏索引后，可以使用比基表低的吞吐配置实现高性能查询\n\n### 使用全局二级索引进行具体化聚合查询\n\nhttps://docs.aws.amazon.com/zh_cn/amazondynamodb/latest/developerguide/bp-gsi-aggregation.html\n\n### 重载全局二级索引\n\nhttps://docs.aws.amazon.com/zh_cn/amazondynamodb/latest/developerguide/bp-gsi-overloading.html\n\n### 对选择性表查询使用全局二级索引写入分片\n\n例如： 有遍历表的需求\n\n此时如果分区键平均分布，只能使用scan 操作，操作昂贵\n\n也可以使用特定的分区键，但是容易产生热键\n\n可以利用全局索引，要在整个键空间中启用选择性查询，可使用写入分片，方式是向用于全局二级索引分区键的每个项目添加一个包含 (0-N) 值的属性。\n\n通过使用此架构设计，事件项目将分布在 GSI 上的 0-N 分区中，从而允许在复合键上使用排序条件来执行分散读取，以便检索指定时间段内具有给定状态的所有项目。\n\n此架构模式以最低的成本交付一个高度选择性的结果集，而无需表扫描。\n\n### 使用全局二级索引创建一致性副本\n\n最终一致\n\n- 全局二级索引副本支持功能\n  - 为不同的读取器设置不同的预置读取容量\n  - 完全消除对表的读取\n\n## 存储大型项目和属性的最佳实践\n\nDynamoDB 当前限制存储在表中的每个项目的大小\n\nDynamoDB 中的项目大小上限为 400 KB，包括属性名称二进制长度（UTF-8 长度）和属性值长度（同为二进制长度）。属性名称也包含在此大小限制之内。\n\n具有本地二级索引的表的项目大小\n\n对于表上的每个local secondary index，以下对象的总大小有 400 KB 的限制：\n\n表中项目数据的大小。\n与该项目对应的local secondary index条目的大小，包括其键值和投影属性。\n\n### 压缩大型属性值\n\n压缩大型属性值可以让属性值符合 DynamoDB 中的项目限制并降低存储成本。压缩算法 (如 GZIP 或 LZO) 将生成之后可存储在 Binary 属性类型中的二进制输出。\n\n比如表中一个属性包含长文本，这些内容就适合压缩处理\n\n### 在S3中存储大型属性值\n\n可以将它们作为对象存储在 Amazon S3 中，然后将对象标识符存储在 DynamoDB 项目中。\n\n实施此策略时，请记住以下几点：\n\nDynamoDB 不支持跨 Amazon S3 和 DynamoDB 的事务。因此，应用程序必须处理任何故障，其中可能包括清理孤立的 Amazon S3 对象。\nAmazon S3 限制对象标识符的长度。因此必须通过不会生成过长对象标识符或违反其他 Amazon S3 约束的方式组织数据。\n\n## 在DynamoDB中处理时间序列数据的最佳实践\n\n### 时间序列数据的设计模式\n\n考虑您想跟踪大量活动的典型时间序列场景。写入访问模式即要记录的所有事件都具有今日日期。读取访问模式读取今日事件的频率最高，读取昨日事件的频率小很多，而读取更早事件的频率是最低的。\n\n一种处理方式是将当前日期和时间构建成主键。\n\n- 以日期为主键\n\n- 以日期或时间间隔创建不同的表\n\n  每个时间段创建一个表，并为表预置所需的读取和写入容量以及所需的索引。\n  在每个时间段结束之前，为下一个时间段预构建表。在当前时间段结束时，事件流量将定向至新表。可以为这些表分配名称以指明这些表所记录的时间段。\n\n  只要表不再被写入，就将其预置的写入容量降至较低的值（例如，1 WCU）并预置适当的读取容量。随着时间推移，降低早期表的预置读取容量。可以选择存档或删除极少或根本不需要其内容的表。\n\n  这种做法的目的是将所需的资源分配给承受最高流量的当前时间段，同时降低使用不活跃的旧表的预置资源，从而节省成本。根据您的业务需求，您可能需要考虑写入分片，以将流量均匀地分配到逻辑分区键。\n\n## 管理多对多关系的最佳实践\n\n### 相邻列表设计模式\n\n相邻列表是一种设计模式，有助于在 Amazon DynamoDB 中为多对多关系建模。一般地说，它们提供在 DynamoDB 中表示图表数据 (节点和边缘) 的方式。\n\n当应用程序的不同实体之间具有多对多关系时，此关系可建模为相邻列表。\n在此模式中，所有顶级实体 (与图表模型中的节点同义) 都是使用分区键表示的。通过将排序键的值设置为目标实体 ID (目标节点)，与其他实体 (图表中的边缘) 的任何关系都将表示为分区内的项目。\n\n例如存储关注信息：\n\n用户A ID_A 为分区键，用户 A 的关注者ID 为排序键\n查询用户A 的所关注的所有人可按ID_A 筛选\n查询用户A 被谁关注可以加一个全局二级索引 索引分区键为表排序键，排序键为表分区键\n\n此模式的优势包括数据重复率最低和精简的查询模式 ，以便查找与目标实体 (让边缘作为目标节点) 相关的所有实体 (节点)。\n\n- 关注关系\n- 好友关系\n\n### 具体化图标模式\n\n## 实现混合数据库系统的最佳实践\n\n### 不是所有数据都迁移到DynamoDB\n\n### 如何实现混合系统\n\n可利用 DynamoDB 流和 AWS Lambda 与一个或多个现有关系数据库系统无缝集成\n\n集成 DynamoDB 流和 AWS Lambda 的系统可提供若干好处：\n\n它可作为具体化视图的持久化缓存运行。\n它可设置为在查询数据时以及在 SQL 系统中修改数据时逐渐填充所查询和所修改数据。这意味着整个视图无需预先填充，这反过来意味着高效利用预置的吞吐容量的可能性更高。\n它的管理成本低并且高度可用和可靠。\n\n- 增量填充 DynamoDB 缓存\n\n  需要某个项目时，首先在 DynamoDB 中查找它。如果它不在此处，则在 SQL 系统中查找它，然后将它加载到 DynamoDB 中\n\n- 通过 DynamoDB 缓存写入\n\n  当客户更改 DynamoDB 中的值时，将触发 Lambda 函数以将新数据写回 SQL 系统\n\n- 通过 SQL 系统更新 DynamoDB\n\n  当内部流程（如库存管理或定价）更改 SQL 系统中的值时，将触发存储过程以将更改传播至 DynamoDB 具体化视图。\n\n## 在DynamoDB为关系数据建模的最佳实践\n\n### 为关系型数据建模的初始步骤\n\n- 对于新应用程序，查看有关活动和目标的用户案例。记录确定的各种使用案例，然后分析这些案例需要的访问模式。\n- 对于现有应用程序，分析查询日志以了解人们目前使用该系统的方式以及密钥访问模式有哪些。\n- DynamoDB 架构设计的常见方法是确定应用程序层实体并使用反规范化和复合键聚合来降低查询复杂性。\n\n### 为关系数据建模的示例\n\n- https://docs.aws.amazon.com/zh_cn/amazondynamodb/latest/developerguide/bp-relational-modeling.html\n\n### 关系型数据库缺陷\n\n- 它规范化数据并将其存储在需要多个查询以写入磁盘的多个表中\n- 它通常会产生与 ACID 兼容的事务系统的性能成本\n- 它使用成本高昂的联接来重组查询结果的所需视图\n\n### DynamoDB的优点\n\n- 架构灵活性让 DynamoDB 存储单个项目内的复杂层次数据\n- 复合键设计让其将相关项目靠近存储在相同表中\n\n## 针对查询和扫描数据的最佳实践\n\n### 扫描的性能注意事项\n\n- Scan 操作的效率低于其他操作。Scan 操作始终扫描整个表或二级索引\n- 应避免对大型表或索引使用带有会删除很多结果的筛选条件的 Scan 操作\n\n### 利用并行扫面\n\n- 如果满足以下条件，就可以选择并行扫描\n  - 表的大小为 20 GB 或更大。\n  - 表的预置读取吞吐量尚未完全利用。\n  - 按顺序执行的 Scan 操作速度过慢。\n\n### 避免读取活动陡增\n\n- 设置读取和写入容量单位要求\n\n  读取容量单位通过每秒强一致性 4 KB 数据读取请求的数量表示。一个最终一致性读取容量单位是每秒 2 个 4 KB 读取请求。默认情况下，`Scan` 操作执行最终一致性读取，可返回最多 1 MB（一页）数据。因此，单个 `Scan` 请求可占用（1 MB 页面大小/4 KB 项目大小）/2（最终一致性读取）= 128 个读取操作。如果改为请求强一致性读取，则 `Scan` 操作占用的吞吐量是预置吞吐量的两倍 — 如 256 次读取操作。\n\n  问题不仅仅在于 `Scan` 使用的容量单位陡增。由于扫描请求的读取项目在分区中彼此相邻，因此扫描还可能会占用同一分区中的所有容量单位。这意味着，请求一直调用相同的分区，导致该分区的所有容量单位用尽，进而限制该分区中的其他请求。如果读取数据请求分布在多个分区之中，则此操作不会给特定分区带来限制。\n\n- 查询技巧\n\n  - 减小页面大小\n\n    由于扫描操作会读取整个页面（默认情况下为 1 MB），因此，您可以通过设置较小的页面大小来降低扫描操作的影响。您可以使用 `Scan` 操作提供的 *Limit* 参数设置请求的页面大小。设置了较小的页面大小后，每个 `Query` 或 `Scan`请求都会使用更少的读取操作，并会在每个请求之间“停顿”。例如，假设每个项目为 4 KB，并且您将页面大小设置为 40 个项目。之后，`Query` 请求仅使用 20 次最终一致性读取操作或 40 次强一致性读取操作。如果占用较小容量单位的 `Query` 或 `Scan` 操作数量较多，您就可以成功完成其他重要请求而不会受到限制。\n\n  - 隔离扫描操作\n\n    应用程序可以创建多个表以彼此区分，甚至多个表可能会复制彼此的内容。您可能会在没有“关键任务型”流量的表中执行扫描。某些应用程序会每小时在两个表之间轮换流量来处理此负载 — 一个用于关键流量，另一个用于计账。其他应用程序可通过让每次写入都在两个表（“关键任务型”表和“影子”表）中执行来实现这一目的。\n\n## 使用全局表的最佳实践\n\n*XMind: ZEN - Trial Version*\n\n## 思维导图\n\n![best practice](http://media.gusibi.mobi/5HvoP9-Hbod2k-btCPDBBj5aiegMfO6awp3w9-DqxTpNUnJhQr4ZyEX7maG-HtRv)\n\n*XMind: ZEN - Trial Version*\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "DynamoDB 最佳实践",
        "date": "2019-06-10 14:36:53",
        "tags": [
          "DynamoDB",
          "nosql"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "dynamodb-best-practice"
    },
    {
      "content": "## json 类型\n\n### 说明\n\n根据[RFC 7159](https://tools.ietf.org/html/rfc7159)中的说明，JSON 数据类型是用来存储 JSON（JavaScript Object Notation）数据的。这种数据也可以被存储为`text`，但是 JSON 数据类型的优势在于能强制要求每个被存储的值符合 JSON 规则。也有很多 JSON 相关的函数和操作符可以用于存储在这些数据类型中的数据\n\nPostgreSQL支持两种 JSON 数据类型：json 和 jsonb。它们几乎接受完全相同的值集合作为输入。两者最大的区别是效率。json数据类型存储输入文本的精准拷贝，处理函数必须在每 次执行时必须重新解析该数据。而jsonb数据被存储在一种分解好的二进制格式中，因为需要做附加的转换，它在输入时要稍慢一些。但是 jsonb在处理时要快很多，因为不需要重新解析。\n\n> 重点：jsonb支持索引\n\n\n由于json类型存储的是输入文本的准确拷贝，存储时会空格和JSON 对象内部的键的顺序。如果一个值中的 JSON 对象包含同一个键超过一次，所有的键/值对都会被保留（** 处理函数会把最后的值当作有效值**）。\n\njsonb不保留空格、不保留对象键的顺序并且不保留重复的对象键。如果在输入中指定了重复的键，只有最后一个值会被保留。 \n\n> 推荐把JSON 数据存储为jsonb \n\n\n在把文本 JSON 输入转换成jsonb时，JSON的基本类型（[RFC 7159 ](https://tools.ietf.org/html/rfc7159)）会被映射到原生的 PostgreSQL类型。因此，jsonb数据有一些次要额外约束。\n`比如：`jsonb将拒绝除 PostgreSQL numeric数据类型范围之外的数字，而json则不会。\n\n\n\n**JSON 基本类型和相应的PostgreSQL类型**\n\n\n| JSON 基本类型 | PostgreSQL类型 | 注释                                  |\n| ------------- | -------------- | ----------------------------------- |\n| `string`      | `text`         | 不允许`\\u0000`，如果数据库编码不是 UTF8，非 ASCII Unicode 转义也是这样 |\n| `number`      | `numeric`      | 不允许`NaN` 和 `infinity`值               |\n| `boolean`     | `boolean`      | 只接受小写`true`和`false`拼写                 |\n| `null`        | (无)           | SQL `NULL`是一个不同的概念             |\n\n\n###  json 输入输出语法\n\n\n```sql\n-- 简单标量/基本值\n-- 基本值可以是数字、带引号的字符串、true、false或者null\nSELECT '5'::json;\n\n-- 有零个或者更多元素的数组（元素不需要为同一类型）\nSELECT '[1, 2, \"foo\", null]'::json;\n\n-- 包含键值对的对象\n-- 注意对象键必须总是带引号的字符串\nSELECT '{\"bar\": \"baz\", \"balance\": 7.77, \"active\": false}'::json;\n\n-- 数组和对象可以被任意嵌套\nSELECT '{\"foo\": [true, \"bar\"], \"tags\": {\"a\": 1, \"b\": null}}'::json;\n\n-- \"->\" 通过键获得 JSON 对象域 结果为json对象\nselect '{\"nickname\": \"goodspeed\", \"avatar\": \"avatar_url\", \"tags\": [\"python\", \"golang\", \"db\"]}'::json->'nickname' as nickname;\n nickname\n-------------\n \"goodspeed\"\n\n-- \"->>\" 通过键获得 JSON 对象域 结果为text \nselect '{\"nickname\": \"goodspeed\", \"avatar\": \"avatar_url\", \"tags\": [\"python\", \"golang\", \"db\"]}'::json->>'nickname' as nickname;\n nickname\n-----------\n goodspeed\n \n-- \"->\" 通过键获得 JSON 对象域 结果为json对象\nselect '{\"nickname\": \"goodspeed\", \"avatar\": \"avatar_url\", \"tags\": [\"python\", \"golang\", \"db\"]}'::jsonb->'nickname' as nickname;\n nickname\n-------------\n \"goodspeed\"\n\n-- \"->>\" 通过键获得 JSON 对象域 结果为text \nselect '{\"nickname\": \"goodspeed\", \"avatar\": \"avatar_url\", \"tags\": [\"python\", \"golang\", \"db\"]}'::jsonb->>'nickname' as nickname;\n nickname\n-----------\n goodspeed\n```\n\n当一个 JSON 值被输入并且接着不做任何附加处理就输出时， json会输出和输入完全相同的文本，而jsonb 则不会保留语义上没有意义的细节\n\n```sql\nSELECT '{\"bar\": \"baz\", \"balance\": 7.77, \"active\":false}'::json;\n                      json                       \n-------------------------------------------------\n {\"bar\": \"baz\", \"balance\": 7.77, \"active\":false}\n\n-- jsonb 不会保留语义上的细节，key 的顺序也和原始数据不一致\nSELECT '{\"bar\": \"baz\", \"balance\": 7.77, \"active\":false}'::jsonb;\n                      jsonb                       \n--------------------------------------------------\n {\"bar\": \"baz\", \"active\": false, \"balance\": 7.77}\n```\n\n\n### json 查询语法\n\n\n> 在使用JSON文档时，推荐 将JSON 文档存储为固定的结构。（该结构是非强制的，但是有一个可预测的结构会使集合的查询更容易。 ）\n> `设计JSON文档建议：`任何更新都在整行上要求一个行级锁。为了减少锁争夺，JSON 文档应该每个表示 一个原子数据（业务规则上的不可拆分，可独立修改的数据）。 \n\n> **这些常用的比较操作符只对jsonb 有效，而不适用于json**\n\n**常用的比较操作符**\n\n| 操作符       | 描述     |\n| ------------ | -------- |\n| `<`          | 小于     |\n| `>`          | 大于     |\n| `<=`         | 小于等于 |\n| `>=`         | 大于等于 |\n| `=`          | 等于     |\n| `<>` or `!=` | 不等于   |\n\n\n\n#### 包含和存在\n\n##### json 数据查询（适用于jsonb）\n\n**json和jsonb 操作符**\n\n![](http://media.gusibi.mobi/PKR8RaA4jTwGLXslUgbb0BF9dM4fnKENY91UUx_BVSLZJ4wzg0s3eHuHbT6r2wgM)\n\n###### `-> 和 ->>` 操作符\n\n> 使用 ->> 查出的数据为text\n> 使用 -> 查出的数据为json 对象\n\n```sql\n-- nickname 为 gs 的用户 这里使用 ->> 查出的数据为text，所以匹配项也应该是text\nselect '{\"nickname\": \"gs\", \"avatar\": \"avatar_url\", \"tags\": [\"python\", \"golang\", \"db\"]}'::json->>'nickname' = 'gs';\nselect '{\"nickname\": \"gs\", \"avatar\": \"avatar_url\", \"tags\": [\"python\", \"golang\", \"db\"]}'::jsonb->>'nickname' = 'gs';\n\n-- 使用 -> 查询，会抛出错误，这里无论匹配项是text类型的 'gs'  还是 json 类型的 '\"gs\"'::json都会抛出异常，json 类型不支持 等号（=）操作符\nselect '{\"nickname\": \"gs\", \"avatar\": \"avatar_url\", \"tags\": [\"python\", \"golang\", \"db\"]}'::json->'nickname' = '\"gs\"';\nERROR:  operator does not exist: json = unknown\n-- json 类型不支持 \"=\" 操作符\nselect '{\"nickname\": \"gs\", \"avatar\": \"avatar_url\", \"tags\": [\"python\", \"golang\", \"db\"]}'::json->'nickname' = '\"gs\"'::json;\nERROR:  operator does not exist: json = json\n\n-- jsonb 格式是可以查询成功的，这里使用 -> 查出的数据为json 对象，所以匹配项也应该是json 对象\nselect '{\"nickname\": \"gs\", \"avatar\": \"avatar_url\", \"tags\": [\"python\", \"golang\", \"db\"]}'::jsonb->'nickname' = '\"gs\"';\n```\n\n###### `#> 和 #>>` 操作符\n\n> 使用 #>> 查出的数据为text\n> 使用 #> 查出的数据为json 对象\n\n```sql\nselect '{\"nickname\": \"gs\", \"avatar\": \"avatar_url\", \"tags\": [\"python\", \"golang\", \"db\"]}'::json#>'{tags,0}' as tag;\n   tag\n----------\n \"python\"\n\nselect '{\"nickname\": \"gs\", \"avatar\": \"avatar_url\", \"tags\": [\"python\", \"golang\", \"db\"]}'::json#>>'{tags,0}' as tag;\n  tag\n--------\n python\n \nselect '{\"nickname\": \"gs\", \"avatar\": \"avatar_url\", \"tags\": [\"python\", \"golang\", \"db\"]}'::jsonb#>'{tags,0}' = '\"python\"';\n ?column?\n----------\n t\nselect '{\"nickname\": \"gs\", \"avatar\": \"avatar_url\", \"tags\": [\"python\", \"golang\", \"db\"]}'::jsonb#>>'{tags,0}' = 'python';\n ?column?\n----------\n t\n\nselect '{\"nickname\": \"gs\", \"avatar\": \"avatar_url\", \"tags\": [\"python\", \"golang\", \"db\"]}'::json#>>'{tags,0}' = 'python';\n ?column?\n----------\n t\n-- 会抛出错误，这里无论匹配项是text类型的 'python'  还是 json 类型的 '\"python\"'::json都会抛出异常，json 类型不支持 等号（=）操作符\nselect '{\"nickname\": \"gs\", \"avatar\": \"avatar_url\", \"tags\": [\"python\", \"golang\", \"db\"]}'::json#>'{tags,0}' = '\"python\"';\nERROR:  operator does not exist: json = unknown\n```\n\n##### jsonb 数据查询（不适用于json）\n\n** 额外的jsonb操作符**\n\n![](http://media.gusibi.mobi/-xkIrM_CZ63Hsh7QQdcQsDe35gDFNOrmSKpmZ9_UoYPawclXzGGg0cD-Ar6wQvR1)\n\n\n###### `@>`操作符\n\n```sql\n-- nickname 为 nickname 的用户\nselect '{\"nickname\": \"gs\", \"avatar\": \"avatar_url\", \"tags\": [\"python\", \"golang\", \"db\"]}'::jsonb @> '{\"nickname\": \"gs\"}'::jsonb;\n\n-- 等同于以下查询\n-- 这里使用 -> 查出的数据为json 对象，所以匹配项也应该是json 对象\nselect '{\"nickname\": \"gs\", \"avatar\": \"avatar_url\", \"tags\": [\"python\", \"golang\", \"db\"]}'::jsonb->'nickname' = '\"gs\"';\nselect '{\"nickname\": \"gs\", \"avatar\": \"avatar_url\", \"tags\": [\"python\", \"golang\", \"db\"]}'::jsonb->>'nickname' = 'gs';\n\n-- 查询有 python 和 golang 标签的数据\nselect '{\"nickname\": \"gs\", \"avatar\": \"avatar_url\", \"tags\": [\"python\", \"golang\", \"db\"]}'::jsonb @> '{\"tags\": [\"python\", \"golang\"]}';\n ?column?\n----------\n t\n```\n\n###### `?`操作符、`?|`操作符和`?&`操作符\n\n```sql\n-- 查询有 avatar 属性的用户\nselect '{\"nickname\": \"gs\", \"avatar\": \"avatar_url\", \"tags\": [\"python\", \"golang\", \"db\"]}'::jsonb ? 'avatar';\n-- 查询有 avatar 属性 并且avatar 数据不为空的数据\nselect '{\"nickname\": \"gs\", \"avatar\": null, \"tags\": [\"python\", \"golang\", \"db\"]}'::jsonb->>'avatar' is not null;\n\n-- 查询 有 avatar 或 tags 的数据\nselect '{\"nickname\": \"gs\", \"tags\": [\"python\", \"golang\", \"db\"]}'::jsonb ?| array['avatar', 'tags'];\n ?column?\n----------\n t\n\n-- 查询 既有 avatar 又有 tags 的用户\nselect '{\"nickname\": \"gs\", \"tags\": [\"python\", \"golang\", \"db\"]}'::jsonb ?& array['avatar', 'tags'];\n ?column?\n----------\n f\n \n -- 查询 tags 中包含 python 标签的数据\n select '{\"nickname\": \"gs\", \"avatar\": \"avatar_url\", \"tags\": [\"python\", \"golang\", \"db\"]}'::jsonb->'tags' ? 'python';\n ?column?\n----------\n t\n```\n\n\n### json 更新\n\n```sql\n-- 更新 account content 字段（覆盖式更新）\nupdate account set content = jsonb_set(content, '{}', '{\"nickname\": \"gs\", \"tags\": [\"python\", \"golang\", \"db\"]}', false);\n\n-- 修改nickanme为nickanme 的用户标签\nupdate account set content = jsonb_set(content, '{tags}', '[\"test\", \"心理\"]', true) where content @> '{\"nickname\": \"nickname\"}'::jsonb;\n\nupdate account set content = jsonb_set(content, '{tags}', '[\"test\", \"心理\", \"医疗\"]', true) where content @> '{\"nickname\": \"nickname\"}'::jsonb;\n\n-- 更新account content字段中 weixin_mp 的值（如果没有会创建）\n\nupdate account set content = jsonb_set(content, '{weixin_mp}', '\"weixin_mp5522bd28-ed4d-11e8-949c-7200014964f0\"', true) where id='5522bd28-ed4d-11e8-949c-7200014964f0';\n\n-- 更新account 去除content 中weixin 字段（如果没有weixin 字段也不会抛出异常）\nupdate account set content= content - 'weixin' where id='5522bd28-ed4d-11e8-949c-7200014964f0';\n```\n\n### json 函数\n\n#### jsonb_pretty\n\n> 作为缩进JSON文本返回from_json。 \n\n```sql\nselect jsonb_pretty('[{\"f1\":1,\"f2\":null},2,null,3]');\n    jsonb_pretty\n--------------------\n [                 +\n     {             +\n         \"f1\": 1,  +\n         \"f2\": null+\n     },            +\n     2,            +\n     null,         +\n     3             +\n ]\n(1 row)\n```\n\n\n\n\n####  jsonb_set \n\njsonb_set() 函数参数如下：\n```c\njsonb_set(target         jsonb,  // 需要修改的数据\n          path           text[], // 数据路径\n          new_value      jsonb,  // 新数据\n          create_missing boolean default true)\n```\n> 如果create_missing 是true （缺省是true），并且path指定的路径在target 中不存在，那么target将包含path指定部分， new_value替换部分， 或者new_value添加部分。 \n\n```sql\n-- target 结构\nselect jsonb_pretty('[{\"f1\":1,\"f2\":null},2]');\n    jsonb_pretty\n--------------------\n [                 +\n     {             +\n         \"f1\": 1,  +\n         \"f2\": null+\n     },            +\n     2             +\n ]\n\n-- 更新 target 第0 个元素 key 为 f1 的值，如果f1 不存在 忽略\nselect jsonb_set('[{\"f1\":1,\"f2\":null},2,null,3]', '{0,f1}','[2,3,4]', false);\n                  jsonb_set\n---------------------------------------------\n [{\"f1\": [2, 3, 4], \"f2\": null}, 2, null, 3]\n\n-- 更新 target 第0 个元素 key 为 f3 的值，如果f3 不存在 创建 \nselect jsonb_set('[{\"f1\":1,\"f2\":null},2]', '{0,f3}','[2,3,4]');\n                  jsonb_set\n---------------------------------------------\n [{\"f1\": 1, \"f2\": null, \"f3\": [2, 3, 4]}, 2]\n \n -- 更新 target 第0 个元素 key 为 f3 的值，如果f3 不存在 忽略\nselect jsonb_set('[{\"f1\":1,\"f2\":null},2]', '{0,f3}','[2,3,4]', false);\n                  jsonb_set\n---------------------------------------------\n [{\"f1\": 1, \"f2\": null}, 2]\n```\n\n详细的json 函数和操作符可以参考文档：[JSON 函数和操作符](http://www.postgres.cn/docs/9.5/functions-json.html)\n\n\n## jsonb 性能分析\n\n我们使用下面的例子来说明一下json 的查询性能\n\n### 表结构\n\n```sql\n-- account 表 id 使用uuid 类型，需要先添加uuid-ossp模块。\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\";\n\n-- create table\ncreate table account (id UUID NOT NULL PRIMARY KEY default uuid_generate_v1(), content jsonb, created_at timestamptz DEFAULT CURRENT_TIMESTAMP, updated_at timestamptz DEFAULT CURRENT_TIMESTAMP);\njson=> \\d account\n                               Table \"public.account\"\n    Column    |           Type           | Collation | Nullable |      Default\n--------------+--------------------------+-----------+----------+--------------------\n id           | uuid                     |           | not null |uuid_generate_v1()\n content      | jsonb                    |           |          |\n created_at   | timestamp with time zone |           |          | CURRENT_TIMESTAMP\n updated_at   | timestamp with time zone |           |          | CURRENT_TIMESTAMP\nIndexes:\n    \"account_pkey\" PRIMARY KEY, btree (id)\n```\n\n\n> 一个好的实践是把 created_at和 updated_at 也放入jsonb 字段，这里只是示例\n\ncontent 数据结构为：\n\n```json\ncontent = {\n    \"nickname\": {\"type\": \"string\"},\n    \"avatar\": {\"type\": \"string\"},\n    \"weixin\": {\"type\": \"string\"},\n    \"tags\": {\"type\": \"array\", \"items\": {\"type\": \"string\"}},\n}\n```\n\n### 准备数据\n\n**批量插入数据**\n\n```sql\n-- 插入100w条有 nickname avatar tags 为[\"python\", \"golang\", \"c\"]的数据\ninsert into account select uuid_generate_v1(), ('{\"nickname\": \"nn-' || round(random()*20000000) || '\", \"avatar\": \"avatar_url\", \"tags\": [\"python\", \"golang\", \"c\"]}')::jsonb from (select * from generate_series(1,100000)) as tmp;\n\n-- 插入100w条有 nickname tags 为[\"python\", \"golang\"]的数据\ninsert into account select uuid_generate_v1(), ('{\"nickname\": \"nn-' || round(random()*2000000) || '\", \"tags\": [\"python\", \"golang\"]}')::jsonb from (select * from generate_series(1,1000000)) as tmp;\n\n-- 插入100w条有 nickname tags 为[\"python\"]的数据\ninsert into account select uuid_generate_v1(), ('{\"nickname\": \"nn-' || round(random()*2000000) || '\", \"tags\": [\"python\"]}')::jsonb from (select * from generate_series(1,1000000)) as tmp;\n```\n\n### 测试查询\n\n* EXPLAIN：显示PostgreSQL计划程序为提供的语句生成的执行计划。\n* ANALYZE：收集有关数据库中表的内容的统计信息。\n\n```sql\n\n--content 中有avatar key 的数据条数 count(*) 查询不是一个好的测试语句，就算是有索引，也只能起到过滤的作用，如果结果集比较大，查询速度还是会很慢\nexplain analyze select count(*) from account where content::jsonb ? 'avatar';\n                   QUERY PLAN\n----------------------------------------------------------------------------------------\n Finalize Aggregate  (cost=29280.40..29280.41 rows=1 width=8) (actual time=170.366..170.366 rows=1 loops=1)\n   ->  Gather  (cost=29280.19..29280.40 rows=2 width=8) (actual time=170.119..174.451 rows=3 loops=1)\n         Workers Planned: 2\n         Workers Launched: 2\n         ->  Partial Aggregate  (cost=28280.19..28280.20 rows=1 width=8) (actual time=166.034..166.034 rows=1 loops=3)\n               ->  Parallel Seq Scan on account  (cost=0.00..28278.83 rows=542 width=0) (actual time=0.022..161.937 rows=33333 loops=3)\n                     Filter: (content ? 'avatar'::text)\n                     Rows Removed by Filter: 400000\n Planning Time: 0.048 ms\n Execution Time: 174.486 ms\n\n\n-- content 中没有avatar key 的数据条数\nexplain analyze select count(*) from account where content::jsonb ? 'avatar' = false;\n                QUERY PLAN\n----------------------------------------------------------------------------------------\n Finalize Aggregate  (cost=30631.86..30631.87 rows=1 width=8) (actual time=207.770..207.770 rows=1 loops=1)\n   ->  Gather  (cost=30631.65..30631.86 rows=2 width=8) (actual time=207.681..212.357 rows=3 loops=1)\n         Workers Planned: 2\n         Workers Launched: 2\n         ->  Partial Aggregate  (cost=29631.65..29631.66 rows=1 width=8) (actual time=203.565..203.565 rows=1 loops=3)\n               ->  Parallel Seq Scan on account  (cost=0.00..28278.83 rows=541125 width=0) (actual time=0.050..163.629 rows=400000 loops=3)\n                     Filter: (NOT (content ? 'avatar'::text))\n                     Rows Removed by Filter: 33333\n Planning Time: 0.050 ms\n Execution Time: 212.393 ms\n```\n\n\n```sql\n--查询content 中nickname 为nn-194318的数据\nexplain analyze select * from account where content@>'{\"nickname\": \"nn-194318\"}';\n                                                         QUERY PLAN\n----------------------------------------------------------------------------------------\n Gather  (cost=1000.00..29408.83 rows=1300 width=100) (actual time=0.159..206.990 rows=1 loops=1)\n   Workers Planned: 2\n   Workers Launched: 2\n   ->  Parallel Seq Scan on account  (cost=0.00..28278.83 rows=542 width=100) (actual time=130.867..198.081 rows=0 loops=3)\n         Filter: (content @> '{\"nickname\": \"nn-194318\"}'::jsonb)\n         Rows Removed by Filter: 433333\n Planning Time: 0.047 ms\n Execution Time: 207.007 ms\n \n-- 对应的查询id 为 'b5b3ed06-7d35-11e9-b3ea-00909e9dab1d' 的数据\nexplain analyze select * from account where id='b5b3ed06-7d35-11e9-b3ea-00909e9dab1d';\n                                                       QUERY PLAN\n----------------------------------------------------------------------------------------\n Index Scan using account_pkey on account  (cost=0.43..8.45 rows=1 width=100) (actual time=0.912..0.914 rows=1 loops=1)\n   Index Cond: (id = 'b5b3ed06-7d35-11e9-b3ea-00909e9dab1d'::uuid)\n Planning Time: 0.348 ms\n Execution Time: 0.931 ms\n```\n\n通过结果可以看到 使用 jsonb 查询和使用主键查询速度差异巨大，通过看查询分析记录可以看到，这两个语句最大的差别在于使用主键的查询用到了索引，而content nickname 的查询没有索引可以使用。\n接下来测试一下使用索引时的查询速度。\n\n\n### 索引\n\n#### GIN 索引介绍\n\nJSONB 最常用的是`GIN` 索引，GIN 索引可以被用来有效地搜索在大量jsonb文档（数据）中出现 的键或者键值对。\n\n> GIN(Generalized Inverted Index, 通用倒排索引) 是一个存储对(key, posting list)集合的索引结构，其中key是一个键值，而posting list 是一组出现过key的位置。如(‘hello', '14:2 23:4')中，表示hello在14:2和23:4这两个位置出现过，在PG中这些位置实际上就是元组的tid(行号，包括数据块ID（32bit）,以及item point(16 bit) )。\n> \n> 在表中的每一个属性，在建立索引时，都可能会被解析为多个键值，所以同一个元组的tid可能会出现在多个key的posting list中。\n> \n> 通过这种索引结构可以快速的查找到包含指定关键字的元组，因此GIN索引特别适用于多值类型的元素搜索，比如支持全文搜索，数组中元素的搜索，而PG的GIN索引模块最初也是为了支持全文搜索而开发的。\n\n![gin 索引数据结构](http://media.gusibi.mobi/olurF8ptRiSWx6WsIThgzKL-QkLlIJB_qF0QTYy5fvhce4-e-ATPQ4O8byaE75IE)\n\n`jsonb`的默认 GIN 操作符类支持使用顶层键存在运算符`?`、`?&`以及`?|` 操作符和路径/值存在运算符`@>`的查询。\n\n```sql\n-- 创建默认索引\nCREATE INDEX idxgin ON api USING GIN (jdoc);\n```\n\n非默认的 GIN 操作符类`jsonb_path_ops`只支持索引`@>`操作符。\n\n```sql\n-- 创建指定路径的索引\nCREATE INDEX idxginp ON api USING GIN (jdoc jsonb_path_ops);\n-- create index  ix_account_content_nickname_gin on account using gin (content, (content->'nickname'));\n-- create index  ix_account_content_tags_gin on account using gin (content, (content->'nickname'));\n-- create index  ix_account_content_tags_gin on account using gin ((content->'tags'));\n```\n\n#### 多索引支持\n\n> PostgreSQL 拥有开放的索引接口，使得PG支持非常丰富的索引方法，例如btree , hash , gin , gist , sp-gist , brin , bloom , rum , zombodb , bitmap (greenplum extend)，用户可以根据不同的数据类型，以及查询的场景，选择不同的索引。\n\n\n#### 查询优化\n\n**创建默认索引**\n\n```sql\n-- 创建简单索引\ncreate index ix_account_content on account USING GIN (content);\n```\n\n现在下面这样的查询就能使用该索引：\n\n```sql\n-- content 中有avatar key 的数据条数\nexplain analyze select count(*) from account where content::jsonb ? 'avatar';\n                                                                QUERY PLAN\n------------------------------------------------------------------------------------------------------------------------------------------\n Aggregate  (cost=4180.49..4180.50 rows=1 width=8) (actual time=43.462..43.462 rows=1 loops=1)\n   ->  Bitmap Heap Scan on account  (cost=30.07..4177.24 rows=1300 width=0) (actual time=8.362..36.048 rows=100000 loops=1)\n         Recheck Cond: (content ? 'avatar'::text)\n         Heap Blocks: exact=2032\n         ->  Bitmap Index Scan on ix_account_content  (cost=0.00..29.75 rows=1300 width=0) (actual time=8.125..8.125 rows=100000 loops=1)\n               Index Cond: (content ? 'avatar'::text)\n Planning Time: 0.078 ms\n Execution Time: 43.503 ms\n```\n\n和之前没有添加索引时速度提升了3倍。\n\n```sql\n-- 查询content 中nickname 为nn-194318的数据\nexplain analyze select * from account where content@>'{\"nickname\": \"nn-194318\"}';\n                                                          QUERY PLAN\n----------------------------------------------------------------------------------------\n Bitmap Heap Scan on account  (cost=46.08..4193.24 rows=1300 width=100) (actual time=0.097..0.097 rows=1 loops=1)\n   Recheck Cond: (content @> '{\"nickname\": \"nn-194318\"}'::jsonb)\n   Heap Blocks: exact=1\n   ->  Bitmap Index Scan on ix_account_content  (cost=0.00..45.75 rows=1300 width=0) (actual time=0.091..0.091 rows=1 loops=1)\n         Index Cond: (content @> '{\"nickname\": \"nn-194318\"}'::jsonb)\n Planning Time: 0.075 ms\n Execution Time: 0.132 ms\n```\n这个查询效率提升更明显，竟然比使用主键还要高效。\n\n**但是下面这种查询并不能使用索引**：\n\n```sql\n-- 查询content 中不存在 avatar key 的数据条数\nexplain analyze select count(*) from account where content::jsonb ? 'avatar' = false;\n                                                                 QUERY PLAN\n----------------------------------------------------------------------------------------\n Finalize Aggregate  (cost=30631.86..30631.87 rows=1 width=8) (actual time=207.641..207.641 rows=1 loops=1)\n   ->  Gather  (cost=30631.65..30631.86 rows=2 width=8) (actual time=207.510..211.062 rows=3 loops=1)\n         Workers Planned: 2\n         Workers Launched: 2\n         ->  Partial Aggregate  (cost=29631.65..29631.66 rows=1 width=8) (actual time=203.739..203.739 rows=1 loops=3)\n               ->  Parallel Seq Scan on account  (cost=0.00..28278.83 rows=541125 width=0) (actual time=0.024..163.444 rows=400000 loops=3)\n                     Filter: (NOT (content ? 'avatar'::text))\n                     Rows Removed by Filter: 33333\n Planning Time: 0.068 ms\n Execution Time: 211.097 ms\n```\n\n该索引也不能被用于下面这样的查询，因为尽管操作符`?` 是可索引的，但它不能直接被应用于被索引列content： \n\n```sql\nexplain analyze select count(1) from account where content -> 'tags' ? 'c';\n                                                               QUERY PLAN\n----------------------------------------------------------------------------------------\n Finalize Aggregate  (cost=30634.57..30634.58 rows=1 width=8) (actual time=184.864..184.864 rows=1 loops=1)\n   ->  Gather  (cost=30634.35..30634.56 rows=2 width=8) (actual time=184.754..189.652 rows=3 loops=1)\n         Workers Planned: 2\n         Workers Launched: 2\n         ->  Partial Aggregate  (cost=29634.35..29634.36 rows=1 width=8) (actual time=180.755..180.755 rows=1 loops=3)\n               ->  Parallel Seq Scan on account  (cost=0.00..29633.00 rows=542 width=0) (actual time=0.022..177.051 rows=33333 loops=3)\n                     Filter: ((content -> 'tags'::text) ? 'c'::text)\n                     Rows Removed by Filter: 400000\n Planning Time: 0.074 ms\n Execution Time: 189.716 ms\n```\n\n**使用表达式索引**\n\n```sql\n-- 创建路径索引\ncreate index ix_account_content_tags on account USING GIN ((content->'tags'));\n```\n\n```sql\n-- 测试查询性能\nexplain analyze select count(1) from account where content -> 'tags' ? 'c';\n                                                                   QUERY PLAN\n----------------------------------------------------------------------------------------\n Aggregate  (cost=4631.74..4631.75 rows=1 width=8) (actual time=49.274..49.275 rows=1 loops=1)\n   ->  Bitmap Heap Scan on account  (cost=478.07..4628.49 rows=1300 width=0) (actual time=8.655..42.074 rows=100000 loops=1)\n         Recheck Cond: ((content -> 'tags'::text) ? 'c'::text)\n         Heap Blocks: exact=2032\n         ->  Bitmap Index Scan on ix_account_content_tags  (cost=0.00..477.75 rows=1300 width=0) (actual time=8.417..8.417 rows=100000 loops=1)\n               Index Cond: ((content -> 'tags'::text) ? 'c'::text)\n Planning Time: 0.216 ms\n Execution Time: 49.309 ms\n```\n\n现在，WHERE 子句`content -> 'tags' ? 'c'` 将被识别为可索引操作符?在索引表达式`content -> 'tags'` 上的应用。\n\n也可以利用包含查询的方式，例如：\n\n```sql\n-- 查寻 \"tags\" 包含数组元素 \"c\" 的数据的个数\nselect count(1) from account where content @> '{\"tags\": [\"c\"]}';\n```\n\ncontent 列上的简单 GIN 索引（默认索引）就能支持索引查询。 但是索引将会**存储content列中每一个键 和值的拷贝**，\n**表达式索引**只存储tags 键下找到的数据。\n\n> 虽然简单索引的方法更加灵活（因为它支持有关任意键的查询），但定向的表达式索引更小并且搜索速度比简单索引更快。\n> 尽管jsonb_path_ops操作符类只支持用 @>操作符的查询，但它比起默认的操作符类 jsonb_ops有更客观的性能优势。一个 jsonb_path_ops索引通常也比一个相同数据上的 jsonb_ops要小得多，并且搜索的专一性更好，特 别是当查询包含频繁出现在该数据中的键时。因此，其上的搜索操作 通常比使用默认操作符类的搜索表现更好。 \n\n## 总结\n\n* PG 有两种 JSON 数据类型：`json` 和 `jsonb`，jsonb 性能优于json，且jsonb 支持索引。\n* jsonb 写入时会处理写入数据，写入相对较慢，json会保留原始数据（包括无用的空格）\n* jsonb 查询优化时一个好的方式是添加GIN 索引\n    - 简单索引和路径索引相比更灵活，但是占用空间多\n    - 路径索引比简单索引更高效，占用空间更小\n\n\n## 参考链接\n\n* [RFC 7159 The JavaScript Object Notation (JSON) Data Interchange Format](https://tools.ietf.org/html/rfc7159)\n* [PostgreSQL 文档： JSON 类型](http://www.postgres.cn/docs/10/datatype-json.html)\n* [JSON 函数和操作符](http://www.postgres.cn/docs/9.5/functions-json.html)\n* [How do I modify fields inside the new PostgreSQL JSON datatype?](https://stackoverflow.com/questions/18209625/how-do-i-modify-fields-inside-the-new-postgresql-json-datatype)\n* [PostgreSQL 9种索引的原理和应用场景](https://yq.aliyun.com/articles/111793)\n* [PostgreSQL GIN索引实现原理](https://github.com/digoal/blog/blob/master/201702/20170204_01.md)\n* [PostgreSQL internals: JSONB type and its indexes](https://bitnine.net/blog-postgresql/postgresql-internals-jsonb-type-and-its-indexes/)\n* [倒排索引](https://zh.wikipedia.org/wiki/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95)\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "PostgreSQL jsonb 使用入门",
        "date": "2019-05-30 13:05:57",
        "tags": [
          "tutorial",
          "database"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "postgresql-json"
    },
    {
      "content": "\n> 《代码大全》读书笔记\n\n> 太长不看版\n![](http://media.gusibi.mobi/2nqKmJp5tMClypa0WqnJXl8sI9Tv4hwo3Zs6oEp4U4nwV9dV1XWqmFjvQNxRrggg)\n\n## 软件构建中的设计\n\n> 软件设计是一项明确的活动\n\n### 设计中的挑战\n\n> `软件设计`一词意味着去构思、创造或发明一套方案，把一份计算机软件的规格说明书要求转变为可实际运行的软件。\n> 设计就是把需求分析和编码调试连接在一起的活动。\n> 好的高层词设计能够提供一个可以稳妥容纳多个较低层次设计的结构。\n\n#### 设计是一个险恶的问题\n\n> 险恶（wicked）的问题就是那种只有通过解决或部分解决才能被明确的问题。\n\nTacoma Narrows 大桥是一个险恶问题的好例子，因为直到这座桥坍塌，工程师才知道不应该只考虑桥的负荷，还需要充分的考虑空气动力学因素（只有建造大桥，才能从中学到需要考虑额外的环节）。\n\n#### 设计是一个了无章法的过程（即使它能得处清爽的成果）\n\n* 是因为在设计的过程中可能会采用很多错误的步骤，多次出错\n* 因为设计的优劣差异往往非常微妙\n* 因为不能判断设计是否足够好\n\n\n#### 设计就是确定取舍和调整顺序的过程\n\n现实世界中，设计者工作的一个关键内容就是衡量彼此冲突的各项设计特性，并尽力在其中寻求平衡。响应速度优先和开发时间短优先得出的设计结果可能是不同的。\n\n#### 设计受到诸多限制\n\n设计的要点一部分是在创造可能发生的事情，另一部分是在限制可能发生的事情。\n\n> 如果一个人有无限空间和资源来建造房子，可能会建造出无法控制的建筑。正是因为有了限制，才得出了简单的结果。软件设计也是一样。\n\n#### 设计是不确定的\n\n每个人设计的结果可能是不同的，并且可能用起来都不错。设计没有标准答案。\n\n#### 设计是一个启发式的过程\n\n\n设计过程中充满了不确定性，因此设计技术也趋于具有探索性--“经验法则”或者“试试没准能行”--而不是保证能产生预期结果的可重复的过程。\n\n#### 设计是自然而然形成的\n\n设计不是在谁的头脑中直接跳出来的，它是在不断的设计评估、非正式讨论、写试经验以及修改试验代码中演化和完善的。\n\n### 关键的设计概念\n\n#### 软件的首要技术使命：管理复杂度\n\n##### 本质的难题和偶然的难题\n\n偶然的难题可以理解为bug，编程语言笨拙的语法，等易于发现容易解决的问题。\n本质的难题则比较复杂，本质上说，软件开发就是不断去发掘错综复杂，相互关连的整套概念的所有细节。本质困难就是：\n\n1. 要面对复杂、无序的现实世界；\n2. 精确而完成的识别出各种依赖关系和外部情况\n3. 设计出完全正确而不是大致正确的解决方案\n。。。\n\n##### 管理复杂度的重要性\n\n一个失败的项目如果是由于技术原因而失败，通常都是因为软件复杂度失控了。如果复杂度失控，那么软件就会变得极端复杂，没有人知道它能做什么，它出了问题如何解决。\n\n**管理复杂度是软件开发中最为重要的技术话题。**\n\n在软件架构层次上，可以通过把大的系统分解为多个子系统来降低问题的复杂度，多个简单的问题比一个复杂的大问题更容易理解。\n\n子系统相互间应该减少依赖；\n子系统的关注点应该是相互分离的。\n\n##### 如何应对复杂度\n\n**高代价、低效率的设计源于下面三种根源：**\n\n1. 用复杂的方法解决简单的问题\n2. 用简单但错误的方法解决复杂的问题\n3. 用不恰当的复杂的方法解决复杂的问题\n\n**用下面的方法管理复杂度**\n\n* 把任何人在同一时间需要处理的本质复杂度降到最低\n* 不要让偶然性的复杂度无谓的增长\n\n#### 理想的设计特征\n\n* 最小的复杂度\n* 易于维护\n* 松散耦合\n* 可扩展性\n* 可重用性\n* 高扇入：让大量的类使用某个给定的类。（意味着设计出的系统很好的利用了在较低层次上的工具类\n* 低扇出：让一个类少量或始终的使用其他类。（高扇出（7个）意味着一个类过多的使用了其他类，可能会变得过于复杂\n* 可移植性\n* 精简性：没有多余的部分\n* 层次性：比如一个新系统会用到很多设计不佳的旧系统，这时就应该为新系统编写一个负责同就代码交互的层（代理模式）\n    * 层次性能把低劣的代码紧闭起来\n    * 如果能最终抛弃或重构旧代码，旧不必修改处交互层之外的任何新代码。\n\n* 标准技术：用到的外来的、古怪的东西越多，也越难理解。\n\n#### 设计的层次\n\n\n![设计的层次](http://media.gusibi.mobi/f_5cYtiP6KGYRSvnhNwgU0Oij5su1slnjVMk40DsRdmSvUJBJRdIhccBmgyWa5yW)\n\n\n##### 1. 软件系统（Software System）\n\n##### 2. 分解为子系统或包（Division into Subsystems or Packages）\n\n这一层的主要目的是确定如何把程序分为主要的子系统，并定义清楚允许各子系统如何使用其他子系统。\n\n> 对于任何需要几周时间才能完成的项目，在这一层上进行划分都是必须的。\n\n这里有个特别重要的点，即不同子系统之间相互通信的原则。如果不同子系统间都可以相互通信，就失去了拆分子系统的意义。\n\n* 如果拿不准改如何设计，就应该先对子系统之间的通信加以限制，等以后需要时再放开。\n* 有一个很好的基本原则是，程序之间不应该有环形关系，比如A类调用B类，B类调用C类，C类又调用A类这种情况，系统设计也应遵守这个原则\n\n###### 一些常用的子系统\n\n* 业务规则：这个是指哪些再计算机系统中编入的规则、策略以及过程。比如开发一个薪资系统，可能就需要把税务局关于允许提扣的金额以及估算的税率编写到系统中。\n* 用户界面：这应该是一个子系统，把用户界面组件同其它组件隔离开。\n* 数据库访问：需要把数据库的访问细节隐藏起来，让程序的绝大部份不需要关心底层实现细节。\n* 对系统的依赖性：把对操作系统的依赖因素归类到一个子系统，就如同把对硬件的依赖因素封装起来一样。\n    * 这里的操作系统也可以是外部系统，比如微信小程序开发中对微信的依赖。\n\n##### 3. 分解为类（Division into Classes）\n\n这一层次上的设计包括识别出系统中所有的类。例如：数据库接口子系统可能会分为数据库访问类、持久化框架类以及数据库元数据类。\n\n**类与对象的比较**\n\n1. 对象是指运行期间在程序中实际存在的具体实体\n2. 类是指在程序源码中存在的静态事物\n\n##### 4. 分解为子程序（Division into Routines）\n\n完整的定义出类内部的子程序，常常会有助于更好的理解类的接口，反过来也有助于对类的接口进行进一步的修改。\n\n> 这一层的分解和设计通常由程序员个人来完成，对于用时超过几个小时的项目就有做的必要了。\n\n##### 5. 子程序内部的设计（Internal Routine Design）\n\n### 设计构造块：启发式方法\n\n> 由于软件设计是非确定性的，因此灵活熟练的运用一组有效的启发式方法，就成了一件特别重要的工作\n\n#### 找出现实世界中的对象\n\n在确定设计方案时，首选且最流行的一种做法便是“常规的”面向对象设计方法，此方法的要点是要鞭尸现实世界中的对象以及人造的对象。具体步骤为：\n\n1. 便是对象及其属性\n2. 确定可以对各个对象进行的操作\n3. 确定各个对象能对其他对象进行的操作\n4. 确定对象的哪些部分对其他对象可见--哪些部分可以是公用的，哪些部分应该是私用的。\n5. 定义每个对象的公开接口\n\n\n经过上述步骤得到一个高层次的、面向对象的系统组织结构之后，你可以用这两种方式来迭代；在高层次的系统组织结构上进行迭代，以便更好的组织类的结构；或者在每一个已经定义好的类上进行迭代，把每个类的设计细化。\n\n#### 形成一致的抽象\n\n抽象是一个能让你在关注某一概念的同时可以放心的忽略其中一些细节的能力---在不同的层次上处理不同的细节。\n\n> 以复杂度的观点看，抽象的主要好处就在于它使你能忽略相关的细节。\n\n好的设计会在子程序接口的层次上、在类接口的层次上以及包接口的层次上（在门把手上、门的层次上以及房屋的层次上）进行抽象。\n\n#### 封装实现细节\n\n抽象是说“让你从高层的细节来看待一个对象”，而封装则说：“初次之外，你不能看到对象的任何其他细节层次”。\n\n> 封装管理复杂度的方式是不让你看到那些复杂度。\n\n#### 当继承能简化设计时就继承\n\n继承能简化编程工作\n\n#### 隐藏秘密（信息隐藏）\n\n信息隐藏是结构化程序设计与面向对象设计的基础之一。\n\n##### 秘密和隐私权\n\n在设计一个类的时候，一项关键性的决策就是确定类的那些特性应该对外可见，哪些应该被隐藏起来。\n类的接口应该尽可能少的暴露其内部工作机制。\n\n\n![好的类接口就像是冰山的尖一样，让大部分内容都不暴露出来](http://media.gusibi.mobi/EI-c5Qdo2Wr453L_jakhC222GtL7R7PUYSpzq4EceNkSBtXhzTyIQ039yQHmBY8J)\n\n##### 信息隐藏的一个例子\n\n比如有一个程序，没个对象都有一个名为id的成员变量来保存唯一的ID。\n\n1. 一种设计方法是用一个整数来表示ID，同时有一个名为 max_id 的全局变量来保存当前的最大值，新的id 使用 ++max_id 来生成。这种设计是不合适的设计\n    - 不是线程安全\n    - ++max_id 可能遍布代码的各个位置，修改id 的生成规则需要改动太大\n2. 一个好的设计方式是，使用一个NewId() 方法来生成id，具体的实现逻辑在 NewId() 方法中，id 的类型也使用自定义的 IdType 类型，而不是指定 int 类型。\n\n\n##### 两种秘密\n\n信息隐藏中所说的秘密主要分为两大类：\n\n* 隐藏复杂度，这样你就不用再去应付它，除非你要特别关注的时候\n* 隐藏变化源，这样当变化发生时，其影响就能被限制在局部范围内。\n\n##### 信息隐藏的障碍\n\n少数情况下，信息隐藏会变的不可能，通常这种情况是由以下障碍造成的：\n\n* 信息过度分散 比如一个变量 数字`42`被写入了代码中（写死了），这样就会造成对它的引用过于分散。最好是把这个信息隐藏起来，比如写入常量中：THE_ANSWER = 42，代码中使用的时候引用 THE_ANSWER 这个常量就可以了。\n* 循环依赖：比如 A 类的子程序引用了B 类中的子程序，而B类中的子程序又引用了A 类中的子程序。这样会造成难以测试，需要保证两个类都正常才可以。\n* 类内数据设置成了全局数据：使用全局数据通常会遇到两个问题：一种是子程序执行时可能有另一个子程序也对它进行了操作，另一种是子程序知道有其他子程序在使用但不知道具体是哪个。这时应该使用只有少数子类可访问的类内数据。\n* 可以察觉的性能损耗：有的开发者为了减少调用关系试图在系统架构层和编码层进行优化。认为额外的层次调用会影响性能（事实上这种担心可能太早了，等以后遇到问题再优化是更好的选择）。\n\n##### 信息隐藏的价值\n\n> 信息隐藏是少数几个得到公认的、在实践中证明了其自身价值的理论技术、并且已经有很长一段时间了（Boehm 1987a）。\n\n1. 大型项目修改起来更容易\n2. 有助于公开接口的设计（使开发者更容易理解什么样的数据应该隐藏、什么样的数据应该公开\n\n#### 找出容易改变的区域\n\n> 对优秀的设计师的一份研究表明，他们所共有的一项特质就是都有对变化的预期能力（Glass 1995）\n> 看起来非常可信\n\n以下是应对变动的措施：\n\n1. 找出看起来容易变化的项目\n2. 把容易变化的项目分离出来\n3. 把看起来容易变化的项目隔离出来。\n\n以下是容易变化的区域：\n\n1. 业务规则\n2. 对硬件的依赖性：屏幕，打印机、键盘、鼠标等设备之间的接口\n3. 输入和输出\n4. 非标准的语言特性\n5. 困难的设计区域和构建区域\n6. 状态变量：可以在使用状态变量是增加至少两层的灵活性和可读性\n  - 不要使用布尔变量作为状态变量\n  - 使用防蚊器子程序取代对状态变量的直接检查\n7. 数据量的限制：当你定义了一个具有100个元素数据的时候，实际上也向外界透露了一些不必要的信息。用全局变量代替100 是一个好的选择。\n\n**预料不同程度的变化**\n\n当考虑系统的潜在变化时，你认为越有可能发生变化的区域，越要做好应对变化的准备。\n找出容易变化的区域的一个好的办法是：受限找出程序中可能对用户有用的最小子集。这一子集构成了系统的核心，不容易变化，然后扩充系统。\n> `通过首先定义清楚核心，来认清哪些组件是附属功能，这时就容易把它们提取出来，并且这些内容也容易改进优化。`\n\n#### 保持松散耦合\n\n模块之间好的耦合关系会松散到恰好能使一个模块能够很容易地被其他模块使用。\n> 请尽量使你创建的模块不依赖或者很少依赖其他模块。\n> 如果模块是微服务中的一个服务，那么一个好的耦合关系是一个服务可以在其它服务挂掉的情况下可以正常提供基础服务。\n\n##### 耦合标准\n\n* 规模：这里的规模指的是模块之间的连接数。对于耦合度来说，小就是美。\n* 可见性：可见性指的是两个模块之间的连接显著程度。通过参数传递数据是一种明显的连接，值得提倡，而通过修改全局数据而使另一模块能够使用该数据则是一种 鬼鬼祟祟的做法，不值得提倡。\n* 灵活性：灵活性指的是模块之间的连接是否容易改动。模块越灵活，越容易被其它模块调用（耦合越松散）越好。\n\n##### 耦合的种类\n\n* 简单数据参数耦合，两个模块之间通过参数传递数据，这种耦合关系正常，可以接受\n* 简单对象耦合，如果一个模块实例化一个对象，那么它们之间的耦合关系就是简单对象耦合。这种耦合关系也能接受\n* 对象耦合 如果object1 要求object2传递给他一个object3，那么这两个模块就是对象参数耦合。这种耦合更紧密，因为它要求object1 了解object3。\n* 语义耦合，如果一个模块不仅使用了另一模块的语法元素，而且还是用了那个模块内部工作细节的语义知识。这种耦合就非常危险，因为更改被调用模块，会影响调用者。\n\n#### 查阅常用的设计模式\n\n设计模式其实是一些现成精炼的解决方案，可用于解决很多软件开发中常见的问题。\n\n设计模式提供了如下好处：\n\n1. 设计模式通过提供现成的抽象来减少复杂度\n2. 设计模式通过把常见解决方案的细节予以制度化来减少出错\n3. 设计模式通过提供多种设计方案儿带来启发性的价值。\n4. 设计模式通过把设计对话提升到一个更高的层次上来简化交流。比如你和其它开发者讨论问题时说：我用来Factory Method。其实已经传递了很多有效信息。\n\n常见的设计模式请参考百科介绍：[设计模式 （设计模式概念）](https://baike.baidu.com/item/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1212549)\n\n[常用设计模式Python实现](https://mp.weixin.qq.com/mp/homepage?__biz=MzAwNjI5MjAzNw==&hid=2&sn=c32f7371e7df2e2282e2bdba080aa9c2)\n\n\n#### 其它的启发式方法\n\n* 高内聚性\n* 构造分层结构\n* 严格描述类契约\n    - 把没个类的接口看作是与程序的其余部分之间的一项契约会更有助于更好的洞察程序。这种契约类似于“如果你承诺提供数据x、y 和 z，并且答应让这些数据具有特征 a、b 和 c，我就承诺基于约束8、9和10来执行操作1、2和3\n* 分配职责\n* 为测试而设计\n    - 如果为了便于测试儿设计这个系统，那么这个系统会是什么样子？\n* 避免失误\n* 有意识的绑定时间\n    - 绑定时间是指的是吧特定的值绑定到某一变量的时间。早绑定会比较简单但不灵活\n* 创建中央控制点\n    - 唯一一个正确位置的原则：为了找到某个事物，需要查找的地方越少，该起来就越容易越简单\n* 考虑使用蛮力突破\n    - 一个可行的蛮力解决方案要好于一个优雅但不能用的解决方案\n* 画一个图\n    - 一幅图顶的上一千句话--鲁迅说的。\n* 保持设计的模块化\n\n#### 使用启发方式的原则\n\n1. 理解问题\n2. 设计一个计划。找出现有数据和未知量之间的联系。\n3. 执行这一计划\n4. 回顾。检视整个解决方案。\n\n### 设计实践\n\n#### 迭代（Iterate）\n\n设计是个迭代的过程，并非只是从A点到B点，也可以从A点到B点，再从B点到A点。在设计方案中尝试不同的做法时，会同时从不同层次取审视问题。更有助于找出相关细节。\n\n> 当你首次尝试得出一个看上去足够好的设计方案后，不要停下来，第二次尝试肯定会好于第一个。\n\n#### 分而治之（Divide and Conquer）\n\n没有人的头脑能大到装下一个复杂程序的全部细节-- Edsger Dijkstra\n\n#### 自上而下和自下而上的设计方法\n\n自上而下和自下而上策略最关键的区别在于，前者是一种分解（decomposition）策略而后者是一种合成（composition）策略。\n\n* 自上而下的设计很简单，因为人们善于把一些大的事物分解成小的组件。\n* 自上而下另一个强项是可以推迟构建的细节\n* 自下而上的一个优点是通常能够焦躁的找出所需的功能，从而带来紧凑合理的设计\n* 自下而上的一个缺点是很难完全独立的使用它。大多数人擅长把大的概念分解成小概念，而不擅长从小概念中得出大的概念。\n* 自下而上设计的另一个缺点是，有时候会发现自己无法使用手头已有的零件来构建整个系统。\n* 自上而下和自下而上设计并不互斥，两者可以协作。\n\n> 设计是一个启发式的过程，没有任何方案能保证万无一失，需要在设计的过程中需要不停的迭代，改进。需要多尝试来找出最佳方案。\n\n#### 建立试验性原型\n\n有些时候，判断一种设计是否合适，只有用过才能知道。创建一个试验性原型（写出用于回答特定设计问题、量最少且能够随时扔掉的代码），来验证设计的可行性，通常可以找出设计中遇到的问题以及需要改进的方向。\n\n#### 合作设计\n\n三个臭皮匠，顶个诸葛亮。\n\n1. 随便找个同事，向他征求意见\n2. 坐在会议室，在白板上画出可选设计方案\n3. 结对编程\n4. 和多名同事一起过设计想法\n\n#### 要做多少设计才够\n\n对于正式编码前的设计工作量和设计文档的正规程度，很难有个准确的定论。下图总结了设计文档的正规化以及所需的设计层次：\n\n![设计的层次](http://media.gusibi.mobi/hFeM_4EYd9btf0y09WRKh6M57Hqc6VNLnpUC8vVUOo28T1cqTy-pMNAvigkzT6HL)\n\n> 如果在编码前判断不了应该做多深入的设计，那么详细的设计是一个好的选择。\n\n#### 记录设计成果\n\n* 把设计文档加入到代码中\n    - 合适的注释非常关键，特别是某些特定的设计决策\n* 用Wiki 来记录设计讨论和决策\n* 写总结邮件\n* 保留设计图\n\n### 总结\n\n* 软件的首要技术使命就是管理复杂度。以简单性为努力目标的设计方案对此最有帮助\n* 简单性可以通过两种方式来获取：轶事减少在同一时间所关注的本质性复杂度的量，二是避免生成不必要的偶然的复杂度\n* 设计是一个启发式的过程。固执于某一种单一方法会损害创新能力，从而损害程序\n* 好的设计都是迭代的，尝试的越多，最终方案会越好\n* 信息隐藏是一个非常有价值的概念。通过询问“我应该隐藏什么？\"能够解决很多设计问题\n\n\n\n## 参考链接\n\n* [常用设计模式Python实现](https://mp.weixin.qq.com/mp/homepage?__biz=MzAwNjI5MjAzNw==&hid=2&sn=c32f7371e7df2e2282e2bdba080aa9c2)\n\n\n\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "创建高质量的代码--软件构建中的设计",
        "date": "2019-05-29 13:05:57",
        "tags": [
          "后端",
          "tutorial"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "Design-in-software-construction"
    },
    {
      "content": "\n## 并发&并行\n\n并发程序含有多个逻辑上的独立执行块，他们可以独立的并行执行，也可以串行执行。\n并行程序解决问题的速度比串行程序快的多，因为其可以同时执行整个任务的多个部分。并行程序可能有多个独立执行块，也可能只有一个。\n\n> 引用Rob Pike的经典描述就是：\n> 并发是同一时间应对多件事情的能力；\n> 并行是同一时间动手做多件事情的能力。\n\n常见的并发模型有：\n\n1. 线程与锁\n2. 函数式编程\n3. actor模型和通信顺序是进行（Communicating Sequential Processes, CSP）\n4. 数据级并行\n5. lambda 架构\n6. 分离标识与状态模型\n\n这篇主要介绍线程与锁模型\n\n## 线程与锁模型\n\n线程与锁模型是对底层硬件运行过程的形式化，非常简单直接，几乎所有的编程语言都对其提供了支持，且不对其使用方法加以限制（易出错）。\n\n> 这篇文章主要使用python语言来演示线程与锁模型。文章结构来自《七周七并发模型》\n\n## 互斥和内存模型\n\n### 创建线程\n\n```python\nfrom threading import Thread\n\ndef hello_world():\n    print(\"Hello from new thread\")\n\ndef main():\n    my_thread = Thread(target=hello_world)\n    my_thread.start()\n    print(\"Hello from main thread\")\n    my_thread.join()\n\nmain()\n\n```\n\n这段代码创建并启动了一个`Thread`实例，首先从`start()` 开始，`my_thread.start() main()`函数的余下部分一起并发执行。最后调用`join()` 来等待`my_thread`线程结束。\n\n运行这段代码输出结果有几种：\n```\nHello from new thread\nHello from main thread\n```\n或者\n```\nHello from main thread\nHello from new thread\n```\n或者\n```\nHello from new threadHello from main thread\n```\n\n究竟哪个结果取决于哪个线程先执行`print()`。多线程编程很难的原因之一就是运行结果可能依赖于时序，多次运行结果并不稳定。 \n\n### 第一把锁\n\n```python\n\nfrom threading import Thread, Lock\n\n\nclass Counter(object):\n    def __init__(self, count=0):\n        self.count = count\n\n    def increment(self):\n        self.count += 1\n\n    def get_count(self):\n        print(\"Count: %s\" % self.count)\n        return self.count\n\n\ndef test_count():\n    counter = Counter()\n\n    class CounterThread(Thread):\n        def run(self):\n            for i in range(10000):\n                counter.increment()\n\n    t1 = CounterThread()\n    t2 = CounterThread()\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n\n    counter.get_count()\n\ntest_count()\n```\n\n这段代码创建一个简单的类Counter 和两个线程，每个线程都调用counter.increment() 10000次。\n\n多次运行这段代码会得到不同的值，原因是两个线程在使用 counter.count 时发生了`竞态条件`（代码行为取决于各操作的时序）。\n\n一个可能的操作是：\n1. 线程t1 获取count的值时，线程t2也同时获取到了count 的值（假设是100），\n2. 这时t1  count + 1， 此时count 为101，回写count 值，然后t2 执行了相同的操作 count+1，因为t2 取到的值也是100 此时 count 仍是101，回写后count 依然是101，但是 +1 操作执行了两次。\n\n竞态条件的解决方法是对 count 进行同步（synchronize）访问。一种操作是使用 `内置锁`(也称互斥锁（mutex）、管程（monitor）或临界区（critical section）)来同步对increment() 的调用。\n\n> 线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。互斥锁为资源引入一个状态：锁定/非锁定。某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；\n> 直到该线程释放资源，将资源的状态变成“非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。\n\n> 当一个线程调用锁的acquire()方法获得锁时，锁就进入“locked”状态。每次只有一个线程可以获得锁。如果此时另一个线程试图获得这个锁，该线程就会变为“blocked”状态，称为“同步阻塞”。\n> 直到拥有锁的线程调用锁的release()方法释放锁之后，锁进入“unlocked”状态。线程调度程序从处于同步阻塞状态的线程中选择一个来获得锁，并使得该线程进入运行（running）状态。\n\n\npython 锁的使用流程如下：\n\n```python\n#创建锁\nmutex = threading.Lock()\n#锁定\nmutex.acquire([timeout])\n#释放\nmutex.release()\n```\n\n推荐使用上下文管理器来操作锁，\n\n```python\nwith lock:\n    do someting\n\n# 相当于\n\nlock.acquire()\n\ntry:\n    # do something...\nfinally:\n    lock.release()\n```\n\n> acquire(blocking=True, timeout=-1)\n> 可以阻塞或非阻塞地获得锁。\n>当调用时参数 blocking 设置为 True （缺省值），阻塞直到锁被释放，然后将锁锁定并返回 True 。\n>在参数 blocking 被设置为 False 的情况下调用，将不会发生阻塞。如果调用时 blocking 设为 True 会阻塞，并立即返回 False ；否则，将锁锁定并返回 True。\n>当浮点型 timeout 参数被设置为正值调用时，只要无法获得锁，将最多阻塞 timeout 设定的秒数。timeout 参数被设置为 -1 时将无限等待。当 blocking 为 false 时，timeout 指定的值将被忽略。\n>如果成功获得锁，则返回 True，否则返回 False (例如发生 超时 的时候)。\n> timeout 参数需要 `python3.2+`\n\n```python\nfrom threading import Thread, Lock\nmutex = Lock()\n\nclass SynchronizeCounter(object):\n    def __init__(self, count=0):\n        self.count = count\n\n    def increment(self):\n        # if mutex.acquire(1): # 获取锁\n        #     self.count += 1\n        #     mutex.release()  # 释放锁\n        # 等同于上述代码\n        with mutex:\n            self.count += 1\n\n    def get_count(self):\n        print(\"Count: %s\" % self.count)\n        return self.count\n\ndef test_synchronize_count():\n    counter = SynchronizeCounter()\n\n    class CounterThread(Thread):\n        def run(self):\n            for i in range(100000):\n                counter.increment()\n\n    t1 = CounterThread()\n    t2 = CounterThread()\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n\n    counter.get_count()\n\n\nif __name__ == \"__main__\":\n    for i in range(100):\n        test_synchronize_count()\n\n```\n\n> 这段代码还有一个隐藏的bug，那就是 get_count()，这里get_count() 是在join()之后调用的，因此是线程安全的，但是如果在其它地方调用了 get_count() 函数。\n由于在 get_count() 中没有进行线程同步，调用时可能会获取到一个失效的值。\n\n\n#### 诡异的内存\n\n对于JAVA等竞态编译语言，\n1. 编译器的静态优化可能会打乱代码的执行顺序\n2. JVM 的动态优化也会打乱代码的执行顺序\n3. 硬件可以通过乱序执行来优化性能\n\n更糟糕的是，有时一个线程产生的修改可能会对另一个线程不可见。\n> 从直觉上来说，编译器、JVM、硬件都不应插手修改原本的代码逻辑。但是近几年的运行效率提升，尤其是共享内存交媾的运行效率提升，都仰仗于此类代码优化。\n> 具体的副作用，Java 内存模型有明确说明。\n> Java 内存模型定义了何时一个线程对内存的修改对另一个线程可见。`基本原则是：如果读线程和写线程不进行同步，就不能保证可见性。`\n\n\n### 多把锁\n\n**一个重点：** 两个线程都需要进行同步。只在其中一个线程进行同步是不够的。\n\n可如果所有的方法都同步，大多数线程可能都会被阻塞，失去了并发的意义，并且可能会出现死锁。\n\n[哲学家进餐问题](https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98)\n\n> `哲学家就餐问题`：假设有五位哲学家围坐在一张圆形餐桌旁，做以下两件事情之一：吃饭，或者思考。吃东西的时候，他们就停止思考，思考的时候也停止吃东西。餐桌中间有一大碗意大利面，每两个哲学家之间有一只餐叉。因为用一只餐叉很难吃到意大利面，所以假设哲学家必须用两只餐叉吃东西。他们只能使用自己左右手边的那两只餐叉。 \n\n> 哲学家从来不交谈，这就很危险，可能产生死锁，每个哲学家都拿着左手的餐叉，永远都在等右边的餐叉（或者相反）。\n即使没有死锁，也有可能发生资源耗尽。例如，假设规定当哲学家等待另一只餐叉超过五分钟后就放下自己手里的那一只餐叉，并且再等五分钟后进行下一次尝试。这个策略消除了死锁（系统总会进入到下一个状态），但仍然有可能发生“活锁”。如果五位哲学家在完全相同的时刻进入餐厅，并同时拿起左边的餐叉，那么这些哲学家就会等待五分钟，同时放下手中的餐叉，再等五分钟，又同时拿起这些餐叉。\n\n下面是哲学家进餐问题的一个实现：\n\n```python\nimport threading\nimport random\nimport time\n\n\nclass Philosopher(threading.Thread):\n\n    running = True\n\n    def __init__(self, xname, forkOnLeft, forkOnRight):\n        threading.Thread.__init__(self)\n        self.name = xname\n        self.forkOnLeft = forkOnLeft\n        self.forkOnRight = forkOnRight\n\n    def run(self):\n        while self.running:\n            #  Philosopher is thinking (but really is sleeping).\n            time.sleep(random.uniform(1, 3))\n            print(\"%s is hungry.\" % self.name)\n            self.dine()\n\n    def dine(self):\n        fork1, fork2 = self.forkOnLeft, self.forkOnRight\n\n        while self.running:\n            fork1.acquire(True)  # 阻塞式获取left 锁\n            # locked = fork2.acquire(True) # 阻塞式 获取right 锁  容易产生死锁\n            locked = fork2.acquire(False)  # 非阻塞式 获取right 锁\n            if locked:\n                break  # 如果被锁定，释放 left 退出等待\n            fork1.release()\n            print(\"%s swaps forks\" % self.name)\n            fork1, fork2 = fork2, fork1\n        else:\n            return\n\n        self.dining()\n        fork2.release()\n        fork1.release()\n\n    def dining(self):\n        print(\"%s starts eating \" % self.name)\n        time.sleep(random.uniform(1, 5))\n        print(\"%s finishes eating and leaves to think.\" % self.name)\n\n\ndef DiningPhilosophers():\n    forks = [threading.Lock() for n in range(5)]\n    philosopherNames = (\"Aristotle\", \"Kant\", \"Buddha\", \"Marx\", \"Russel\")\n\n    philosophers = [\n        Philosopher(philosopherNames[i], forks[i % 5], forks[(i + 1) % 5])\n        for i in range(5)\n    ]\n\n    Philosopher.running = True\n    for p in philosophers:\n        p.start()\n    for p in philosophers:\n        p.join()\n    time.sleep(100)\n    Philosopher.running = False\n    print(\"Now we're finishing.\")\n\n\nDiningPhilosophers()\n\n```\n\n### 外星方法的危害\n\n规模较大的程序常用监听器模式来解耦模块，这里我们构造一个类从一个URL进行下载，Listeners 监听下载进度。\n\n```python\nimport requests\nimport threading\n\n\nclass Listeners(object):\n    def __init__(self, count=0):\n        self.count = count\n        self.done_count = 0.0\n        self.listeners = []\n\n    def append(self, listener):\n        self.listeners.append(listener)\n\n    def remove(self, listener):\n        self.listeners.remove(listener)\n\n    def on_progress(self, n):\n        # 一些我们不知道的实现\n        # do someting\n        # self.done_count += 1\n        # print(\"Process: %f\" % (self.done_count / self.count))\n        pass\n\n\nlisteners = Listeners(5)\n\n\nclass Downloader(threading.Thread):\n    def __init__(\n        self, group=None, target=None, name=None, args=(), kwargs=None, daemon=None\n    ):\n        threading.Thread.__init__(\n            self, group=group, target=target, name=name, daemon=daemon\n        )\n        self.url = kwargs.get(\"url\")\n\n    def download(self):\n        resp = requests.get(self.url)\n\n    def add_listener(self, listener):\n        listeners.append(listener)\n\n    def remove_listener(self, listener):\n        listeners.delete(listener)\n\n    def update_progress(self, n):\n        for listener in listeners:\n            listner.on_progress(n)\n\n    def run(self):\n        self.download()\n        print(self.url)\n        listeners.on_progress(1)\n\n\ndef test():\n    urls = [\n        \"https://www.baidu.com\",\n        \"https://www.google.com\",\n        \"https://www.bing.com\",\n        \"https://www.zaih.com\",\n        \"https://www.github.com\",\n    ]\n    ts = [Downloader(kwargs=dict(url=url)) for url in urls]\n    print(ts)\n    [t.start() for t in ts]\n    [t.join() for t in ts]\n\n\nif __name__ == \"__main__\":\n    test()\n\n```\n这段代码中，add_listener， remove_listener 和 update_progress 都是同步方法，但 update_progress 调用了一个我们不知道如何实现的方法。如果这个方法中，获取了一把锁，程序在执行的过程中就可能发生死锁。所以，我们要尽量避免使用这种方法。还有一种方法是在遍历之前对 listeners 进行保护性复制，再针对这份副本进行遍历。（现在调用外星方法不再需要加锁）\n\n## 超越内置锁\n\n### 可重入锁\n\nLock() 虽然方便，但限制很多：\n1. 一个线程因为等待内置锁而进入阻塞之后，就无法中断该线程\n2. Lock() 不知道当前拥有锁的线程是否是当前线程，如果当前线程获取了锁，再次获取也会阻塞。\n\n重入锁是(threading.RLock)一个可以被同一个线程多次获取的同步基元组件。在内部，它在基元锁的锁定/非锁定状态上附加了 \"所属线程\" 和 \"递归等级\" 的概念。在锁定状态下，某些线程拥有锁 ； 在非锁定状态下， 没有线程拥有它。\n\n若要锁定锁，线程调用其 acquire() 方法；一旦线程拥有了锁，方法将返回。若要解锁，线程调用 release() 方法。 acquire()/release() 对可以嵌套；只有最终 release() (最外面一对的 release() ) 将锁解开，才能让其他线程继续处理 acquire() 阻塞。\n\nthreading.RLock 提供了显式的 acquire() 和 release() 方法\n一个好的实践是：\n\n    lock = threading.RLock()\n    \nLock 和 RLock 的使用区别如下：\n\n```python\n#rlock_tut.py\nimport threading\nnum = 0\nlock = Threading.Lock()\nlock.acquire()\nnum += 1\nlock.acquire() # 这里会被阻塞\nnum += 2\nlock.release()\n\n# With RLock, that problem doesn’t happen.\nlock = Threading.RLock()\nlock.acquire()\nnum += 3\nlock.acquire() # 不会被阻塞.\nnum += 4\nlock.release()\nlock.release() # 两个锁都需要调用 release() 来释放.\n\n```\n\n### 超时\n\n使用内置锁时，阻塞的线程无法被中断，程序不能从死锁恢复，可以给锁设置超时时间来解决这个问题。\n\n> timeout 参数需要 python3.2+\n\n```python\nimport time\nfrom threading import Thread, Lock\n\nlock1 = RLock()\nlock2 = RLock()\n\n# 这个程序会一直死锁下去，如果想突破这个限制，可以在获取锁的时候加上超时时间\n# > python threading 没有实现 销毁(destroy)，停止(stop)，暂停(suspend)，继续（resume）,中断（interrupt）等\n\n\nclass T1(Thread):\n    def run(self):\n        print(\"start run T1\")\n        lock1.acquire()\n        # lock1.acquire(timeout=2) # 设置超时时间可避免死锁\n        time.sleep(1)\n        lock2.acquire()\n        # lock2.acquire(timeout=2) # 设置超时时间可避免死锁\n        lock1.release()\n        lock2.release()\n\n\nclass T2(Thread):\n    def run(self):\n        print(\"start run T2\")\n        lock2.acquire()\n        # lock2.acquire(timeout=2) # 设置超时时间可避免死锁\n        time.sleep(1)\n        lock1.acquire()\n        # lock1.acquire(timeout=2) # 设置超时时间可避免死锁\n        lock2.release()\n        lock1.release()\n\n\ndef test():\n    t1, t2 = T1(), T2()\n    t1.start()\n    t2.start()\n\n    t1.join()\n    t2.join()\n\n\nif __name__ == \"__main__\":\n    test()\n\n```\n\n### 交替锁\n\n如果我们要在链表中插入一个节点。一种做法是用锁保护整个链表，但链表加锁时其它使用者无法访问。交替锁可以只所追杀链表的一部分，允许不涉及被锁部分的其它线程自由访问。\n\n![交替锁](http://media.gusibi.mobi/TEbTwYoXnf5oLt4T3ovmxSALDg90i63Lx3t2EZIfyqVyo6bDHJGVnvu-v89vas7E)\n\n```python\n\nfrom random import randint\nfrom threading import Thread, Lock\n\nclass Node(object):\n\n    def __init__(self, value, prev=None, next=None):\n        self.value = value\n        self.prev = prev\n        self.next = next\n        self.lock = Lock()\n\n\nclass SortedList(Thread):\n\n    def __init__(self, head):\n        Thread.__init__(self)\n        self.head = head\n\n    def insert(self, value):\n        head = self.head\n        node = Node(value)\n        print(\"insert: %d\" % value)\n        while True:\n            if head.value <= value:\n                if head.next != None:\n                    head = head.next\n                else:\n                    head.lock.acquire()\n                    head.next = node\n                    node.prev = head\n                    head.lock.release()\n                    break\n            else:\n                prev = head.prev\n                prev.lock.acquire()\n                head.lock.acquire()\n                if prev != None:\n                    prev.next = node\n                else:\n                    self.head = node\n                node.prev = prev\n                prev.lock.release()\n                node.next = head\n                head.prev = node\n                head.lock.release()\n                break\n\n    def run(self):\n        for i in range(5):\n            self.insert(randint(10, 20))\n\n\ndef test():\n    head = Node(10)\n    t1 = SortedList(head)\n    t2 = SortedList(head)\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n    while head:\n        print(head.value)\n        head = head.next\n\n\nif __name__ == \"__main__\":\n    test()\n```\n\n这种方案不仅可以让多个线程并发的进行链表插入操作，还能让其他的链表操作安全的并发。\n\n### 条件变量\n\n并发编程经常需要等待某个事件发生。比如从队列删除元素前需要等待队列非空、向缓存添加数据前需要等待缓存有足够的空间。条件变量就是为这种情况设计的。\n\n条件变量总是与某种类型的锁对象相关联，锁对象可以通过传入获得，或者在缺省的情况下自动创建。当多个条件变量需要共享同一个锁时，传入一个锁很有用。锁是条件对象的一部分，不必单独地跟踪它。\n\n条件变量服从上下文管理协议：使用 with 语句会在它包围的代码块内获取关联的锁。 acquire() 和 release() 方法也能调用关联锁的相关方法。\n\n其它方法必须在持有关联的锁的情况下调用。 wait() 方法释放锁，然后阻塞直到其它线程调用 notify() 方法或 notify_all() 方法唤醒它。一旦被唤醒， wait() 方法重新获取锁并返回。它也可以指定超时时间。\n\n```python\n#condition_tut.py\nimport random, time\nfrom threading import Condition, Thread\n\"\"\"\n'condition' variable will be used to represent the availability of a produced\nitem.\n\"\"\"\ncondition = Condition()\nbox = []\ndef producer(box, nitems):\n    for i in range(nitems):\n        time.sleep(random.randrange(2, 5))  # Sleeps for some time.\n        condition.acquire()\n        num = random.randint(1, 10)\n        box.append(num)  # Puts an item into box for consumption.\n        condition.notify()  # Notifies the consumer about the availability.\n        print(\"Produced:\", num)\n        condition.release()\ndef consumer(box, nitems):\n    for i in range(nitems):\n        condition.acquire()\n        condition.wait()  # Blocks until an item is available for consumption.\n        print(\"%s: Acquired: %s\" % (time.ctime(), box.pop()))\n        condition.release()\nthreads = []\n\"\"\"\n'nloops' is the number of times an item will be produced and\nconsumed.\n\"\"\"\nnloops = random.randrange(3, 6)\nfor func in [producer, consumer]:\n    threads.append(Thread(target=func, args=(box, nloops)))\n    threads[-1].start()  # Starts the thread.\nfor thread in threads:\n    \"\"\"Waits for the threads to complete before moving on\n       with the main script.\n    \"\"\"\n    thread.join()\nprint(\"All done.\")\n\n```\n\n### 原子变量\n\n> 与锁相比使用原子变量的优点：\n> 1. 不会忘记在正确的时候获取锁\n> 2. 由于没有锁的参与，对原子变量的操作不会引发死锁。\n> 3. 原子变量时无锁（lock-free）非阻塞（non-blocking）算法的基础，这种算法可以不用锁和阻塞来达到同步的目的。\n\n**python 不支持原子变量**\n## 总结\n\n### 优点 \n\n线程与锁模型最大的优点是适用面广，更接近于“本质”--近似于对硬件工作方式的形式化--正确使用时效率高。\n此外，线程与锁模型也可轻松的集成到大多数编程语言。\n\n### 缺点\n\n1. 线程与锁模型没有为并行提供直接的支持\n2. 线程与锁模型只支持共享内存模型，如果要支持分布式内存模型，就需要寻求其他技术的帮助。\n3. 用线程与锁模型编写的代码难以测试（比如死锁问题可能很久才会出现），出了问题后很难找到问题在哪，并且bug难以复现\n4. 代码难以维护（要保证所有对象的同步都是正确的、必须按  顺序来获取多把锁、持有锁时不调用外星方法。还要保证维护代码的开发者都遵守这个规则\n\n\n## 参考链接\n\n* [Let’s Synchronize Threads in Python](https://hackernoon.com/synchronization-primitives-in-python-564f89fee732?gi=ce162d119247)\n* [哲学家进餐问题](https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98)\n\n#### References\n\n[1] 哲学家进餐问题: https://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98\n[2] Let’s Synchronize Threads in Python: https://hackernoon.com/synchronization-primitives-in-python-564f89fee732?gi=ce162d119247\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "并发模型：线程与锁",
        "date": "2019-05-19 12:29:39",
        "tags": [
          "python",
          "读书笔记",
          "并发"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "concurrency-models-thread-and-lock"
    },
    {
      "content": "\n\n> Json web token (JWT), 根据官网的定义，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。\n> 详细介绍可以查看这篇文章 [理解JWT（JSON Web Token）认证及实践](https://mp.weixin.qq.com/s/gUgh_kmMu0Hmobeah7wNLQ)\n\n## JWT 特点\n\n### 优点\n\n* 体积小，因而传输速度快\n* 传输方式多样，可以通过URL/POST参数/HTTP头部等方式传输\n* 严格的结构化。它自身（在 payload 中）就包含了所有与用户相关的验证消息，如用户可访问路由、访问有效期等信息，服务器无需再去连接数据库验证信息的有效性，并且 payload 支持为你的应用而定制化。\n* 支持跨域验证，可以应用于单点登录。\n\n### 存在的问题\n\nJWT 自身（在 payload 中）就包含了所有与用户相关的验证消息，所以通常情况下不需要保存。这种设计存在几个问题：\n\n1. Token不能撤销--客户端重置密码后之前的JWT依然可以使用（JWT 并没有过期或者失效\n2. 不支持refresh token，JWT过期后需要执行登录授权的完整流程\n3. 无法知道用户签发了几个JWT\n\n针对第一个问题，可能的解决方法有：\n\n1. 保存JWT到数据库（或Redis），这样可以针对每个JWT单独校验\n2. 在重置密码等需要作废之前全部JWT时，把操作时间点记录到数据库（或Redis），校验JWT时同时判断此JWT创建之后有没有过重置密码等类似操作，如果有校验不通过\n\n\n当然，这种解决方法都会多一次数据库请求，JWT自身可校验的优势会有所减少，同时也会影响认证效率。\n\n这篇文章主要介绍解决第二个问题（不支持refresh token）的思路。\n\n### refresh token\n\nrefresh token是OAuth2 认证中的一个概念，和OAuth2 的access token 一起生成，表示更新令牌，过期所需时间比access toen 要长，可以用来获取下一次的access token。\n\n如果JWT 需要添加 refresh token支持，refresh token需要满足的条件有一下几项：\n\n1. 和JWT一起生成返回给客户端\n2. 有实效时间，有效时间比JWT要长\n3. 只能用来换取下一次JWT，不能用于访问认证\n4. 不能重复使用（可选）\n\n\n#### refresh token 获取流程\n\n![](http://media.gusibi.mobi/kY3mm6nLAlHkGDxHJF1WLctLSbp9eA-6iirdYBlC0CDwMcq_rTPsCWpAhmWUr_nJ)\n\n#### refresh token 使用流程\n\n![](http://media.gusibi.mobi/-PJDYI_rQ-EiYl6aGJ-_zPtkgKY9nRnBnShAj47rsoEY115E8IRlM4zMuOvx70zi)\n\n## 代码示例\n\n```python\nimport jwt\nimport time\n\n# 使用 sanic 作为restful api 框架 \ndef create_token(account_id, username):\n    payload = {\n        \"iss\": \"gusibi.mobi\",\n        \"iat\": int(time.time()),\n        \"exp\": int(time.time()) + 86400 * 7,\n        \"aud\": \"www.gusibi.mobi\",\n        \"sub\": account_id,\n        \"username\": username,\n        \"scopes\": ['open']\n    }\n    token = jwt.encode(payload, 'secret', algorithm='HS256')\n    payload['grant_type'] = \"refresh\"\n    refresh_token = jwt.encode(payload, 'secret', algorithm='HS256')\n    return True, {\n        'access_token': token,\n        'account_id': account_id,\n        \"refresh_token\": refresh_token\n        }\n\n# 验证refresh token 出否有效\ndef verify_refresh_token(token):\n    payload = jwt.decode(token, 'secret', audience='www.gusibi.com', algorithms=['HS256'])\n    # 校验token 是否有效，以及是否是refresh token，验证通过后生成新的token 以及 refresh_token\n    if payload and payload.get('grant_type') == 'refresh':\n        # 如果需要标记此token 已经使用，需要借助redis 或者数据库（推荐redis）\n        return True, payload\n    return False, None\n\n# 验证token 是否有效\ndef verify_bearer_token(token):\n    #  如果在生成token的时候使用了aud参数，那么校验的时候也需要添加此参数\n    payload = jwt.decode(token, 'secret', audience='www.gusibi.com', algorithms=['HS256'])\n    # 校验token 是否有效，以及不能是refresh token\n    if payload and not payload.get('grant_type') == 'refresh':\n        return True, payload\n    return False, None\n```\n\n\n## 参考链接\n\n* [理解JWT（JSON Web Token）认证及实践](https://mp.weixin.qq.com/s/gUgh_kmMu0Hmobeah7wNLQ)\n* [理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)[1] \n\nReferences\n[1] 理解OAuth 2.0: http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\n\n\n------\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "JWT RefreshToken 实践",
        "date": "2019-04-29 13:05:57",
        "tags": [
          "restful",
          "tutorial",
          "后端"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "jwt-refresh-token"
    },
    {
      "content": "\n\n`go modules` 是 golang 1.11 新加的特性。现在1.12 已经发布了，是时候用起来了。Modules官方定义为：\n\n> 模块是相关Go包的集合。modules是源代码交换和版本控制的单元。 go命令直接支持使用modules，包括记录和解析对其他模块的依赖性。modules替换旧的基于GOPATH的方法来指定在给定构建中使用哪些源文件。\n\n## 如何使用 Modules ？\n\n1. 把 golang 升级到 1.11（现在1.12 已经发布了，建议使用1.12）\n2. 设置 `GO111MODULE`\n\nGO111MODULE\n\n`GO111MODULE` 有三个值：`off`, `on`和`auto（默认值）`。\n\n* `GO111MODULE=off`，go命令行将不会支持module功能，寻找依赖包的方式将会沿用旧版本那种通过vendor目录或者GOPATH模式来查找。\n* `GO111MODULE=on`，go命令行会使用modules，而一点也不会去GOPATH目录下查找。\n* `GO111MODULE=auto`，默认值，go命令行将会根据当前目录来决定是否启用module功能。这种情况下可以分为两种情形：\n    - 当前目录在GOPATH/src之外且该目录包含go.mod文件\n    - 当前文件在包含go.mod文件的目录下面。\n\n> 当modules 功能启用时，依赖包的存放位置变更为`$GOPATH/pkg`，允许同一个package多个版本并存，且多个项目可以共享缓存的 module。\n\n### go mod\n\ngolang 提供了 `go mod`命令来管理包。\n\ngo mod 有以下命令：\n\n| 命令 | 说明 |\n| --- | --- |\n|download  | download modules to local cache(下载依赖包) |\n| edit | edit go.mod from tools or scripts（编辑go.mod |\n| graph | print module requirement graph (打印模块依赖图)|\n| init | initialize new module in current directory（在当前目录初始化mod） |\n| tidy | add missing and remove unused modules(拉取缺少的模块，移除不用的模块) |\n| vendor  | make vendored copy of dependencies(将依赖复制到vendor下) |\n| verify | verify dependencies have expected content (验证依赖是否正确） |\n| why | explain why packages or modules are needed(解释为什么需要依赖) |\n\n## 如何在项目中使用\n\n### 示例一：创建一个新项目\n\n1. 在`GOPATH 目录之外`新建一个目录，并使用`go mod init` 初始化生成`go.mod` 文件\n\n```sh\n➜  ~ mkdir hello\n➜  ~ cd hello\n➜  hello go mod init hello\ngo: creating new go.mod: module hello\n➜  hello ls\ngo.mod\n➜  hello cat go.mod\nmodule hello\n\ngo 1.12\n```\n\n> go.mod文件一旦创建后，它的内容将会被go toolchain全面掌控。go toolchain会在各类命令执行时，比如go get、go build、go mod等修改和维护go.mod文件。\n\ngo.mod 提供了`module`, `require`、`replace`和`exclude` 四个命令\n\n* `module`  语句指定包的名字（路径）\n* `require` 语句指定的依赖项模块\n* `replace` 语句可以替换依赖项模块\n* `exclude` 语句可以忽略依赖项模块\n\n2. 添加依赖\n\n新建一个 server.go 文件，写入以下代码：\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\n\t\"github.com/labstack/echo\"\n)\n\nfunc main() {\n\te := echo.New()\n\te.GET(\"/\", func(c echo.Context) error {\n\t\treturn c.String(http.StatusOK, \"Hello, World!\")\n\t})\n\te.Logger.Fatal(e.Start(\":1323\"))\n}\n```\n\n执行 `go run server.go` 运行代码会发现 go mod 会自动查找依赖自动下载：\n\n```sh\n$ go run server.go\ngo: finding github.com/labstack/echo v3.3.10+incompatible\ngo: downloading github.com/labstack/echo v3.3.10+incompatible\ngo: extracting github.com/labstack/echo v3.3.10+incompatible\ngo: finding github.com/labstack/gommon/color latest\ngo: finding github.com/labstack/gommon/log latest\ngo: finding github.com/labstack/gommon v0.2.8\n# 此处省略很多行\n...\n\n   ____    __\n  / __/___/ /  ___\n / _// __/ _ \\/ _ \\\n/___/\\__/_//_/\\___/ v3.3.10-dev\nHigh performance, minimalist Go web framework\nhttps://echo.labstack.com\n____________________________________O/_______\n                                    O\\\n⇨ http server started on [::]:1323\n```\n\n现在查看go.mod 内容：\n\n```go\n$ cat go.mod\n\nmodule hello\n\ngo 1.12\n\nrequire (\n\tgithub.com/labstack/echo v3.3.10+incompatible // indirect\n\tgithub.com/labstack/gommon v0.2.8 // indirect\n\tgithub.com/mattn/go-colorable v0.1.1 // indirect\n\tgithub.com/mattn/go-isatty v0.0.7 // indirect\n\tgithub.com/valyala/fasttemplate v1.0.0 // indirect\n\tgolang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a // indirect\n)\n```\n\ngo module 安装 package 的原則是先拉最新的 release tag，若无tag则拉最新的commit，详见 [Modules官方介绍](https://github.com/golang/go/wiki/Modules)。 go 会自动生成一个 go.sum 文件来记录 dependency tree：\n\n```shell\n$ cat go.sum\ngithub.com/labstack/echo v3.3.10+incompatible h1:pGRcYk231ExFAyoAjAfD85kQzRJCRI8bbnE7CX5OEgg=\ngithub.com/labstack/echo v3.3.10+incompatible/go.mod h1:0INS7j/VjnFxD4E2wkz67b8cVwCLbBmJyDaka6Cmk1s=\ngithub.com/labstack/gommon v0.2.8 h1:JvRqmeZcfrHC5u6uVleB4NxxNbzx6gpbJiQknDbKQu0=\ngithub.com/labstack/gommon v0.2.8/go.mod h1:/tj9csK2iPSBvn+3NLM9e52usepMtrd5ilFYA+wQNJ4=\ngithub.com/mattn/go-colorable v0.1.1 h1:G1f5SKeVxmagw/IyvzvtZE4Gybcc4Tr1tf7I8z0XgOg=\ngithub.com/mattn/go-colorable v0.1.1/go.mod h1:FuOcm+DKB9mbwrcAfNl7/TZVBZ6rcnceauSikq3lYCQ=\n... 省略很多行\n```\n\n3. 再次执行脚本 `go run server.go` 发现跳过了检查并安装依赖的步骤。\n4. 可以使用命令 `go list -m -u all` 来检查可以升级的package，使用`go get -u need-upgrade-package` 升级后会将新的依赖版本更新到go.mod\n        * 也可以使用 `go get -u` 升级所有依赖\n\n\n#### go get 升级\n\n* 运行 go get -u 将会升级到最新的次要版本或者修订版本(x.y.z, z是修订版本号， y是次要版本号)\n* 运行 go get -u=patch 将会升级到最新的修订版本\n* 运行 go get package@version 将会升级到指定的版本号version\n* 运行go get如果有版本的更改，那么go.mod文件也会更改\n\n\n### 示例二：改造现有项目(helloword)\n\n项目目录为：\n\n```shell\n$ tree\n.\n├── api\n│   └── apis.go\n└── server.go\n\n1 directory, 2 files\n```\n\nserver.go 源码为：\n\n```go\npackage main\n\nimport (\n    api \"./api\"  // 这里使用的是相对路径\n    \"github.com/labstack/echo\"\n)\n\nfunc main() {\n    e := echo.New()\n    e.GET(\"/\", api.HelloWorld)\n    e.Logger.Fatal(e.Start(\":1323\"))\n}\n```\n\napi/apis.go 源码为：\n\n```go\npackage api\n\nimport (\n    \"net/http\"\n\n    \"github.com/labstack/echo\"\n)\n\nfunc HelloWorld(c echo.Context) error {\n    return c.JSON(http.StatusOK, \"hello world\")\n}\n```\n\n1. 使用 `go mod init ***` 初始化go.mod\n\n```shell\n$ go mod init helloworld\ngo: creating new go.mod: module helloworld\n```\n\n2. 运行 `go run server.go`\n\n```shell\ngo: finding github.com/labstack/gommon/color latest\ngo: finding github.com/labstack/gommon/log latest\ngo: finding golang.org/x/crypto/acme/autocert latest\ngo: finding golang.org/x/crypto/acme latest\ngo: finding golang.org/x/crypto latest\nbuild command-line-arguments: cannot find module for path _/home/gs/helloworld/api\n```\n\n首先还是会查找并下载安装依赖，然后运行脚本 `server.go`，这里会抛出一个错误：\n\n```shell\nbuild command-line-arguments: cannot find module for path _/home/gs/helloworld/api\n```\n但是`go.mod` 已经更新：\n\n```json\n$ cat go.mod\nmodule helloworld\n\ngo 1.12\n\nrequire (\n        github.com/labstack/echo v3.3.10+incompatible // indirect\n        github.com/labstack/gommon v0.2.8 // indirect\n        github.com/mattn/go-colorable v0.1.1 // indirect\n        github.com/mattn/go-isatty v0.0.7 // indirect\n        github.com/valyala/fasttemplate v1.0.0 // indirect\n        golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a // indirect\n)\n```\n\n##### 那为什么会抛出这个错误呢？\n\n这是因为 server.go 中使用 internal package 的方法跟以前已经不同了，由于 go.mod会扫描同工作目录下所有 package 并且`变更引入方法`，必须将 helloworld当成路径的前缀，也就是需要写成 import helloworld/api，以往 GOPATH/dep 模式允许的 import ./api 已经失效，详情可以查看这个 [issue](https://github.com/golang/go/issues/26645)。\n\n3. 更新旧的package import 方式\n\n所以server.go 需要改写成：\n\n```go\npackage main\n\nimport (\n    api \"helloworld/api\"  // 这是更新后的引入方法\n    \"github.com/labstack/echo\"\n)\n\nfunc main() {\n    e := echo.New()\n    e.GET(\"/\", api.HelloWorld)\n    e.Logger.Fatal(e.Start(\":1323\"))\n}\n```\n\n> `一个小坑`：开始在golang1.11 下使用go mod 遇到过 `go build github.com/valyala/fasttemplate: module requires go 1.12` [这种错误](https://github.com/golang/go/issues/27565)，遇到类似这种需要升级到1.12 的问题，直接升级golang1.12 就好了。幸亏是在1.12 发布后才尝试的`go mod` 🤷‍♂️\n\n4. 到这里就和新创建一个项目没什么区别了\n\n\n## 使用replace替换无法直接获取的package\n\n由于某些已知的原因，并不是所有的package都能成功下载，比如：`golang.org`下的包。\n\nmodules 可以通过在 go.mod 文件中使用 replace 指令替换成github上对应的库，比如：\n\n\n```json\nreplace (\n\tgolang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a => github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a\n)\n```\n\n或者\n\n```json\nreplace golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a => github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a\n```\n\n\n## 参考链接\n\n* [Modules官方介绍](https://github.com/golang/go/wiki/Modules)\n* [Golang 1.11 新功能介紹 – Modules](https://www.lightblue.asia/golang-1-11-new-festures-modules/?doing_wp_cron=1552464864.6369309425354003906250)\n* [What are Go modules and how do I use them?](https://talks.godoc.org/github.com/myitcv/talks/2018-08-15-glug-modules/main.slide#1)\n* [go mod doesn't work for github.com/gomarkdown/markdown/html ](https://github.com/golang/go/issues/27565)\n* [再探go modules：使用与细节](https://www.cnblogs.com/apocelipes/p/10295096.html)\n* [初窥Go module](https://tonybai.com/2018/07/15/hello-go-module/)\n\n\n#### References\n\n[1] Modules官方介绍: https://github.com/golang/go/wiki/Modules\n[2] issue: https://github.com/golang/go/issues/26645\n[3] 这种错误: https://github.com/golang/go/issues/27565\n[4] Modules官方介绍: https://github.com/golang/go/wiki/Modules\n[5] Golang 1.11 新功能介紹 – Modules: https://www.lightblue.asia/golang-1-11-new-festures-modules/?doing_wp_cron=1552464864.6369309425354003906250\n[6] What are Go modules and how do I use them?: https://talks.godoc.org/github.com/myitcv/talks/2018-08-15-glug-modules/main.slide#1\n[7] go mod doesn't work for github.com/gomarkdown/markdown/html : https://github.com/golang/go/issues/27565\n[8] 再探go modules：使用与细节: https://www.cnblogs.com/apocelipes/p/10295096.html\n[9] 初窥Go module: https://tonybai.com/2018/07/15/hello-go-module/\n\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "Golang mod 入门",
        "date": "2019-03-16 11:49:35",
        "tags": [
          "golang"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "golang-mod"
    },
    {
      "content": "\n\n> 本文是《垃圾回收的算法与实现》读书笔记\n>\n> 上一篇为[《GC 标记-清除算法》](https://mp.weixin.qq.com/s/mJo5ADptfDxEVoqZjUIWTw) \n\n\n### 引用计数算法\n\n> 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。这也就是需要回收的对象。\n>\n> `引用计数算法`是对象记录自己被多少**程序**引用，引用计数为零的对象将被清除。\n>\n> `计数器`表示的是有多少程序引用了这个对象（被引用数）。计数器是无符号整数。\n\n#### 计数器的增减\n\n引用计数法没有明确启动 GC 的语句，它与程序的执行密切相关，在程序的处理过程中通过增减计数器的值来进行内存管理。\n\n\n\n##### **new_obj()** 函数\n\n与`GC标记-清除`算法相同，程序在生成新对象的时候会调用 new_obj()函数。\n\n\n\n```c\nfunc new_obj(size){\n    obj = pickup_chunk(size, $free_list)\n    \n    if(obj == NULL)\n        allocation_fail()\n    else\n        obj.ref_cnt = 1  // 新对象第一只被分配是引用数为1\n        return obj\n}\n```\n\n\n\n这里 `pickup_chunk()`函数的用法与`GC标记-清除算法`中的用法大致相同。不同的是这里返回 NULL 时，分配就失败了。这里 `ref_cnt` 域代表的是 obj 的计数器。\n\n\n\n> 在引用计数算法中，除了连接到空闲链表的对象，其他对象都是活跃对象。所以如果 pickup_chunk()返回 NULL，堆中也就没有其它大小合适的块了。\n\n\n\n##### **update_ptr()** 函数\n\nupdate_ptr() 函数用于更新指针 `ptr`，使其指向对象 obj，同时进行计数器值的增减。\n\n\n\n```c\nfunc update_ptr(ptr, obj){\n    inc_ref_cnt(obj)     // obj 引用计数+1\n    dec_ref_cnt(*ptr)    // ptr之前指向的对象(*ptr)的引用计数-1\n    *ptr = obj\n}\n```\n\n\n\n>  这里 update_ptr 为什么需要先调用 `inc_ref_cnt`，再调用`dec_ref_cnt`呢？\n>\n> 是因为有可能 *ptr和 obj 可能是同一个对象，如果先调用`dec_ref_cnt`可能会误伤。\n\n\n\n**inc_ref_cnt()**函数\n\n这里inc_ref_cnt函数只对对象 obj 引用计数+1\n\n```go\nfunc inc_ref_cnt(obj){\n    obj.ref_cnt++\n}\n```\n\n\n\n**dec_ref_cnt()** 函数\n\n这里 dec_ref_cnt 函数会把之前引用的对象进行-1 操作，如果这时对象的计数器变为0，说明这个对象是一个垃圾对象，需要销毁，那么被它引用的对象的计数器值都需要相应的-1。\n\n```go\nfunc dec_ref_cnt(obj){\n    obj_ref_cnt--\n    if(obj.ref_cnt == 0)\n        for(child : children(obj))\n            dec_ref_cnt(*child)  // 递归将被需要销毁对象引用的对象计数-1\n    reclaim(obj)\n}\n```\n\n\n\n![update_prt() 函数执行是的情况](http://media.gusibi.mobi/txUtZf4Me8iDveCpZWKaqzhnqxhuGwmSLwX8NxfJEAa3UC1D1byrEpmfLgpAXTQp)\n\n\n\n上图这里开始时，A 指向 B，第二步 A 指向了 C。可以看到通过更新，B 的计数器值变为了0，因此 B 被回收（连接到空闲链表），C 的计数器值由1变成了2。\n\n\n\n> 通过上边的介绍，应该可以看出引用计数垃圾回收的特点。\n>\n> 1. 在变更数组元素的时候会进行指针更新\n> 2. 通过更新执行计数可能会产生没有被任何程序引用的垃圾对象\n> 3. 引用计数算法会时刻监控更新指针是否会产生垃圾对象，一旦生成会立刻被回收。\n>\n> 所以如果调用 `pickup_chunk`函数返回 NULL，说明堆中所有对象都是活跃对象。\n\n\n\n#### 引用计数算法的优点\n\n1. 可立即回收垃圾\n\n   > 每个对象都知道自己的引用计数，当变为0时可以立即回收，将自己接到空闲链表\n\n2. 最大暂停时间短\n\n   > 因为只要程序更新指针时程序就会执行垃圾回收，也就是每次通过执行程序生成垃圾时，这些垃圾都会被回收，内存管理的开销分布于整个应用程序运行期间，无需挂起应用程序的运行来做，因此消减了最大暂停时间（但是增多了垃圾回收的次数）\n   >\n   > > `最大暂停时间`，因执行 GC 而暂停执行程序的最长时间。\n\n3. 不需要沿指针查找\n\n   > 产生的垃圾立即就连接到了空闲链表，所以不需要查找哪些对象是需要回收的\n\n#### 引用计数算法的缺点\n\n1. 计数器值的增减处理频繁\n\n   > 因为每次对象更新都需要对计数器进行增减，特别是被引用次数多的对象。\n\n2. 计数器需要占用很多位\n\n   > 计数器的值最大必须要能数完堆中所有对象的引用数。比如我们用的机器是32位，那么极端情况，可能需要让2的32次方个对象同时引用一个对象。这就必须要确保各对象的计数器有32位大小。也就是对于所有对象，必须保留32位的空间。\n   >\n   > 假如对象只有两个域，那么其计数器就占用了整体的1/3。\n\n3. 循环引用无法回收\n\n   > 这个比较好理解，循环引用会让计数器最小值为1，不会变为0。\n\n\n\n#### 循环引用\n\n\n\n```python\nclass Person{  // 定义 Person 类\n    string name\n    Person lover\n}\n\nlilw = new Person(\"李雷\")    // 生成 person 类的实例 lilw\nhjmmwmw = new Person(\"韩梅梅\") // 生成 person 类的实例 hjmwmw\n\nlilw.lover = hjmwmw   // lilw 引用 hjmwmw\nhjmwmw.lover = lilw   // hjmwmw 引用 lilw\n\n```\n\n\n\n像这样，两个对象相互引用，所以各个对象的计数器都为1，且这些对象没有被其他对象引用。所以计数器最小值也为1，不可能为0。\n\n\n\n### 延迟引用计数法\n\n\n\n引用计数法虽然缩小了`最大暂停时间`，但是`计数器的增减处理`特别多。为了改善这个缺点，`延迟引用计数法(Deferred Reference Counting)`被研究了出来。\n\n\n\n通过上边的描述，可以知道之所以计数器增减处理特别繁重，是因为有些增减是根引用的变化，因此我们可以让根引用的指针变化不反映在计数器上。比如我们把 `update_ptr($ptr, obj)`改写成`*$ptr = obj`，这样频繁重写对重对象中引用关系时，计数器也不需要修改。但是这有一个问题，那就是计数器并不能正确反映出对象被引用的次数，就有可能会出现，对象仍在活动，却被回收。\n\n\n\n在**延迟引用计数法**中使用`ZCT(Zero Count Table)`，来修正这一错误。\n\n> ZCT 是一个表，它会事先记录下计数器在 `dec_ref_cnt()`函数作用下变成 0 的对象。\n\n\n\n![ZCT](http://media.gusibi.mobi/R24lHD7lfMxlk4zSb5OE5gbhXy6YDtoMdjmdwMpEaX5uo_rRofrRZmqHcF5c99xD)\n\n#### dec_ref_cnt 函数\n\n在延迟引用计数法中，引用计数为0 的对象并不一定是垃圾，会先存入到 zct 中保留。\n\n```go\nfunc dec_ref_cnt(obj){\n    obj_ref_cnt--\n    if(obj.ref_cnt == 0) //引用计数为0 先存入到 $zct 中保留\n        if(is_full($zct) == TRUE) // 如果 $zct 表已经满了 先扫描 zct 表，清除真正的垃圾\n            scan_zct()\n        push($zct, obj)\n}\n```\n\n\n\n#### scan_zct 函数\n\n```python\nfunc scan_zct(){\n    for(r: $roots)\n        (*r).ref_cnt++\n    \n    for(obj : $zct)\n        if(obj.ref_cnt == 0)\n            remove($zct, obj)\n            delete(obj)\n    \n    for(r: $roots)\n        (*).ref_cnt--\n}\n```\n\n\n\n1. 第二行和第三行，程序先把所有根直接引用的计数器都进行增量。这样，来修正计数器的值。\n2. 接下来检查 `$zct` 表中的对象，如果此时计数器还为0，则说明没有任何引用，那么将对象先从 `$zct`中清除，然后调用 `delete()`回收。\n\ndelete() 函数定义如下：\n\n\n\n```python\nfunc delete(obj){\n    for(child : children(obj)) // 递归清理对象的子对象\n        (*child).ref_cnt--\n        if (*child).ref_cnt == 0 \n            delete(*child)\n    \n    reclaim(obj)\n}\n```\n\n\n\n#### new_obj() 函数\n\n除 dec_ref_cnt 函数需要调整，new_obj 函数也要做相应的修改。\n\n```go\nfunc new_obj(size){\n    obj = pickup_chunk(size, $free_list)\n    \n    if(obj == NULL) // 空间不足\n        scan_zct()  // 扫描 zct 以便获取空间\n        obj = pickup_chunk(size, $free_list) // 再次尝试分配\n        if(obj == NULL)\n            allocation_fail()  // 提示失败\n            \n     obj.ref_cnt = 1\n     return obj\n}\n```\n\n\n\n> 如果第一次分配空间不足，需要扫描 $zct，以便再次分配，如果这时空间还不足，就提示失败\n\n\n\n在延迟引用计数法中，程序延迟了根引用的计数，通过延迟，减轻了因根引用频繁变化而导致的计数器增减所带来的额外的负担。\n\n但是，延迟引用计数却不能马上将垃圾进行回收，`可立即回收垃圾`这一优点也就不存在了。`scan_zct`函数也会增加程序的最大暂停时间。\n\n\n\n### Sticky 引用计数法\n\n对于引用计数法，有一个不能忽略的部分是计数器位宽的设置。假设为了反映所有引用，计数器需要1个字（32位机器就是32位）的空间。但是这会大量的消耗内存空间。比如，2个字的对象就需要一个字的计数器。也就是计数器会使对象所占的空间增大1.5倍。\n\n\n\n`sticky 引用计数法`就是用来减少位宽的。\n\n> 如果我们为计数器的位数设为5，那么计数器最大的引用数为31，如果有超过31个对象引用，就会爆表。对于爆表，我们怎么处理呢？\n\n\n\n#### 1. 什么都不做\n\n这种处理方式对于计数器爆表的对象，再有新的引用也不在增加，当然，当计数器为0 的时候，也不能直接回收（因为可能还有对象在引用）。这样其实是会产生残留的对象占用内存。\n\n> 不过，研究表明，大部分对象其实只被引用了一次就被回收了，出现5位计数器溢出的情况少之又少。\n>\n> 爆表的对象大部分也都是重要的对象，不会轻易回收。\n>\n> 所以，什么都不做也是一个不错的办法。\n\n#### 2. 使用GC 标记-清除算法进行管理\n\n这种方法是，对于爆表的对象，使用 GC 标记-清除算法来管理。\n\n```go\nfunc mark_sweep_for_counter_overflow(){\n    reset_all_ref_cnt()\n    mark_phase()\n    sweep_phase()\n}\n```\n\n\n\n首先，把所有对象的计数器都设为0，然后进行标记和清除阶段。\n\n标记阶段代码为：\n\n```go\nfunc mark_phase(){\n    for (r: $roots)  // 先把根引用的对象推到标记栈中\n        push(*r, $mark_stack)\n    \n    while(is_empty($mark_stack) == False) // 如果堆不为空\n        obj = pop($mark_stack)\n        obj.ref_cnt++  \n        if(obj.ref_cnt == 1) // 这里必须把各个对象及其子对象堆进行标记一次\n            for(child : children(obj))\n                push(*child, $mark_stack)\n}\n```\n\n\n\n>  在标记阶段，先把根引用的对象推到标记栈中\n>\n> 然后按顺序从标记栈中取出对象，对计数器进行增量操作。\n>\n> 对于循环引用的对象来说，obj.ref_cnt >  1，为了避免无谓的 push 这里需要进行 if(obj.ref_cnt == 1) 的判断\n\n\n\n清除阶段代码为：\n\n```go\nfunc sweep_phase(){\n    sweeping = $heap_top\n    while(sweeping < $heap_end)  // 因为循环引用的所有对象都会被 push 到 head_end 所以也能被回收\n        if(sweeping.ref_cnt == 0)\n            reclaim(sweeping)\n        sweeping += sweeping.size\n}\n```\n\n\n\n在清除阶段，程序会搜索整个堆，回收计数器仍为0的对象。\n\n\n\n> 这里的 GC 标记-清除算法和上一篇[GC 标记-清除算法](https://mp.weixin.qq.com/s/mJo5ADptfDxEVoqZjUIWTw) 主要不同点如下：\n>\n> 1. 开始时将所有对象的计数器值设为0\n> 2. 不标记对象，而是对计数器进行增量操作\n> 3. 为了对计数器进行增量操作，算法对活动对象进行了不止一次的搜索。\n\n\n\n这里将 GC 标记-清除算法和引用计数法结合起来，在计数器溢出后，对象称为垃圾也不会漏掉清除。并且也能回收循环引用的垃圾。\n\n因为在查找对象时不是设置标志位而是把计数器进行增量，所以需要多次查找活动对象，所以这里的标记处理比以往的标记清除花的时间更长，吞吐量会相应的降低。\n\n\n## 参考链接\n\n* [垃圾回收的算法与实现](https://book.douban.com/subject/26821357/)\n* [《GC 标记-清除算法》](https://mp.weixin.qq.com/s/mJo5ADptfDxEVoqZjUIWTw)\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "垃圾回收算法|引用计数法",
        "date": "2018-08-12 11:15:05",
        "tags": [
          "垃圾回收",
          "算法",
          "读书笔记"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "gc-reference-counting"
    },
    {
      "content": "\n##\n\n### \n\n## 参考链接\n\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "categories": [
          "xxx",
          "xxxx"
        ],
        "date": "2018-08-12 10:21:42",
        "description": "description",
        "author": "goodspeed",
        "permalink": "/post/url-path",
        "tags": [
          "xx",
          "xxxx"
        ],
        "title": "title",
        "published": false,
        "hideInList": false,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "gc-partial-mark-sweep"
    },
    {
      "content": "\n我在 github 托管 Python 代码，然后将包发布到 Pypi，通常的操作步骤是，更新完代码将提交到 github ，然后手动将包更新到 pypi，这样比较繁琐，就想到了使用github+travis-ci 构建一个自动部署环境。\n\n\n### 注册 pypi\n\n访问[https://pypi.org](https://pypi.org) 点击`Register`注册账号，记住自己的用户名密码。\n\n### 创建 setup.py 文件\n\nsetup.py 文件放置于包的根目录，示例内容如下：\n\n```python\n#!/usr/bin/env python\nfrom setuptools import setup, find_packages\n\nwith open(\"README.md\", \"r\") as fh:\n    long_description = fh.read()\n\nwith open('requirements.txt') as f:\n    requirements = [l for l in f.read().splitlines() if l]\n\nsetup(name=\"python-weixin\",  # 项目名\n      version=\"0.3.2\",       # 版本号\n      description=\"Python Weixin API client support wechat-app\",  #简介\n      long_description=long_description,  # 长简介 这里使用的 readme 内容\n      long_description_content_type=\"text/markdown\",\n      license=\"BSD\",   # 授权\n      install_requires=requirements, # 依赖\n      author=\"gusibi\",  # 作者\n      author_email=\"xxx@gmail.com\",  # 邮箱\n      url=\"https://github.com/gusibi/python-weixin\",  # 地址\n      download_url=\"https://github.com/gusibi/python-weixin/archive/master.zip\",\n      packages=find_packages(),\n      keywords=[\"python-weixin\", \"weixin\", \"wechat\", \"sdk\", \"weapp\", \"wxapp\"],\n      zip_safe=True)\n```\n\n\n\n以上特别需要注意的是 `packages`参数，用来申明你的包里面要包含的目录，这里使用setuptools自动决定要包含哪些包。\n\n\n\n### 配置 travis-ci\n\n\n\ngithub 提供了多种集成方式，这里我们选择 Travis-ci\n\n![](http://media.gusibi.mobi/WFUXxGYuC2Vsf5A-5ogKxthVs6xR3UU69UvYt4rFTsTn6ngDLEj62Qe05tZfKhpl)\n\n\n\n选择后访问 [https://travis-ci.com/profile](https://travis-ci.com/profile)，如果是第一次使用 travis-ci 可以使用 github 账号登录，然后选择对应的 github 库激活。\n\n\n![](http://media.gusibi.mobi/bRInfNXvDr4_nkBX5hbmRdCMpTLicG2wrXgsWeBEylhKNe1SKiK8KQYeBNP5SwyT)\n\n\n\n然后在 github 代码库的根目录添加 `.travis.yml` 文件。\n\n\n\n```yml\nlanguage: python\npython:   # 指定运行环境，这里会分别在 2.7 和 3.5 运行\n  - '2.7'\n  - '3.5' \ninstall:\n  - pip install -r requirements.txt   # 安装依赖\nscript: python test_example.py  # 如果有单元测试这里应该执行单元测试\n```\n\n\n\n> script 是一个必须的命令，通常如果有单元测试的话这里应该执行单元测试\n\n#### 添加 Pypi 部署配置\n\n通过在 `.travis.yml` 中添加 deploy 模块， `Travis CI` 实现自动部署，\n\n\n\n```yml\nlanguage: python\npython:\n- '2.7'\n- '3.5'\ninstall:\n- pip install -r requirements.txt\nscript: python test_example.py\ndeploy:\n  provider: pypi\n  user: goodspeed     # pypi 用户名\n  password: password  # pypi 密码\n  on:\n    python: 2.7\n    tags: true\n    branch: master\n```\n\n\n\n在 `deploy` 部分，我们指定 `provider` 为 pypi，然后添加 `user`、`password`。\n\n在 `on` 部分我们声明一些特殊的配置，比如：\n\n* `brance: master` 意思是只有 master 分支才执行打包部署\n* `python: 2.7` 意思是只在 python 2.7 版本执行打包部署\n* `tags: true` 意思是只有在发布一个新的版本时才执行打包部署\n\n具体配置参考： [Conditional-Releases-with-on](https://docs.travis-ci.com/user/deployment#Conditional-Releases-with-on)\n\n\n\n#### 加密密码\n\n上面的配置使用的是明文密码，这样就把pypi 账号公开了，太不安全。这里推荐使用 `travis-encrypt` 加密密码。\n\n\n\n##### 安装 travis-encrypt\n\n\n\n```bash\npip install travis-encrypt\n```\n\n然后在 `.travis.yml` 所在目录执行：\n\n\n\n```bash\ntravis-encrypt --deploy gusibi python-weixin .travis.yml\nPassword: # 在这里输入pypi 密码\n```\n\n\n>这里 `gusibi` `python-weixin` 需要替换成相对应的 github username 和 repository。\n>\n>命令参考：[travis-encrypt](https://pypi.org/project/travis-encrypt/)\n\n\n\n执行完之后password 部分旧会被加密后的秘钥代替，最终 `.travis.yml` 内容如下：\n\n\n\n```yml\nlanguage: python\npython:\n- '2.7'\n- '3.5'\ninstall:\n- pip install -r requirements.txt\nscript: python test_example.py\ndeploy:\n  provider: pypi\n  user: goodspeed\n  password:\n    secure: cjQdXGKkNpwKmGgEhONtd2YR+PF44gtZgMegv5O3CRsszocaRqxcBdfwi0qz6KupLMWl/WTq+bYtzf42lpytMe7cB/CPA2sCUDEo6qyIE+Brb5J57GUhd9HIhP5F44BHKWzBnYFbgPsQ2k1ckEDJsUp5yyFvUBkQmv3+LOo9Kf492oCQlgnzaGSRtPQaG56XdLKgCZrxdtfteTalTbjQO7w/GNm5lBn4l7iY1qWiQmzFxkUuZu317yAnohdH84fq9Ozov4S3nPNSTt800HjHkXwaBzxMuJ2SJBadZAW/abCvk34IPyvxjy7upNNLq80/yvgYKzxWBklcP9LxJX2Pwk9NtTY1zUEykkwdBVxZShhBXtWDma/yWQp2RdCVZtLS4GTg4X61PMgH0iwzwzGW8LARj2ZMowQoPipUYCJ7qUfyXrxU05ypizWKIIfrqdRh8Twj9Jhyg/fAoRygCoXNtMqwSmomjkwl6f1i+6lAQENdmVKQTesP56r/olXKb4rhrOgyhj7anJd3F/SZ+g8jQFHHGLcaSkEoVXL6BFPDMxYdMRmx5HKonP9uQO74ZdeevkHK0wFzSbjqpKdVzeuYuyPiHnDyooyjGL+2BzE/Zzo5KCNEflAE22kAuAbjXCuJji7+j47QohrlYjmj2+F7NDBE5sJRp3yLJWIEPqLND/k=\n  on:\n    python: 2.7\n    tags: true\n    branch: master\n```\n\n\n\n\n\n将代码提交之后，访问 travis-ci.org 会看到已经触发了 ci ，正在构建：\n\n\n\n![](http://media.gusibi.mobi/6yydw0RZ2b26fRKzQXlV-QoRLHaOxrj04pVlFhJTULsF7OPE2Z4msVKV1fGUWkXB)\n\n\n\n> 这里有两个 job 正在同时构建，分别是 python2.7 环境和 python3.5 环境。\n\n但是这时并没有把包部署到 pypi，还需要在 `github releases 页面重新发布一个版本来触发部署`。\n\n\n\n## 参考链接\n\n* [https://github.com/romgar/5minutes/blob/master/content/articles/howto-deploy-python-package-on-pypi-with-github-and-travis.md][https://github.com/romgar/5minutes/blob/master/content/articles/howto-deploy-python-package-on-pypi-with-github-and-travis.md]\n* [https://pypi.org](https://pypi.org) \n* [https://github.com/gusibi/python-weixinn](https://github.com/gusibi/python-weixin)\n* [https://pypi.org/project/travis-encrypt/](https://pypi.org/project/travis-encrypt/)\n* [https://docs.travis-ci.com/user/deployment#Conditional-Releases-with-on](https://docs.travis-ci.com/user/deployment#Conditional-Releases-with-on)\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "使用github+travis将Python包部署到Pypi",
        "date": "2018-07-23 15:45:46",
        "tags": [
          "python",
          "后端",
          "tutorial"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "howto-deploy-python-package-on-pypi-with-github-and-travis"
    },
    {
      "content": "\n> 本文是《垃圾回收的算法与实现》读书笔记\n\n\n![](http://media.gusibi.mobi/kJ8L52gJq08Mi142RTC-wAwzbMUgwGTKue3rPKNWVrYTlvOMczGlXFvmEt1C1MRM)\n\n### 什么是GC标记-清除算法（Mark Sweep GC）\n\nGC 标记-清除算法由`标记阶段`和`清除阶段`构成。在标记阶段会把所有的活动对象都做上标记，然后在清除阶段会把没有标记的对象，也就是`非活动`对象回收。\n\n\n> `名词解释：`\n>\n> 在 GC 的世界里`对象`指的是通过应用程序利用的数据的集合。是 GC 的基本单位。一般由头（header）和域（field）构成。\n>\n> `活动对象:`能通过引用程序引用的对象就被称为活动对象。（可以直接或间接从全局变量空间中引出的对象）\n>\n> `非活动对象:`不能通过程序引用的对象呗称为非活动对象。（这就是被清除的目标）\n\n\n\n标记-清除算法的伪代码如下所示：\n\n\n\n```go\nfunc mark_sweep(){\n    mark_phase()   // 标记阶段\n    sweep_phase()  // 清除阶段\n} \n```\n\n\n\n### 标记阶段\n\n\n\n> 标记阶段就是遍历对象并标记的处理过程。\n\n标记阶段伪代码如下：\n\n```go\nfunc mark_phase(){\n    for (r : $roots)  // 在标记阶段，会给所有的活动对象打上标记\n        mark(*r)\n}\n\nfunc mark(){\n    if (obj.mark == False)\n        obj.mark = True            // 先标记找出的活动对象\n        for (child: children(obj)) // 然后递归的标记通过指针数组能访问到的对象\n            mark(*child)\n}\n```\n\n\n\n> 这里 `$root `是指针对象的起点，通过$root 可以遍历全部活动对象。\n\n下图是标记前和标记后内存中堆的状态\n\n![执行 GC 前堆的状态](http://media.gusibi.mobi/E66QEbTr9uxUcn-_4HAJbjhIiPrO_gZ-RQcn6Wiiu8iQnP9wlA5xZ5KACvMLvEK-)\n\n![执行 GC 后堆的状态](http://media.gusibi.mobi/7_BEou-9LxGREQm2CyB18NZLRMh43R8g6xY2UwXfHXw7eyYwpaSvSWPndirCzuHv)\n\n\n\n### 清除阶段\n\n> 在清除阶段，collector 会遍历整个堆，回收没有打上标记的对象（垃圾），使其能再次利用。\n\nsweep_phase() 函数伪代码实现如下：\n\n\n\n```go\nfunc sweep_phase(){\n    sweeping = $heap_start            // 首先将堆的首地址赋值给 sweeping\n    while(sweeping < $head_end){\n        if(sweeping.mark == TRUE)\n            // 如果是标记状态就设为 FALSE，如果是活动对象，还会在标记阶段被标记为 TRUE\n            sweeping.mark == FALSE    \n        else:\n            sweeping.next = $free_list   // 将非活动对象 拼接到 $free_list 头部位置\n            $free_list = sweeping\n        sweeping += sweeping.size\n    }     \n}\n```\n\n\n\n> `size` 域指的是存储对象大小的域，在对象头中事先定义。\n>\n> `next` 域只在生成空闲链表以及从空闲链表中取出分块时才会用到。\n>\n> `分块(chunk)` 这里是指为利用对象而事先准备出来的空间。\n>\n> 内存中区块的块生路线为 `分块-->活动对象-->垃圾—>分块-->... `\n\n在清除阶段我们会把非活动回收再利用。回收对象就是把对象作为分块，连接到被称为`空闲链表`的单向链表。之后再分配空间时只需遍历这个空闲链表就可以了找到分块了。\n\n下图是清除阶段结束后堆的状态：\n\n![清除阶段结束后堆的状态](http://media.gusibi.mobi/S1zEqC5TqtGnlofpDBf-8u_hBaLrtqyMT_vpEePlcVTVwVaJ_zwLFdXnIGbKfGBT)\n\n\n\n### 分配\n\n> 回收垃圾的目的是为了能再次分配\n\n当程序申请分块时，怎样才能把大小合适的分块分配给程序呢？\n\n分配伪代码如下：\n\n\n\n```go\nfunc new_obj(size){  // size 是需要的分块大小\n    chunk = pickup_chunk(size, $free_list)  // 遍历 $free_list 寻找大于等于 size 的分块\n    if(chunk != NULL)  \n        return chunk\n    else\n        allocation_fail()   // 如果没找到大小合适的分块 提示分配失败\n}\n```\n\n\n\n`pickup_chunk()`函数不止返回和 size 大小相同的分块，也会返回大于 size 大小的分块（这时会将其分割成 size 大小的分块和去掉 size 后剩余大小的分块，并把剩余部分还给空闲链表）。\n\n\n\n> 分配策略有三种 `First-fit`,`Best-fit`,`Worst-fit`\n>\n> `First-fit`：发现大于等于 size的分块立刻返回\n>\n> `Best-fit`：找到大小和 size 相等的分块再返回\n>\n> ``Worst-fit`：找到最大的分块，然后分割成 size 大小和剩余大小（这种方法容易产生大量小的分块\n\n\n\n#### 合并\n\n根据分配策略的不同，分配过程中会出现大量小的分块，如果分块是连续的，我们就可以把小分块合并成一个大的分块，`合并是在清除阶段完成的`，包含了合并策略的清除代码如下：\n\n\n\n```go\nfunc sweep_phase(){\n    sweeping = $heap_start            // 首先将堆的首地址赋值给 sweeping\n    while(sweeping < $head_end){\n        if(sweeping.mark == TRUE)\n            // 如果是标记状态就设为 FALSE，如果是活动对象，还会在标记阶段被标记为 TRUE\n            sweeping.mark == FALSE    \n        else:\n            if(sweeping == $free_list + $free_list.size)  // 堆的地址正好和空闲链表大小相同\n                $free_list.size += sweeping.size\n            else\n                sweeping.next = $free_list   // 将非活动对象 拼接到 $free_list 头部位置\n                $free_list = sweeping\n        sweeping += sweeping.size\n    }     \n}\n```\n\n\n\n> `$heap_end = $heap_start + HEAP_SIZE`\n>\n> 所以这里`sweeping == $free_list + $free_list.size`可以理解为需要清除的堆的地址正好和空闲链接相邻\n\n\n\n### 优/缺 点\n\n#### 优点\n\n* 实现简单\n* 与`保守式 GC 算法`兼容\n\n\n\n#### 缺点\n\n* 碎片化严重（由上面描述的分配算法可知，容易产生大量小的分块\n* 分配速度慢（由于空闲区块是用链表实现，分块可能都不连续，每次分配都需要遍历空闲链表，极端情况是需要遍历整个链表的。\n* 与`写时复制技术`不兼容\n\n> 写时复制（copy-on-write）是众多 UNIX 操作系统用到的内存优化的方法。比如在 Linux 系统中使用 fork() 函数复制进程时，大部分内存空间都不会被复制，只是复制进程，只有在内存中内容被改变时才会复制内存数据。\n>\n> 但是如果使用标记清除算法，这时内存会被设置`标志位`，就会频繁发生不应该发生的复制。\n\n### 多个空闲链表\n\n上面所说的标记清除算法只用到了一个空闲链表对大小不一的分块统一处理。但这样做每次都需要遍历一遍来寻找大小合适的分块，非常浪费时间。\n\n这里我们使用多个空闲链表的方法来存储非活动对象。比如：将两个字的分块组成一个空闲链表，三个字的分块组成另一个空闲链表，等等。。\n\n这时，如果需要分配三个字的分块，那我们只需要查询对应的三个字的空闲链表就可以了。\n\n> 到底需要制造多少个空闲链表呢？\n>\n> 因为通常程序不会 申请特别大的分块，所以我们通常给分块大小设置一个上限，比如100，大于这个上限的组成一个特殊的空闲链表。这样101 个空闲链表就够了。\n\n### 位图标记\n\n在单纯的 GC 标记-清除算法中，用于标记的位是被分配到对象头中的。算法是把对象和头一并处理，但这和写时复制不兼容。\n\n`位图标记`法是只收集各个对象的标志位并表格化，不喝对象一起管理。在标记的时候不在对象的头里设置位置，而是在特定的表格中置位。\n\n\n\n![位图标记](http://media.gusibi.mobi/hEEQsacTXvFE97jV14u-Jc-ghhrDKg6TY_w20Mvizspa1cmEQFvtV5ADazkBAOy0)\n\n\n\n> 在位图标记中重要的是，位图表格中位的位置要和堆里的各个对象切实对应。一般来说堆中的一个字会分配到一个位。\n\n\n\n位图标记中 mark() 函数的伪代码实现如下：\n\n\n\n```go\nfunc mark(obj){\n    obj_num = (obj - $heap_start) / WORD_LENGTH  // WORD_LENGTH 是一个常量，表示机器中一个字的位宽\n    index = obj_num / WORD_LENGTH\n    offset = obj_num % WORD_LENGTH\n    \n    if ($bitmap_tbl[index] & (1 << offset)) == 0\n        $bitmap_tbl[index] |= (1 << offset)\n        for (child: children(obj)) // 然后递归的标记通过指针数组能访问到的对象\n            mark(*child)\n}\n```\n\n\n\n这里 obj_num 指的是从位图表格前面数，obj 的标志位在第几个。例如 E 的 obj_num 是8。\n\nobj_num 除以 WORD_LENGTH 得到的商 index 以及余数 offset 来分别表示位图表格的行编号和列编号。\n\n\n\n#### 优点\n\n* 和写时复制技术兼容\n* 清除更高效（只需要遍历位图表格就可以，清除的时候也只需要清除表格中的标志位）。\n\n### 延迟清除\n\n清除操作所花费的时间和堆的大小成正比，堆越大，标记-清除 动作花费的时间越长，也就越影响程序的运行。\n\n延迟清除（lazy sweep）是缩短清除操作花费导致程序最大暂停时间的方法。\n\n> `最大暂停时间`，因执行 GC 而暂停执行程序的最长时间。\n\n延迟清除中 new_obj() 函数会在分配的时候调用 `lazy_sweep()`函数，进行清除操作。如果它能用清除操作来分配分块，就会返回分块，如果不能分配分块，就会执行标记操作。然后重复这个步骤，直到找到分块或者`allocation_fail`\n\n\n\n通过延迟清除法可以缩减程序的暂停时间，不过延迟效果并不是均衡的。比如下图这种刚标记完堆的情况：\n\n![堆里垃圾分布不均的情况](http://media.gusibi.mobi/yOIKeU-sQUx1m4C56IcH__oPcq3aR7zKxokJ0kiaqGfBCT9UNqUGnXUalUmcLM9S)\n\n\n\n这时，活动对象和非活动对象都是相邻分布，如果程序在活动对象周围开始清除，那它找到的对象都是活动对象不可清除，只能不停遍历，暂停时间就会变长。\n\n## 参考链接\n\n* [垃圾回收的算法与实现](https://book.douban.com/subject/26821357/)\n* [画说 Ruby 与 Python 垃圾回收](https://mp.weixin.qq.com/s/4aEUixY3cioH2OXTgYX0Mg)\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "垃圾回收算法|GC标记-清除算法",
        "date": "2018-07-21 03:15:05",
        "tags": [
          "垃圾回收",
          "算法",
          "读书笔记"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "gc-mark-sweep"
    },
    {
      "content": "\n> gRPC 一开始由 google 开发，是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。 本文通过一个简单的 Hello World 例子来向您介绍 gRPC 。\n\n\n### gRPC 是什么？\n\ngRPC 也是基于以下理念：定义一个*服务*，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个*存根*能够像服务端一样的方法。\n\n在 gRPC 里*客户端*应用可以像调用本地对象一样直接调用另一台不同的机器上*服务端*应用的方法，使得我们能够更容易地创建分布式应用和服务。\n\n![gPRC](http://media.gusibi.mobi/t21KzebjklAAMbWL7Aos4KYZLkkbjrGwZkNLUwxrT7Igz1D5Ea2xCJ0W0EOPrgXK)\n\n\ngRPC 客户端和服务端可以在多种环境中运行和交互，并且可以用任何 gRPC 支持的语言来编写。\n\n\n> gRPC 支持 C++ Java Python Go Ruby C# Node.js PHP Dart 等语言\n\n\ngRPC 默认使用 *protocol buffers*，这是 Google 开源的一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。\n\n### 安装 Google Protocol Buffer\n\n#### 方法一（建议使用）\n\n\n\n参考文档：[gRPC Python Quickstart](https://grpc.io/docs/quickstart/python.html)\n\n\n\n##### 1. 安装 gRPC\n\n```bash\n\npython -m pip install grpcio\n# 或者\nsudo python -m pip install grpcio\n\n# 在 El Capitan OSX 系统下可能会看到以下报错\n\n$ OSError: [Errno 1] Operation not permitted: '/tmp/pip-qwTLbI-uninstall/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/six-1.4.1-py2.7.egg-info'\n\n# 可以使用以下命令\npython -m pip install grpcio --ignore-installed\n```\n\n\n\n##### 2. 安装 gRPC tools\n\n\n\nPython gPRC tools 包含 protocol buffer 编译器和用于从 `.proto` 文件生成服务端和客户端代码的插件\n\n```bash\npython -m pip install grpcio-tools\n```\n\n\n\n#### 方法二：\n\n在 github 页面[protobuf Buffers](https://github.com/google/protobuf/releases)可以下载二进制源码，下载后执行以下命令安装：\n\n```bash\ntar -zxvf protobuf-all-3.5.1.tar\ncd protobuf-all-3.5.1\n./configure\nmake\nmake install\n\n>> protoc --version\nlibprotoc 3.5.1  # 安装成功\n```\n\n因为是要使用 Protobuf + Python 测试，所以还要安装 python运行环境。[protobuf Buffers python 文档](https://github.com/google/protobuf/tree/master/python)\n\n```bash\n# 打开 python 目录\ncd python\npython setup.py install  # 安装 python 运行环境\n```\n\n\n\n### Protobuf 基本使用\n\n#### 定义一个消息类型\n\n先来看一个非常简单的例子。假设你想定义一个“搜索请求”的消息格式，每一个请求含有一个查询字符串、你感兴趣的查询结果所在的页数，以及每一页多少条查询结果。可以采用如下的方式来定义消息类型的.proto文件了：\n\n```protobuf\nsyntax = \"proto3\";  // 声明使用 proto3 语法\n\nmessage SearchRequest {\n  string query = 1;  // 每个字段都要指定数据类型\n  int32 page_number = 2; // 这里的数字2 是标识符，最小的标识号可以从1开始，最大到2^29 - 1, or 536,870,911。不可以使用其中的[19000－19999]\n  int32 result_per_page = 3; // 这里是注释，使用 //\n}\n```\n\n\n\n* 文章的第一行指定了你正在使用 proto3 语法：如果不指定，编译器会使用 proto2。`这个指定语法必须是文件的非空非注释的第一行`。\n* `SearchRequest`消息格式有三个字段，在消息中承载的数据分别对应于每一个字段。其中每个字段都有一个名字和一种类型。\n* 向.proto文件添加注释，可以使用C/C++/java风格的`双斜杠(//)` 语法格式。\n* 在消息体中，每个字段都有唯一的一个数字标识符。这些标识符用来在消息的二进制格式中识别各个字段，一旦开始使用就不能再改变。\n\n> [1,15]之内的标识号在编码的时候会占用一个字节。[16,2047]之内的标识号则占用2个字节。所以应该为那些频繁出现的消息元素保留 [1,15]之内的标识号。切记：要为将来有可能添加的、频繁出现的标识号预留一些标识号。\n\n\n\n#### 指定字段规则\n\n所指定的消息字段修饰符必须是如下之一：\n\n- singular：一个格式良好的消息应该有0个或者1个这种字段（但是不能超过1个）。\n\n- repeated：在一个格式良好的消息中，这种字段可以重复任意多次（包括0次）。重复的值的顺序会被保留。\n\n  在proto3中，repeated的标量域默认情况虾使用packed。\n\n  \n\n  ```protobuf\n  message Test4 {\n    repeated int32 d = 4 [packed=true];\n  }\n  ```\n\n  \n\n#### 数值类型\n\n一个标量消息字段可以含有一个如下的类型——该表格展示了定义于.proto文件中的类型，以及与之对应的、在自动生成的访问类中定义的类型：\n\n| .proto Type | Notes                                                        | C++ Type | Java Type  | Python Type[2] | Go Type | Ruby Type                 |\n| ----------- | ------------------------------------------------------------ | -------- | ---------- | -------------- | ------- | ------------------------------ |\n| double      |                                                              | double   | double     | float          | float64 | Float                     |\n| float       |                                                              | float    | float      | float          | float32 | Float                     |\n| int32       | 使用变长编码，对于负值的效率很低，如果你的域有可能有负值，请使用sint64替代 | int32    | int        | int       | int32   | Fixnum 或者 Bignum（根据需要） |\n| uint32      | 使用变长编码                                                 | uint32   | int        | int/long       | uint32  | Fixnum 或者 Bignum（根据需要） | \n| uint64      | 使用变长编码                                                 | uint64   | long       | int/long       | uint64  | Bignum                      |\n| sint32      | 使用变长编码，这些编码在负值时比int32高效的多                | int32    | int        | int            | int32   | Fixnum 或者 Bignum（根据需要） |\n| sint64      | 使用变长编码，有符号的整型值。编码时比通常的int64高效。      | int64    | long       | int/long       | int64   | Bignum                         |\n| fixed32     | 总是4个字节，如果数值总是比总是比228大的话，这个类型会比uint32高效。 | uint32   | int        | int            | uint32  | Fixnum 或者 Bignum（根据需要） | \n| fixed64     | 总是8个字节，如果数值总是比总是比256大的话，这个类型会比uint64高效。 | uint64   | long       | int/long       | uint64  | Bignum                      |\n| sfixed32    | 总是4个字节                                                  | int32    | int        | int            | int32   | Fixnum 或者 Bignum（根据需要） |\n| sfixed64    | 总是8个字节                                                  | int64    | long       | int/long       | int64   | Bignum                      |\n| bool        |                                                              | bool     | boolean    | bool           | bool    | TrueClass/FalseClass      |\n| string      | 一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本。         | string   | String     | str/unicode    | string  | String (UTF-8)                 |\n| bytes       | 可能包含任意顺序的字节数据。                                 | string   | ByteString | str            | []byte  | String (ASCII-8BIT)           |\n\n\n\n#### 默认值\n\n当一个消息被解析的时候，如果被编码的信息不包含一个特定的singular元素，被解析的对象锁对应的域被设置位一个默认值，对于不同类型指定如下：\n\n- 对于strings，默认是一个空string\n\n- 对于bytes，默认是一个空的bytes\n\n- 对于bools，默认是false\n\n- 对于数值类型，默认是0\n\n- 对于枚举，默认是第一个定义的枚举值，必须为0;\n\n- 对于消息类型（message），域没有被设置，确切的消息是根据语言确定的，详见[generated code guide](https://developers.google.com/protocol-buffers/docs/reference/overview?hl=zh-cn)\n\n  对于可重复域的默认值是空（通常情况下是对应语言中空列表）。\n\n\n\n#### 嵌套类型\n\n你可以在其他消息类型中定义、使用消息类型，在下面的例子中，Result消息就定义在SearchResponse消息内，如：\n\n\n\n```protobuf\nmessage SearchResponse {\n  message Result {\n    string url = 1;\n    string title = 2;\n    repeated string snippets = 3;\n  }\n  repeated Result results = 1;\n}\n```\n\n\n\n在 message SearchResponse 中，定义了嵌套消息 `Result`，并用来定义`SearchResponse`消息中的`results`域。\n\n\n\n### Protobuf 文件编译\n\n\n\n#### 从.proto文件生成了什么？\n\n\n\n当用protocol buffer编译器来运行.proto文件时，编译器将生成所选择语言的代码，这些代码可以操作在.proto文件中定义的消息类型，包括获取、设置字段值，将消息序列化到一个输出流中，以及从一个输入流中解析消息。\n\n- 对C++来说，编译器会为每个.proto文件生成一个.h文件和一个.cc文件，.proto文件中的每一个消息有一个对应的类。\n- 对Java来说，编译器为每一个消息类型生成了一个.java文件，以及一个特殊的Builder类（该类是用来创建消息类接口的）。\n- 对Python来说，有点不太一样——Python编译器为.proto文件中的每个消息类型生成一个含有静态描述符的模块，，该模块与一个元类（metaclass）在运行时（runtime）被用来创建所需的Python数据访问类。\n- 对go来说，编译器会位每个消息类型生成了一个.pd.go文件。\n- 对于Ruby来说，编译器会为每个消息类型生成了一个.rb文件。\n- javaNano来说，编译器输出类似域java但是没有Builder类\n- 对于Objective-C来说，编译器会为每个消息类型生成了一个pbobjc.h文件和pbobjcm文件，.proto文件中的每一个消息有一个对应的类。\n- 对于C#来说，编译器会为每个消息类型生成了一个.cs文件，.proto文件中的每一个消息有一个对应的类。\n\n\n\n### Python gRPC 示例\n\n#### 编译\n\n这里我们用Python 编译一下，看得到什么：\n\n```protobuf\n// 文件名 hello.proto\nsyntax = \"proto3\";\n\npackage hello;\n\n// The greeting service definition.\nservice Greeter {\n  // Sends a greeting\n  rpc SayHello (HelloRequest) returns (HelloReply) {}\n}\n\n// The request message containing the user's name.\nmessage HelloRequest {\n  string name = 1;\n}\n\n// The response message containing the greetings\nmessage HelloReply {\n  string message = 1;\n}\n```\n\n\n\n使用以下命令编译:\n\n```bash\npython -m grpc_tools.protoc -I./ --python_out=. --grpc_python_out=. ./hello.proto\n```\n\n生成了两个文件：\n\n* `hello_pb2.py` 此文件包含生成的 request(`HelloRequest`) 和 response(`HelloReply`) 类。\n* `hello_pb2_grpc.py` 此文件包含生成的 客户端(`GreeterStub`)和服务端(`GreeterServicer`)的类。\n\n源码地址为[https://github.com/grpc/grpc/blob/master/examples/protos/helloworld.proto](https://github.com/grpc/grpc/blob/master/examples/protos/helloworld.proto)\n\n\n\n虽然现在已经生成了服务端和客户端代码，但是我们还需要手动实现以及调用的方法。\n\n\n\n#### 创建服务端代码\n\n创建和运行 `Greeter` 服务可以分为两个部分：\n\n- 实现我们服务定义的生成的服务接口：做我们的服务的实际的“工作”的函数。\n\n- 运行一个 gRPC 服务器，监听来自客户端的请求并传输服务的响应。\n\n  \n\n在当前目录，打开文件 greeter_server.py，实现一个新的函数：\n\n```python\nfrom concurrent import futures\nimport time\n\nimport grpc\n\nimport hello_pb2\nimport hello_pb2_grpc\n\n_ONE_DAY_IN_SECONDS = 60 * 60 * 24\n\n\nclass Greeter(hello_pb2_grpc.GreeterServicer):\n\t# 工作函数\n    def SayHello(self, request, context):\n        return hello_pb2.HelloReply(message='Hello, %s!' % request.name)\n\n\ndef serve():\n    # gRPC 服务器\n    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))\n    hello_pb2_grpc.add_GreeterServicer_to_server(Greeter(), server)\n    server.add_insecure_port('[::]:50051')\n    server.start()  # start() 不会阻塞，如果运行时你的代码没有其它的事情可做，你可能需要循环等待。\n    try:\n        while True:\n            time.sleep(_ONE_DAY_IN_SECONDS)\n    except KeyboardInterrupt:\n        server.stop(0)\n\nif __name__ == '__main__':\n    serve()\n```\n\n#### 更新客户端代码\n\n在当前目录，打开文件 greeter_client.py，实现一个新的函数：\n\n```python\nfrom __future__ import print_function\n\nimport grpc\n\nimport hello_pb2\nimport hello_pb2_grpc\n\n\ndef run():\n    channel = grpc.insecure_channel('localhost:50051')\n    stub = hello_pb2_grpc.GreeterStub(channel)\n    response = stub.SayHello(hello_pb2.HelloRequest(name='goodspeed'))\n    print(\"Greeter client received: \" + response.message)\n\n\nif __name__ == '__main__':\n    run()\n```\n\n\n\n> 对于返回单个应答的 RPC 方法（\"response-unary\" 方法），gRPC Python 同时支持同步（阻塞）和异步（非阻塞）的控制流语义。对于应答流式 RPC 方法，调用会立即返回一个应答值的迭代器。调用迭代器的 `next()` 方法会阻塞，直到从迭代器产生的应答变得可用。\n\n\n\n#### 运行代码\n\n\n\n1. 首先运行服务端代码\n\n```bash\npython greeter_server.py\n```\n\n2. 然后运行客户端代码\n\n```bash\npython greeter_client.py\n# output\n\nGreeter client received: Hello, goodspeed!\n```\n\n> [源码地址: https://github.com/grpc/grpc/tree/master/examples/python](https://github.com/grpc/grpc/tree/master/examples/python)\n\n## 参考链接\n\n* [gRPC 官方文档中文版](https://doc.oschina.net/grpc?t=56831)\n* [Protobuf3语言指南](https://blog.csdn.net/u011518120/article/details/54604615)\n* [Google Protocol Buffer 的使用和原理](https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html)\n* [gRPC Python Quickstart](https://grpc.io/docs/quickstart/python.html)\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "Python gRPC 入门",
        "date": "2018-06-07 15:49:17",
        "tags": [
          "python",
          "tutorial",
          "grpc",
          "小程序"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "hello_grpc"
    },
    {
      "content": "\n>Newrelic 是APM（Application Performance Management）（应用性能管理/监控）解决方案提供商。项目中，通常用它来追踪应用的性能。最近看了一下 newrelic-python-agent 源码，这是查看源码过程中的一些记录。\n \n### 目录结构\nnewrelic 目录结构如下：\n\n```bash\nnewrelic\n├── admin  # 常用命令\n├── api    # 探针\n├── bootstrap\n├── common  \n├── core\n├── extras\n│   └── framework_django\n│       └── templatetags\n├── hooks   # 数据库 web 各个库的一些探针\n│   ├── framework_tornado\n│   ├── framework_tornado_r3\n│   └── framework_tornado_r4\n├── network\n├── packages\n│   ├── requests\n│   │   └── packages\n│   │       ├── chardet\n│   │       └── urllib3\n│   │           ├── packages\n│   │           │   └── ssl_match_hostname\n│   │           └── util\n│   └── wrapt\n└── samplers\n```\n\n### 命令\n\n使用 `newrelic-admin help` 可以列出所有命令：\n\n```bash\n$ newrelic-admin help\n\nUsage: newrelic-admin command [options]\n\nType 'newrelic-admin help <command>'for help on a specific command.\n\nAvailable commands are:\n  generate-config\n  license-info\n  license-key\n  local-config\n  network-config\n  record-deploy\n  run-program\n  run-python\n  server-config\n  validate-config\n```\n\n通过 setup.py 代码可以知道：\n\n```python\nif with_setuptools:\n    kwargs['entry_points'] = {\n            'console_scripts': ['newrelic-admin = newrelic.admin:main'],\n            }\n```\n\n`newrelic-admin` 命令调用的是 `newrelic.admin:main`，这是代码的入口。首先看一下 `newrelic/admin/`目录。\n\n#### admin\n\n> admin 目录是 newrelic-admin help 列出的命令脚本所在目录。 \n\n包含文件如下：\n\n```bash\n$ tree\nadmin\n├── __init__.py\n├── __main__.py\n├── debug_console.py\n├── generate_config.py\n├── license_info.py\n├── license_key.py\n├── local_config.py\n├── network_config.py\n├── record_deploy.py\n├── run_program.py\n├── run_python.py\n├── server_config.py\n└── validate_config.py\n```\n\n`__init__.py` 的 main 函数 是命令执行的入口。\n\n`__init__.py` 文件中代码\n\n```python\nload_internal_plugins()\nload_external_plugins()\n```\n\n用来加载 `_builtin_plugins` 中定义的命令。 \n\n#### run_program\n\n首先看下 run_program 命令，这个命令使用方式如下：\n\n```bash\nnewrelic-admin run-program your command\n```\n\n`newrelic/admin/run_program.py` 中 `run_program` 函数有装饰器 command，用来定义将命令以及相关说明添加到字典 `_commands`。\n\n在 `run_program` 中代码：\n\n```python\nroot_directory = os.path.dirname(root_directory)\nboot_directory = os.path.join(root_directory, 'bootstrap')\n\nif 'PYTHONPATH' in os.environ:\n    path = os.environ['PYTHONPATH'].split(os.path.pathsep)\n    if not boot_directory in path:\n        python_path = \"%s%s%s\" % (boot_directory, os.path.pathsep, os.environ['PYTHONPATH'])\n\nos.environ['PYTHONPATH'] = python_path\n```\n\n可以发现`newrelic/bootstrap/sitecustomize.py` 文件被加入到了 PYTHONPATH。\n\n> python 解释器初始化的时候会自动 import `PYTHONPATH` 下存在的 `sitecustomize` 和 `usercustomize` 模块。\n\n之后的功能比较简单，就是调用 os 模块执行命令。\n\n现在看下`newrelic/bootstrap/sitecustomize.py` 代码。\n\n在 这个文件的最后一行：\n\n```python\nnewrelic.config.initialize(config_file, environment)\n```\n\n这里用来初始化newrelic，具体代码在 `newrelic/config.py`文件。\n\n以下是initialize函数：\n\n```python\ndef initialize(config_file=None, environment=None, ignore_errors=None,\n            log_file=None, log_level=None):\n\n    if config_file is None:\n        config_file = os.environ.get('NEW_RELIC_CONFIG_FILE', None)\n\n    if environment is None:\n        environment = os.environ.get('NEW_RELIC_ENVIRONMENT', None)\n\n    if ignore_errors is None:\n        ignore_errors = newrelic.core.config._environ_as_bool(\n                'NEW_RELIC_IGNORE_STARTUP_ERRORS', True)\n\n    _load_configuration(config_file, environment, ignore_errors,\n            log_file, log_level)  # 加载配置\n\n    if _settings.monitor_mode or _settings.developer_mode:\n        _settings.enabled = True\n        _setup_instrumentation()  # 设置探针\n        _setup_data_source()  # TODO\n        _setup_extensions()   # TODO\n        _setup_agent_console()   # TODO\n    else:\n        _settings.enabled = False\n```\n\n其中第14行 `_load_configuration` 是用来加载 newrelic 的相关配置。比如：日志目录、各种环境变量、秘钥、newrelic host 地址等等。 \n\n`_setup_instrumentation() 中 _process_module_builtin() 用来设置探针。\n\n数据库、外部请求 等监控模块都位于 hook 目录下，通过 `_process_module_builtin` 函数将进程与监控模块进行绑定，包括 django 的主要模块以及常用的数据库等。在核心模块执行的时候触发监控，将数据回传到 `api.time_trace` 模块进行处理。\n\n而对于硬件信息的检测则由 `commo.system_info` 进行。\n\n### newrelic run_program 初始化过程\n\n以下为 flask 应用初始化过程，其它应用类似：\n\n1. `newrelic/admin/__init__.py main()`\n2. `newrelic/admin/run_program.py` 代码中会把 `newrelic/bootstrap/sitecustomize.py` 添加到 `PYTHONPATH`,python 解释器初始化的时候会自动 import `PYTHONPATH` 下存在的 `sitecustomize` 和 `usercustomize` 模块\n3. `newrelic/bootstrap/sitecustomize.py` 调用 `newrelic.config.initialize()`，`_setup_instrumentation()` 函数被调用，`_process_module_builtin`会把需要 wrap 的包先添加到_import_hooks。\n4. `newrelic/config.py` 中  `sys.meta_path.insert(0, newrelic.api.import_hook.ImportHookFinder())` 执行\n5. `newrelic/api/import_hook.py  ImportHookFinder().find_model()`\n6. `newrelic/api/import_hook.py  _ImportHookLoader() or _ImportHookChainedLoader()`\n7. `newrelic/api/import_hook.py  _notify_import_hooks`  `callable` 为 `newrelic/config _module_import_hook  _instrument`\n8. `newrelic/hooks/framework_flask.py instrument_flask_app`\n9. `newrelic/api/web_transaction.py wrap_wsgi_application`\n10. `newrelic/common/object_wrapper.py wrap_object`\n\n在代码中，使用到了第三方包 `wrapt`，以下是 wrapt 的官方描述（[文档地址](https://wrapt.readthedocs.io/en/latest/index.html))。\n\n> wrapt模块的目的是为Python提供一个透明的对象代理，它可以作为构建函数包装器和装饰函数的基础。wrapt 提供了一个简单易用的decorator工厂，利用它你可以简单地创建decorator，并且在任何情况下都可以正确地使用它们。\n\n`wrapt`简单示例如下：\n\n```python\nimport wrapt\n# 普通装饰器\n@wrapt.decorator\ndef pass_through(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\n@pass_through\ndef function():\n    pass\n\n# 带参数的装饰器\nimport wrapt\n\ndef with_arguments(myarg1, myarg2):\n    @wrapt.decorator\n    def wrapper(wrapped, instance, args, kwargs):\n        return wrapped(*args, **kwargs)\n    return wrapper\n\n@with_arguments(1, 2)\ndef function():\n    pass\n```\n\n要实现decorator，需要首先定义一个装饰器函数。这将在每次调用修饰函数时调用。装饰器函数需要使用四个位置参数:\n\n- wrapped - The wrapped function which in turns needs to be called by your wrapper function.\n- instance - The object to which the wrapped function was bound when it was called.\n- args - The list of positional arguments supplied when the decorated function was called.\n- kwargs - The dictionary of keyword arguments supplied when the decorated function was called.\n\n具体使用参考文档吧。 [文档地址](https://wrapt.readthedocs.io/en/latest/index.html)\n\n------\n\nnewrelic 源码仔细看下去，太...复杂了。下一篇再分析一个 flask 请求到结束探针工作的完整过程吧。\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "newrelic python agent 源码分析-1",
        "date": "2018-05-16 12:17:13",
        "tags": [
          "python",
          "后端",
          "weixin",
          "development"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "newrelic_source_code_1"
    },
    {
      "content": "\n> 上一篇我们了解了golang 的变量、函数和基本类型，这一篇将介绍一下控制流\n\n现在我们看一个复杂点的例子:\n\n### fibonacci(递归版)\n\n``` go\npackage main\nimport \"fmt\"\n\nfunc main() {\n    result := 0\n    for i := 0; i <= 10; i++ {\n\t     result = fibonacci(i)\n\t     fmt.Printf(\"fibonacci(%d) is: %d\\n\", i, result)\n\t  }\n}\n\nfunc fibonacci(n int) (res int) {\n    if n <= 1 {\n        res = 1\n\t   } else {\n\t       res = fibonacci(n-1) + fibonacci(n-2)\n\t   }\n\treturn\n}\n\n    // outputs\n\n    fibonacci(0) is: 1\n    fibonacci(1) is: 1\n    fibonacci(2) is: 2\n    fibonacci(3) is: 3\n    fibonacci(4) is: 5\n    fibonacci(5) is: 8\n    fibonacci(6) is: 13\n    fibonacci(7) is: 21\n    fibonacci(8) is: 34\n    fibonacci(9) is: 55\n    fibonacci(10) is: 89\n```\n\n\n* for i := 0; i <= 10; i++ {} 第7行是一个循环结构 这里for 循环是一个控制流\n\n## 控制流\n### For\n\nGo 只有一种循环接口-- `for 循环`\n\nFor 支持三种循环方式,包括类 while 语法\n\n#### 1 基本for循环 支持初始化语句\n``` go\ns := \"abc\"\nfor i, n := 0, len(s); i < n; i++ {\n\t// i, n 为定义的变量 只在for 循环内作用\n    println(s[i])\n}\n```\n\n*基本的 for 循环包含三个由分号分开的组成部分：*\n\n* 初始化语句：在第一次循环执行前被执行\n* 循环条件表达式：每轮迭代开始前被求值\n* 后置语句：每轮迭代后被执行\n\n#### 2 替代 while (n > 0) {}\n\nC 的 while 在 Go 中叫做 for\n\n``` go\nn := len(s)\n// 循环初始化语句和后置语句都是可选的。\nfor n > 0 { // 等同于 for (; n > 0;) {}\n    println(s[n])\n    n--\n}\n```\n\n#### 3 死循环\n```go\n    for { // while true\n        println(s)\n    }\n```\n\n### IF…ELSE\n\n> 就像 for 循环一样，Go 的 if 语句也不要求用 ( ) 将条件括起来，同时， { } 还是必须有的\n\n* 条件表达式必须是布尔类型，可省略条件表达式括号\n* 支持初始化语句,可定义代码块局部变量\n* 代码块左大括号必须在条件表达式尾部\n\n```go\nx := 0\n\n// if x > 10  // Error: missing condition in if statement(左大括号必须在条件表达式尾部)\n// {\n// }\n\nif x > 10{\n    ...\n}else{\n    ...\n}\n\nif n := \"abc\"; x > 0 {  // 初始化语句(在这里是定义变量)\n\tprintln(n[2])\n} else if x < 0 {\n\tprintln(n[1])\n} else {\n    println(n[0])     // 局部变量 n 有效范围是 整个 if/else 块\n}\n```\n\n> if 语句定义的变量作用域仅在if范围之内(包含else语句)\n> 不支持三元操作符 \"a > b ? a : b\"\n\n以上是上段代码出现的两个控制流，剩下的控制流还有\n\n* Switch\n* Range\n* Goto, Break, Continue, defer\n\n### Switch\n\nswitch 语句用于选择执行，语法如下：\n\n```go\n    switch optionalStatement; optionalExpression{\n\t\tcase expressionList1: block1\n\t\t...\n\t\tcase expressionListN: blockN\n\t\tdefault: blockD\n\t}\n```\n\n先看一个例子:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n)\n\nfunc main() {\n\tfmt.Print(\"Go runs on \")\n\tswitch os := runtime.GOOS; os { // 将 os 与 case 条件匹配\n\tcase \"darwin\":\n\t\tfmt.Println(\"OS X.\")\n\tcase \"linux\":\n\t\tfmt.Println(\"Linux.\")\n\tcase \"plan9\", \"openbsd\": // 多个条件命中其一即可(OR)\n\t\tfmt.Println(\"plan9 | openbsd\")\n\tdefault:\n\t\t// freebsd, openbsd,\n\t\t// plan9, windows...\n\t\tfmt.Printf(\"%s.\", os)\n\t}\n}\n\n```\n\n* 如果有可选语句声明, 分号是必要的, 无论后边的可选表达式语句是否出现(如果可选语句没有出现默认为true)\n* 每一个case 语句必须要有一个表达式列表，多个用分号隔开\n* switch 语句自上而下执行，当匹配成功后执行case分支的代码块，执行结束后退出switch\n```go\nswitch i {\ncase 0: // 空分支，只有当 i == 0 时才会进入分支 相当于 \"case 0: break;\"\ncase 1:\n    f() // 当 i == 0 时函数不会被调用\n}\n```\n\n* 如果想要在执行完每个分支的代码后还继续执行后续的分支代码，可以使用fallthrough 关键字达到目的\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc switch1(n int) {\n\tswitch { // 这里用的是没有条件的switch 语句会直接执行\n\tcase n == 0:\n\t\tfmt.Println(0)\n\t\tfallthrough  // fallthrough 需放在 case 块结尾，可用 break 阻止\n\tcase n == 1: // 如果匹配到0 这里会继续执行\n\t\tfmt.Println(1)\n\tcase n == 2: // fallthrough 不会对这里有作用\n\t\tfmt.Println(2)\n\tdefault:\n\t\tfmt.Println(\"default\")\n\t}\n}\n\nfunc main() {\n\tswitch1(0)\n}\n# output\n0\n1\n```\n* 用 default 可以指定当其他所有分支都不匹配的时候的行为\n\n```go\n    switch i {\n    \tcase 0:\n    \tcase 1:\n    \t\tf()\n    \tdefault:\n    \t\tg()  // 当i不等于0 或 1 时调用\n    }\n```\n\n### Range\n\n> Range 类似迭代器的操作，返回(索引，值)或(健，值)\n\n它可以迭代任何一个集合（包括字符串、数组、数组指针、切片、字典、通道）\n\n基本语法如下:\n\n```go\ncoll := 3string[\"a\", \"b\", \"c\"]\nfor ix, val := range coll {\n   ...\n}\n\n// 允许返回单值\n\nfor ix := range coll {\n    println(ix, coll[ix])\n}\n\n// 也可以使用 _ 忽略\n\nfor _, val := range coll {\n    println(val)\n}\n\n// 也可以只迭代，不返回。可用来执行清空 channel 等操作\n\nfor range coll {\n    ...\n}\n```\n\nval 始终为集合中对应索引的值拷贝，因此它一般只具有只读性质，对它所做的任何修改都不会影响到集合中原有的值（译者注：如果 val 为指针，则会产生指针的拷贝，依旧可以修改集合中的原值\n一个字符串是 Unicode 编码的字符（或称之为 rune）集合，因此您也可以用它迭代字符串\n\n下面是每种数据类型使用range时 ix和val 的值\n\n| date type   | ix      | value    | 值类型        |\n| ----------- | ------- | -------- | ------------- |\n| string      | index   | s[index] | unicode, rune |\n| array/slice | index   | s[index] |               |\n| map         | key     | m[index] |               |\n| channel     | element |          |               |\n\n> range 会复制目标数据。字符串、切片基本结构是个很小的结构体，而字典、通道本身是指针封装，复制成本很小，无需专门优化。\n>\n> 如果是数组，可改成数组指针或者切片类型。\n\n### Break continue\n\nbreak 和 continue 都可在多级嵌套循环中跳出\n\n> break 可用于 for、switch、select语句，终止整个语句块执行\n>\n> continue 仅能 于 for 循环，终止后续操作，立即进入下一轮循环。\n\n### goto\n\ngoto 语句可以配合标签（label）形式的标识符使用，即某一行第一个以冒号`:`结尾的单词，标签区分大小写。\n\n```go\npackage main\n\nfunc main() {\n    i:=0\n    HERE:\n\t    print(i)\n\t\ti++\n        if i==5 {\n\t        return\n\t    }\n        goto HERE\n}\n# output 01234\n```\n\n> 使用标签和 goto 语句是不被鼓励的：它们会很快导致非常糟糕的程序设计，而且总有更加可读的替代方案来实现相同的需求。\n\nfor、switch 或 select 语句都可以配合标签（label）形式的标识符使用\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\nLABEL1:\n    for i := 0; i <= 5; i++ {\n\t\tfor j := 0; j <= 5; j++ {\n\t\t\tif j == 4 {\n\t\t\t\tcontinue LABEL1\n\t\t\t}\n\t\t\tfmt.Printf(\"i is: %d, and j is: %d\\n\", i, j)\n\t\t}\n\t}\n}\n\n```\n\n> continue 语句指向 LABEL1，当执行到该语句的时候，就会跳转到 LABEL1 标签的位置\n\n### defer\n\ndefer 语句会延迟函数的执行直到上层函数返回\n\n延迟调用的参数会立刻生成，但是在上层函数返回前函数都不会被调用\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tdefer fmt.Println(\"world\")\n\n\tfmt.Println(\"hello\")\n}\n\n// output\nhello\nworld\n```\n\n*defer 栈*\n\n延迟的函数调用被压入一个栈中。当函数返回时， 会按照后进先出的顺序调用被延迟的函数调用。\ndefer 常用来定义简单的方法\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"counting\")\n\n\tfor i := 0; i < 10; i++ {\n\t\t\tdefer fmt.Println(i)\n\t\t}\n\n\t\tfmt.Println(\"done\")\n}\n// 可以想一下会输出什么\n// 代码执行 https://tour.go-zh.org/flowcontrol/13\n```\n\n*关键字 defer 允许我们进行一些函数执行完成后的收尾工作，例如：*\n\n* 关闭文件流：\n\n    // open a file defer file.Close()\n\n* 解锁一个加锁的资源\n\n    mu.Lock() defer mu.Unlock()\n\n* 打印最终报告\n\n    printHeader() defer printFooter()\n\n* 关闭数据库链接\n\n\t// open a database connection defer disconnectFromDB()\n\n合理使用 defer 语句能够使得代码更加简洁。\n\n下面的代码展示了在调试时使用 defer 语句的手法\n\n```go\npackage main\n\nimport (\n\t\"io\"\n    \"log\"\n)\n\nfunc func1(s string) (n int, err error) {\n    defer func() {\n\t        log.Printf(\"func1(%q) = %d, %v\", s, n, err)\n\t    }()\n    return 7, io.EOF\n}\n\nfunc main() {\n    func1(\"Go\")\n}\n\n// 输出\nOutput: 2016/04/25 10:46:11 func1(\"Go\") = 7, EOF\n```\n\n更多defer 的用法([https://blog.go-zh.org/defer-panic-and-recover](https://blog.go-zh.org/defer-panic-and-recover))\n\n### 参考链接\n\n[Go 指南](https://tour.go-zh.org/flowcontrol/1)\n[The way to go -- 控制结构](https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/05.0.md)\n[Effective Go](https://golang.org/doc/effective_go.html)\n\n到这里简单的控制流用法讲解就结束了\n\n下节将会是golang 数据结构部分, 会用到的代码为\n\n### fibonacci(内存版)\n\n```go\n package main\n\n import (\n     \"fmt\"\n     \"time\"\n )\n\n const LIM = 41\n\n var fibs [LIM]uint64\n\n func main() {\n     var result uint64 = 0\n     start := time.Now()\n     for i := 0; i < LIM; i++ {\n         result = fibonacci(i)\n         fmt.Printf(\"fibonacci(%d) is: %d\\n\", i, result)\n     }\n     end := time.Now()\n     delta := end.Sub(start)\n     fmt.Printf(\"longCalculation took this amount of time: %s\\n\", delta)\n }\n func fibonacci(n int) (res uint64) {\n     // memoization: check if fibonacci(n) is already known in array:\n     if fibs[n] != 0 {\n         res = fibs[n]\n         return\n     }\n     if n <= 1 {\n         res = 1\n     } else {\n         res = fibonacci(n-1) + fibonacci(n-2)\n     }\n     fibs[n] = res\n     return\n }\n```\n\n------\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "Golang 学习笔记-2：控制流",
        "date": "2018-04-17 15:49:35",
        "tags": [
          "golang",
          "读书笔记"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "golang-learning-note-2"
    },
    {
      "content": "\n## 变量&函数\n\n最近在学习golang，写下学习笔记提升记忆。\n为了看起来不是那么枯燥，本学习笔记采用分析代码的形式。\n\n首先搬出我们最经典的第一段代码:\n\n### hello world\n\n```go\n    package main // 0\n\n    import \"fmt\" // 1实现格式化的 I/O\n\n    /* Print something */ // 2\n    func main() { // 3\n    \tfmt.Println(\"Hello, world; or καλημε ́ρα κóσμε; orこんにちは 世界\") // 4\n    }\n```\n\n首先我们要认识到\n\n> 每个Go 程序都是由包组成，程序的运行入口是包main\n\n1. 首行这个是必须的。所有的 Go 文件以 `package something` 开头,对于独立运行的执行文件必须是 `package main`;\n2. 这是说需要将fmt加入到main。不是main 的包被称为库 末尾以 `//` 开头的内容是单行注释 Package fmt包含有格式化I/O函数，类似于C语言的printf和scanf\n3. 这也是注释，表示多行注释。\n4. package main 必须首先出现,紧跟着是 import。在 Go 中,package 总是首先出现, 然后是 import,然后是其他所有内容。当 Go 程序在执行的时候,首先调用的函数 是 main.main(),这是从 C 中继承而来。这里定义了这个函数\n5. 调用了来自于 fmt 包的函数打印字符串到屏幕。字符串由 \" 包裹,并且可以包含非 ASCII 的字符。这里使用了希腊文和日文、中文\"\n\n### 编译和运行代码\n\n构建 Go 程序的最佳途径是使用 go 工具。 构建 helloworld 只需要:\n\n```\n    1. go build helloworld.go\n    # 结果是叫做 helloworld 的可执行文件。\n    2. ./helloworld\n    # Hello, world; or καλημε ́ρα κóσμε; or こんにちは世界\n```\n\n\n### 变量\n\nGo 是静态类型语言，不能在运行期改变变量类型。\n\n变量如果不提供初始化值将自动初始化为零值。如果提供初始化值，可省略变量类型，由编译器自动推断。\n\n```go\n    var x int\n    // 使用关键字 var 定义变量, 跟函数的参数列表一样，类型在后面。\n    var c, python, java bool\n    // 多个相同类型的变量可以写在一行。\n    var f float32 = 1.6\n    var i, j int = 1, 2\n    // 变量定义可以包含初始值，每个变量对应一个。\n    var s = \"abc\"\n    // 如果初始化是使用表达式，则可以省略类型；变量从初始值中获得类型。\n```\n\n变量在定义时没有明确的初始化时会赋值为*零值* 。\n\n零值是：\n\n* 数值类型为 0 ，\n* 布尔类型为 false ，\n* 字符串为 \"\" （空字符串）。\n\n在函数内部,可用更简略的 \":=\"  式定义变量。\n\n```go\n    func main() {\n        n, s := 12, \"Hello, World!\"\n        println(s, n)\n    }\n```\n\n> 函数外的每个语句都必须以关键字开始（ var 、 func 、等等）， := 结构不能使用在函数外。\n\n可一次定义多个变量。\n\n```go\n    var x, y, z int\n    var s, n = \"abc\", 123\n    var (\n    \ta int\n    \tb float32\n    )\n\n    func main() {\n        n, s := 0x1234, \"Hello, World!\"\n        println(x, s, n)\n    }\n```\n\n一个特殊的变量名是 \\_(下划线)。任何赋给它的值都被丢弃。在这个例子中,将 35 赋值给 b,同时丢弃 34。\n\n```go\n    _, b := 34, 35\n```\n\nGo 的编译器会对声明却未使用的变量报错\n\n```go\n    var s string // 全局变量没问题。\n\n    func main() {\n        i := 0 // Error: i declared and not used。(可使  \"_ = i\" 规避)\n    }\n```\n\n定义完之后的变量可以被重新赋值 比如第8行，将计算结果赋值给result。\n\n### 常量\n\n> 常量值必须是编译期可确定的数字、字符串、布尔值。\n\n常量的定义与变量类似，只不过使用 const 关键字\n\n```go\n    const x, y int = 1, 2\n    const s = \"Hello, World!\"\n    // 多常量初始化 // 类型推断\n    // 常量组\n    const (\n    \ta, b = 10, 100\n    \tc bool = false\n    )\n\n    func main() _{\n    \tconst x = 'xxx'      // 未使用局部常量不会引发编译错误\n    }\n```\n\n在常量中，如果不提供类型和初始化值，那么被看作和上一常量相同\n\n```go\n    const (\n\t\ts = \"abc\"\n\t\tx           // x = \"abc\"\n\t)\n```\n\n#### 变量值的引用\n\n通常情况下 go 语言的`变量持有相应的值`。\n对于`通道`、`函数`、`方法`、`映射`以及`切片`的引用变量，它们持有的都是`引用`，也既是`保存指针的变量`。\n\n**值在传递给函数或者方法的时候会被复制一次**\n\n不同类型参数所占空间如下：\n\n|类型        | 占用空间   | \n|:-------   |:-----  |\n|bool       |类型占1~8个字节\n|传递字符串   |占 16个字节（64位）或者8个字节（32位）\n|传递切片     |占 16个字节（64位）或者12个字节（32位）\n|传递指针     |占 8个字节（64位）或者4个字节（32位）\n\n> `数组`是按值传递的，所以传递大数组代价较大 可用切片代替\n\n`变量是赋给内存块的名字，该内存块用于保存特定的数据类型`。\n\n`指针是指保存了另一个变量内存地址的变量`。创建的指针用来指向另一个某种类型的变量。\n为了便于理解，我们看以下两段代码。\n\n```go\nx := 3    y := 22\n// 变量 x, y 为int型 分别赋值 3   22  内存地址 0xf840000148   0xf840000150\nx == 3  &&  y == 22\n```\n\n```go\npi := &x\n\n// 变量pi 为 *int(指向int型变量的指针)   在这里我们将变量x的内存地址赋值给pi，即pi 保存了另一个变量的内存地址（这也是指针定义）\n\npi == 3 && x == 3 && y == 22  \nx++\n\n// x + 1 此时 x==4 pi 指向x的内存地址 所以\n\npi == 4 && x == 4 && y == 22\n\n*pi++\n\n// *pi ++ 意为着pi指向的值增加\n*pi == 5 & x == 5 && y == 22\n\npi := &y\n\n//pi 指向y的内存地址\n*pi == 22 && x == 5 && y == 22\n\n*pi++\n\n// *pi++ 意为着pi指向的值增加\n\n*pi == 23 && x == 5 && y == 23\n```\n\n### 基本类型\n\nGo 有明确的数字类型命名, 支持 Unicode, 支持常用数据结构\n\n|类型          | 长度   | 默认值| 说明|\n|:-------      |:-----  | :---- | :----   |\n|bool          | 1      | false |\n|byte          | 1      | 0     | unit8\n|rune          | 4      | 0     | int32 的别名 代表一个Unicode 码\n|int, unit     | 4 或 8 | 0     | 32 或 64\n|int8, unit8   | 1      | 0     | -128 ~ 127, 0~255\n|int16, unit16 | 2      | 0     | -32768 ~ 32767, 0 ~ 65535\n|int32, unit32 | 4      | 0     | -21亿~ 21亿, 0 ~ 42亿\n|int64, unit64 | 8      | 0     |\n|float32       | 4      | 0.0   |\n|float64       | 8      | 0.0   |\n|complex64     | 8      |       |\n|complex128    | 16     |       |\n|unitptr       | 4或8   |       | 足以存储指针的unit32 或unit64 整数\n|array         |        |       | 值类型\n|struct        |        |       | 值类型\n|string        |        | \"\"    | UTF-8 字符串\n|slice         |        | nil   | 引用类型\n|map           |        | nil   | 引用类型\n|channel       |        | nil   | 引用类型\n|interface     |        | nil   | 接口\n|function      |        | nil   | 函数\n\n> `int`，`uint` 和 `uintptr` 类型在32位的系统上一般是32位，而在64位系统上是64位。当你需要使用一个整数类型时，你应该首选 `int`，仅当有特别的理由才使用定长整数类型或者无符号整数类型。\n> 引用类型包括 `slice`、`map` 和 `channel`。它们有复杂的内部结构,除了申请内存外,还需要初始化相关属性\n\n### 类型转换\n\n**go `不支持` 隐式的类型转换**\n\n> 使用表达式 T(v) 将值 v 转换为类型 T 。\n\n```go\nvar b byte = 100\n// var n int = b // Error: cannot use b (type byte) as type int in assignment\nvar n int = int(b) // 显式转换\n\n```\n\n**不能将其他类型当 bool 值使用**\n\n```go\na := 100\nif a {                  // Error: non-bool a (type int) used as if condition\n    println(\"true\")\n}\n```\n\n### 函数\n\n首先看下面这段代码\n\n```go\n    package main\n\n    import \"fmt\"\n\n    func add(x int, y int) int {\n    \treturn x + y\n    }\n\n    func main() {\n    \tfmt.Println(add(42, 13))\n    }\n```\n\n#### 函数定义\n\n> 使用关键字 func 定义函数,左大括号不能另起一行\n\ngolang中符合规范的函数一般写成如下的形式：\n\n```go\n    func functionName(parameter_list) (return_value_list) {\n       …\n    }\n\n    // parameter_list 是参数列表\n    // return_value_list 是返回值列表 下边有详细的讲解\n```\n\n#### 函数的特性\n\n* 无需声明原型。 (1)\n* 支持不定长变参。\n* 支持多返回值。\n* 支持命名返回参数。\n* 支持匿名函数和闭包。\n* 不支持 嵌套 (nested)、重载 (overload) 和 默认参数 (default parameter)\n\n```go\n    func test(x int, y int, s string) (r int, s string) { // 类型相同的相邻参数可合并\n        n := x + y                                    // 多返回值必须用括号。\n        return n, fmt.Sprintf(s, n)\n    }\n```\n\n> 关键字 `func` 用于定义一个函数\n> `test` 是你函数的名字\n> int 类型的变量 x, y 和 string 类型的变量 s 作为`输入参数`参数用`pass-by-value`方式传递,意味着它们会被复制\n> 当`两个或多个连续的函数命名参数是同一类型`，则除了最后一个类型之外，其他都可以省略。\n\n在这个例子中：\n```go\nx int, y int\n```\n被缩写为\n```go\nx, y int\n```\n\n`变量` r 和 s 是这个函数的`命名返回值`。在 Go 的函数中可以返回多个值。\n如果不想对返回的参数命名,只需要提供类型:(int, string)。 如果`只有一个返回值`，可以省略圆括号。如果函数是一个子过程,并且没有任何返回值,也可以省略这些内容。\n函数体。注意 return 是一个语句,所以包裹参数的括号是可选的。\n不定长参数其实就是slice，只能有一个，且必须是最后一个。\n\n```go\n    func test(s string, n ...int) string {\n        var x int\n    \t\tfor _, i := range n {\n    \t\t\t x += i\n    \t\t}\n    \treturn fmt.Sprintf(s, x)\n    }\n    // 使用slice 做变参时，必须展开\n    func main() {\n        s := []int{1, 2, 3}\n        println(test(\"sum: %d\", s...))\n    }\n```\n\n> 函数是第一类对象,可作为参数传递\n\n就像其他在 Go 中的其他东西一样,函数也是值而已。它们可以像下面这样赋值给变量:\n\n```go\n    func main() {\n        a := func() {                  // 定义一个匿名函数,并且赋值给 a\n    \t\tprintln(\"Hello\")\n    \t}                              // 这里没有 ()\n        a()                            // 调用函数\n    }\n```\n\n如果使用 fmt.Printf(\"\\%T\\n\", a) 打印 a 的类型,输出结果是 func()\n\n#### 返回值\n\n函数可以返回任意数量返回值\n\nGo 函数的返回值或者结果参数可以指定一个名字,并且像原始的变量那样使用,就像 输入参数那样。如果对其命名,在函数开始时,它们会用其类型的零值初始化\n\n```go\n    package main\n\n    import \"fmt\"\n\n    func swap(x, y string) (string, string) {\n    \treturn y, x\n    }\n\n    func main() {\n    \ta, b := swap(\"hello\", \"world\")\n    \tfmt.Println(a, b)\n    }\n\n    /*\n       函数可以返回任意数量返回值\n       swap 函数返回了两个字符串\n    */\n\n```\n\nGo 的返回值可以被命名，并且就像在函数体开头声明的变量那样使用。\n\n```go\n    package main\n\n    import \"fmt\"\n\n    func split(sum int) (x, y int) { // 初始化返回值为 x,y\n    \tx = sum * 4 / 9              // x,y 已经初始化，可以直接赋值使用\n    \ty = sum - x\n    \treturn                       // 隐式返回x,y(裸返回)\n    }\n\n    func main() {\n    \tfmt.Println(split(17))\n    }\n\n    /*\n       在长的函数中这样的裸返回会影响代码的可读性。\n    */\n```\n\n> 有返回值的函数,必须有明确的return 语句,否则会引发编译错误\n\n### 名词解释\n\n函数原型\n\n> `函数声明`由函数返回类型、函数名和形参列表组成。形参列表必须包括形参类型,但是不必对形参命名。这三个元素被称为函数原型,函数原型描述了函数的接口\n`函数原型`类似函数定义时的函数头，又称函数声明。为了能使函数在定义之前就能被调用，C++规定可以先说明函数原型，然后就可以调用函数。函数定义可放在程序后面。 由于函数原型是一条语句，因此函数原型必须以分号结束。函数原型由函数返回类型、函数名和参数表组成，它与函数定义的返回类型、函数名和参数表必须一致。函数原型必须包含参数的标识符（对函数声明而言是可选的）\n注意：`函数原型与函数定义`必须一致，否则会引起连接错误。\n\n## 下节预告\n\n变量和函数部分暂时这些，有更新还会补充。下一篇将会是控制流。\n将会用到的代码为:\n\n```go\n    package main\n\n    import \"fmt\"\n\n    func main() {\n        result := 0\n        for i := 0; i <= 10; i++ {\n          result = fibonacci(i)\n          fmt.Printf(\"fibonacci(%d) is: %d\\n\", i, result)\n       }\n    }\n\n    func fibonacci(n int) (res int) {\n        if n <= 1 {\n            res = 1\n    \t   } else {\n    \t       res = fibonacci(n-1) + fibonacci(n-2)\n    \t   }\n    \treturn\n    }\n```\n\n## 参考链接\n\n* [Go 指南](https://tour.go-zh.org/basics/4)\n* [The way to go -- 变量](https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/04.4.md)\n* [Effective Go](https://golang.org/doc/effective_go.html)\n\n------\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "Golang 学习笔记-1：变量&函数",
        "date": "2018-02-22 12:45:22",
        "tags": [
          "golang",
          "读书笔记"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "golang-learning-note-1"
    },
    {
      "content": "\n\n> `场景：`现在需要开发一个前后端分离的应用，后端采用 RESTful API 最为方便，但是如果这个后端服务会在一天中的某些时候有高并发的情况，使用什么样的架构最为简单呢？\n\n\n刚思考这个问题的时候我想到的解决方案可能有以下几种：\n\n* 使用CDN内容分发网络，减少主服务器的压力\n\n* 使用LVS服务器负载均衡\n\n* 使用缓存\n\n* 硬件层 提高带宽，使用SSD 硬盘，使用更好的服务器\n\n* 代码层，优化代码（使用性能更好的语言等\n\n  ​\n\n但以上的几个方法都需要关注服务器的存储和计算资源，以便随时调整以满足更高的性能，并且高并发的请求也是分时段的，配置了更高性能的服务器在访问量变低的时候也是资源浪费。\n\n\n\n这个时候可以使用 FaaS（Functions as a Service） 架构，跟传统架构不同在于，他们运行于无状态的容器中，可以由事件触发，短暂的，完全被第三方管理，功能上FaaS就是不需要关心后台服务器或者应用服务，只需关心自己的代码即可。其中AWS Lambda是目前最佳的FaaS实现之一。\n\n\n\n## AWS Lambda\n\nAWS Lambda 是一项计算服务，使用时无需预配置或管理服务器即可运行代码。AWS Lambda 只在需要时执行代码并自动缩放。借助 AWS Lambda，几乎可以为任何类型的应用程序或后端服务运行代码，而且无需执行任何管理。现在 AWS Lambda 支持 Node.js、Java、C# 和 Python。\n\n\n\n### 使用场景\n\n\n\nLambda 常见的应用场景有以下几种：\n\n* 将Lambda 作为事件源用于 AWS 服务（比如音频上传到 s3后，触发 Lambda 音频转码服务，转码音频文件 \n* 通过 HTTPS (Amazon API Gateway) 实现的按需 Lambda 函数调用（配合 API Gateway创建简单的微服务\n* 按需 Lambda 函数调用（使用自定义应用程序构建您自己的事件源）\n* 计划的事件（比如每天晚上12点生成报表发送到指定邮箱\n\n\n\n下图是将Lambda 作为事件源用于 AWS 服务案例的一个执行流程图：\n\n\n\n![](<http://media.gusibi.mobi/oXCMUsm_ZNoPkU5g5aa0OcXvvBo9_-TAB3xqUFlB4ktJlzakD_E9IA-3gQu85_QO>)\n\n\n\n1. 用户将对象上传到 S3 存储桶（对象创建事件）。\n2. Amazon S3 检测到对象创建事件。 \n3. Amazon S3 调用在存储桶通知配置中指定的 Lambda 函数。 \n4. AWS Lambda 通过代入您在创建 Lambda 函数时指定的执行角色来执行 Lambda 函数。\n5. Lambda 函数执行。\n\n\n\n这篇文章主要介绍 将 Lambda 作为事件源用于 AWS 服务 和 配合 API Gateway 创建简单的微服务。\n\n\n\n### 如何使用 Lambda\n\n\n接下来将使用一个案例介绍如何使用 Lambda。\n\n\n\n#### 将 AWS Lambda 与 Amazon API Gateway 结合使用（按需并通过 HTTPS）\n\n\n\n##### 步骤 1：设置 AWS 账户和 AWS CLI\n\n* [注册 AWS 账户并在该账户中创建管理员用户](https://docs.aws.amazon.com/zh_cn/lambda/latest/dg/setting-up.html)\n* [设置 AWS Command Line Interface (AWS CLI)](https://docs.aws.amazon.com/zh_cn/lambda/latest/dg/setup-awscli.html)\n\n##### 步骤 2：创建 HelloWorld Lambda 函数和探索控制台\n\n###### 创建 Hello World Lambda 函数\n\n1. 登录 AWS 管理控制台并打开 AWS Lambda 控制台。\n2. 选择 **Get Started Now**。（仅当未创建任何 Lambda 函数时，控制台才显示 **Get Started Now** 页面。如果您已创建函数，则会看到 **Lambda > Functions** 页面。在该列表页面上，选择 **Create a Lambda function** 转到 **Lambda > New function** 页面。下图是这种情况\n\n![](<http://media.gusibi.mobi/jgJKvz3ArQBbZqp5-F78j_2jmUThAsViZBWtLhIUcPigMyNrfP40RfLpYTsPzKyw>)\n\n\n\n3. 这里选择从头开始创作，填写函数名、选择角色，点击创建函数\n4. 配置创建好的Lambda函数\n\n![](<http://media.gusibi.mobi/uxR1UPvYab9pvHs3lCMGBeih8kHopl1pkm5zvDbSBSZCczcufvzaTHmh1lI7O_rU>)\n\n\n> 需要注意的是：处理程序填写部分为  代码文件名+文件中函数名，这里我们文件名lambda_function， 函数名是 lambda_handler，处理程序部分填写为 lambda_function.lambda_handler。\n\n5. 添加触发器，这里我们选择API Gateway ，在配置部分选择之前配置好的 API，点击添加。然后保存函数\n\n![](<http://media.gusibi.mobi/qJ8heUNoZuUw_Qkt3uw1q2ZYFlzGAneB6AdBnyV7TKrQFTsCI79buo2WnhwGCcjH>)\n\n##### 测试AWS Lambda + Amazon API Gateway\n\n登录 aws 控制台，打开 API Gateway，选择我们刚刚选用的 API，点击测试，我们将会看到以下输出\n\n![](http://media.gusibi.mobi/S3dppxZIKbOf83UOPNEiEwKEvMw7n_Mng0Wk3PTrA8REa1lv-CPnRBg6BM8HkxMw)\n\n\n详细信息可以参考 官方文档（https://docs.aws.amazon.com/zh_cn/lambda/latest/dg/getting-started.html）\n\n通过上面的步骤，我们了解了如何使用一个 Lambda 函数，现在我们看下如何构建 Lambda 函数。\n\n\n\n### 如何构建Lambda\n\n#### 创建 Lambda 函数\n\n在创建 Lambda 函数时，需要指定一个*处理程序*（此处理程序是代码中的函数），AWS Lambda 可在服务执行代码时调用它。在 Python 中创建处理程序函数时，使用以下一般语法结构。\n\n\n```python\ndef handler_name(event, context): \n    ...\n    return some_value\n```\n\n在该语法中，需要注意以下方面：\n\n- `event` - AWS Lambda 使用此参数将事件数据传递到处理程序。此参数通常是 Python `dict` 类型。它也可以是 `list`、`str`、`int`、`float` 或 `NoneType` 类型。 \n\n- `context` - AWS Lambda 使用此参数向处理程序提供运行时信息。此参数为 `LambdaContext` 类型。\n\n- （可选）处理程序可返回值。返回的值所发生的状况取决于调用 Lambda 函数时使用的调用类型：\n\n  - 如果使用 `RequestResponse` 调用类型（同步执行），AWS Lambda 会将 Python 函数调用的结果返回到调用 Lambda 函数的客户端（在对调用请求的 HTTP 响应中，序列化为 JSON）。例如，AWS Lambda 控制台使用 `RequestResponse` 调用类型，因此当您使用控制台调用函数时，控制台将显示返回的值。\n\n    如果处理程序返回 `NONE`，AWS Lambda 将返回 null。\n\n  - 如果使用 `Event` 调用类型（异步执行），则丢弃该值。 \n\n\n\n#### context对象\n\n\n\n在执行 Lambda 函数时，它可以与 AWS Lambda 服务进行交互以获取有用的运行时信息，例如：\n\n- AWS Lambda 终止您的 Lambda 函数之前的剩余时间量（超时是 Lambda 函数配置属性之一）。\n- 与正在执行的 Lambda 函数关联的 CloudWatch 日志组和日志流。\n- 返回到调用了 Lambda 函数的客户端的 AWS 请求 ID。可以使用此请求 ID 向 AWS Support 进行任何跟进查询。 \n- 如果通过 AWS 移动软件开发工具包调用 Lambda 函数，则可了解有关调用 Lambda 函数的移动应用程序的更多信息。\n\n\n\n##### Context 对象方法 (Python)\n\ncontext 对象提供了以下方法：\n\n###### get_remaining_time_in_millis()\n\n返回在 AWS Lambda 终止函数前剩余的执行时间（以毫秒为单位）。 \n\n\n##### Context 对象属性 (Python)\n\n\ncontext 对象提供了以下属性：\n\n###### function_name\n\n正在执行的 Lambda 函数的名称。\n\n###### function_version\n\n正在执行的 Lambda 函数版本。如果别名用于调用函数，`function_version` 将为别名指向的版本。\n\n###### invoked_function_arn\n\nARN 用于调用此函数。它可以是函数 ARN 或别名 ARN。非限定的 ARN 执行 `$LATEST` 版本，别名执行它指向的函数版本。 \n\n###### memory_limit_in_mb\n\n为 Lambda 函数配置的内存限制（以 MB 为单位）。您在创建 Lambda 函数时设置内存限制，并且随后可更改此限制。\n\n###### aws_request_id\n\n与请求关联的 AWS 请求 ID。这是返回到调用了 `invoke` 方法的客户端的 ID。 注意如果 AWS Lambda 重试调用（例如，在处理 Kinesis 记录的 Lambda 函数引发异常的情况下）时，请求 ID 保持不变。\n\n###### log_group_name\n\nCloudWatch 日志组的名称，可从该日志组中查找由 Lambda 函数写入的日志。\n\n###### log_stream_name\n\nCloudWatch 日志流的名称，可从该日志流中查找由 Lambda 函数写入的日志。每次调用 Lambda 函数时，日志流可能会更改，也可能不更改。如果 Lambda 函数无法创建日志流，则该值为空。当向 Lambda 函数授予必要权限的执行角色未包括针对 CloudWatch Logs 操作的权限时，可能会发生这种情况。\n\n###### identity\n\n通过 AWS 移动软件开发工具包进行调用时的 Amazon Cognito 身份提供商的相关信息。它可以为空。identity.cognito_identity_ididentity.cognito_identity_pool_id\n\n###### client_context\n\n通过 AWS 移动软件开发工具包进行调用时的客户端应用程序和设备的相关信息。它可以为空。\n\n* client.installation_id\n* client.app_title\n* client.app_version_name\n* client.app_version_code\n* client.app_package_name\n* custom – 由移动客户端应用程序设置的自定义值的 dict。\n* env – 由 AWS 开发工具包提供的环境信息的 dict。\n\n##### 示例\n\n查看以下 Python 示例。它有一个函数，此函数也是处理程序。处理程序通过作为参数传递的 `context` 对象接收运行时信息。 \n\n```python\nfrom __future__ import print_function\n\nimport time\ndef get_my_log_stream(event, context):       \n    print(\"Log stream name:\", context.log_stream_name)\n    print(\"Log group name:\",  context.log_group_name)\n    print(\"Request ID:\",context.aws_request_id)\n    print(\"Mem. limits(MB):\", context.memory_limit_in_mb)\n    # Code will execute quickly, so we add a 1 second intentional delay so you can see that in time remaining value.\n    time.sleep(1) \n    print(\"Time remaining (MS):\", context.get_remaining_time_in_millis())\n```\n\n\n\n此示例中的处理程序代码只打印部分运行时信息。每个打印语句均在 CloudWatch 中创建一个日志条目。如果您使用 Lambda 控制台调用函数，则控制台会显示日志。\n\n\n\n#### 日志记录\n\n\n\n您的 Lambda 函数可包含日志记录语句。AWS Lambda 将这些日志写入 CloudWatch。如果您使用 Lambda 控制台调用 Lambda 函数，控制台将显示相同的日志。\n\n以下 Python 语句生成日志条目：\n\n- `print` 语句。\n- `logging` 模块中的 `Logger` 函数（例如，`logging.Logger.info` 和 `logging.Logger.error`）。\n\n`print` 和 `logging.*` 函数将日志写入 CloudWatch Logs 中，而 `logging.*` 函数将额外信息写入每个日志条目中，例如时间戳和日志级别。\n\n\n\n##### 查找日志\n\n可查找 Lambda 函数写入的日志，如下所示：\n\n- 在 AWS Lambda 控制台中 - AWS Lambda 控制台中的 ** Log output**  部分显示这些日志。 \n\n- 在响应标头中，当您以编程方式调用 Lambda 函数时 - 如果您以编程方式调用 Lambda 函数，则可添加 `LogType`参数以检索已写入 CloudWatch 日志的最后 4 KB 的日志数据。AWS Lambda 在响应的 `x-amz-log-results` 标头中返回该日志信息。有关更多信息，请参阅[Invoke](https://docs.aws.amazon.com/zh_cn/lambda/latest/dg/API_Invoke.html)。\n\n  如果您使用 AWS CLI 调用该函数，则可指定带有值 `Tail` 的 ` --log-type parameter` 来检索相同信息。\n\n- 在 CloudWatch 日志中 - 要在 CloudWatch 中查找您的日志，您需要知道日志组名称和日志流名称。可以使用代码中的 `context.logGroupName` 和 `context.logStreamName` 属性来获取此信息。在运行 Lambda 函数时，控制台或 CLI 中生成的日志将会向您显示日志组名称和日志流名称。\n\n\n\n#### 函数错误\n\n如果 Lambda 函数引发异常，AWS Lambda 会识别失败，将异常信息序列化为 JSON 并将其返回。考虑以下示例：\n\n```python\ndef always_failed_handler(event, context):\n    raise Exception('I failed!')\n```\n\n在调用此 Lambda 函数时，它将引发异常，并且 AWS Lambda 返回以下错误消息：\n\n```json\n{\n  \"errorMessage\": \"I failed!\",\n  \"stackTrace\": [\n    [\n      \"/var/task/lambda_function.py\",\n      3,\n      \"my_always_fails_handler\",\n      \"raise Exception('I failed!')\"\n    ]\n  ],\n  \"errorType\": \"Exception\"\n}\n```\n\n\n\n详细信息参考官方文档：https://docs.aws.amazon.com/zh_cn/lambda/latest/dg/lambda-app.html\n\n\n\n### 注意事项\n\n\n\n#### AWS Lambda 限制\n\nAWS Lambda 在使用中会强加一些限制，例如，程序包的大小或 Lambda 函数在每次调用中分得的内存量。\n\n**每个调用的 AWS Lambda 资源限制**\n\n| 资源                                       | 限制                                       |\n| ---------------------------------------- | ---------------------------------------- |\n| 内存分配范围                                   | 最小值 = 128 MB/最大值 = 1536 MB (增量为 64 MB). 如果超过最大内存使用量，则函数调用将会终止。 |\n| 临时磁盘容量（“/tmp”空间）                         | 512MB                                    |\n| 文件描述符数                                   | 1024                                     |\n| 过程和线程数（合并总数量）                            | 1024                                     |\n| 每个请求的最大执行时长                              | 300 秒                                    |\n| [Invoke](https://docs.aws.amazon.com/zh_cn/lambda/latest/dg/API_Invoke.html) 请求正文有效负载大小 (RequestResponse/同步调用) | 6MB                                      |\n| [Invoke](https://docs.aws.amazon.com/zh_cn/lambda/latest/dg/API_Invoke.html) 请求正文有效负载大小 (Event/异步调用) | 128 K                                    |\n\n**每个区域的 AWS Lambda 账户限制**\n\n| 资源    | 默认限制 |\n| ----- | ---- |\n| 并发执行数 | 1000 |\n\n并发执行是指在任意指定时间对您的函数代码的执行数量。您可以估计并发执行计数，但是，根据 Lambda 函数是否处理来自基于流的事件源的事件，并发执行计数会有所不同。\n\n- **基于流的事件源** - 如果您创建 Lambda 函数处理来自基于流的服务（Amazon Kinesis Data Streams 或 DynamoDB 流）的事件，则每个流的分区数量是并发度单元。如果您的流有 100 个活动分区，则最多会有 100 个 Lambda 函数调用并发运行。然后，每个 Lambda 函数按照分区到达的顺序处理事件。\n\n- **并非基于流的事件源** - 如果您创建 Lambda 函数处理来自并非基于流的事件源（例如，Amazon S3 或 API 网关）的事件，则每个发布的事件是一个工作单元。因此，这些事件源发布的事件数（或请求数）影响并发度。\n\n  您可以使用以下公式来估算并发 Lambda 函数调用数。\n\n  ```\n  events (or requests) per second * function duration\n  ```\n\n  例如，考虑一个处理 API Gateway 的 Lambda 函数。假定 Lambda 函数平均用时 0.3 秒，API Gateway 每秒请求 1000 次。因此，Lambda 函数有 300 个并发执行。\n\n  ​\n\n具体信息参考[Lambda 函数并行执行](https://docs.aws.amazon.com/zh_cn/lambda/latest/dg/concurrent-executions.html)\n\n\n\n**AWS Lambda 部署限制 **\n\n| 项目                                       | 默认限制  |\n| ---------------------------------------- | ----- |\n| Lambda 函数部署程序包大小 (压缩的 .zip/.jar 文件)      | 50 MB |\n| 每个区域可以上传的所有部署程序包的总大小                     | 75GB  |\n| 可压缩到部署程序包中的代码/依赖项的大小 (未压缩的 .zip/.jar 大小).注意每个 Lambda 函数都会在其的 `/tmp` 目录中接收到额外的 500 MB 的非持久性磁盘空间。该 `/tmp` 目录可用于在函数初始化期间加载额外的资源，如依赖关系库或数据集。 | 250MB |\n| 环境变量集的总大小                                | 4 KB  |\n\n\n\n> 本文内容主要参考 AWS Lambda 官方文档，详细信息请访问 https://docs.aws.amazon.com/zh_cn/lambda/latest/dg/welcome.html\n\n\n\n## 参考链接\n\n\n\n[AWS Lambda 开发入门](https://docs.aws.amazon.com/zh_cn/lambda/latest/dg/getting-started.html)\n\n[创建部署程序包 (Python)](https://docs.aws.amazon.com/zh_cn/lambda/latest/dg/lambda-python-how-to-create-deployment-package.html)\n\n[Lambda 函数并行执行](https://docs.aws.amazon.com/zh_cn/lambda/latest/dg/concurrent-executions.html)\n\n[高并发解决方案](http://blog.csdn.net/chichengit/article/details/49078525)\n\n[如何优化网站高并发访问?](https://www.zhihu.com/question/22002547)\n\n[高并发的解决方案](https://www.jianshu.com/p/e6de7020d627)\n\n[Serverless开发编程思想](https://zhuanlan.zhihu.com/p/28079865)\n\n[一个简单的 Serverless 架构例子](https://zhuanlan.zhihu.com/p/26761180)\n\n[使用lambda带来的架构优势](https://zhuanlan.zhihu.com/p/20297696)\n\n\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "AWS-Lambda 使用入门",
        "date": "2018-01-13 09:23:49",
        "tags": [
          "AWS",
          "Lambda",
          "serverless",
          "python"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "Amazon-Lambda-Start"
    },
    {
      "content": "\n\n## 容器\n\nPython 内置了丰富的容器类型：list、tuple、set、dict和 collections 中的namedtuple()、deque、ChainMap、Counter、OrderedDict、defaultdict。\ncollections 相关的数据结构暂时先不介绍，这一篇先介绍 list、tuple、set 和 dict。\n\n> `解释：`容器类型相对应的是扁平的数据类型，容器存放的是它们所包含的任意类型的对象的引用，而扁平的数据结构存放的是值而不是引用。\n> 换句话说，扁平的数据结构其实是一段连续的内存空间，它里边只能存放字符、字节和数值这种基础类型，并且只能是其中的一种。\n> `可能越解释越不清楚了`\n\n### list（列表）\n\n#### 初始化列表\n\n```python\nempty_list = []  # 初始化一个空列表\nnums = [1]  # 初始化只有一个值的列表\nnumbers = [1, 2, 3, 4]  # 初始化一个有四个数字的列表\nstrings = ['a', 'b', 'c', 'd']  # 初始化一个有四个字符的列表\n```\n列表中的元素可以是任意数据类型，比如：\n\n```python\nlist1 = ['1', 2, 'c', 'hello' ['world']] \n```\n\n列表 list1 中包含了数字、字符串以及一个列表。\n\n#### 访问列表\n\n可以使用 len() 方法获取 list 元素的个数。\n\n列表用索引来访问 list 中每个位置的元素，索引从0开始\n\n```python\n>>> nums = [1, 2, 3, 4, 5]\n>>> nums[0]  # 索引从0开始\n1\n>>> nums[3]\n4\n>>> nums[5]\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nIndexError: list index out of range\n```\n当索引超出了范围时，Python会报一个IndexError错误。\n\n索引还可以是负值，比如\n\n```python\n>>> nums[-1]  # 最后一个是-1 倒数第二个是 -2 依次类推 \n5\n>>> nums[-3]\n3\n>>> nums[-6]  # 负值的索引超出了范围时，也会报一个IndexError错误。\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nIndexError: list index out of range\n```\n\n如果列表中的元素也是列表：\n\n```python\n>>> nums = [1, 2, [3, 4, 5]]\n>>> nums\n[1, 2, [3, 4, 5]]\n# 要访问内部列表的中的值可以这样\n>>> nums[2][2]\n5\n```\n\n#### 分片\n\n列表可以使用索引获取特定位置的元素，也可以传入两个索引获取索引之间的元素，比如：\n\n```python\n>>> nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> nums\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> nums[0:1]\n[0]\n>>> nums[0:5]\n[0, 1, 2, 3, 4]\n>>> nums[1:7]\n[1, 2, 3, 4, 5, 6]\n```\n通过上边的例子可以看出，分片的语法结构为\n\n```python\nlist[start_index:end_index]\n```\n意思是 取列表中从 start_index 位置开始取，取值个数为 end_index-start_index，也就是取 list[start_index] 到 list[end_index-1] 的元素。\n#### 列表常用方法\n\n##### append\n列表是可变的，可以往list中追加元素到末尾：\n\n```python\n>>> nums = []\n>>> nums\n[]\n>>> nums.append(1)  # 使用 append 方法往列表的末尾追加元素\n>>> nums\n[1]\n```\n\n##### insert\n\n把元素插入到指定位置：\n\n```python\n>>> nums = [0, 2, 3]\n>>> nums\n[0, 2, 3]\n>>> nums.insert(1, 10)  # 向索引位置1 处插入数字10\n>>> nums\n[0, 10, 2, 3]\n# 如果指定的索引超过了列表的长度，会把元素插入到最后\n>>> nums.insert(10, 5)\n>>> nums\n[0, 10, 2, 3, 5]\n```\n\n##### pop\n\n删除末尾的元素：\n\n```python\n>>> nums = [1, 2, 3, 4]\n>>> nums.pop()\n4\n>>> nums\n[1, 2, 3]\n```\n\n删除指定位置的元素：\n\n```python\n>>> nums.pop(1)\n2\n>>> nums\n[1, 3]\n>>> nums.pop(3)  # 指定的位置超出了列表的大小\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nIndexError: list index out of range\n```\n\n##### sorted\n\n排序列表：\n\n```python\n>>> nums = [1, 4, 2, 3]\n>>> sorted(nums)\n[1, 2, 3, 4]\n```\n\nsorted() 函数会把传入的列表作为参数，返回一个排序后的列表（`注意`：sorted 返回一个新的列表，并不会改变当前列表）\n\n```python\n# 接上一段代码\n>>> nums\n[1, 4, 2, 3]\n```\n\n修改指定位置的值：\n\n```python\n>>> nums = [1, 2, 3, 4, 5, 6]\n>>> nums[1]\n2\n>>> nums[1] = 10\n>>> nums\n[1, 10, 3, 4, 5, 6]\n```\n\n### tuple\n\n元组和列表类似，这里主要说一下不同：\n\n#### 1：初始化方式不同\n\n元组使用半角小括号`()`，列表使用方括号`[]`\n\n```python\n>>> nums = ()  # 声明一个没有元素的空元组\n>>> nums\n()\n>>> nums = (1, 2, 3)\n>>> nums\n(1, 2, 3)\n```\n\n如果元组中只有一个值，声明的时候要在第一个元素后加逗号(,):\n\n```python\n>>> nums = (1,)\n>>> nums\n(1, )\n>>> nums = (1)  # 不加逗号python 认为这里的括号是数学运算符\n>>> nums\n1\n```\n\n> 不加逗号python 认为这里的括号是`数学运算符`，对数字1 进行单独运算结果还是 1，所以返回1\n\n#### 2： 元组不可变\n\n元组一旦声明，它的元素是不可变的，不能使用 append、pop、insert 等方法。\n\n```python\n>>> nums = (1, 2, 3)\n>>> nums.append()\nTraceback (most recent call last)\n<ipython-input-23-926c4dd5b5cb> in <module>()\n----> 1 nums.append(1)\nAttributeError: 'tuple' object has no attribute 'append'\n```\n\n其它获取元素的方法和列表的一致。\n\n### 练习\n\n请用索引取出下面list的指定元素：\n\n```python\n# -*- coding: utf-8 -*-\n\nL = [\n    ['Apple', 'Google', 'Microsoft'],\n    ['Java', 'Python', 'Ruby', 'PHP'],\n    ['Adam', 'Bart', 'Lisa']\n]\n \n# 打印Apple:\nprint ?\n# 打印Python:\nprint ?\n# 将 PHP 修改为 JavaScript\n```\n\n### dict（字典）\n\ndict 是使用键-值（key-value）存储，具有极快查询速度的一种数据结构。\n\n#### 初始化字典\n\n比如我们可以用一个dict 存储一个用户信息：\n\n```python\nuser = {\n    'nickname': 'goodspeed',\n    'avatar': 'http://url.jpg',\n}\n```\n\n#### 访问字典里的数据\n\n如果我们想查找字典里的某个值，可以根据 key 读取。比如\n\n```python\n>>> user = {\n    'nickname': 'goodspeed',\n    'avatar': 'http://url.jpg',\n}\n>>> nickname = user['nickname']\n>>> nickname\ngoodspeed\n```\n\n如果我们使用了一个不存在的 `key`，dict 会报错：\n```python\n>>> user = {}\n>>> user['nickname']\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nKeyError: 'nickname'\n```\n \n上边这个例子是因为 dict `user` 不存在`key` nickname，所以抛出`KeyError` 异常。\n\n> 如何避免KeyError 错误呢？\n\n1. 使用之前充分了解 dict 结构（不靠谱，程序总是存在各种各样的可能，谁知道到底有没有）\n2. 取值之前先判断 `key` 是否存在（使用 `in` 判断)\n\n```python\n>>> user = {\n    'nickname': 'goodspeed',\n    'age': 8\n}\n>>> 'nickname' in user  # user 有 nickname 这个 key\nTrue\n>>> 'avatar' in user # user 没有 nickname 这个 key\nFalse\n```\n\n如果我们使用这种方式取值代码可能是这样的：\n\n```python\nuser = {\n    'nickname': 'goodspeed',\n    'age': 8\n}\nif 'nickname' in user:\n    nickname = user['nickname']\nelse:\n    nickanme = '默认值'     \n```\n\n这显然太啰嗦了，python 有更好的办法：\n\n3. 使用 `get()` 方法，比如：\n\n```python\n>>> user = {\n    'nickname': 'goodspeed',\n    'age': 8\n}\n\n>>> nickname = user.get('nickname', '如果nickname 不存在，我是默认值')\n>>> nickname\ngoodspeed\n\n>>> avatar = user.get('avatar', 'avatar 不存在，取到的值就是我')\n>>> avatar\navatar 不存在，取到的值就是我\n```\n\n> 简单多了吧 🙄🙃\n\n#### 更新 dict\n\ndict 是可变容器，它的数据可以增加修改，比如\n\n```python\n>>> user = { # 初始化一个字典 只有一个 nickname key\n    'nickname': 'goodspeed',\n}\n>>> user['age'] = 8\n>>> user\n{\n    'nickname': 'goodspeed',\n    'age': 8\n}\n# 我说我8岁大家都不信，非让我写真实年龄，没办法我只能改了🤷‍♀️\n>>> user['age'] = 9 # 这下满意了吧\n>>> user\n{\n    'nickname': 'goodspeed',\n    'age': 9\n}\n```\n\n> 那如果想一次更新多个值呢? 使用`update` 方法\n\n```python\n>>> user = {} # 初始化一个空字典\n>>> user.update({'nickname': 'goodspeed', 'age': 8}) # 使用 update 更新字典\n>>> user\n{\n    'nickname': 'goodspeed',\n    'age': 8\n}\n```\n\n#### 字典 key 注意事项\n\n1. key 必须是不可变对象（可以暂时限制为，字符，数字等值）\n2. key 不能重复，如果重复设置，后边的值会覆盖前一次的值\n\n### set\n\nset 和 dict 类似，也是一组 key 的集合，但是 set 只有 key 没有对应的 value。\n\n> set 中也没有重复的 key\n\n#### 初始化一个set\n\n```python\n>>> s = set() # 初始化一个空的集合\n# 也可以把一个序列作为初始化参数\n>>> sl = set([1, 2, 3])  # 把列表作为参数\n>>> sl\n{1, 2, 3}\n>>> st = set((1, 2, 3)) # 把元组作为参数\n>>> st\n{1, 2, 3}\n>>> ss = set('hello') # 把字符串作为参数\n>>> ss\n{'e', 'h', 'l', 'o'}\n```\n\n> set 中的 key 是无序的（顺序如何，看 set 心情）\n\n#### set 常用方法\n\n##### add \n\n使用 add 向 set 添加一个 元素。\n\n```python\n>>> s = set()\n>>> s.add(1)\n>>> s\n{1}\n>>> s.add(2)\n>>> s\n{2, 1}\n```\n\nset 中的 key 是不可重复的所以，使用 add 添加相同的 key，会自动去重，比如\n\n```python\n>>> s = set()\n>>> for i in range(10): # 向集合添加10次字符 'a'\n        s.add('a')\n>>> s \n{'a'} #  set 自动去重，所以仍然只有一个元素\n```\n\n##### remove\n\nset 可是已使用 `remove()` 方法删除集合中的一个 key，比如：\n```python\n>>> s = set([1, 2, 3])\n>>> s.remove(1)\n>>> s\n{2, 3}\n>>> s.remove(4)  # 如果使用 remove 删除一个不存在的 key，会抛出 KeyError 错误\nTraceback (most recent call last)\n<ipython-input-20-737bdeaad795> in <module>()\n----> 1 s.remove(4)\nKeyError: 4\n```\n\n## 流程控制\n\n### 条件判断 if\n\n条件判断是程序的一个基本流程控制。语法结构如下：\n\n```python\nif 条件:\n    条件成立执行语句\nelif 第二个条件:\n    条件成立执行语句\nelse:\n    上述条件都不成立，执行的语句\n```\n\n#### if 语句注意事项\n\n* 条件语句后要加冒号`:`\n* if 语句是从上向下依次执行的，如果在某个判断上是 True，剩下的语句就不会执行了。\n* 通过布尔运算得到结果为 True，条件就算成立\n\n> 空列表，空字典，空元组，空集合，空字符串，0都不为真\n\n```python\n>>> s = set()\n>>> if s:\n        print '这不是一个空集合'\n    else:\n        print 's 为空集合'    \n```\n\n#### boolean\n\n布尔值只有两个值 True、False。在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来：\n\n```python\n>>> True\nTrue\n>>> False\nFalse\n>>> 3 > 2\nTrue\n>>> 3 > 5\nFalse\n```\n\n布尔值和条件运算是条件判断的基本条件，比如：\n\n```python\nage = 4\nif age > 3:\n    print '成熟点，你已经不是3岁的孩子了'\nelif age > 20:\n    print '你都是中年人了，可怜🤕'\nelse:\n    print '你3岁小孩懂什么'\n```\n\n> 我们上边说过，if 语句是从上向下依次执行的，如果某个判断为 True，剩下的就会忽略不在执行，那么，这个代码中第二个判断 `age > 20` 永远不会执行，因为 `> 20` 肯定也 大于 3，会执行第一个条件\n\n### 循环\n\n要打印2次 `hello world` 我们可以直接写：\n\n```python\nprint 'hello world'\nprint 'hello world'\n```\n\n但是如果我们要打印100 次、1000次就需要用到循环语句了。\nPython 循环有两种方式：计数循环和条件循环。\n\n#### 计数循环（for...in）\n\n计数循环的示例如下：\n\n```python\nfor i in [1, 2, 3, 4]:\n    print i\n```\n\n* 变量 i 从1开始\n* 对应列表的每一个值，循环会把指令块中所有代码执行一遍\n* 每次执行循环时，变量 i 会赋值为列表中的下一个值\n* 每次循环称为一次迭代\n\n> `for 循环` 不仅仅可以用在 list 上，还可以作用在其他可迭代对象上（元组、字典、集合、字符串等）\n\n#### range() 函数\n\n* range() 会创建一个列表，其中包含某个范围内的数\n* range(5) —> [0, 1, 2, 3, 4]\n* range(1, 6) —> [1, 2, 3, 4, 5, 6]\n* range(x, y) 默认从0计数，循环次数为 y-x\n\nrange 函数不仅仅只是可以每次增加一个数，还可以指定步长，比如：\n\n* range(1, 10, 2) —> [1, 3, 5, 7, 9]\n这个意思是，生成一个列表，从1开始，到10结束，每个数字间隔为2（后一个数字减前一个数字值为2）\n\n##### range() 还可以反向计数\n\n* range(5, 1, -1) —> [5, 4, 3, 2]\n\n##### 练习\n\n使用 for 循环 计算 1到100 的和。\n\n#### 条件循环（while）\n\n条件循环基本语法为：\n\n```python\nwhile 条件:\n    语句块\n```\n\n只要满足条件，就会不断循环：\n\n```python\nwhile True:\n    print 'hello' \n```\n\n这个循环因为 True 一直为真，所以条件一直满足，所以如果运行代码，会一直打印 hello 字符串。\n\n所以使用 while 循环要在代码块中设定可以跳出的条件，比如：\n\n```python\na = 0\nwhile a< 100:\n    print a\n    a = a + 1 # a 不停自加\n```\n\n可以执行下上述代码，看下效果。\n\n##### 练习\n\n使用 while 循环，计算1，2， 3...100 的和。\n\n\n### 跳出循环\n\n跳出循环有两种形式，使用 `break` 或着使用 `continue`。\n\n#### break\n\n如果在循环中使用 `break` 循环会直接结束，之后的循环就不再执行\n\n```python\n>>> for i in range(100):\n        if i > 2: # 当i = 3 时 循环就直接退出\n            break\n        print i\n0\n1\n2\n```\n这段代码执行之会打印 0 1 2 因为大于2后循环会直接终结。\n\n#### continue\n\n在循环中使用 `continue`，此次循环会被跳过，直接执行下一次循环\n\n```python\n>>> for i in range(5):\n        if i == 3:\n            continue\n        print i\n0\n1\n2\n4\n```\n上边这段代码，当 i 值等于3时，我们跳过当前循环，直接执行下一次，所以执行的结果为\n\n0, 1, 2, 4\n\n#### 练习\n\n使用 continue 计算 1 到 3245 间所有数字中奇数的和。\n \n## 参考链接\n\n* [使用list和tuple](https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014316724772904521142196b74a3f8abf93d8e97c6ee6000)\n* [python基础数据类型及内置容器详解](http://blog.csdn.net/qq_30490125/article/details/50916268)\n* [条件判断和循环](https://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001374738281887b88350bd21544e6095d55eaf54cac23f000)\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "python容器和控制语句",
        "date": "2017-09-05 09:44:27",
        "tags": [
          "python"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-container-and-control"
    },
    {
      "content": "\n> 这是小程序开发第二篇，主要介绍如何上传图片到腾讯云，之所以选择腾讯云，是因为腾讯云免费空间大😂\n\n## 准备工作\n\n上传图片主要是将图片上传到腾讯云对象存储（COS）。\n\n要使用对象存储 API，需要先执行以下步骤：\n\n1. 购买腾讯云对象存储（COS）服务\n2. 在腾讯云 [对象存储控制台](https://console.qcloud.com/cos4/index) 里创建一个 Bucket\n3. 在控制台 [个人 API 密钥](https://console.qcloud.com/capi) 页面里获取 AppID、SecretID、SecretKey 内容\n4. 编写一个请求签名算法程序（或使用任何一种服务端 SDK）\n5. 计算签名，调用 API 执行操作\n\n所以我们要做的准备工作有：\n\n* 进入[腾讯云官网](https://www.qcloud.com)，注册帐号\n* 登录[云对象存储服务（COS）控制台](https://console.qcloud.com/cos4)，开通COS服务，创建资源需要上传的Bucket\n* 在小程序官网上配置域名信息（否则无法在小程序中发起对该域名的请求）\n\n![image](http://media.gusibi.mobi/dloLMnRv8lJosOZt_gv9apWHmFRKfBcUtw0bgXR-Q_uSnmuQK5uP822b6lrYqlxq)\n\n这些配置过程这里就不做说明了，接下来主要介绍步骤4、5。\n\n小程序上传图片到 cos 流程如下图：\n\n![图片上传流程图](http://media.gusibi.mobi/LC4VsGph5WEJrKEGK7pbyaJGRpshIMx9H4qh804WDJNiInrIirAmNMvQPXMltb0a)\n\n在这个过程中我们需要实现的是，鉴权服务器返回签名的步骤以及小程序的相关步骤。\n\n## COS鉴权服务\n\n使用对象存储服务 COS 时，可通过 RESTful API 对 COS 发起 HTTP 匿名请求或 HTTP 签名请求，对于签名请求，COS 服务器端将会进行对请求发起者的身份验证。\n\n* 匿名请求：HTTP 请求不携带任何身份标识和鉴权信息，通过 RESTful API 进行 HTTP 请求操作。\n* 签名请求：HTTP 请求时添加签名，COS服务器端收到消息后，进行身份验证，验证成功则可接受并执行请求，否则将会返回错误信息并丢弃此请求。\n腾讯云COS对象存储，基于密钥 HMAC (Hash Message Authentication Code) 的自定义 HTTP 方案进行身份验证。\n\n上传图片是一个签名请求，需要进行签名验证。之所以我们\n\n### 签名流程\n\n客户通过对 HTTP 请求进行签名，并将签名后的请求发送至腾讯云进行签名验证，具体流程如下图所示。\n\n![签名流程](https://mc.qcloudimg.com/static/img/4a1eb29033caa977c648cb84d9398fdd/image.png)\n\n我们使用 sdk 开发，这个流程大致了解下就行，签名的实现 sdk 已经包含，只需要调用方法即可。\n\n通过签名流程我们可以知道，签名需要 SecretId 和 SecretKey，这两个信息不适合存放在客户端中，这也是我们单独部署一个鉴权服务器的主要原因。\n\n### 签名生成 API\n\n上一篇[小程序开发：python sanic 实现小程序登录注册]() 我们介绍过，服务端使用 [`sanic`](https://github.com/channelcat/sanic) 框架 + [`swagger_py_codegen`](https://github.com/guokr/swagger-py-codegen) 生成 rest-api。\n\n添加签名生成 api 我们需要先在文档中添加 API 的相关描述。[文档代码：https://github.com/gusibi/Metis/blob/master/docs/v1.yml](https://github.com/gusibi/Metis/blob/master/docs/v1.yml)\n\n```yml\n    /qc_cos/config:\n        get:\n            summary: 腾讯云配置\n            description: 腾讯云配置\n            tags: [Config]\n            operationId: get_qc_cos_config\n            parameters:\n                - $ref: '#/parameters/AccessToken'\n                - $ref: '#/parameters/qcos_path_in_query'\n            responses:\n                200:\n                    schema:\n                        $ref: '#/definitions/QCOSConfig'\n                default:\n                    description: Unexpected error\n                    schema:\n                        $ref: '#/definitions/Error'\n            security:\n                - OAuth2: [open]\n```\n\n> 这个接口我们要求登录才能调用。\n文档定义完成之后，调用 \n```sh\nswagger_py_codegen -s  docs/v1.yml . -p apis -tlp sanic\n```\n生成代码模板，API 代码实现如下：\n```python\n    from qcloud_cos.cos_auth import Auth\n    \n    async def get(self, request):\n        auth = Auth(appid=Config.QCOS_APPID,\n                    secret_id=Config.QCOS_SECRET_ID,\n                    secret_key=Config.QCOS_SECRET_KEY)\n        expired = time() + 3600 # 签名有效时间 3600 秒\n        # 上传到 cos bucket 的目录\n        dir_name = request.raw_args.get('cos_path', '/xrzeti')\n        # 生成签名\n        sign = auth.sign_more(Config.QCOS_BUCKET_NAME,\n                              cos_path=dir_name,\n                              expired=expired)\n        return {\"sign\": sign}, 200\n```\n\n> 由于 腾讯云COSv4 的Python SDK 只支持 python2，而 sanic 需要 python3.5+ 所以，这里我 fork 出来一份添加了 python3 的支持。\n[https://github.com/gusibi/cos-python-sdk-v4](https://github.com/gusibi/cos-python-sdk-v4)。使用 python3 环境的可以使用这个版本。\n\n##  上传图片到 cos\n\n### 选择图片\n\n> `wx.chooseImage(OBJECT)`\n从本地相册选择图片或使用相机拍照。\n\n调用这个方法，小程序会把选择的图片放到临时路径（在小程序本次启动期间可以正常使用，如需持久保存，需在主动调用 wx.saveFile，在小程序下次启动时才能访问得到），我们只能将临时路径的文件上传。\n\n核心代码如下：\n\n```js\n    uploadToCos: function () {\n        var that = this;\n\n        // 选择上传的图片\n        wx.chooseImage({\n            sizeType: ['original', 'compressed'], // 图片类型 original 原图，compressed 压缩图，默认二者都有\n            success: function (res) {\n\n                // 获取文件路径\n                var file = res.tempFiles[0];\n                console.log(file.size);\n\n                // 获取文件名\n                var fileName = file.path.match(/(wxfile:\\/\\/)(.+)/)\n                fileName = fileName[2]\n\n                // 获取到图片临时路径后，指定文件名 上传到cos\n                upload(file.path, fileName, that);\n            }\n        })\n    }\n    \n```\n这里图片选择成功后，我们取原图上传到 cos。\n\n### 上传图片\n\ncos 上传图片的URL由 cos_region，appid，bucket_name和 cos_dir_name 拼接而成。\n把以下字段配置成自己的cos相关信息，详情可看[API文档](https://www.qcloud.com/document/product/436/6066)\n```js\ncosUrl = \"https://\" + REGION + \".file.myqcloud.com/files/v2/\" + APPID + \"/\" + BUCKET_NAME + DIR_NAME;\n```\n\n> `REGION`: cos上传的地区\n> `APPID`: 账号的appid\n> `BUCKET_NAME`: cos bucket的名字\n> `DIR_NAME`: 上传的文件目录\n\n\n```js\nvar config = require('../config.js');\n// 先确定上传的 URL\nvar cosUrl = \"https://\" + config.cos_region + \".file.myqcloud.com/files/v2/\" + config.cos_appid + \"/\" + config.cos_bucket_name + config.cos_dir_name;\n\n//填写自己的鉴权服务器地址\nvar cosSignatureUrl = config.host + '/v1/qc_cos/config?cos_path=' + config.cos_dir_name;\n\n/**\n * 上传方法\n * filePath: 上传的文件路径\n * fileName： 上传到cos后的文件名\n * that: 小程序所在当前页面的 object\n */\nfunction upload(filePath, fileName, that) {\n    var data;\n\n    // 鉴权获取签名\n    wx.request({\n        url: cosSignatureUrl,\n        header: {\n            Authorization: 'JWT' + ' ' + that.data.jwt.access_token\n        },\n        success: function (cosRes) {\n            // 获取签名\n            var signature = cosRes.data.sign;\n\n            // 头部带上签名，上传文件至COS\n            var uploadTask = wx.uploadFile({\n                url: cosUrl + '/' + fileName,\n                filePath: filePath,\n                header: {\n                    'Authorization': signature\n                },\n                name: 'filecontent',\n                formData: {\n                    op: 'upload'\n                },\n                success: function (uploadRes) {\n                    // 上传成功后的操作\n                    var upload_res = JSON.parse(uploadRes.data)\n                    var files = that.data.files;\n                    files.push(upload_res.data.source_url);\n                    that.setData({\n                        upload_res: upload_res,\n                        files: files,\n                        test_image: upload_res.data.source_url\n                    })\n                },\n                fail: function (e) {\n                    console.log('e', e)\n                }\n            });\n            // 上传进度条\n            uploadTask.onProgressUpdate((res) => {\n                that.setData({\n                    upload_progress: res.progress\n                })\n                if (res.progress === 100){\n                    that.setData({\n                        upload_progress: 0\n                    })\n                }\n            })\n        }\n    })\n    return data\n}\n```\n小程序提供了 `uploadTask.onProgressUpdate()` 来获取图片的上传进度，这里我将图片的上传进度显示了出来。\n\n完整代码参考：[metis-wxapp: https://github.com/gusibi/Metis-wxapp](https://github.com/gusibi/Metis-wxapp/tree/master/dist)\n\n## 参考链接\n\n* [WeCOS-UGC-DEMO——微信小程序用户资源上传COS示例](https://github.com/tencentyun/wecos-ugc-upload-demo/blob/master/README.md)\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "小程序开发：上传图片到腾讯云",
        "date": "2017-08-27 04:17:13",
        "tags": [
          "python",
          "tutorial",
          "weixin",
          "小程序",
          "swagger"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "metis-2-weapp-upload-file-to-cos"
    },
    {
      "content": "\n> 这是《CSS设计指南》的读书笔记，用于加深学习效果。\n\n## display 属性\n\n`display`是 CSS 中最重要的用于控制布局的属性。每个元素都有一个默认的 display 值。对于大多数元素它们的默认值通常是 block 或 inline 。一个 block 元素通常被叫做块级元素。一个 inline 元素通常被叫做行内元素。\n\n#### block\n\n`div` 是一个标准的块级元素。一个块级元素会新开始一行并且尽可能撑满容器。其他常用的块级元素包括 `p` 、 `form` 和HTML5中的新元素： `header` 、 `footer` 、 `section` 等等。\n\n#### inline\n\n`img` 是一个标准的行内元素。你可以把两个 `<img>` 标签写在两行，但这并不影响图片再浏览器中的显示效果，它们会并列出现在一行上。而且标签直接的空白（标记中的两个<img>标签虽然分别位于两行，但这并不影响图片在浏览器中显示时的效果。图片是行内元素，所以它们显示的时候就会并列出现在一行上。而且，标签之间的空白（包括制表、回车和空格）都会被浏览器忽略。\n\n`a` 元素是最常用的行内元素，它可以被用作链接。\n\n#### none\n\n另一个常用的 display 值是 none。一些特殊元素的默认 display 值是它，例如`script`。display:none 通常被 JavaScript 用来在不删除元素的情况下隐藏或显示元素。\n把display设置为 none，该元素及所有包含在其中的元素，都不会在页面中显示。它们原来占据的空间也会被回收。\n\n> 相对的属性是 `visibility`，这个属性常用的值是 visible（默认）和 hidden。把元素的 visibility 设定为 hidden，元素会隐藏，但它占据的空间仍然存在。\n\n#### 其他 display 值\n\n还有很多的更有意思的 display 值，几乎所有HTML元素的display属性值要么为block，要么为inline。最明显的一个例外是table元素，它有自己特殊的display属性值。[这里有一份详细的列表](https://developer.mozilla.org/en-US/docs/Web/CSS/display)。\n\n块级元素（比如标题和段落）会相互堆叠在一起沿页面向下排列，每个元素分别占一行。而行内元素（比如链接和图片）则会相互并列，只有在空间不足以并列的情况下才会折到下一行显示 。\n\n块级元素和行内元素是可以互相转化的：\n\n```css\n/*默认为块级元素*/\np {display: inline;}\n/*默认为行内元素*/\na {display: block;}\n```\n\n属性了 display 属性之后，我们来看下页面布局：\n\n## 布局的基本概念\n\n多栏布局有三种基本的实现方案：`固定宽度`、`流动`、 `弹性`。\n\n* 固定宽度布局的大小不会随用户调整浏览器窗口大小而变化，一般是900到1100像素宽。其中960像素是最常见的，因为这个宽度适合所有现代显示器，而且能够被16、12、10、8、6、5、4和3整除，不仅容易计算等宽分栏的数量，而且计算结果也能得到没有小数的像素数。 \n\n* 流动布局的大小会随用户调整浏览器窗口大小而变化。这种布局能够更好地适应大屏幕，但同时也意味着放弃对页面某些方面的控制，比如随着页面宽度变化，文本行的长度和页面元素之间的位置关系都可能变化。Amazon.com的页面采用的就是流动中栏布局，在各栏宽度加大时通过为内容元素周围添加空白来保持内容居中，而且现在的导航条会在布局变窄到某个宽度时收缩进一个下拉菜单中，从而为内容腾出空间。\n\n* 弹性布局与流动布局类似，在浏览器窗口变宽时，不仅布局变宽，而且所有内容元素的大小也会变化，让人产生一种所有东西都变大了的感觉。\n\n### 布局的高度\n\n多数情况下，布局中结构化元素（乃至任何元素）的高度是不必设定的。事实上，我甚至想告诉你根本不应该给元素设定高度。除非你确实需要这样做，比如在页面中创造一个绝对定位的元素。\n\n> 为什么正常情况下都应该保持元素height属性的默认值auto不变呢？很简单，只有这样元素才能随自己包含内容的增加而在垂直方向上扩展。这样扩展的元素会把下方的元素向下推，而布局也能随着内容数量的增减而垂直伸缩。假如你明确设定了元素的高度，那么超出的内容要么被剪掉，要么会跑到容器之外——取决于元素overflow属性的设定。\n\n### 布局的宽度\n\n与高度不同，我们需要更精细地控制布局宽度，以便随着浏览器窗口宽度的合理变化，布局能够作出适当的调整，确保文本行不会过长或过短。如果随意给元素添加内边距、边框，或者元素本身过大，导致浮动元素的宽度超过包含元素的布局宽度，那浮动元素就可能“躲”到其他元素下方。应该让这些内容元素自动扩展到填满栏的宽度。(这是块级元素的默认行为)\n\n## 三栏-固定宽度布局\n\n我们先从一个简单的居中的单栏布局开始吧。看下面 HTML 代码，主要标记的 ID 是 wrapper：\n\n```html\n<div id=\"wrapper\">\n\t<article>\n        <h1>Single-Column Layout</h1>\n        <p>这是第一段</p>\n        <h2>This is a Second-Level Heading</h2>\n        <p>这是第二段</p>\n    </article>\n</div>\n```\n布局相关 css 如下：\n\n```css\n#wrapper {\n\twidth:960px; margin:0 auto; border:1px solid;\n}\narticle {\n\tbackground:#ffed53;\t\n}\n```\n\n![效果图](http://media.gusibi.mobi/ehJIyepJP3ARTLkMYIDfndpryupJA8PrXFP1MlcUdPiDuX0gfMZo8r15dRn35M9l)\n\n> 如图所示，通过给外包装设定宽度值，并将其水平外边距设定为 auto，这个单栏布局在页面上居中了。随着向里添加内容，这一栏的高度会相应增加。外包装中的article元素本质上就是一个没有宽度的块级盒子（关于“没有宽度的盒子”，请参见3.2节），它水平扩展填满了外包装。\n\n下面，我们再向外包装里添加一个导航元素，让它作为第二栏。\n\nHTML 代码如下：\n\n```html\n<div id=\"wrapper\">\n\t<nav>\n        <ul>\n            <li><a href=\"#\">Link 1</a></li>\n            <li><a href=\"#\">Link 2</a></li>\n            <li><a href=\"#\">Link 3</a></li>\n        </ul>\n    </nav>\n    <article>\n        <h1>Single-Column Layout</h1>\n        <p>这是第一段</p>\n        <h2>This is a Second-Level Heading</h2>\n        <p>这是第二段.</p>\n    </article>\n</div>\n```\n\n这里我们将两栏都添加`float: left`，以让它们并排显示。\n\n```css\n#wrapper {\n\twidth:960px; \n\tmargin:0 auto; \n\tborder:1px solid; \n\toverflow:hidden;\n}\nnav {\n\twidth:150px;\n\tfloat:left; /*浮动*/\n\tbackground:#dcd9c0;\n\t}\nnav li {\n    /*去掉列表项目符号*/\n\tlist-style-type:none;\n\t}\narticle {\n\twidth:810px;\n\tfloat:left; /*浮动*/\n\tbackground:#ffed53;\t\n\t}\n```\n![效果图](http://media.gusibi.mobi/FJAogkzMENomRRtTqAobo1o3EiGsSSMBjhdz-4NZc2NOP0vaEjUF6br4TeZvH943)\n> 这里我们把两栏的总宽度设定为外包装的宽度（150+810=960），并浮动它们，就可以创造出并肩排列的两栏来。每一栏的长度取决于内容多少。\n\n接下来我们添加第三栏。\n\n```html\n<div id=\"wrapper\">\n\t<nav>\n        <ul>\n            <li><a href=\"#\">Link 1</a></li>\n            <li><a href=\"#\">Link 2</a></li>\n            <li><a href=\"#\">Link 3</a></li>\n        </ul>\n    </nav>\n    <article>\n        <h1>Single-Column Layout</h1>\n        <p>这是第一段</p>\n        <h2>This is a Second-Level Heading</h2>\n        <p>这是第二段.</p>\n    </article>\n    <aside>\n        <h3>This is the Sidebar</h3>\n        <p>这是侧边栏.</p>\n    </aside>\n</div>\n```\n接下来我们调整一下 article 这一栏的宽度，为第三栏腾出空间\n\n```css\n#wrapper {\n\twidth:960px; margin:0 auto; border:1px solid; overflow:hidden;\n}\nnav {\n\twidth:150px;\n\tfloat:left;\n\tbackground:#dcd9c0;\n}\narticle {\n\twidth:600px;\n\tfloat:left;\n\tbackground:#ffed53;\t\n}\naside {\n\twidth:210px;\n\tfloat:left;\n\tbackground:#3f7ccf;\n}\n```\n\n![三栏的示意图](http://media.gusibi.mobi/ih7NWCcRAtvH4fHkIJ26zbdTl0K378Ew4oKFbVu1y8TCUrQsqvFFruceGWPdPoaP)\n\n> 如图所示，通过把三个浮动容器的总宽度设定为恰好等于外包装的宽度（150+600+210=960），就有了三栏布局的框架。\n\n现在我们再添加一个页眉和页脚：\n\n```html\n<div id=\"wrapper\">\n\t<header>\n\t\t<h1>A Fixed-Width Layout</h1>\n\t</header>\n\t<nav>\n        <ul>\n            <li><a href=\"#\">Link 1</a></li>\n            <li><a href=\"#\">Link 2</a></li>\n            <li><a href=\"#\">Link 3</a></li>\n        </ul>\n    </nav>\n    <article>\n        <h1>Single-Column Layout</h1>\n        <p>这是第一段</p>\n        <h2>This is a Second-Level Heading</h2>\n        <p>这是第二段.</p>\n    </article>\n    <aside>\n        <h3>This is the Sidebar</h3>\n        <p>这是侧边栏.</p>\n    </aside>\n   \t<footer>\n        <p>This is the footer. Phasellus pretium gravida interdum. Nam interdum posuere tempus. Ut commodo laoreet dolor, non hendrerit mi dictum vitae. Nam nec egestas libero.</p>\n    </footer>\n</div>\n```\n为了让页脚在最下一栏不浮动到 `aside` 后边，我们为页脚应用`clear:both`，以组织它向上移动。\ncss 样式如下：\n\n```css\n* {margin:0; padding:0;} \n#wrapper {\n    width:960px;\n    margin:0 auto;\n    border:1px solid;\n} \nheader {\n    background:#f00;\n} \nnav {\n    width:150px;\n    float:left;\n    background:#dcd9c0;\n} \nnav li {\n    list-style-type:none;\n} \narticle {\n    width:600px;\n    float:left;\n    background:#ffed53;\n}\naside {\n    width:210px;\n    float:left;\n    background:#3f7ccf;\n} \nfooter {\n    clear:both;\n    background:#000;\n}\n```\n现在效果如图：\n![三栏+页眉+页脚的效果图](http://media.gusibi.mobi/qGmwPd79PzMw_N-UcZFSj8teXyQ11LnBN_r5aeExPp44vtBtZ4YGYRNor_Pp2bfq)\n\n现在各栏太拥挤，每栏的高度也都由文本内容决定，我们现在修改一下，为内容间加上空白。\n\n### 为栏设定内边距和边距\n\n为了让内容与栏边界空开距离，为栏添加水平外边距和内边距，但这样会导致布局宽度增大，进而浮动栏下滑。\n比如，我们给 article 增加内边距：\n\n```css\narticle {\n    width: 600px;\n    float: left;\n    background: #ffed53;\n    padding: 10px 20px;\n}\n```\n效果如图：\n\n![article 增加内边距后的效果图](http://media.gusibi.mobi/rjwewoLYNvkPSRnwJYZJTCUqZLYpsDr6P1oFgWe0X3fdQDdApeNcrKvb07jQw4AR)\n\n由于增加了内边距导致`article`的总宽度增加，导致右边的栏不能再与前两排并列在一起。有三种方法来预防改问题发生：\n\n* 从设定的元素宽度中减去添加的水平外边距、边框和内边距的宽度和。 \n* 在容器内部的元素上添加内边距或外边距。 \n* 使用CSS3的box-sizing属性切换盒子缩放方式，比如section {box-sizing:border-box;} 。 应用box-sizing属性后，给section添加边框和内边距都不会增大盒子，相反会导致内容变窄。\n\n### 重设宽度以抵消内边距和边框\n\n一个代代相传的解决方案是通过数学计算。CSS开发者需要用比他们实际想要的宽度小一点的宽度，需要减去内边距和边框的宽度。`比如我们给600像素宽的中间栏增加了20像素的内边距，为了抵消增加的内边距，可以把栏减少40像素而设定为560像素。`值得庆幸地是你不需要再这么做了...\n\n### 给容器内部元素应用内边距和边框\n\n把外边距和内边距应用到内容元素上确实有效，不过这样的前提是这些元素没有明确的设定宽度，这样内容才会随内外边距的增加而缩小。\n与其为容器中的元素添加外边距，不如在栏中再添加一个没有宽度的div，让它包含所有内容元素，然后再给这个div应用边框和内边距。如此一来，只要为内部div设定一次样式，就可以把让所有内容元素与栏边界保持一致的距离。而且，将来再需要调整时也会很方便。任何新增内容元素的宽度都由这个内部div决定。\n\n下面我们用这种方法修复上面第三栏浮动到下边的问题。\n\n```html\n<article>\n    <div class=\"inner\">\n    <!-- 这里是各种内容 -->\n    </div>\n</article>\n```\n\n接下来，我们不仅要给内部 div 应用内边距，还要给她应用外边距和边框。\n\n```css\n/*更新 css*/\narticle {\n\twidth:600px;\n\tfloat:left;\n\tbackground:#ffed53;\n}\narticle .inner {\n\tmargin:10px; \n\tborder:2px solid red;\n\tpadding:20px; \n}\n```\n\n效果如图：\n![给容器内部元素应用内边距和边框的示例图](http://media.gusibi.mobi/rQINy0ZYV9tT-nU7LJPlfY-RqwcDLA7n5PdZzdEEa-eGPz43J0G40nnLbbYvycAa)\n\n以上措施使布局有了明显改观。就这么简单的几下，布局就显得更专业了。处理栏及其内部div的关键在于，浮动栏并设定栏宽，但不给任何内容元素设定宽度。要让内容元素扩展以填充它们的父元素——内部div。这样，只要简单地设定内部div的外边距和内边距，就可以让它们以及它们包含的内容与栏边界保持一定距离。\n\n### 使用 box-sizing:border-box\n\n人们慢慢的意识到传统的盒子模型不直接，所以他们新增了一个叫做 box-sizing 的CSS属性。当你设置一个元素为 box-sizing: border-box; 时，此元素的内边距和边框不再会增加它的宽度。这里有一个与前一页相同的例子，唯一的区别是两个元素都设置了 box-sizing: border-box; \n\n```css\nnav {\n\t-webkit-box-sizing:border-box;\n    -moz-box-sizing:border-box;\n\tbox-sizing:border-box;\n\twidth:150px;\n\tfloat:left;\n\tbackground:#dcd9c0;\n\tpadding:10px 10px;\n\t}\narticle {\n\t-webkit-box-sizing:border-box;\n    -moz-box-sizing:border-box;\n\tbox-sizing:border-box;\n\twidth:600px;\n\tfloat:left;\n\tbackground:#ffed53;\t\n\tpadding:10px 20px;\n}\naside {\n    -webkit-box-sizing:border-box;\n    -moz-box-sizing:border-box;\n\tbox-sizing:border-box;\n\twidth:210px;\n\tfloat:left;\n\tbackground:#3f7ccf;\n\tpadding:10px 10px;\n}\n```\n\n![使用 box-sizing: border-box; 的效果图](http://media.gusibi.mobi/W72nR0pZ9isuBunBOxwMX5O1fnacmxEZdNSTQkT0uDPm_87znZleYhehw83kslGH)\n\n这是目前为止最好的解决方法了，那最简单有效的方法就是在 css 里添加这样一条规则：\n\n```css\n* {\n    -webkit-box-sizing:border-box;\n    -moz-box-sizing:border-box;\n    box-sizing:border-box;        \n    }\n```\n## 三栏-中栏流动布局\n\n中栏流动布局的目的是在屏幕变窄时，中栏变窄，左栏和右栏宽度不变。\n这里我们使用`负外边距`实现。\n\n### 用负外边距实现\n\n实现三栏布局且让中栏内容区流动（不固定）的核心问题是处理右栏的定位，并在中栏内容区大小改变时控制右栏与布局的关系。\n\n这里我们使用`Ryan Brill`给出的控制两个外包装容器的外边距的解决方案。其中一个外包装包围三栏，另一个外保障包围左栏和中栏。\n\nhtml代码示例如下：\n```html\n<div id=\"main_wrapper\">\n    <header>\n        <!-- 页眉-->\n    </header>\n    <div id=\"threecolwrap\">/*三栏外包装（包围全部三栏）*/\n        <div id=\"twocolwrap\">/*两栏外包装（包围左栏和中栏）*/ /*左栏*/\n            <nav>\n                <!-- 导航 -->\n            </nav> /*中栏*/\n            <article>\n                <!-- 区块 -->\n            </article>\n        </div>/*结束两栏外包装（twocolwrap）*/ /*右栏*/\n        <aside>\n            <!-- 侧栏 -->\n        </aside>\n    </div>/*结束三栏外包装（threecolwrap）*/\n    <footer>\n        <!-- 页脚 -->\n    </footer>\n</div> \n```\ncss规则如下：\n\n```css\n* {\n    margin: 0;\n    padding: 0;\n}\n\nbody {\n    font: 1em helvetica, arial, sans-serif;\n}\n\ndiv#main_wrapper {\n    min-width: 600px;\n    max-width: 1100px;\n    /*超过最大宽度时，居中布局*/\n    margin: 0 auto;\n    /*背景图片默认从左上角开始拼接*/\n    background: url(images/bg_tile_150pxw.png) repeat-y #eee;\n}\n\nheader {\n    padding: 5px 10px;\n    background: #3f7ccf;\n}\n\ndiv#threecolwrap {\n    /*浮动强制它包围浮动的栏*/\n    float: left;\n    width: 100%;\n    /*背景图片右对齐*/\n    background: url(images/bg_tile_210pxw.png) top right repeat-y;\n}\n\ndiv#twocolwrap {\n    /*浮动强制它包围浮动的栏*/\n    float: left;\n    width: 100%;\n    /*把右栏拉到区块外边距腾出的位置上*/\n    margin-right: -210px;\n}\n\nnav {\n    float: left;\n    width: 150px;\n    background: #f00;\n    padding: 20px 0;\n}\n\n/*让子元素与栏边界保持一定距离*/\n\nnav>* {\n    margin: 0 10px;\n}\n\narticle {\n    width: auto;\n    margin-left: 150px;\n    /*在流动居中的栏右侧腾出空间*/\n    margin-right: 210px;\n    background: #eee;\n    padding: 20px 0;\n}\n\n/*让子元素与栏边界保持一定距离*/ \narticle>* {\n    margin: 0 20px;\n}\n\naside {\n    float: left;\n    width: 210px;\n    background: #ffed53;\n    padding: 20px 0;\n}\n\n/*让子元素与栏边界保持一定距离*/ \naside>* {\n    margin: 0 10px;\n}\n\nfooter {\n    clear: both;\n    width: 100%;\n    text-align: center;\n    background: #000;\n}\n```\n![宽屏效果](http://media.gusibi.mobi/DMdD7nQ_BMk1Q8tQMwYgnu6BJDVM_BZMRx5C1sUUVj1AtFFb5EkD9aEshr-qDEhb)\n![窄屏效果](http://media.gusibi.mobi/9S7ij-86f1AF6eV7jOziitveLNrUpbO_untKwE4uofOXyvE5UrVvxY_1DEnVzp50)\n\n> `基本原理：`上面两幅图展示了流动中栏布局。三栏中的右栏是210像素宽。为了给右栏腾出空间，中栏article元素有一个210像素的右外边距。包围左栏和中栏的两栏外包装上210像素的负右外边距，会把右栏拉回article元素右外边距（在两栏外包装内部右侧）创造的空间内。中栏aticle元素的宽度是auto，因此它仍然会力求占据浮动左栏剩余的所有空间。可是，一方面它自己的右外边距在两栏外包装内为右栏腾出了空间，另一方面两栏外包装的负右外边距又把右栏拉到了该空间内。\n\n### 百分比宽度\n\n上面的例子中，我们用到了`百分比宽度`，百分比是一种相对于包含块的计量单位。你还能同时使用 min-width 和 max-width 来限制最大或最小宽度！\n\n你可以用百分比做布局，但是这需要更多的工作。如果我们上边的例子中 nav 用百分比宽度做布局，当窗口宽度很窄时 nav 的内容会以一种不太友好的方式被包裹起来。\n\n## inline-block 布局\n\n上面的例子我们实现多栏并列的方式是使用`float`，不过我们也可以使用`inline-block`。下边是我们把 float 替换为`inline-block` 的例子。\n\n```css\nnav {\n\twidth:150px;\n    display: inline-block;\n    vertical-align: top;\n\tbackground:#dcd9c0;\n\t}\narticle {\n    word-spacing:0;\n\twidth:600px;\n    display: inline-block;\n    vertical-align: top;\n\tbackground:#ffed53;\t\n\t}\naside {\n    word-spacing:0;\n\twidth:210px;\n    display: inline-block;\n    vertical-align: top;\n\tbackground:#3f7ccf;\n\t}\n```\n\n使用`inline-block`，有一些事情需要你牢记：\n* vertical-align 属性会影响到 inline-block 元素，你可能会把它的值设置为 top 。\n* 你需要设置每一列的宽度\n* 如果HTML源代码中元素之间有空格，那么列与列之间会产生空隙\n\n特别是第三条，如果我们不做任何修改，两个 block 之间会存在空格，像这样：\n\n![列与列之间有空格](http://media.gusibi.mobi/8uHhpJiVoVCzg007mXBb2vHjceIB8Ja4Irws_AvxpE07QhjH360KZhiFniFMpmzr)\n\n因为列与列之间产生了空格，所以 aside 跑到了下边。这里最简单的解决办法是：\n\n```html\n<nav>\n导航\n</nav><article>\n内容\n</article><aside>\n第三栏\n</aside>\n```\n\n其他解决方案可以参考这篇文章 [Fighting the Space Between Inline Block Elements](https://css-tricks.com/fighting-the-space-between-inline-block-elements/)\n\n## 其他布局方式\n\n初次之外，css 还提供了 `column`、`flexbox`等布局方式，这些以后有机会再介绍吧。\n\n## 总结\n\n这篇文章我们介绍了用浮动的有宽度的元素来创建多栏布局、如何让固定布局在页面上居中以及让它们在一定范围内可以伸缩。同时也了解了如何使用内部div在浮动元素中生成间距，而又不会改变布局的总宽度。\n\n## 参考链接\n* [CSS入门指南-2：盒子模型、浮动和清除](https://mp.weixin.qq.com/s?__biz=MzAwNjI5MjAzNw==&mid=2655752018&idx=1&sn=6915e4f11ba08fa196a64375224cd92e&chksm=80b0b878b7c7316e1a065ae991c534cc11ca5fe72b33690a98fb1c3f6f53f8c98c4c8744cd3a#rd)\n* [CSS入门指南-3：定位元素](https://mp.weixin.qq.com/s?__biz=MzAwNjI5MjAzNw==&mid=2655752022&idx=1&sn=a37d1ec3bab1d8188ae6ae45b1b1a211&chksm=80b0b87cb7c7316ac3dcf29669d83f84300f1d85f8262848519ab1a37d754846b8eb482be436#rd)\n* [学习CSS布局](http://zh.learnlayout.com)\n* [Fighting the Space Between Inline Block Elements](https://css-tricks.com/fighting-the-space-between-inline-block-elements/)\n* [Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)\n\n------\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "CSS入门指南-4：页面布局",
        "date": "2017-08-10 14:36:53",
        "tags": [
          "css",
          "读书笔记",
          "html",
          "tutorial",
          "前端"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "css-learing-4-page-layout"
    },
    {
      "content": "\n开发微信小程序时，接入小程序的授权登录可以快速实现用户注册登录的步骤，是快速建立用户体系的重要一步。这篇文章将介绍 python + sanic + 微信小程序实现用户快速注册登录全栈方案。\n\n**微信小程序登录时序图如下：**\n\n![登录时序图](http://media.gusibi.mobi/_5HFdz7B13G7D1rN0hnqAvRwE_tLPZCQc_7YHkBID_zHVzVxzLClBPr9DPnufdSf)\n\n这个流程分为两大部分：\n1. 小程序使用 wx.login() API 获取 code，调用 wx.getUserInfo() API 获取 encryptedData 和 iv，然后将这三个信息发送给第三方服务器。\n2. 第三方服务器获取到 code、encryptedData和 iv 后，使用 code 换取 session_key，然后将 session_key 利用 encryptedData 和 iv 解密在服务端获取用户信息。根据用户信息返回 jwt 数据，完成登录。\n\n下面我们先看一下小程序提供的 API。\n\n## 小程序登录 API\n\n在这个授权登录的过程中，用到的 API 如下：\n\n* wx.login\n* wx.getUserInfo\n\n`wx.chekSession` 是可选的，这里并没有用到。\n\n### wx.login(OBJECT)\n\n调用此接口可以获取登录凭证（code），以用来换取用户登录态信息，包括用户的唯一标识（openid） 及本次登录的 会话密钥（session_key）。\n\n如果接口调用成功，返回结果如下：\n\n参数名 | 类型 | 说明\n------|------|------\nerrMsg |String| 调用结果\ncode  |String| 用户允许登录后，回调内容会带上 code（有效期五分钟），开发者需要将 code 发送到开发者服务器后台，使用code 换取 session_key api，将 code 换成 openid 和 session_key\n\n#### code 换取 session_key \n\n开发者服务器使用登录凭证 code 获取 session_key 和 openid。其中 session_key 是对用户数据进行加密签名的密钥。为了自身应用安全，session_key 不应该在网络上传输。所以这一步应该在服务器端实现。\n\n### wx.getUserInfo\n\n此接口用来获取用户信息。\n\n> 当 `withCredentials` 为 true 时，要求此前有调用过 wx.login 且登录态尚未过期，此时返回的数据会包含 encryptedData, iv 等敏感信息；当 withCredentials 为 false 时，不要求有登录态，返回的数据不包含 encryptedData, iv 等敏感信息。\n\n接口success 时返回参数如下：\n\n参数名 | 类型 | 说明\n------|------|------\nuserInfo |\tOBJECT|\t用户信息对象，不包含 openid 等敏感信息\nrawData\t| String |\t不包括敏感信息的原始数据字符串，用于计算签名。\nsignature | \tString |\t使用 sha1( rawData + sessionkey ) 得到字符串，用于校验用户信息，参考文档 signature。\nencryptedData\t|String |\t包括敏感数据在内的完整用户信息的加密数据，详细见加密数据解密算法\niv\t| String\t| 加密算法的初始向量，详细见加密数据解密算法\n\n`encryptedData` 解密后为以下 json 结构，详见加密数据解密算法\n\n```json\n{\n    \"openId\": \"OPENID\",\n    \"nickName\": \"NICKNAME\",\n    \"gender\": GENDER,\n    \"city\": \"CITY\",\n    \"province\": \"PROVINCE\",\n    \"country\": \"COUNTRY\",\n    \"avatarUrl\": \"AVATARURL\",\n    \"unionId\": \"UNIONID\",\n    \"watermark\":\n    {\n        \"appid\":\"APPID\",\n    \"timestamp\":TIMESTAMP\n    }\n}\n```\n\n> 由于解密 encryptedData 需要 session_key 和 iv 所以，在给服务器端发送授权验证的过程中需要将 code、encryptedData 和 iv 一起发送。\n\n## 服务器端提供的 API\n\n服务器端授权需要提供两个 API：\n\n1. /oauth/token 通过小程序提供的验证信息获取服务器自己的 token\n2. /accounts/wxapp 如果登录用户是未注册用户，使用此接口注册为新用户。\n\n### 换取第三方 token（/oauth/token）\n\n开始授权时，小程序调用此 API 尝试换取jwt，如果用户未注册返回401，如果用户发送参数错误，返回403。\n\n接口 获取 jwt 成功时返回参数如下：\n\n参数名 | 类型 | 说明\n------|------|------\naccount_id | string | 当前授权用户的用户 ID\naccess_token | string | jwt（登录流程中的第三方 session_key\ntoken_type | string | token 类型（固定Bearer）\n\n小程序授权后应该先调用此接口，如果结果是用户未注册，则应该调用新用户注册的接口先注册新用户，注册成功后再调用此接口换取 jwt。\n\n### 新用户注册（/accounts/wxapp）\n\n注册新用户时，服务器端需要存储当前用户的 openid，所以和授权接口一样，请求时需要的参数为 code、encryptedData 和 iv。\n\n注册成功后，将返回用户的 ID 和注册时间。此时，应该再次调用获取 token 的接口去换取第三方 token，以用来下次登录。\n\n## 实现流程\n\n接口定义好之后，来看下前后端整体的授权登录流程。\n\n![小程序授权登录流程](http://media.gusibi.mobi/epM1xSYKuQ84VNnsNMH88km6edqNdkLLNcqYyWxs8UYMsUqlasLvYkmb14FtZF9K)\n\n这个流程需要注意的是，在 C 步（使用 code 换取 session ）之后我们得到 session_key，然后需要用 session_key 解密得到用户数据。\n\n然后使用 openid 判断用户是否已经注册，如果用户已经注册，生成  jwt 返回给小程序。\n如果用户未注册返回401， 提示用户未注册。\n\n> `jwt(3rd_session)` 用于第三方服务器和小程序之间做登录态校验，为了保证安全性，jwt 应该满足：\n> 1. 足够长。建议有 2^128 组合\n> 2. 避免使用 srand(当前时间)，然后 rand() 的方法，而是采用操作系统提供的真正随机数机制。\n> 3. 设置一定的有效时间，\n\n当然，在小程序中也可以使用手机号登录，不过这是另一个功能了，就不在这里叙述了。\n\n## 代码实现\n\n说了这么多，接下来看代码吧。\n\n### 小程序端代码\n\n代码逻辑为：\n\n1. 用户在小程序授权\n2. 小程序将授权消息发送到服务器，服务器检查用户是否已经注册，如果注册返回 jwt，如果没注册提示用户未注册，然后小程序重新请求注册接口，注册用户，注册成功后重复这一步。\n\n为了简便，这里在小程序 启动的时候就请求授权。代码实现如下。\n\n```javascript\n// app.js\nvar config = require('./config.js')\n\nApp({\n  onLaunch: function () {\n    // 调用API从本地缓存中获取数据\n    var jwt = wx.getStorageSync('jwt')\n    var that = this\n    if (!jwt.access_token) { // 检查 jwt 是否存在 如果不存在调用登录\n      that.login()\n    } else {\n      console.log(jwt.account_id)\n    }\n  },\n  login: function () {\n    // 登录部分代码\n    var that = this\n    wx.login({\n      // 调用 login 获取 code\n      success: function (res) {\n        var code = res.code\n        wx.getUserInfo({\n          // 调用 getUserInfo 获取 encryptedData 和 iv\n          success: function (res) {\n            // success\n            that.globalData.userInfo = res.userInfo\n            var encryptedData = res.encryptedData || 'encry'\n            var iv = res.iv || 'iv'\n            console.log(config.basic_token)\n            wx.request({ // 发送请求 获取 jwt\n              url: config.host + '/auth/oauth/token?code=' + code,\n              header: {\n                Authorization: config.basic_token\n              },\n              data: {\n                username: encryptedData,\n                password: iv,\n                grant_type: 'password',\n                auth_approach: 'wxapp'\n              },\n              method: 'POST',\n              success: function (res) {\n                if (res.statusCode === 201) {\n                  // 得到 jwt 后存储到 storage，\n                  wx.showToast({\n                    title: '登录成功',\n                    icon: 'success'\n                  })\n                  wx.setStorage({\n                    key: 'jwt',\n                    data: res.data\n                  })\n                  that.globalData.access_token = res.data.access_token\n                  that.globalData.account_id = res.data.sub\n                } else if (res.statusCode === 401) {\n                  // 如果没有注册调用注册接口\n                  that.register()\n                } else {\n                  // 提示错误信息\n                  wx.showToast({\n                    title: res.data.text,\n                    icon: 'success',\n                    duration: 2000\n                  })\n                }\n              },\n              fail: function (res) {\n                console.log('request token fail')\n              }\n            })\n          },\n          fail: function () {\n            // fail\n          },\n          complete: function () {\n            // complete\n          }\n        })\n      }\n    })\n  },\n  register: function () {\n    // 注册代码\n    var that = this\n    wx.login({ // 调用登录接口获取 code\n      success: function (res) {\n        var code = res.code\n        wx.getUserInfo({\n          // 调用 getUserInfo 获取 encryptedData 和 iv\n          success: function (res) {\n            // success\n            that.globalData.userInfo = res.userInfo\n            var encryptedData = res.encryptedData || 'encry'\n            var iv = res.iv || 'iv'\n            console.log(iv)\n            wx.request({ // 请求注册用户接口\n              url: config.host + '/auth/accounts/wxapp',\n              header: {\n                Authorization: config.basic_token\n              },\n              data: {\n                username: encryptedData,\n                password: iv,\n                code: code\n              },\n              method: 'POST',\n              success: function (res) {\n                if (res.statusCode === 201) {\n                  wx.showToast({\n                    title: '注册成功',\n                    icon: 'success'\n                  })\n                  that.login()\n                } else if (res.statusCode === 400) {\n                  wx.showToast({\n                    title: '用户已注册',\n                    icon: 'success'\n                  })\n                  that.login()\n                } else if (res.statusCode === 403) {\n                  wx.showToast({\n                    title: res.data.text,\n                    icon: 'success'\n                  })\n                }\n                console.log(res.statusCode)\n                console.log('request token success')\n              },\n              fail: function (res) {\n                console.log('request token fail')\n              }\n            })\n          },\n          fail: function () {\n            // fail\n          },\n          complete: function () {\n            // complete\n          }\n        })\n      }\n    })\n  },\n\n  get_user_info: function (jwt) {\n    wx.request({\n      url: config.host + '/auth/accounts/self',\n      header: {\n        Authorization: jwt.token_type + ' ' + jwt.access_token\n      },\n      method: 'GET',\n      success: function (res) {\n        if (res.statusCode === 201) {\n          wx.showToast({\n            title: '已注册',\n            icon: 'success'\n          })\n        } else if (res.statusCode === 401 || res.statusCode === 403) {\n          wx.showToast({\n            title: '未注册',\n            icon: 'error'\n          })\n        }\n\n        console.log(res.statusCode)\n        console.log('request token success')\n      },\n      fail: function (res) {\n        console.log('request token fail')\n      }\n    })\n  },\n\n  globalData: {\n    userInfo: null\n  }\n})\n\n```\n\n### 服务端代码\n\n服务端使用 [`sanic`](https://github.com/channelcat/sanic) 框架 + [`swagger_py_codegen`](https://github.com/guokr/swagger-py-codegen) 生成 rest-api。\n数据库使用 MongoDB，[`python-weixin`](https://github.com/gusibi/python-weixin) 实现了登录过程中 code 换取 session_key 以及 encryptedData 解密的功能，所以使用python-weixin 作为 python 微信 sdk 使用。\n\n> 为了过滤无效请求，服务器端要求用户在获取 token 或授权时在 header 中带上 `Authorization` 信息。 `Authorization` 在登录前使用的是 Basic 验证（格式 (Basic hashkey) 注 hashkey为client_id + client_secret 做BASE64处理），只是用来校验请求的客户端是否合法。不过Basic 基本等同于明文，并不能用它来进行严格的授权验证。\n\n> jwt 原理及使用参见 [理解JWT（JSON Web Token）认证及实践](https://mp.weixin.qq.com/s?__biz=MzAwNjI5MjAzNw==&mid=2655752020&idx=1&sn=b5e56989a57e9b8067eb6614381a04fd&chksm=80b0b87eb7c73168d7eb1d7f1a95e759b9b0934318571de4f6d2455402e654e6c09d9b022f25)\n\n使用 swagger 生成代码结构如下：\n\n![](http://media.gusibi.mobi/BOj58PeS7fLB1FzEivAQA07SYkXPy3ajaajEXKYDUo05rGTfZSThiPg5Mqi7janu)\n\n由于代码太长，这里只放获取 jwt 的逻辑：\n\n```python\ndef get_wxapp_userinfo(encrypted_data, iv, code):\n    from weixin.lib.wxcrypt import WXBizDataCrypt\n    from weixin import WXAPPAPI\n    from weixin.oauth2 import OAuth2AuthExchangeError\n    appid = Config.WXAPP_ID\n    secret = Config.WXAPP_SECRET\n    api = WXAPPAPI(appid=appid, app_secret=secret)\n    try:\n        # 使用 code  换取 session key    \n        session_info = api.exchange_code_for_session_key(code=code)\n    except OAuth2AuthExchangeError as e:\n        raise Unauthorized(e.code, e.description)\n    session_key = session_info.get('session_key')\n    crypt = WXBizDataCrypt(appid, session_key)\n    # 解密得到 用户信息\n    user_info = crypt.decrypt(encrypted_data, iv)\n    return user_info\n\n\ndef verify_wxapp(encrypted_data, iv, code):\n    user_info = get_wxapp_userinfo(encrypted_data, iv, code)\n    # 获取 openid\n    openid = user_info.get('openId', None)\n    if openid:\n        auth = Account.get_by_wxapp(openid)\n        if not auth:\n            raise Unauthorized('wxapp_not_registered')\n        return auth\n    raise Unauthorized('invalid_wxapp_code')\n    \n    \ndef create_token(request):\n    # verify basic token\n    approach = request.json.get('auth_approach')\n    username = request.json['username']\n    password = request.json['password']\n    if approach == 'password':\n        account = verify_password(username, password)\n    elif approach == 'wxapp':\n        account = verify_wxapp(username, password, request.args.get('code'))\n    if not account:\n        return False, {}\n    payload = {\n        \"iss\": Config.ISS,\n        \"iat\": int(time.time()),\n        \"exp\": int(time.time()) + 86400 * 7,\n        \"aud\": Config.AUDIENCE,\n        \"sub\": str(account['_id']),\n        \"nickname\": account['nickname'],\n        \"scopes\": ['open']\n    }\n    token = jwt.encode(payload, 'secret', algorithm='HS256')\n    # 由于 account 中 _id 是一个 object 需要转化成字符串\n    return True, {'access_token': token, 'account_id': str(account['_id'])}\n```\n\n具体代码可以在 [Metis：https://github.com/gusibi/Metis](https://github.com/gusibi/Metis) 查看。\n\n> `Note`: 如果试用代码，请先设定 oauth2_client，使用自己的配置。\n> > 不要将私密配置信息提交到 github。\n\n## 参考链接\n\n* [《微信小程序七日谈》- 第五天：你可能要在登录功能上花费大力气：http://www.cnblogs.com/ihardcoder/p/6279602.html](http://www.cnblogs.com/ihardcoder/p/6279602.html)\n* [理解JWT（JSON Web Token）认证及实践](https://mp.weixin.qq.com/s?__biz=MzAwNjI5MjAzNw==&mid=2655752020&idx=1&sn=b5e56989a57e9b8067eb6614381a04fd&chksm=80b0b87eb7c73168d7eb1d7f1a95e759b9b0934318571de4f6d2455402e654e6c09d9b022f25)\n* [网站微信登录－python 实现：http://blog.gusibi.site/post/weixin-python-login/](http://blog.gusibi.site/post/weixin-python-login/)\n\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "小程序开发：python sanic 实现小程序登录注册",
        "date": "2017-07-30 04:17:13",
        "tags": [
          "python",
          "tutorial",
          "weixin",
          "小程序",
          "swagger"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "metis-1-wxapp-login"
    },
    {
      "content": "\n> 这是《CSS设计指南》的读书笔记，用于加深学习效果。\n前一篇[CSS入门指南-2：盒子模型、浮动和清除](https://mp.weixin.qq.com/s?__biz=MzAwNjI5MjAzNw==&mid=2655752018&idx=1&sn=6915e4f11ba08fa196a64375224cd92e&chksm=80b0b878b7c7316e1a065ae991c534cc11ca5fe72b33690a98fb1c3f6f53f8c98c4c8744cd3a#rd)介绍了css盒子模型、浮动和清除，这一篇介绍 css元素的定位。\n\n## 定位（position）\nCSS 布局的核心是 position 属性，对元素盒子应用这个属性，可以相对于它在常规文档流中的位置重新定位。\nposition 属性有4个值：`static`、`relative`、`absoulte`、`fixed`，默认值为 static。\n\n接下来我会用以下四个段落来逐个说明这些属性是什么意思。\n\n```html\n<p id=\"first\">First Paragraph</p>\n<p id=\"Second\">Second Paragraph</p>\n<p id=\"specialpara\">Third Paragraph</p>\n<p id=\"fourth\">First Paragraph</p>\n```\n\n### 静态定位（static）\n\n我们先看一下四个段落都采用静态定位的效果。\n\n![四段都采用静态定位的图示](http://media.gusibi.mobi/R_7xrRQEA1TEc4S1GJsxwpfz99rx6nvnb0KZNOc1m-D5P8bdMAq-mQsvZ85xxMSb)\n\n> 静态定位下，每个元素在处在常规文档流中，它们都是块级元素，所以会在页面中自上而下地堆叠。\n\n### 相对定位（relative）\n\n现在我把第三段的 position 属性设置为 relative。\n\n```css\np#specialpara {\n    position: relative;\n    top: 25px;\n    left: 30px;\n}\n```\n\n因为相对定位`相对的是它原来在文档流中的位置（默认位置）`，所以如果只设置 position 样式不会有任何变化。这里我同时设置了 top 和 left 属性来改变它的位置。\n\n现在它的效果如图所示：\n\n![第三段使用相对定位的效果图](http://media.gusibi.mobi/5OFF-2lXXl-JAY4tUuAl0V3Z5q6livJzUz11Fs7N8nIbz9mYgGp8GlzA6oM6_U9J)\n\n> 现在，第三段从原来的元素（body）中挣脱了出来，与它在文档中的默认位置相比向下移动了25像素，向右移动了30像素。\n\n需要注意的是，除了这个元素自己相对于原始位置挪动了一下以外，页面没有任何改变。这个元素原来占据的空间没有动，其他元素也没动。\n\n这时，如果不想第四段被它挡住，可以给第四段设置一个 margin-top 值。\n\n### 绝对定位（absoulte）\n\n绝对定位跟静态定位和相对定位相比，它会把元素彻底从文档流中拿出来。\n\n我们把 position 改为绝对定位看一下：\n\n```css\np#specialpara {\n    position: absoulte;\n    top: 25px;\n    left: 30px;\n}\n```\n\n效果如图：\n\n![第三段使用绝对定位的效果图](http://media.gusibi.mobi/2-U0Y3OwzCz9gOLmV-LF96-U1nnRhPUjvX6InOVjCfPo9vWCqwx0d_mQlmsFCkWL)\n\n> 可以看到，第三段原来的位置被回收了。这说明绝对定位的元素脱离了常规文档流，它现在是相对于顶级元素 body 在定位。\n\n现在就涉及到一个概念：`定位上下文`，这个后边说，先继续看最后一种定位方式：`固定定位`。\n\n> `盒子位移属性是如何工作？`\n\n>盒子的位移属性有四个“top、right、bottom和left”，用来指定元素的定位位置和方向。这些属性只能在元素的“position”属性设置了“relative、absolute和fixed”属性值，才生效。\n\n>对于相对定位元素，这些属性的设置让元素从默认位置移动。例如，top设置一个值“20px”在一个相对定位的元素上，这个元素会在原来位置向下移动“20px”。\n\n>对于绝对定位和固定定位，这些属性指定了元素与父元素边缘之间的距离，例如，绝对定位的元素设置一个“top”值为“20px”，将使绝对定位元素相对于其设置了相对定位的祖先元素顶部边缘向下移动“20px”，反之，如果设置一个“top”值为“20px”，将使绝对定位元素相对于其设置了相对定位的祖先元素顶部边缘向上移动“20px”。（绝对定位的参考点是其祖先元素设置了“relative”或者“absolute”值）。\n\n事实上，一个相对定位元素同时设置了“top”和“bottom”位移属性值，实际上“top”优先级高于“bottom”。然而，一个相对定位元素同时设置了“left”和“right”位移属性，他们的优先级取决于页面使用的是哪种语言，例如，如果你的页面是英文页面，那么“left”位移属性优先级高，如果你的页面是阿拉伯语，那么“right”的位移属性优先级高\n\n### 固定定位（fixed）\n\n固定定位与绝对定位类似，我们先看下把定位改为相对定位的效果：\n\n```css\np#specialpara {\n    position: fixed;\n    top: 25px;\n    left: 30px;\n}\n```\n\n效果如图：\n\n![第三段使用固定定位的效果图](http://media.gusibi.mobi/g_yr-9KcVSriUd_apawLXJRM3qoZ5fHF3rbJXhq2kUafT3A_eg9D2Jv8Dd0sUTMf)\n\n> 这样看效果和绝对定位完全一致，但是固定定位的定位上下文是`浏览器窗口`，她并不会随页面滚动。\n\n以下是使用相对定位和固定定位的图示：\n\n![使用固定定位的示意图](http://media.gusibi.mobi/31atM18aEdu0ogKsBdM0c1Dmc-l_Gyw2sIee4TE6NCCIG7A1YXAbSUZA_OWRUttM)\n\n![使用绝对定位的示意图](http://media.gusibi.mobi/G0pLxrvwS6cxCaesieCs9inVKgzsyolbzRFIYcqvwDhnIIprWTlRWj8p6UCFo9SP)\n\n#### 固定页头和页脚\n\n固定定位最常见的一种用途就是在页面中创建一个固定头部、或者脚部、或者固定页面的一个侧面。就算是用户移动浏览器的滚动条，还是会固定在页面。\n\n现在我们来看下定位上下文。\n\n## 定位上下文\n\n把元素的 position 属性设定为 relative、absolute或 fixed 后，可以使用 top、right、bottom 和 left 属性，相对于另一个元素移动该元素的位置。这里`另一个元素`就是当前元素的`定位上下文`。\n\n我们在介绍绝对定位的时候说过，绝对定位元素默认的定位上下文是  `body`，这是因为 body 是标记中所有元素唯一的祖先元素。不过，如果把他相应的元素设定为 relative，绝对定位元素的任何祖先元素都可以成为它的定位上下文。\n\n比如：\n\n```html\n<body>\n    <div id=\"outer\">\n      <div id=\"inner\"> This is text for a paragraph to demonstrate contextual\n        positioning. Here are two divs, one nested in the other. The inner div now\n        has absolute positioning, so it positions itself relative to the default\n        positioning context, body.</div>\n    </div>\n</body>\n```\n\ncss 样式如下：\n\n```css\ndiv#outer {\n    width:250px; \n    margin:100px 40px; \n    border-top:3px solid red;\n}\ndiv#inner {\n    top:10px; \n    left:20px; \n    background:#DDD;\n}\n```\n\n结果如图：\n\n![两个嵌套的 div。给外部的上方加了边框，给内部的加了背景](http://media.gusibi.mobi/GMOwNNvXspDO5-z8jgN_xtU39GWx6F8kGIgO4f1rjWfLBbY8GxRspaF65xve5nJy)\n\n> 这里内部和外部的 div 都是是静态定位，不存在谁是谁的定位上下文这个问题，所以 top 和 left 属性并没有生效。\n\n下面我们把内部 div 设定为绝对定位，来看一下变化。\n\n```css\ndiv#inner {\n    top:10px; \n    left:20px; \n    background:#DDD;\n}\n```\n\n这是效果如图：\n![这里由于定位上下文是 body，所以 top 和 left 都是相对于 body 的移动](http://media.gusibi.mobi/tIL-dsUeItz8GycFe89rmxUphejURxfSZLEkO4KjefpEJATysQV5_Ny-EujVmlcT)\n\n这里由于不存在相对定位的其他祖先元素可以作为定位上下文，绝对定位只能相对于 body 定位。\n\n> 事实上，只要把元素的外边距和内边距设定好，多数情况下使用静态定位就可以实现页面布局了。`除非真正需要那么做，否则不要轻易修改元素的 position 属性。`\n\n现在我们把外部 div 的 position 设置为 relative：\n\n```css\ndiv#outer {\n    position: relative;\n    width:250px; \n    margin:100px 40px; \n    border-top:3px solid red;\n}\n```\n\n![外部 div 改为相对定位的效果图](http://media.gusibi.mobi/jA4DvQn5T5PjIWmFJc7FE8bx5a31PMF5Y8czNOGD0d_5MdAoE_PM44bIT1-fa0_y)\n\n外部 div 改为相对定位之后，后代中绝对定位的元素就会按照 top 和 left 属性的设定，相对于外部 div 定位。此时内部 div的 top 和 left 属性参照的就是外部 div。\n\n最后我们说一下和定位相关的显示属性。\n\n## 显示属性\n\n所有的元素都有`display`属性。display 属性有两个最常用的值：`block（块级元素）`和`inline（行内元素）`。\n\n* 块级元素：比如段落、标题、列表等，在浏览器中上下堆叠显示。\n* 行内元素：比如 a、span、和 img，在浏览器中左右并排显示，只有前一行没有空间时才会显示对下一行。\n\n块级元素和行内元素是可以互相转化的：\n\n```css\n/*默认为块级元素*/\np {display: inline;}\n/*默认为行内元素*/\na {display: block;}\n```\n\n> display 还有一个属性值：`none`。把display设置为 none，该元素及所有包含在其中的元素，都不会在页面中显示。它们原来占据的空间也会被回收\n> 相对的属性是 `visibility`，这个属性常用的值是 visible（默认）和 hidden。把元素的 visibility 设定为 hidden，元素会隐藏，但它占据的空间仍然存在。\n\n我们上一篇 [CSS入门指南-2：盒子模型、浮动和清除](https://mp.weixin.qq.com/s?__biz=MzAwNjI5MjAzNw==&mid=2655752018&idx=1&sn=6915e4f11ba08fa196a64375224cd92e&chksm=80b0b878b7c7316e1a065ae991c534cc11ca5fe72b33690a98fb1c3f6f53f8c98c4c8744cd3a#rd) 中提到的 `clearfix` 类就用到了这个属性，在那里我们会添加一个块级元素，然后把内容隐藏，以用来清除浮动。clearfix 的样式如下：\n\n```css\n.clearfix:after {\n     content: \".\";\n     display: block;\n     height: 0;\n     clear: both;\n     visibility: hidden;\n    }\n```\n\n## 参考链接\n\n* [10步掌握CSS定位: position static relative absolute float](http://www.see-design.com.tw/i/css_position.html)\n* [HTML和CSS高级指南之二——定位详解](https://www.w3cplus.com/css/advanced-html-css-lesson2-detailed-css-positioning.html)\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "categories": [
          "development",
          "web",
          "读书笔记",
          "前端"
        ],
        "date": "2017-07-26 14:21:49",
        "author": "goodspeed",
        "permalink": "/post/css-learing-3-positioning-elements",
        "tags": [
          "css",
          "读书笔记",
          "html",
          "tutorial",
          "前端"
        ],
        "title": "CSS入门指南-3：定位元素",
        "published": false,
        "hideInList": false,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "css-learing-3-positioning-elements"
    },
    {
      "content": "\n> 最近想做个小程序，需要用到授权认证流程。以前项目都是用的 OAuth2 认证，但是Sanic 使用OAuth2 不太方便，就想试一下 JWT 的认证方式。\n> 这一篇主要内容是 JWT 的认证原理，以及python 使用 jwt 认识的实践。\n\n## 几种常用的认证机制\nHUGOMORE42\n### HTTP Basic Auth\n\n`HTTP Basic Auth` 在HTTP中，基本认证是一种用来允许Web浏览器或其他客户端程序在请求时提供用户名和口令形式的身份凭证的一种登录验证方式，通常用户名和明码会通过HTTP头传递。\n\n在发送之前是以用户名追加一个冒号然后串接上口令，并将得出的结果字符串再用Base64算法编码。例如，提供的用户名是Aladdin、口令是open sesame，则拼接后的结果就是Aladdin:open sesame，然后再将其用`Base64编码`，得到QWxhZGRpbjpvcGVuIHNlc2FtZQ==。最终将Base64编码的字符串发送出去，由接收者解码得到一个由冒号分隔的用户名和口令的字符串。\n\n> `优点` \n基本认证的一个优点是基本上所有流行的网页浏览器都支持基本认证。\n\n> `缺点` \n由于用户名和密码都是Base64编码的，而Base64编码是可逆的，所以用户名和密码可以认为是明文。所以只有在客户端和服务器主机之间的连接是安全可信的前提下才可以使用。\n\n接下来我们看一个更加安全也适用范围更大的认证方式 `OAuth`。\n\n### OAuth\n\nOAuth 是一个关于授权（authorization）的开放网络标准。允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。现在的版本是2.0版。\n\n严格来说，OAuth2不是一个标准协议，而是一个安全的授权框架。它详细描述了系统中不同角色、用户、服务前端应用（比如API），以及客户端（比如网站或移动App）之间怎么实现相互认证。\n\n#### 名词定义\n\n* Third-party application: 第三方应用程序，又称\"客户端\"（client）\n* HTTP service：HTTP服务提供商\n* Resource Owner：资源所有者，通常称\"用户\"（user）。\n* User Agent：用户代理，比如浏览器。\n* Authorization server：认证服务器，即服务提供商专门用来处理认证的服务器。\n* Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。\n\nOAuth 2.0 运行流程如图：\n\n![OAuth 2.0 运行流程](http://media.gusibi.mobi/9zOAPS-K2Eo9C8vlyPe4EpQ15mRaKCsK8gCy5Wdu2bhogzTImDN0g_v8y7ufbdRl)\n\n（A）用户打开客户端以后，客户端要求用户给予授权。\n（B）用户同意给予客户端授权。\n（C）客户端使用上一步获得的授权，向认证服务器申请令牌。\n（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。\n（E）客户端使用令牌，向资源服务器申请获取资源。\n（F）资源服务器确认令牌无误，同意向客户端开放资源。\n\n> `优点`\n快速开发\n实施代码量小\n维护工作减少\n如果设计的API要被不同的App使用，并且每个App使用的方式也不一样，使用OAuth2是个不错的选择。\n\n> `缺点`：\n> OAuth2是一个安全框架，描述了在各种不同场景下，多个应用之间的授权问题。有海量的资料需要学习，要完全理解需要花费大量时间。\n> OAuth2不是一个严格的标准协议，因此在实施过程中更容易出错。\n\n了解了以上两种方式后，现在终于到了本篇的重点，JWT 认证。\n\n## JWT 认证\n\n> `Json web token (JWT)`, 根据官网的定义，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。\n\n### JWT 特点\n\n* 体积小，因而传输速度快\n* 传输方式多样，可以通过URL/POST参数/HTTP头部等方式传输\n* 严格的结构化。它自身（在 payload 中）就包含了所有与用户相关的验证消息，如用户可访问路由、访问有效期等信息，服务器无需再去连接数据库验证信息的有效性，并且 payload 支持为你的应用而定制化。\n* 支持跨域验证，可以应用于单点登录。\n\n### JWT原理\n\nJWT是Auth0提出的通过对JSON进行加密签名来实现授权验证的方案，编码之后的JWT看起来是这样的一串字符：\n\n```\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ  \n```\n由 `.` 分为三段，通过解码可以得到：\n\n#### 1. 头部（Header）\n\n```python\n// 包括类别（typ）、加密算法（alg）；\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n```\n\njwt的头部包含两部分信息：\n\n* 声明类型，这里是jwt\n* 声明加密的算法 通常直接使用 HMAC SHA256\n\n然后将头部进行base64加密（该加密是可以对称解密的)，构成了第一部分。\n\n```sh\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9\n```\n\n#### 2. 载荷（payload）\n\n载荷就是存放有效信息的地方。这些有效信息包含三个部分：\n\n* 标准中注册声明\n* 公共的声名\n* 私有的声明\n\n`公共的声明 ：`\n公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。\n\n`私有的声明 ：`\n私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。\n\n下面是一个例子：\n\n``` python\n// 包括需要传递的用户信息；\n{ \"iss\": \"Online JWT Builder\", \n  \"iat\": 1416797419, \n  \"exp\": 1448333419, \n  \"aud\": \"www.gusibi.com\", \n  \"sub\": \"uid\", \n  \"nickname\": \"goodspeed\", \n  \"username\": \"goodspeed\", \n  \"scopes\": [ \"admin\", \"user\" ] \n}\n```\n\n* iss: 该JWT的签发者，是否使用是可选的；\n* sub: 该JWT所面向的用户，是否使用是可选的；\n* aud: 接收该JWT的一方，是否使用是可选的；\n* exp(expires): 什么时候过期，这里是一个Unix时间戳，是否使用是可选的；\n* iat(issued at): 在什么时候签发的(UNIX时间)，是否使用是可选的；\n\n其他还有：\n\n* nbf (Not Before)：如果当前时间在nbf里的时间之前，则Token不被接受；一般都会留一些余地，比如几分钟；，是否使用是可选的；\n* jti: jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击。\n\n将上面的JSON对象进行`base64编码`可以得到下面的字符串。这个字符串我们将它称作JWT的Payload（载荷）。\n\n```\neyJpc3MiOiJPbmxpbmUgSldUIEJ1aWxkZXIiLCJpYXQiOjE0MTY3OTc0MTksImV4cCI6MTQ0ODMzMzQxOSwiYXVkIjoid3d3Lmd1c2liaS5jb20iLCJzdWIiOiIwMTIzNDU2Nzg5Iiwibmlja25hbWUiOiJnb29kc3BlZWQiLCJ1c2VybmFtZSI6Imdvb2RzcGVlZCIsInNjb3BlcyI6WyJhZG1pbiIsInVzZXIiXX0\n```\n> `信息会暴露`：由于这里用的是可逆的base64 编码，所以第二部分的数据实际上是明文的。我们应该避免在这里存放不能公开的隐私信息。\n\n#### 3. 签名（signature）\n\n```python\n// 根据alg算法与私有秘钥进行加密得到的签名字串；\n// 这一段是最重要的敏感信息，只能在服务端解密；\nHMACSHA256(  \n    base64UrlEncode(header) + \".\" +\n    base64UrlEncode(payload),\n    SECREATE_KEY\n)\n```\n\njwt的第三部分是一个签证信息，这个签证信息由三部分组成：\n\n* header (base64后的)\n* payload (base64后的)\n* secret\n\n将上面的两个编码后的字符串都用句号.连接在一起（头部在前），就形成了:\n\n```\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJKb2huIFd1IEpXVCIsImlhdCI6MTQ0MTU5MzUwMiwiZXhwIjoxNDQxNTk0NzIyLCJhdWQiOiJ3d3cuZXhhbXBsZS5jb20iLCJzdWIiOiJqcm9ja2V0QGV4YW1wbGUuY29tIiwiZnJvbV91c2VyIjoiQiIsInRhcmdldF91c2VyIjoiQSJ9\n```\n\n最后，我们将上面拼接完的字符串用HS256算法进行加密。在加密的时候，我们还需要提供一个密钥（secret）。如果我们用 `secret` 作为密钥的话，那么就可以得到我们加密后的内容:\n\n```\npq5IDv-yaktw6XEa5GEv07SzS9ehe6AcVSdTj0Ini4o\n```\n\n将这三部分用.连接成一个完整的字符串,构成了最终的jwt:\n\n```\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJPbmxpbmUgSldUIEJ1aWxkZXIiLCJpYXQiOjE0MTY3OTc0MTksImV4cCI6MTQ0ODMzMzQxOSwiYXVkIjoid3d3Lmd1c2liaS5jb20iLCJzdWIiOiIwMTIzNDU2Nzg5Iiwibmlja25hbWUiOiJnb29kc3BlZWQiLCJ1c2VybmFtZSI6Imdvb2RzcGVlZCIsInNjb3BlcyI6WyJhZG1pbiIsInVzZXIiXX0.pq5IDv-yaktw6XEa5GEv07SzS9ehe6AcVSdTj0Ini4o\n```\n\n> `签名的目的`：签名实际上是对头部以及载荷内容进行签名。所以，如果有人对头部以及载荷的内容解码之后进行修改，再进行编码的话，那么新的头部和载荷的签名和之前的签名就将是不一样的。而且，如果不知道服务器加密的时候用的密钥的话，得出来的签名也一定会是不一样的。\n> 这样就能保证token不会被篡改。\n\ntoken 生成好之后，接下来就可以用token来和服务器进行通讯了。\n\n下图是client 使用 JWT 与server 交互过程:\n\n![client 使用 JWT 与server 交互过程](http://media.gusibi.mobi/o-dTqqd8zFCnMRDTifTFZJ-8ASvco764IQHFQt5fYDQDmNPn_XuCgMNy_XSUYh1N)\n\n这里在第三步我们得到 JWT 之后，需要将JWT存放在 client，之后的每次需要认证的请求都要把JWT发送过来。（请求时可以放到 header 的 Authorization ）\n\n### JWT 使用场景\n\nJWT的主要优势在于使用无状态、可扩展的方式处理应用中的用户会话。服务端可以通过内嵌的声明信息，很容易地获取用户的会话信息，而不需要去访问用户或会话的数据库。在一个分布式的面向服务的框架中，这一点非常有用。\n\n但是，如果系统中需要使用黑名单实现长期有效的token刷新机制，这种无状态的优势就不明显了。\n\n> `优点`\n快速开发\n不需要cookie\nJSON在移动端的广泛应用\n不依赖于社交登录\n相对简单的概念理解\n\n> `缺点`\nToken有长度限制\nToken不能撤销\n需要token有失效时间限制(exp)\n\n## python 使用JWT实践\n\n我基本是使用 python 作为服务端语言，我们可以使用 [pyjwt：https://github.com/jpadilla/pyjwt/](https://github.com/jpadilla/pyjwt/)\n\n使用比较方便，下边是我在应用中使用的例子：\n\n```python\nimport jwt\nimport time\n\n# 使用 sanic 作为restful api 框架 \ndef create_token(request):\n    grant_type = request.json.get('grant_type')\n    username = request.json['username']\n    password = request.json['password']\n    if grant_type == 'password':\n        account = verify_password(username, password)\n    elif grant_type == 'wxapp':\n        account = verify_wxapp(username, password)\n    if not account:\n        return {}\n    payload = {\n        \"iss\": \"gusibi.com\",\n         \"iat\": int(time.time()),\n         \"exp\": int(time.time()) + 86400 * 7,\n         \"aud\": \"www.gusibi.com\",\n         \"sub\": account['_id'],\n         \"username\": account['username'],\n         \"scopes\": ['open']\n    }\n    token = jwt.encode(payload, 'secret', algorithm='HS256')\n    return True, {'access_token': token, 'account_id': account['_id']}\n    \n\ndef verify_bearer_token(token):\n    #  如果在生成token的时候使用了aud参数，那么校验的时候也需要添加此参数\n    payload = jwt.decode(token, 'secret', audience='www.gusibi.com', algorithms=['HS256'])\n    if payload:\n        return True, token\n    return False, token\n```\n\n这里，我们可以使用 jwt 直接生成 token，不用手动base64加密和拼接。\n\n详细代码可以参考 [gusibi/Metis: 一个测试类小程序（包含前后端代码）](https://github.com/gusibi/Metis/blob/master/apis/verification.py)。\n\n> 这个项目中，api 使用 python sanic，文档使用 [swagger-py-codegen](https://github.com/guokr/swagger-py-codegen) 生成，提供 swagger ui。\n\n现在可以使用 swagger ui 来测试jwt。\n\n![swagger ui 界面](http://media.gusibi.mobi/QJiuK_OVWOjin9Lrh_Z9Y3Q8TKce5XAHgU1v4p7e7XG-TpS4rowapEbjl--zoMle)\n\n## 总结\n\n这一篇主要介绍了 jwt 的原理、验证步骤，最后是使用 `pyjwt` 包演示 生成token以及校验token的方法。\n\n> 以上提到的包可以在`公号回复关键字`获取地址\n\n### 预告，下一篇是介绍小程序中使用 JWT 的认证流程及实现。 \n\n## 参考链接\n\n* [HTTP基本认证](https://zh.wikipedia.org/wiki/HTTP基本认证)\n* [访问需要HTTP Basic Authentication认证的资源的各种语言的实现](http://www.cnblogs.com/QLeelulu/archive/2009/11/22/1607898.html)\n* [理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n* [OAuth 2和JWT - 如何设计安全的API？](http://moakap.leanote.com/post/OAuth-2-vs.-JSON-Web-Token-JWT-如何设计安全的API？)\n* [Securing RESTful Web Services with OAuth2](https://content.pivotal.io/blog/securing-restful-web-services-with-oauth2)\n* [Server 端的认证——拥抱 ](https://juejin.im/entry/581c8e92bf22ec0068c0cbfc)\n* [JSON Web Token - 在Web应用间安全地传递信息](http://blog.leapoahead.com/2015/09/06/understanding-jwt/)\n* [八幅漫画理解使用JSON Web](http://blog.leapoahead.com/2015/09/07/user-authentication-with-jwt/)\n* [基于Token的WEB后台认证机制](http://www.cnblogs.com/xiekeli/p/5607107.html)\n* [什么是 JWT -- JSON WEB TOKEN](http://www.jianshu.com/p/576dbf44b2ae)\n------\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "理解JWT（JSON Web Token）认证及实践",
        "date": "2017-07-23 13:05:57",
        "tags": [
          "restful",
          "tutorial",
          "swagger"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "jwt-learn-and-practice-with"
    },
    {
      "content": "> 这是CSS设计指南的读书笔记，用于加深学习效果。\n\n上一篇介绍了css 的工作原理，这一篇主要介绍`盒子模型`和`浮动`。\n\n## 盒子模型\n\n> 所谓盒子模型，就是浏览器为页面中的每个HTML元素生成的矩形盒子。这些盒子们都要按照可见版式模型在页面上排布。\n\nHUGOMORE42\n\n可见的页面版式主要由三个属性控制：position、display和float。\n\n* position：控制页面上元素的位置关系\n* display：控制元素是堆叠、并排还是不在页面出现\n* float：提供控制的方式，以便吧元素组成多栏布局\n\n元素盒子的属性可以分成三组：\n\n* 边框(board)。可以甚至边框的宽窄、样式和颜色\n* 内边距(padding)。可以甚至盒子内容区与边框的间距\n* 外边距(margin)。可以设置盒子与相邻元素的间距\n\n\n![盒模型示意图展示了HTML元素的边框、内边距和外边距之间的关系](http://omuo4kh1k.bkt.clouddn.com/4J2VDi7TIFFuSOVgWp-3uuDrzvYh7oMDxeNv5OxgpaQoUGlHPo8tL43fAa5iheKn)\n\n元素盒子还有一个背景层，可以改变颜色，也可以添加图片。\n\n### 简写样式\n\nCSS为边框、内边距和外边距分别规定了简写属性，每个简写声明中，属性值得顺序都是上、右、下、左。\n\n比如：\n\n```css\n{\n  margin-top: 5px; \n  margin-right: 10px;\n  margin-bottom: 12px; \n  margin-left: 8px;\n}\n```\n\n使用简写则为这样：\n\n```css\n{\n    margin: 12px 10px 12px 8px;\n}\n```\n如果有一个值没写，那么则使用对边的值。\n\n比如：\n\n```css\n{margin: 12px 10px 12px;}\n/*等同于*/\n{\n    margin: 12px 10px 12px 10px;\n}\n```\n\n如果只写一个值，则4个边都取这个值。\n\n```css\n{margin: 12px;}\n/*等同于*/\n{margin: 12px 12px 12px 12px;}\n```\n\n另外每个盒子的属性也分三个粒度，这三个粒度从一般到特殊分别举例如下：\n\n```css\n{\n    border: 2px dashed red;\n}\n```\n\n混合使用三种粒度的简写属性达成设计目标是很常见的。比如，想为盒子的上边和下边添加4像素的红色边框，为左边添加1像素宽的红色边框，而右边没有。可以这么写：\n\n```css\n{border: 4px solid red;} /* 先给4条边设置相同的样式*/\n{border-left-width: 1px;} /* 修改左边框宽度*/\n{border-fight: none;} /*移出右边框*/\n```\n\n### 盒子边框\n\nborder 有三个相关属性。\n\n* 宽度（border-width)。可以使用thin、medium和thick等文本值，也可以使用除百分比和负值之外的任何绝对值。\n* 样式（border-style)。有none、hidden、dotted、dashed等文本值。\n* 颜色（border-color）。可以使用任意颜色值，包括RGB、HSL、十六进制颜色值和颜色关键字。\n\n### 盒子内边距\n\n内边距是盒子内容区与盒子边框之间的距离。\n\n![](http://omuo4kh1k.bkt.clouddn.com/sKiD0I3LeE7lTK8rARqH8TFpzVK9vh4QoAWCg_7Ll7m9V8VMkBNKY_YfvVUueia8)\n\n上图的样式为：\n\n```css\np {\n    font: 16px helvetica, sans-serif; \n    width: 220px; \n    border: 2px solid red; \n    background-color: #caebff;\n}\n```\n可以看到在没有设定内边距的情况下，内容紧挨着边框。\n\n设定边框后：\n\n```css\np {\n    font: 16px helvetica, arial, sans-serif; \n    width: 220px; \n    border: 2px solid red; \n    background-color: #caebff; \n    padding: 10px;\n}\n```\n效果如下，可以看到样式舒服了很多：\n\n![添加内边距后的效果图](http://omuo4kh1k.bkt.clouddn.com/k6hxSxGq2igZL_RfVnFVqsdD-kX40LgyIPKoXyOprfTQfgL2DdnU4RRBB0c7qYXB)\n\n> 内边距在盒子的内部，所以也会取得盒子背景。也就是说，多出来的内边距并没有挤压文本内容，实际是加在了声明的盒子宽度之上。\n\n### 盒子外边距\n\n![外边距的例子](http://media.gusibi.mobi/nU6FAYz7aFdQrfj7ByrBHbcvJx5F86G_jlpttdfaGt24vpb4KsYUln3JuVW7ZZ14)\n\n上图的例子中，第一组是默认情况，第二组是在第一组基础上添加了边框，第三组是把第二组的外边距设置为了0，标题和段落全紧挨在一起了。\n\n> 推荐大家吧这条规则作为样式表的第一条规则：\n\n```css\n* {margin: 0; padding: 0;}\n```\n\n这条规则是把所有元素默认的外边距和内边距都设定为0。这样，我们可以为那些真正需要添加边距的元素设定边距。\n\n### 叠加外边距\n\n比如下边这个样式：\n\n```css\np {\n    height: 50px;\n    border: 1px solid #000;\n    backgroundcolor: #fff;\n    margin-top: 50px;\n    margin-bottom: 30px;\n}\n```\n\n如果我们把这个样式应用到3个前后相接的段落上，由于上边距和下边距相邻，`你可能会认为他们之间的外边距是80（50+30）像素，但是实际上是50像素`，这就是边距叠加。\n\n> 垂直方向上外边距会叠加 水平方向的不会\n> `外边距单位` 根据经验，水平边距可以使用像素，以便该段文本始终与包含元素边界保持固定间距，不受自豪变大或变小的影响。而对于上下外边距，已`em` 为单位则可以让段间距随字号变化而相应增大或缩小。\n\n\n### 盒子有多大\n\n### 没有宽度的盒子\n\n如果没有显式的设置元素的 `width` 属性，我们就称这个盒子没有宽度。\n如果没有设定 width， 那么这个属性的默认值是 auto，会让元素的宽度扩展到与父元素同宽。\n\n我们看个例子🌰：\n\n```html\n<body>\n<p> 这个元素没有设置宽度</p>\n</body>\n```\n\n设置样式：\n\n```css\nbody {\n    font-family: helvetica, arial, sans-serif;\n    size: 1em;\n    marging: 0px;\n    background-color: #caebff;\n}\n\np {\n    margin: 0;\n    background-color: #fff;\n}\n```\n\n![不设置宽度的样式](http://media.gusibi.mobi/ZzLp1aWGAOITCd_lxtpRdQ6NX1NRqE8Sgjk38YvazbBCB8nExjmrAL5CPZsDAG7U)\n\n可以看到，不给段落设置宽度，段落会填满 body 元素。\n\n为了更加明显，我给段落左右分别加一个边框，再加一个外边距。\n\n```css\np {\n    margin:0 30px; \n    background-color:#fff; \n    padding:0 20px; \n    border: solid red; \n    border-width: 0 6px;\n}\n```\n\n![段落添加左右边框](http://media.gusibi.mobi/Wc3Sep8w8seiPVOK-aC70y-maRXmdR0gqqLq9pLXZvjtu0FuTKruWq8mKX_dLMj6)\n\n这时段落内容区域变成了 288像素（我把浏览器宽度手动调成了400px，400-(20+6+30)x2）。\n\n> `结论`：没有宽度的元素始终会扩展到填满其父元素的宽度为止。添加水平边框、内边距和外边距会导致内容宽度减少，减少量等于水平边框、内边距和外边距的和。\n\n### 有宽度的盒子\n\n还是上边的例子，我们先把外边距去掉，固定宽度400px；\n\n```css\np {\n    width:400px; \n    margin:0; \n    padding:0 20px;  \n    border:solid red;  \n    border-width: 0 6px  0 6px;  \n    background-color:#fff;\n}\n```\n\n![设定宽度、内边距、边框的样式](http://media.gusibi.mobi/p-NHopjzQr4Wb9oQGYVrmjTT-kROYvB0p-cBVEW2uEtliPKnMDxZC-0NowuYuzs0)\n\n可以看到，盒子的宽度并不是400px，而是452像素（400+(20+6)*2）。\n\n再给盒子加上外边距：\n\n```css\np {\n    width:400px; \n    margin:0 30px; \n    padding:0 20px;  \n    border:solid red;  \n    border-width: 0 6px  0 6px;  \n    background-color:#fff;\n}\n```\n\n![设定宽度、内边距、外边距、边框的样式](http://media.gusibi.mobi/t1Np4vU0aQAiAJ-anFl4nJEEJVh_58Mtv5wgwG6umS103kIolQz374za8QFWbiP1)\n\n可以看到，这时总宽度达到了512像素（30+6+20+400+20+6+30=512）\n\n> `结论`: 为设定了宽度的盒子添加边框、内边距和外边距，会导致盒子更宽。实际上盒子的 width 属性设定的只是盒子内容区的宽度，而非盒子整体的宽度\n\n## 浮动与清除\n\n### 浮动\n\ncss 设计 float（浮动）属性的主要目的是为了实现文本绕排图片的效果，这个属性也是创建多栏布局最简单的方式。\n我们先看一个例子：\n\n```html\n<img .../>\n<p>..the paragraph text...</p>\n```\n\ncss 规则如下。\n\n```css\np {\n    margin: 0;\n    border: 1px solid red;\n}\nimg {\n    float: left;\n    margin: 0 4px 4px 0;\n}\n```\n这个例子的样式如图所示：\n![](http://media.gusibi.mobi/oO9LyVmGMagZ6OLJTOp6X4cVPsXliIY5i6DgzFeFm7tflJwZeZLbImciTfmC9yDl)\n> 这里我们给图片加了 `float: left` 样式，这时浏览器就会把图片向上推，直到它碰到父元素的内边界（也就是body）。后面的内容不再认为浮动元素在它的前边，所以它会占据父元素左上角的位置。不过，它的内容会绕开浮动的图片。\n\n### 创建分栏\n\n在上面的基初上如何使内容分栏呢？\n只要再用一`float` 属性就可以了。\n\n```css\np {\n    float: left; /* 加上这两行*/\n    width: 200px;\n    ...\n}\n```\n\n![](http://media.gusibi.mobi/uLsus15W0rQdkt-NzbZwFJuRlczzkEyAWgLb94eGAOGJN-9P_Xi644qyJcgviz8w)\n\n这样同时浮动图片和有宽度的段落，会使图片绕排效果消失，而浮动的段落也向左向上移动。变成了多栏的效果。\n\n### 围住浮动元素\n\n看下这个例子：\n\n```html\n<section>\n    <img src=\"images/rubber_duck2.jpg\">\n    <p>It's fun to float.</p>\n</section>\n<footer>Here is the footer element that runs across</footer>\n```\n\n应用样式如下：\n\n```css\nsection {\n    border: 1px solid blue;\n    margin: 0 0 10px 0;\n}\np {\n    marging: 0;\n}\nfooter {\n    border: 1px solid red;\n}\n```\n\n效果如图：\n\n![浮动图片后标题跑到了右边，但父元素section也收缩到只包含文本的高度](http://media.gusibi.mobi/FgZ9xXjRtez6W2GXoMKbhzDq25LRtJISiO90AYkJ6yEKJ9WB0QUvU1Zz-f7wEmlB)\n\n但这并不是我们想要的，我们并不想让footer 被提到上边。\n浮动元素脱离了原来的文档流，不受父元素的控制。如果我们想让父元素还包含浮动的子元素，怎么做呢？\n有三种方法：\n\n#### 为父元素应用 `overflow: hidden`\n\n只需要在 `section` 加上这个样式：\n```css\nsection {\n    overflow: hidden;\n    ...\n}\n```\n现在效果如图：\n\n![section 又包围了浮动的图片](http://media.gusibi.mobi/Kepon_jsAnaY99ITC0Oc5SapqZD5PjXOhwAuyeX-O8OH2Ag2hmryl9wH5jdI_gSR)\n\n> 实际上，`overflow: hidden` 声明凯真正用途是防止包含元素被超大内容撑大。也就是说应用上这个之后，包含元素（父元素）会保持其设定的宽度，如果子元素过大，会被截掉。\n\n#### 浮动父元素\n\n第二种方法是让父元素和子元素同时浮动。\n\n```css\nsection {\n    float: left;\n    width: 100%;\n    border: 1px solid blue;\n}\nimg {\n    float: left;\n}\nfooter {\n    border: 1px solid red;\n    clear: left;\n}\n```\n\n浮动section 后，不管其子元素是否浮动，都会被包围。因此需要用 `width: 100%` 让section 与浏览器同宽。由于section 也浮动，所以footer 会往它旁边挤，这时需要使用 `clear: left` 以保证不会被提升到浮动的元素旁边。\n\n#### 在父元素内容的末尾添加浮动元素，可以直接在标记中加，也可以通过给父元素添加clearfix 类来加。\n\n第三种方法是给父元素添加一个非浮动的子元素，然后清除该子元素。\n\n> 这种方式可以生效是因为父元素一定会包围非浮动子元素，且清除会让这个子元素处于最下。\n\n这里我们使用神奇的 `clearfix` 规则：\n\n```css\n.clearfix:after {\n\t content: \".\";\n\t display: block;\n\t height: 0;\n\t clear: both;\n\t visibility: hidden;\n\t}\n```\n\n这个 `clearfix` 规则最早是由程序员 `Tony Aslett` 发明的，它只添加了一个清除的包含句点作为非浮动元素（必须有内容，句点是最小的内容）。规则中其他生命是为了确保这个伪元素没有高度，而且不可见。\n\n> `after` 会在元素内容（而不是元素后插入一个伪元素）\n> 使用clear: both 意味着 section 中新增的子元素会被清除左右浮动元素。\n\n我们看了三种方法围住浮动元素的方式。\n\n那如果没有父元素，如果清除浮动呢？\n\n比如下边这个例子：\n\n```html\n<section>\n    <img src=\"images/rubber_duck3.jpg\">\n    <p>This text sits next to the image and because the text extends below the bottom of the image, the next image positions itself correctly under the previous image.</p>\n    <img src=\"images/beach_ball.jpg\">\n    <p>This text is short, so the next image can float up beside this one.</p>\n    <img src=\"images/yellow_float.jpg\">\n    <p>Because the previous image's text does not extend below it, this image and text move up next to the previous image. This problem can be solved by the use of the clear property.</p>\n</section>\n```\n样式如下：\n\n```css\nsection {\n    width:300px; b\n    order:1px solid red;\n}\nimg {\n    float:left; \n    margin:0 4px 4px 0;\n}\np {\n    font-family:helvetica, arial, sans-serif; \n    margin:0 0 5px 0;\n}\n```\n\n效果如图所示：\n\n![](http://media.gusibi.mobi/bgZc0EUo1bur6AIje1zvk3hrV2XF4obDGJ3YzGRfDEriPyfneQWQ45Xb5iEVIJCD)\n\n由于第二张图下方有空间，所以第三张图及说明文字会上浮到第二张图片右侧，这并不是我们想要的结果。\n\n我们想要的效果是如下图这样：\n\n![](http://media.gusibi.mobi/VBkwrlGf31kzH72-6luCmCeBgqCB2_-8giCfqQtY9KBWV0pU-5KsUFJ8STTJde2J)\n\n那怎么实现呢？ 还是应用 `clearfix` 规则。为每个段落加上clearfix 类。通过`clearfix`类清除元素后，布局就是我们希望的了。\n\n\n这一篇主要介绍了盒子模型，浮动和清除。下一篇介绍css 布局。\n\n-------\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "CSS入门指南-2：盒子模型、浮动和清除",
        "date": "2017-07-19 14:22:49",
        "tags": [
          "css",
          "读书笔记",
          "html",
          "tutorial",
          "前端"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "css-learing-2-box-model-float-and-clear"
    },
    {
      "content": "\n> <section class=\"caption\">asyncio </section> 上一篇我们介绍了 asyncio 包，以及如何使用异步编程管理网络应用中的高并发。在这一篇，我们主要介绍使用 asyncio 包编程的两个例子。\n\n## async/await语法\n\n我们先介绍下 async/await 语法，要不然看完这篇可能会困惑，为什么之前使用 asyncio.coroutine 装饰器 和 yield from，这里都是 用的 async 和 await？\n\n> [python并发2：使用asyncio处理并发](https://mp.weixin.qq.com/s?__biz=MzAwNjI5MjAzNw==&mid=2655751998&idx=1&sn=37833d3d7582d38f85a526de7eeda814)\n\nasync/await 是Python3.5 的新语法，语法如下：\n\n```python\nasync def read_data(db):\n    pass\n```\nasync 是明确将函数声明为协程的关键字，即使没有await表达式，函数执行也会返回一个协程对象。\n在协程函数内部，可以在某个表达式之前使用 await 关键字来暂停协程的执行，以等待某协程完成：\n\n```python\nasync def read_data(db):\n    data = await db.fetch('SELECT ...')\n```\n\n这个代码如果使用 asyncio.coroutine 装饰器语法为：\n\n```python\n@asyncio.coroutine\ndef read_data(db):\n    data = yield from db.fetch('SELECT ...')\n```\n\n这两段代码执行的结果是一样的，也就是说 可以把 asyncio.coroutine 替换为 async， yield from 替换为 await。\n\n使用新的语法有什么好处呢：\n* 使生成器和协程的概念更容易理解，因为语法不同\n* 可以消除由于重构时不小心移出协程中yield 声明而导致的不明确错误，这回导致协程变成普通的生成器。\n\n## 使用 asyncio 包编写服务器\n\n这个例子主要是使用 asyncio 包 和 unicodedata 模块，实现通过规范名称查找Unicode 字符。\n\n我们先来看一下代码：\n\n```python\n# charfinder.py\nimport sys\nimport re\nimport unicodedata\nimport pickle\nimport warnings\nimport itertools\nimport functools\nfrom collections import namedtuple\n\nRE_WORD = re.compile('\\w+')\nRE_UNICODE_NAME = re.compile('^[A-Z0-9 -]+$')\nRE_CODEPOINT = re.compile('U\\+[0-9A-F]{4, 6}')\n\nINDEX_NAME = 'charfinder_index.pickle'\nMINIMUM_SAVE_LEN = 10000\nCJK_UNI_PREFIX = 'CJK UNIFIED IDEOGRAPH'\nCJK_CMP_PREFIX = 'CJK COMPATIBILITY IDEOGRAPH'\n\nsample_chars = [\n    '$',  # DOLLAR SIGN\n    'A',  # LATIN CAPITAL LETTER A\n    'a',  # LATIN SMALL LETTER A\n    '\\u20a0',  # EURO-CURRENCY SIGN\n    '\\u20ac',  # EURO SIGN\n]\n\nCharDescription = namedtuple('CharDescription', 'code_str char name')\n\nQueryResult = namedtuple('QueryResult', 'count items')\n\n\ndef tokenize(text):\n    '''\n    :param text: \n    :return: return iterable of uppercased words \n    '''\n    for match in RE_WORD.finditer(text):\n        yield match.group().upper()\n\n\ndef query_type(text):\n    text_upper = text.upper()\n    if 'U+' in text_upper:\n        return 'CODEPOINT'\n    elif RE_UNICODE_NAME.match(text_upper):\n        return 'NAME'\n    else:\n        return 'CHARACTERS'\n\n\nclass UnicodeNameIndex:\n    # unicode name 索引类\n\n    def __init__(self, chars=None):\n        self.load(chars)\n\n    def load(self, chars=None):\n        # 加载 unicode name    \n        self.index = None\n        if chars is None:\n            try:\n                with open(INDEX_NAME, 'rb') as fp:\n                    self.index = pickle.load(fp)\n            except OSError:\n                pass\n        if self.index is None:\n            self.build_index(chars)\n        if len(self.index) > MINIMUM_SAVE_LEN:\n            try:\n                self.save()\n            except OSError as exc:\n                warnings.warn('Could not save {!r}: {}'\n                              .format(INDEX_NAME, exc))\n\n    def save(self):\n        with open(INDEX_NAME, 'wb') as fp:\n            pickle.dump(self.index, fp)\n\n    def build_index(self, chars=None):\n        if chars is None:\n            chars = (chr(i) for i in range(32, sys.maxunicode))\n        index = {}\n        for char in chars:\n            try:\n                name = unicodedata.name(char)\n            except ValueError:\n                continue\n            if name.startswith(CJK_UNI_PREFIX):\n                name = CJK_UNI_PREFIX\n            elif name.startswith(CJK_CMP_PREFIX):\n                name = CJK_CMP_PREFIX\n\n            for word in tokenize(name):\n                index.setdefault(word, set()).add(char)\n\n        self.index = index\n\n    def word_rank(self, top=None):\n        # (len(self.index[key], key) 是一个生成器，需要用list 转成列表，要不然下边排序会报错\n        res = [list((len(self.index[key], key)) for key in self.index)]\n        res.sort(key=lambda  item: (-item[0], item[1]))\n        if top is not None:\n            res = res[:top]\n        return res\n\n    def word_report(self, top=None):\n        for postings, key in self.word_rank(top):\n            print('{:5} {}'.format(postings, key))\n\n    def find_chars(self, query, start=0, stop=None):\n        stop = sys.maxsize if stop is None else stop\n        result_sets = []\n        for word in tokenize(query):\n            # tokenize 是query 的生成器 a b 会是 ['a', 'b'] 的生成器\n            chars = self.index.get(word)\n            if chars is None:\n                result_sets = []\n                break\n            result_sets.append(chars)\n\n        if not result_sets:\n            return QueryResult(0, ())\n\n        result = functools.reduce(set.intersection, result_sets)\n        result = sorted(result)  # must sort to support start, stop\n        result_iter = itertools.islice(result, start, stop)\n        return QueryResult(len(result),\n                           (char for char in result_iter))\n\n    def describe(self, char):\n        code_str = 'U+{:04X}'.format(ord(char))\n        name = unicodedata.name(char)\n        return CharDescription(code_str, char, name)\n\n    def find_descriptions(self, query, start=0, stop=None):\n        for char in self.find_chars(query, start, stop).items:\n            yield self.describe(char)\n\n    def get_descriptions(self, chars):\n        for char in chars:\n            yield self.describe(char)\n\n    def describe_str(self, char):\n        return '{:7}\\t{}\\t{}'.format(*self.describe(char))\n\n    def find_description_strs(self, query, start=0, stop=None):\n        for char in self.find_chars(query, start, stop).items:\n            yield self.describe_str(char)\n\n    @staticmethod  # not an instance method due to concurrency\n    def status(query, counter):\n        if counter == 0:\n            msg = 'No match'\n        elif counter == 1:\n            msg = '1 match'\n        else:\n            msg = '{} matches'.format(counter)\n        return '{} for {!r}'.format(msg, query)\n\ndef main(*args):\n    index = UnicodeNameIndex()\n    query = ' '.join(args)\n    n = 0\n    for n, line in enumerate(index.find_description_strs(query), 1):\n        print(line)\n    print('({})'.format(index.status(query, n)))\n\n\nif __name__ == '__main__':\n    if len(sys.argv) > 1:\n        main(*sys.argv[1:])\n    else:\n        print('Usage: {} word1 [word2]...'.format(sys.argv[0]))\n\n```\n\n这个模块读取Python内建的Unicode数据库，为每个字符名称中的每个单词建立索引，然后倒排索引，存入一个字典。\n例如，在倒排索引中，'SUN' 键对应的条目是一个集合，里面是名称中包含'SUN' 这个词的10个Unicode字符。倒排索引保存在本地一个名为charfinder_index.pickle 的文件中。如果查询多个单词，会计算从索引中所得集合的交集。\n运行示例如下：\n\n```python\n    >>> main('rook')  # doctest: +NORMALIZE_WHITESPACE\n    U+2656  ♖  WHITE CHESS ROOK\n    U+265C  ♜  BLACK CHESS ROOK\n    (2 matches for 'rook')\n    >>> main('rook', 'black')  # doctest: +NORMALIZE_WHITESPACE\n    U+265C  ♜  BLACK CHESS ROOK\n    (1 match for 'rook black')\n    >>> main('white bishop')  # doctest: +NORMALIZE_WHITESPACE\n    U+2657  ♗   WHITE CHESS BISHOP\n    (1 match for 'white bishop')\n    >>> main(\"jabberwocky's vest\")\n    (No match for \"jabberwocky's vest\")\n```\n\n这个模块没有使用并发，主要作用是为使用 asyncio 包编写的服务器提供支持。\n下面我们来看下 tcp_charfinder.py 脚本：\n\n```python\n# tcp_charfinder.py\nimport sys\nimport asyncio\n\n# 用于构建索引，提供查询方法\nfrom charfinder import UnicodeNameIndex\n\nCRLF = b'\\r\\n'\nPROMPT = b'?> '\n\n# 实例化UnicodeNameIndex 类，它会使用charfinder_index.pickle 文件\nindex = UnicodeNameIndex()\n\nasync def handle_queries(reader, writer):\n    # 这个协程要传给asyncio.start_server 函数，接收的两个参数是asyncio.StreamReader 对象和 asyncio.StreamWriter 对象\n    while True:  # 这个循环处理会话，直到从客户端收到控制字符后退出\n        writer.write(PROMPT)  # can't await!  # 这个方法不是协程，只是普通函数；这一行发送 ?> 提示符\n        await writer.drain()  # must await!  # 这个方法刷新writer 缓冲；因为它是协程，所以要用 await\n        data = await reader.readline()  # 这个方法也是协程，返回一个bytes对象，也要用await\n        try:\n            query = data.decode().strip()\n        except UnicodeDecodeError:\n            # Telenet 客户端发送控制字符时，可能会抛出UnicodeDecodeError异常\n            # 我们这里默认发送空字符\n            query = '\\x00'\n        client = writer.get_extra_info('peername')  # 返回套接字连接的远程地址\n        print('Received from {}: {!r}'.format(client, query))  # 在控制台打印查询记录\n        if query:\n            if ord(query[:1]) < 32:  # 如果收到控制字符或者空字符，退出循环\n                break\n            # 返回一个生成器，产出包含Unicode 码位、真正的字符和字符名称的字符串\n            lines = list(index.find_description_strs(query)) \n            if lines:\n                # 使用默认的UTF-8 编码把lines    转换成bytes 对象，并在每一行末添加回车符合换行符\n                # 参数列表是一个生成器\n                writer.writelines(line.encode() + CRLF for line in lines) \n            writer.write(index.status(query, len(lines)).encode() + CRLF) # 输出状态\n\n            await writer.drain()  # 刷新输出缓冲\n            print('Sent {} results'.format(len(lines)))  # 在服务器控制台记录响应\n\n    print('Close the client socket')  # 在控制台记录会话结束\n    writer.close()  # 关闭StreamWriter流\n\n\n\ndef main(address='127.0.0.1', port=2323):  # 添加默认地址和端口，所以调用默认可以不加参数\n    port = int(port)\n    loop = asyncio.get_event_loop()\n    # asyncio.start_server 协程运行结束后，\n    # 返回的协程对象返回一个asyncio.Server 实例，即一个TCP套接字服务器\n    server_coro = asyncio.start_server(handle_queries, address, port,\n                                loop=loop) \n    server = loop.run_until_complete(server_coro) # 驱动server_coro 协程，启动服务器\n\n    host = server.sockets[0].getsockname()  # 获得这个服务器的第一个套接字的地址和端口\n    print('Serving on {}. Hit CTRL-C to stop.'.format(host))  # 在控制台中显示地址和端口\n    try:\n        loop.run_forever()  # 运行事件循环 main 函数在这里阻塞，直到服务器的控制台中按CTRL-C 键\n    except KeyboardInterrupt:  # CTRL+C pressed\n        pass\n\n    print('Server shutting down.')\n    server.close()\n    # server.wait_closed返回一个 future\n    # 调用loop.run_until_complete 方法，运行 future\n    loop.run_until_complete(server.wait_closed())  \n    loop.close()  # 终止事件循环\n\n\nif __name__ == '__main__':\n    main(*sys.argv[1:])\n\n```\n\n运行 tcp_charfinders.py\n\n```bash\npython tcp_charfinders.py\n```\n\n打开终端，使用 telnet 命令请求服务，运行结果如下所示：\n\n![在 telnet 会话中访问tcp版字符串查找服务器所做的查询](http://media.gusibi.mobi/gjKne6lhnA1QoQEksLjU8ujZEIlaH-F622yCUcfD6QTB-M6DT84qK04A9rLMSosx)\n\nmain 函数几乎会立即显示 Serving on... 消息，然后在调用loop.run_forever() 方法时阻塞。这时，控制权流动到事件循环中，而且一直等待，偶尔会回到handle_queries 协程，这个协程需要等待网络发送或接收数据时，控制权又交给事件循环。\n\nhandle_queries 协程可以处理多个客户端发来的多次请求。只要有新客户端连接服务器，就会启动一个handle_queries 协程实例。\n\n> handle_queries 的I/O操作都是使用bytes格式。我们从网络得到的数据要解码，发出去的数据也要编码\n\nasyncio包提供了高层的流API，提供了现成的服务器，我们只需要实现一个处理程序。详细信息可以查看文档：[https://docs.python.org/3/library/asyncio-stream.html](https://docs.python.org/3/library/asyncio-stream.html)\n\n虽然，asyncio包提供了服务器，但是功能相对来说还是比较简陋的，现在我们使用一下 基于asyncio包的 web 框架 sanci，用它来实现一个http版的简易服务器\n\n> <section class=\"caption\">sanic</section> 的简单入门在上一篇文章有介绍，[python web 框架 Sanci 快速入门](https://mp.weixin.qq.com/s?__biz=MzAwNjI5MjAzNw==&mid=2655752001&idx=1&sn=2c2e84f5f493514fdbff482a28dd7551&chksm=80b0b86bb7c7317df9d1c7b13411a231b91bb107de5e99c5379a3d9d072d5d3fb8117f364188#rd)\n\n## 使用 sanic 包编写web 服务器\n \nSanic 是一个和类Flask 的基于Python3.5+的web框架，提供了比较高阶的API，比如路由、request参数，response等，我们只需要实现处理逻辑即可。\n\n下边是使用 sanic 实现的简易的 字符查询http web 服务：\n\n```python\nfrom sanic import Sanic\nfrom sanic import response\n\nfrom charfinder import UnicodeNameIndex\n\napp = Sanic()\n\nindex = UnicodeNameIndex()\n\nhtml_temp = '<p>{char}</p>'\n\n@app.route('/charfinder')  # app.route 函数的第一个参数是url path，我们这里指定路径是charfinder\nasync def charfinder(request):\n    # request.args 可以取到url 的查询参数\n    # ?key1=value1&key2=value2 的结果是 {'key1': ['value1'], 'key2': ['value2']}\n    # 我们这里支持传入多个查询参数，所以这里使用 request.args.getlist('char')\n    # 如果我们 使用 request.args.get('char') 只能取到第一个参数\n    query = request.args.getlist('char')\n    query = ' '.join(query)\n    lines = list(index.find_description_strs(query))\n    # 将得到的结果生成html\n    html = '\\n'.join([html_temp.format(char=line) for line in lines])\n    return response.html(html)\n\nif __name__ == '__main__':\n    app.run(host=\"0.0.0.0\", port=8000)  # 设置服务器运行地址和端口号\n```\n\n对比两段代码可以发现，使用 sanic 非常简单。\n\n运行服务：\n\n```sh\npython http_charsfinder.py\n```\n我们在浏览器输入地址 http://0.0.0.0:8000/charfinder?char=sun 结果示例如下\n\n![http://media.gusibi.mobi/BruF3mWEA0c2KEh5wqP92DajeNuZ_2LI6LeamF-kpYcDqmy8xlVw3V98tbIdHEeI](http://media.gusibi.mobi/BruF3mWEA0c2KEh5wqP92DajeNuZ_2LI6LeamF-kpYcDqmy8xlVw3V98tbIdHEeI)\n\n### 现在对比下两段代码 \n\n在TCP 的示例中，服务器通过main函数下的这两行代码创建并排定运行时间：\n\n```python\nserver_coro = asyncio.start_server(handle_queries, address, port,\n                                loop=loop)\nserver = loop.run_until_complete(server_coro)\n```\n\n而在sanic的HTTP示例中，使用，创建服务器：\n\n```python\napp.run(host=\"0.0.0.0\", port=8000)\n```\n\n这两个看起来运行方式完全不同，但如果我们翻开sanic的源码会看到 app.run() 内部是调用 的 `server_coroutine = loop.create_server()`创建服务器，\nserver_coroutine 是通过 `loop.run_until_complete()`驱动的。\n\n所以说，为了启动服务器，这两个都是由 loop.run_until_complete 驱动，完成运行的。只不过 sanic 封装了run 方法，使得使用更加方便。\n\n> 这里可以得到一个基本事实：只有驱动协程，协程才能做事，而驱动 asyncio.coroutine 装饰的协程有两种方式，使用 yield from 或者传给asyncio 包中某个参数为协程或future的函数，例如 run_until_complete\n\n现在如果你搜索 cjk，会得到7万多条数据3M 的一个html文件，耗时大约2s，这如果是生产服务的一个请求，耗时2s是不能接收的，我们可以使用分页，这样我们可以每次只取200条数据，当用户想看更多数据时再使用 ajax 或者 websockets发送下一批数据。\n\n这一篇我们使用 asyncio 包实现了TCP服务器，使用sanic（基于asyncio `sanic 默认使用 uvloop替代asyncio`）实现了HTTP服务器，用于按名称搜索Unicode 字符。但是并没有涉及服务器并发部分，这部分可以以后再讨论。\n\n> 这一篇还是 《流畅的python》asyncio 一章的读书笔记，下一篇将是python并发的第三篇，《使用线程处理并发》。\n\n## 参考链接\n\n* [Python 3.5将支持Async/Await异步编程:http://www.infoq.com/cn/news/2015/05/python-async-await](http://www.infoq.com/cn/news/2015/05/python-async-await)\n* [python web 框架 Sanci 快速入门](https://mp.weixin.qq.com/s?__biz=MzAwNjI5MjAzNw==&mid=2655752001&idx=1&sn=2c2e84f5f493514fdbff482a28dd7551&chksm=80b0b86bb7c7317df9d1c7b13411a231b91bb107de5e99c5379a3d9d072d5d3fb8117f364188#rd)\n* [python并发2：使用asyncio处理并发](https://mp.weixin.qq.com/s?__biz=MzAwNjI5MjAzNw==&mid=2655751998&idx=1&sn=37833d3d7582d38f85a526de7eeda814)\n\n------\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "python并发3：使用asyncio编写服务器",
        "date": "2017-06-30 08:29:39",
        "tags": [
          "python",
          "tutorial",
          "读书笔记",
          "并发"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-asyncio-server"
    },
    {
      "content": "\n## asyncio \n\n`asyncio` 是Python3.4 之后引入的标准库的，这个包使用事件循环驱动的协程实现并发。\nasyncio 包在引入标准库之前代号 `“Tulip”（郁金香）`，所以在网上搜索资料时，会经常看到这种花的名字。\n\n### 什么是事件循环?\n\n`wiki 上说：`事件循环是”一种等待程序分配事件或者消息的编程架构“。基本上来说事件循环就是：`”当A发生时，执行B\"`。或者用最简单的例子来解释这一概念就是每个浏览器中都存在的JavaScript事件循环。当你点击了某个东西（“当A发生时”），这一点击动作会发送给JavaScript的事件循环，并检查是否存在注册过的onclick 回调来处理这一点击（执行B)。只要有注册过的回调函数就会伴随点击动作的细节信息被执行。事件循环被认为是一种虚幻是因为它不停的手机事件并通过循环来发如何应对这些事件。\n\n对 Python 来说，用来提供事件循环的 asyncio 被加入标准库中。asyncio 重点解决网络服务中的问题，事件循环在这里将来自套接字（socket）的 I/O 已经准备好读和/或写作为“当A发生时”（通过selectors模块）。除了 GUI 和 I/O，事件循环也经常用于在别的线程或子进程中执行代码，并将事件循环作为调节机制（例如，合作式多任务）。如果你恰好理解 Python 的 GIL，事件循环对于需要释放 GIL 的地方很有用。\n\n## 线程与协程\n\n我们先看两断代码，分别用 threading 模块和asyncio 包实现的一段代码。\n\n```python\n# sinner_thread.py\n\nimport threading\nimport itertools\nimport time\nimport sys\n\n\nclass Signal: # 这个类定义一个可变对象，用于从外部控制线程\n    go = True\n\n\ndef spin(msg, signal):  # 这个函数会在单独的线程中运行，signal 参数是前边定义的Signal类的实例\n    write, flush = sys.stdout.write, sys.stdout.flush\n    for char in itertools.cycle('|/-\\\\'):  # itertools.cycle 函数从指定的序列中反复不断地生成元素\n        status = char + ' ' + msg\n        write(status)\n        flush()\n        write('\\x08' * len(status))  # 使用退格符把光标移回行首\n        time.sleep(.1)  # 每 0.1 秒刷新一次\n        if not signal.go:  # 如果 go属性不是 True，退出循环\n            break\n\n    write(' ' * len(status) + '\\x08' * len(status))  # 使用空格清除状态消息，把光标移回开头\n\n\ndef slow_function():  # 模拟耗时操作\n    # 假装等待I/O一段时间\n    time.sleep(3)  # 调用sleep 会阻塞主线程，这么做事为了释放GIL，创建从属线程\n    return 42\n\n\ndef supervisor():  # 这个函数设置从属线程，显示线程对象，运行耗时计算，最后杀死进程\n    signal = Signal()\n    spinner = threading.Thread(target=spin,\n                               args=('thinking!', signal))\n    print('spinner object:', spinner)  # 显示线程对象 输出 spinner object: <Thread(Thread-1, initial)>\n    spinner.start()  # 启动从属进程\n    result = slow_function()  # 运行slow_function 行数，阻塞主线程。同时丛书线程以动画形式旋转指针\n    signal.go = False\n    spinner.join()  # 等待spinner 线程结束\n    return result\n\ndef main():\n    result = supervisor()  \n    print('Answer', result)\n\n\nif __name__ == '__main__':\n    main()\n\n```\n\n执行一下，结果大致是这个样子：\n\n![](http://omuo4kh1k.bkt.clouddn.com/QQ20170619-224013-HD.gif)\n\n这是一个动图，“thinking\" 前的 \\ 线是会动的（为了录屏，我把sleep 的时间调大了）\n\n> python 并没有提供终止线程的API，所以若想关闭线程，必须给线程发送消息。这里我们使用signal.go 属性：在主线程中把它设置为False后，spinner 线程会接收到，然后退出\n\n现在我们再看下使用 asyncio 包的版本：\n\n```python\n# spinner_asyncio.py\n# 通过协程以动画的形式显示文本式旋转指针\n\nimport asyncio\nimport itertools\nimport sys\n\n@asyncio.coroutine # 打算交给asyncio 处理的协程要使用 @asyncio.coroutine 装饰\ndef spin(msg):\n    write, flush = sys.stdout.write, sys.stdout.flush\n    for char in itertools.cycle('|/-\\\\'):  # itertools.cycle 函数从指定的序列中反复不断地生成元素\n        status = char + ' ' + msg\n        write(status)\n        flush()\n        write('\\x08' * len(status))  # 使用退格符把光标移回行首\n        try:\n            yield from asyncio.sleep(0.1)  # 使用 yield from asyncio.sleep(0.1) 代替 time.sleep(.1), 这样的休眠不会阻塞事件循环\n        except asyncio.CancelledError:  # 如果 spin 函数苏醒后抛出 asyncio.CancelledError 异常，其原因是发出了取消请求\n            break\n\n    write(' ' * len(status) + '\\x08' * len(status))  # 使用空格清除状态消息，把光标移回开头\n\n\n@asyncio.coroutine\ndef slow_function():  # 5 现在此函数是协程，使用休眠假装进行I/O 操作时，使用 yield from 继续执行事件循环\n    # 假装等待I/O一段时间\n    yield from asyncio.sleep(3)  # 此表达式把控制权交给主循环，在休眠结束后回复这个协程\n    return 42\n\n\n@asyncio.coroutine\ndef supervisor():  #这个函数也是协程，因此可以使用 yield from 驱动 slow_function\n    spinner = asyncio.async(spin('thinking!'))  # asyncio.async() 函数排定协程的运行时间，使用一个 Task 对象包装spin 协程，并立即返回\n    print('spinner object:', spinner)  # Task 对象，输出类似 spinner object: <Task pending coro=<spin() running at spinner_asyncio.py:6>>\n    # 驱动slow_function() 函数，结束后，获取返回值。同事事件循环继续运行，\n    # 因为slow_function 函数最后使用yield from asyncio.sleep(3) 表达式把控制权交给主循环\n    result = yield from slow_function()\n    # Task 对象可以取消；取消后会在协程当前暂停的yield处抛出 asyncio.CancelledError 异常\n    # 协程可以捕获这个异常，也可以延迟取消，甚至拒绝取消\n    spinner.cancel()\n\n    return result\n\ndef main():\n    loop = asyncio.get_event_loop()  # 获取事件循环引用\n    # 驱动supervisor 协程，让它运行完毕；这个协程的返回值是这次调用的返回值\n    result = loop.run_until_complete(supervisor())\n    loop.close()\n    print('Answer', result)\n\n\nif __name__ == '__main__':\n    main()\n```\n\n> 除非想阻塞主线程，从而冻结事件循环或整个应用，否则不要再 asyncio 协程中使用 time.sleep().\n> 如果协程需要在一段时间内什么都不做，应该使用 yield from asyncio.sleep(DELAY)\n\n使用 @asyncio.coroutine 装饰器不是强制要求，但建议这么做因为这样能在代码中突显协程，如果还没从中产出值，协程就把垃圾回收了（意味着操作未完成，可能有缺陷），可以发出警告。这个装饰器不会预激协程。\n\n这两段代码的执行结果基本相同，现在我们看一下两段代码的核心代码 supervisor 主要区别：\n\n* asyncio.Task 对象差不多与 threading.Thread 对象等效（Task 对象像是实现写作时多任务的库中的绿色线程\n* Task 对象用于驱动协程，Thread 对象用于调用可调用的对象\n* Task 对象不由自己动手实例化，而是通过把协程传给 asyncio.async(...) 函数或 loop.create_task(...) 方法获取\n* 获取的Task 对象已经排定了运行时间；Thread 实例必须调用start方法，明确告知它运行\n* 在线程版supervisor函数中，slow_function 是普通的函数，由线程直接调用，而异步版的slow_function 函数是协程，由yield from 驱动。\n* 没有API能从外部终止线程，因为线程随时可能被中断。而如果想终止任务，可以使用Task.cancel() 实例方法，在协程内部抛出CancelledError 异常。协程可以在暂停的yield 处捕获这个异常，处理终止请求\n* supervisor 协程必须在main 函数中由loop.run_until_complete 方法执行。\n\n> 协程和线程相比关键的一个优点是，\n> 线程必须记住保留锁，去保护程序中的重要部分，防止多步操作再执行的过程中中断，防止山水处于于晓状态\n> 协程默认会做好保护，我们必须显式产出（使用yield 或 yield from 交出控制权）才能让程序的余下部分运行。\n\n### asyncio.Future：故意不阻塞\n\nasynci.Future 类与 concurrent.futures.Future 类的接口基本一致，不过实现方式不同，不可互换。\n\n上一篇[python并发 1：使用 futures 处理并发](http://blog.gusibi.site/post/python-concurrency-with-futures/)我们介绍过 concurrent.futures.Future 的 future，在 concurrent.futures.Future 中，future只是调度执行某物的结果。在 asyncio 包中，BaseEventLoop.create_task(...) 方法接收一个协程，排定它的运行时间，然后返回一个asyncio.Task 实例（也是asyncio.Future 类的实例，因为 Task 是 Future 的子类，用于包装协程。（在 concurrent.futures.Future 中，类似的操作是Executor.submit(...)）。\n\n与concurrent.futures.Future 类似，asyncio.Future 类也提供了 \n\n* .done()  返回布尔值，表示Future 是否已经执行\n* .add_done_callback() 这个方法只有一个参数，类型是可调用对象，Future运行结束后会回调这个对象。\n* .result() 这个方法没有参数，因此不能指定超时时间。 如果调用 .result() 方法时期还没有运行完毕，会抛出 asyncio.InvalidStateError 异常。\n\n> 对应的 concurrent.futures.Future 类中的 Future 运行结束后调用result(), 会返回可调用对象的结果或者抛出执行可调用对象时抛出的异常，如果是 Future 没有运行结束时调用 f.result()方法，这时会阻塞调用方所在的线程，直到有结果返回。此时result 方法还可以接收 timeout 参数，如果在指定的时间内 Future 没有运行完毕，会抛出 TimeoutError 异常。\n\n*我们使用asyncio.Future 时， 通常使用yield from，从中获取结果，而不是使用 result()方法* yield from 表达式在暂停的协程中生成返回值，回复执行过程。\n\nasyncio.Future 类的目的是与 yield from 一起使用，所以通常不需要使用以下方法：\n\n* 不需调用 my_future.add_down_callback(...), 因为可以直接把想在 future 运行结束后的操作放在协程中 yield from my_future 表达式的后边。（因为协程可以暂停和恢复函数）\n* 无需调用 my_future.result(), 因为 yield from 产生的结果就是（result = yield from my_future)\n\n在 asyncio 包中，可以使用yield from 从asyncio.Future 对象中产出结果。这也就意味着我们可以这么写：\n\n```python\nres = yield from foo()  # foo 可以是协程函数，也可以是返回 Future 或 task 实例的普通函数\n```\n\n#### asyncio.async(...)* 函数\n\n```python\nasyncio.async(coro_or_future, *, loop=None)\n```\n这个函数统一了协程和Future: 第一个参数可以是二者中的任意一个。如果是Future 或者 Task 对象，就直接返回，如果是协程，那么async 函数会自动调用 loop.create_task(...) 方法创建 Task 对象。 loop 参数是可选的，用于传入事件循环; 如果没有传入，那么async函数会通过调用asyncio.get_event_loop() 函数获取循环对象。\n\n#### BaseEventLoop.create_task(coro)\n\n这个方法排定协程的执行时间，返回一个 asyncio.Task 对象。如果在自定义的BaseEventLoop 子类上调用，返回的对象可能是外部库中与Task类兼容的某个类的实例。\n\n> BaseEventLoop.create_task() 方法只在Python3.4.2 及以上版本可用。 Python3.3 只能使用 asyncio.async(...)函数。\n\n如果想在Python控制台或者小型测试脚本中实验future和协程，可以使用下面的片段：\n\n```python\nimport asyncio\n\ndef run_sync(coro_or_future):\n    loop = asyncio.get_event_loop()\n    return loop.run_until_complete(coro_or_future)\n\na = run_sync(some_coroutine())\n```\n\n## 使用asyncio 和 aiohttp 包下载\n\n现在，我们了解了asyncio 的基础知识，是时候使用asyncio 来重写我们 上一篇 [python并发 1：使用 futures 处理并发](http://blog.gusibi.site/post/python-concurrency-with-futures/) 下载国旗的脚本了。\n\n先看一下代码：\n\n```python\nimport asyncio\n\nimport aiohttp  # 需要pip install aiohttp\n\nfrom flags import save_flag, show, main, BASE_URL\n\n\n@asyncio.coroutine  # 我们知道，协程应该使用 asyncio.coroutine 装饰\ndef get_flag(cc):\n    url = \"{}/{cc}/{cc}.gif\".format(BASE_URL, cc=cc.lower())\n     # 阻塞的操作通过协程实现，客户代码通过yield from 把指责委托给协程，以便异步操作\n    resp = yield from aiohttp.request('GET', url) \n    # 读取也是异步操作\n    image = yield from resp.read()\n    return image\n\n\n@asyncio.coroutine\ndef download_one(cc):  # 这个函数也必须是协程，因为用到了yield from\n    image = yield from get_flag(cc) \n    show(cc)\n    save_flag(image, cc.lower() + '.gif')\n    return cc\n\n\ndef download_many(cc_list):\n    loop = asyncio.get_event_loop()  # 获取事件序号底层实现的引用\n    to_do = [download_one(cc) for cc in sorted(cc_list)] # 调用download_one 获取各个国旗，构建一个生成器对象列表\n    # 虽然函数名称是wait 但它不是阻塞型函数，wait 是一个协程，等传给他的所有协程运行完毕后结束\n    wait_coro = asyncio.wait(to_do)\n    res, _ = loop.run_until_complete(wait_coro) # 执行事件循环，知道wait_coro 运行结束；事件循环运行的过程中，这个脚本会在这里阻塞。\n    loop.close() # 关闭事件循环\n    return len(res)\n\nif __name__ == '__main__':\n    main(download_many)\n```\n\n这段代码的运行简述如下：\n\n1. 在download_many 函数获取一个事件循环，处理调用download_one 函数生成的几个协程对象\n2. asyncio 事件循环一次激活各个协程\n3. 客户代码中的协程（get_flag）使用 yield from 把指责委托给库里的协程（aiohttp.request)时，控制权交还给事件循环，执行之前排定的协程\n4. 事件循环通过基于回调的底层API，在阻塞的操作执行完毕后获得通知。\n5. 获得通知后，主循环把结果发给暂停的协程\n6. 协程向前执行到下一个yield from 表达式，例如 get_flag 函数的yield from resp.read()。事件循环再次得到控制权，重复第4~6步，直到循环终止。\n\ndownload_many 函数中，我们使用了 asyncio.wait(...) 函数，这个函数是一个协程，协程的参数是一个由future或者协程构成的可迭代对象；wait 会分别把各个协程包装进一个Task对象。最终的结果是，wait 处理的所有对象都通过某种方式变成Future 类的实例。\n\n> wait 是协程函数，因此，返回的是一个协程或者生成器对象；waite_coro 变量中存储的就是这种对象\n\nloop.run_until_complete 方法的参数是一个future 或协程。如果是协程，run_until_complete 方法与 wait 函数一样，把协程包装进一个Task 对象中。这里 run_until_complete 方法把 wait_coro 包装进一个Task 对象中，由yield from 驱动。wait_coro 运行结束后返回两个参数，第一个参数是结束的future 第二个参数是未结束的future。\n\n> <section class=\"caption\">wait</section>有两个命名参数，timeout 和 return_when 如果设置了可能会返回未结束的future。\n\n有一点你可能也注意到了，我们重写了get_flags 函数，是因为之前用到的 requests 库执行的是阻塞型I/O操作。为了使用 asyncio 包，我们必须把函数改成异步版。\n\n### 小技巧\n\n如果你觉得 使用了协程后代码难以理解，可以采用 Python之父（Guido van Rossum）的建议，假装没有yield from。\n\n已上边这段代码为例：\n\n```python\n@asyncio.coroutine\ndef get_flag(cc):\n    url = \"{}/{cc}/{cc}.gif\".format(BASE_URL, cc=cc.lower())\n    resp = yield from aiohttp.request('GET', url) \n    image = yield from resp.read()\n    return image\n\n# 把yield form 去掉\n\ndef get_flag(cc):\n    url = \"{}/{cc}/{cc}.gif\".format(BASE_URL, cc=cc.lower())\n    resp = aiohttp.request('GET', url) \n    image = resp.read()\n    return image\n\n# 现在是不是清晰多了\n```\n\n### 知识点\n\n在asyncio 包的API中使用 yield from 时，有个细节要注意：\n\n使用asyncio包时，我们编写的异步代码中包含由asyncio本身驱动的协程（委派生成器），而生成器最终把指责委托给asyncio包或者第三方库中的协程。这种处理方式相当于架起了管道，让asyncio事件循环驱动执行底层异步I/O的库函数。\n\n\n## 避免阻塞型调用\n\n我们先看一个图，这个图显示了电脑从不同存储介质中读取数据的延迟情况：\n\n![](http://media.gusibi.mobi/w8Yl9AQJQ3JzHTnPCUPqwRBuN_BdmLH3iRlvpaNbavfCOvlmiUz5PLexfSZEOXo6)\n\n通过这个图，我们可以看到，阻塞型调用对于CPU来说是巨大的浪费。有什么办法可以避免阻塞型调用中止整个应用程序么？\n\n有两种方法：\n\n* 在单独的线程中运行各个阻塞型操作\n* 把每个阻塞型操作转化成非阻塞的异步调用使用\n\n当然我们推荐第二种方案，因为第一种方案中如果每个连接都使用一个线程，成本太高。\n第二种我们可以使用把生成器当做协程使用的方式实现异步编程。对事件循环来说，调用回调与在暂停的协程上调用 .send() 方法效果差不多。各个暂停的协程消耗的内存比线程小的多。\n\n现在，你应该能理解为什么 flags_asyncio.py 脚本比 flags.py 快的多了吧。\n\n> 因为flags.py 是依次同步下载，每次下载都要用几十亿个CPU周期等待结果。而在flags_asyncio.py中，在download_many 函数中调用loop.run_until_complete 方法时，事件循环驱动各个download_one 协程，运行到yield from 表达式出，那个表达式又驱动各个 get_flag 协程，运行到第一个yield from 表达式处，调用 aiohttp.request()函数。这些调用不会阻塞，因此在零点几秒内所有请求都可以全部开始。\n\n## 改进 asyncio 下载脚本\n现在我们改进一下上边的 flags_asyncio.py，在其中添加上异常处理，计数器\n\n```python\nimport asyncio\nimport collections\nfrom collections import namedtuple\nfrom enum import Enum\n\nimport aiohttp\nfrom aiohttp import web\n\nfrom flags import save_flag, show, main, BASE_URL\n\nDEFAULT_CONCUR_REQ = 5\nMAX_CONCUR_REQ = 1000\n\nResult = namedtuple('Result', 'status data')\nHTTPStatus = Enum('Status', 'ok not_found error')\n\n# 自定义异常用于包装其他HTTP货网络异常，并获取country_code，以便报告错误\nclass FetchError(Exception):\n    def __init__(self, country_code):\n        self.country_code = country_code\n\n\n@asyncio.coroutine\ndef get_flag(cc):\n    # 此协程有三种返回结果：\n    # 1.  返回下载到的图片\n    # 2. HTTP 响应为404 时，抛出web.HTTPNotFound 异常\n    # 3. 返回其他HTTP状态码时， 抛出aiohttp.HttpProcessingError\n    url = \"{}/{cc}/{cc}.gif\".format(BASE_URL, cc=cc.lower())\n    resp = yield from aiohttp.request('GET', url)\n    if resp.status == 200:\n        image = yield from resp.read()\n        return image\n    elif resp.status == 404:\n        raise web.HttpNotFound()\n    else:\n        raise aiohttp.HttpProcessionError(\n            code=resp.status, message=resp.reason,\n            headers=resp.headers\n        )\n\n\n@asyncio.coroutine\ndef download_one(cc, semaphore):\n    # semaphore 参数是 asyncio.Semaphore 类的实例\n    # Semaphore 类是同步装置，用于限制并发请求\n    try:\n        with (yield from semaphore):\n             # 在yield    from  表达式中把semaphore   当成上下文管理器使用，防止阻塞整个系统\n             # 如果semaphore 计数器的值是所允许的最大值，只有这个协程会阻塞\n              image = yield from get_flag(cc)\n              # 退出with语句后 semaphore 计数器的值会递减，\n              # 解除阻塞可能在等待同一个semaphore对象的其他协程实例\n    except web.HTTPNotFound:\n        status = HTTPStatus.not_found\n        msg = 'not found'\n    except Exception as exc:\n        raise FetchError(cc) from exc\n    else:\n        save_flag(image, cc.lower() + '.gif')\n        status = HTTPStatus.ok\n        msg = 'ok'\n    return Result(status, cc)\n\n@asyncio.coroutine\ndef downloader_coro(cc_list):\n    counter = collections.Counter()\n    # 创建一个 asyncio.Semaphore 实例，最多允许激活MAX_CONCUR_REQ个使用这个计数器的协程\n    semaphore = asyncio.Semaphore(MAX_CONCUR_REQ)\n    # 多次调用 download_one 协程，创建一个协程对象列表\n    to_do = [download_one(cc, semaphore) for cc in sorted(cc_list)]\n    # 获取一个迭代器，这个迭代器会在future运行结束后返回future\n    to_do_iter = asyncio.as_completed(to_do)\n    for future in to_do_iter:\n        # 迭代允许结束的 future    \n        try:\n            res = yield from future # 获取asyncio.Future 对象的结果（也可以调用future.result）\n        except FetchError as exc:\n            # 抛出的异常都包装在FetchError  对象里\n            country_code = exc.country_code\n            try:\n                # 尝试从原来的异常 （__cause__）中获取错误消息\n                error_msg = exc.__cause__.args[0]\n            except IndexError:\n                # 如果在原来的异常中找不到错误消息，使用所连接异常的类名作为错误消息\n                error_msg = exc.__cause__.__class__.__name__\n            if error_msg:\n                msg = '*** Error for {}: {}'\n                print(msg.format(country_code, error_msg))\n            status = HTTPStatus.error\n        else:\n            status = res.status\n        counter[status] += 1\n    return counter\n\ndef download_many(cc_list):\n    loop = asyncio.get_event_loop()\n    coro = downloader_coro(cc_list)\n    counts = loop.run_until_complete(coro)\n    loop.close()\n    return counts\n\n\nif __name__ == '__main__':\n    main(download_many)\n```\n\n由于协程发起的请求速度较快，为了防止向服务器发起太多的并发请求，使服务器过载，我们在download_coro 函数中创建一个asyncio.Semaphore 实例，然后把它传给download_one 函数。\n\n> `Semaphore` 对象维护着一个内部计数器，若在对象上调用 `.acquire()` 协程方法，计数器则递减；若在对象上调用 `.release()` 协程方法，计数器则递增。计数器的值是在初始化的时候设定。\n如果计数器大于0，那么调用 `.acquire()` 方法不会阻塞，如果计数器为0， `.acquire()` 方法会阻塞调用这个方法的协程，直到其他协程在同一个 Semaphore 对象上调用 `.release()` 方法，让计数器递增。\n\n在上边的代码中，我们并没有手动调用 .acquire() 或 .release() 方法，而是在 download_one 函数中 把 semaphore 当做上下文管理器使用:\n\n```python\nwith (yield from semaphore):\n    image = yield from get_flag(cc)\n```\n这段代码保证，任何时候都不会有超过 MAX_CONCUR_REQ 个 get_flag 协程启动。\n\n### 使用 asyncio.as_completed 函数\n\n因为要使用 yield from 获取 asyncio.as_completed 函数产出的future的结果，所以 as_completed 函数秩序在协程中调用。由于 download_many 要作为参数传给非协程的main 函数，我已我们添加了一个新的 downloader_coro 协程，让download_many 函数只用于设置事件循环。\n\n### 使用Executor 对象，防止阻塞事件循环\n现在我们回去看下上边**关于电脑从不同存储介质读取数据的延迟情况图**，有一个实时需要注意，那就是访问本地文件系统也会阻塞。\n上边的代码中，save_flag 函数阻塞了客户代码与 asyncio 事件循环公用的唯一线程，因此保存文件时，整个应用程序都会暂停。为了避免这个问题，可以使用事件循环对象的 run_in_executor 方法。\n\nasyncio 的事件循环在后台维护着一个ThreadPoolExecutor 对象，我们可以调用 run_in_executor 方法，把可调用的对象发给它执行。\n下边是我们改动后的代码：\n\n```python\n@asyncio.coroutine\ndef download_one(cc, semaphore):\n    try:\n        with (yield from semaphore):\n            image = yield from get_flag(cc)\n    except web.HTTPNotFound:\n        status = HTTPStatus.not_found\n        msg = 'not found'\n    except Exception as exc:\n        raise FetchError(cc) from exc\n    else:\n        # 这里是改动部分\n        loop = asyncio.get_event_loop()  # 获取事件循环的引用\n        loop.run_in_executor(None, save_flag, image, cc.lower() + '.gif')\n        status = HTTPStatus.ok\n        msg = 'ok'\n    return Result(status, cc)\n\n```\n\nrun_in_executor 方法的第一个参数是Executor 实例；如果设为None,使用事件循环的默认 ThreadPoolExecutor 实例。\n\n## 从回调到future到协程\n\n在接触协程之前，我们可能对回调有一定的认识，那么和回调相比，协程有什么改进呢？\n\npython中的回调代码样式：\n\n```python\ndef stage1(response1):\n    request2 = step1(response1)\n    api_call2(request2, stage2)\n    \ndef stage2(response2):\n    request3 = step3(response3)\n    api_call3(request3, stage3)   \n\n def stage3(response3):\n     step3(response3) \n\napi_call1(request1, stage1)\n```\n上边的代码的缺陷：\n* 容易出现回调地狱\n* 代码难以阅读\n\n在这个问题上，协程能发挥很大的作用。如果换成协程和yield from 结果做的异步代码，代码示例如下：\n\n```python\n@asyncio.coroutine\ndef three_stages(request1):\n    response1 = yield from api_call1(request1)\n    request2 = step1(response1)\n    response2 = yield from api_call2(requests)\n    request3 = step2(response2)\n    response3 = yield from api_call3(requests)\n    step3(response3)  \n    \nloop.create_task(three_stages(request1)\n```\n和之前的代码相比，这个代码就容易理解多了。如果异步调用 api_call1,api_call2,api_call3 会抛出异常，那么可以把相应的 yield from 表达式放在 try/except 块中处理异常。\n使用协程必须习惯 yield from 表达式，并且协程不能直接调用，必须显式的排定协程的执行时间，或在其他排定了执行时间的协程中使用yield from 表达式吧它激活。如果不使用 loop.create_task(three_stages(request1))，那么什么都不会发生。\n\n下面我们用一个实际的例子来演示一下：\n\n#### 每次下载发起多次请求\n\n我们修改一下上边下载国旗的代码，使在下载国旗的同时还可以获取国家名称在保存图片的时候使用。\n我们使用协程和yield from 解决这个问题：\n\n```python\n@asyncio.coroutine\ndef http_get(url):\n    resp = yield from aiohttp.request('GET', url)\n    if resp.status == 200:\n        ctype = resp.headers.get('Content-type', '').lower()\n        if 'json' in ctype or url.endswith('json'):\n            data = yield from resp.json()\n        else:\n            data = yield from resp.read()\n        return data\n    elif resp.status == 404:\n        raise web.HttpNotFound()\n    else:\n        raise aiohttp.HttpProcessionError(\n            code=resp.status, message=resp.reason,\n            headers=resp.headers)\n\n\n@asyncio.coroutine\ndef get_country(cc):\n    url = \"{}/{cc}/metadata.json\".format(BASE_URL, cc=cc.lower())\n    metadata = yield from http_get(url)\n    return metadata['country']\n\n\n@asyncio.coroutine\ndef get_flag(cc):\n    url = \"{}/{cc}/{cc}.gif\".format(BASE_URL, cc=cc.lower())\n    return (yield from http_get(url))\n\n\n@asyncio.coroutine\ndef download_one(cc, semaphore):\n    try:\n        with (yield from semaphore):\n            image = yield from get_flag(cc)\n        with (yield from semaphore):\n            country = yield from get_country(cc)\n    except web.HTTPNotFound:\n        status = HTTPStatus.not_found\n        msg = 'not found'\n    except Exception as exc:\n        raise FetchError(cc) from exc\n    else:\n        country = country.replace(' ', '_')\n        filename = '{}--{}.gif'.format(country, cc)\n        print(filename)\n        loop = asyncio.get_event_loop()\n        loop.run_in_executor(None, save_flag, image, filename)\n        status = HTTPStatus.ok\n        msg = 'ok'\n    return Result(status, cc)\n```\n在这段代码中，我们在download_one 函数中分别在 semaphore 控制的两个with 块中调用get_flag 和 get_country，是为了节约时间。\n\nget_flag 的return 语句在外层加上括号，是因为() 的运算符优先级高，会先执行括号内的yield from 语句 返回的结果。如果不加 会报句法错误\n加() ，相当于 \n```python\nimage = yield from http_get(url)\nreturn image\n```\n如果不加()，那么程序会在 yield from 处中断，交出控制权，这时使用return 会报句法错误。\n\n\n## 总结\n\n这一篇我们讨论了：\n\n* 对比了一个多线程程序和asyncio版，说明了多线程和异步任务之间的关系\n* 比较了 asyncio.Future 类 和 concurrent.futures.Future 类的区别\n* 如何使用异步编程管理网络应用中的高并发\n* 在异步编程中，与回调相比，协程显著提升性能的方式\n\n下一篇，我们将介绍如何使用asyncio包编写服务器\n\n## 参考链接\n\n* [class asyncio.Semaphore](https://docs.python.org/3/library/asyncio-sync.html#asyncio.Semaphore)\n* [asyncio — Asynchronous I/O, event loop, coroutines and tasks](https://docs.python.org/3/library/asyncio.html)\n* [【译】 Python 3.5 协程究竟是个啥](http://blog.rainy.im/2016/03/10/how-the-heck-does-async-await-work-in-python-3-5/)\n* [PEP 0492 Coroutines with async and await syntax](https://www.python.org/dev/peps/pep-0492/)\n* [Python 之 asyncio](https://juejin.im/entry/57b138e1165abd00542ab1fa)\n* [我所不能理解的Python中的Asyncio模块](https://python.freelycode.com/contribution/detail/515)\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "python并发2：使用asyncio处理并发",
        "date": "2017-06-23 08:29:39",
        "tags": [
          "python",
          "tutorial",
          "读书笔记",
          "并发"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-asyncio"
    },
    {
      "content": "\n> 作为Python程序员，平时很少使用并发编程，偶尔使用也只需要派生出一批独立的线程，然后放到队列中，批量执行。所以，不夸张的说，虽然我知道线程、进程、并行、并发的概念，但每次使用的时候可能还需要再打开文档回顾一下。\n\n现在这一篇还是 *《流畅的python》读书笔记*，译者在这里把future 翻译为“期物”，我觉得不太合适，既然future不能找到一个合适的词汇，暂时还是直接使用 future 吧。\n\n\n## concurrent.futures\n\nfuture 是一种对象，表示异步执行的操作。这个概念是 concurrent.futures模块和asyncio包的基础。\n\nconcurrent.futures 模块是Python3.2 引入的，对于Python2x 版本，Python2.5 以上的版本可以安装 futures 包来使用这个模块。\n\nHUGOMORE42\n\n从Python3.4起，标准库中有两个为Future的类：concurrent.futures.Future 和 asyncio.Future。这两个类作用相同：两个Future类的实例都表示可能已经完成或未完成的延迟计算。\n\nFuture 封装待完成的操作，可放入队列，完成的状态可以查询，得到结果（或抛出异常）后可以获取结果（或异常）。\n\n我们知道，如果程序中包含I/O操作，程序会有很高的延迟，CPU会处于等待状态，这时如果我们不使用并发会浪费很多时间。\n\n### 示例\n\n我们先举个例子：\n\n下边是有两段代码，主要功能都是从网上下载人口前20的国际的国旗：\n第一段代码(flagss.py)是依序下载：下载完一个图片后保存到硬盘，然后请求下一张图片；\n第二段代码(flagss_threadpool.py)使用 concurrent.futures 模块，批量下载10张图片。\n\n运行分别运行两段代码3次，结果如下：\n\nimages.py 的结果如下\n\n```bash\n$ python flags.py\nBD BR CD CN DE EG ET FR ID IN IR JP MX NG PH PK RU TR US VN \n20 flags downloaded in 6.18s\n\n$ python flags.py\nBD BR CD CN DE EG ET FR ID IN IR JP MX NG PH PK RU TR US VN \n20 flags downloaded in 5.67s\n\n$ python flags.py\nBD BR CD CN DE EG ET FR ID IN IR JP MX NG PH PK RU TR US VN \n20 flags downloaded in 6.55s\n\n```\n\n> 可以看到，依次下载10张图片，平均需要6秒\n\nflags_threadpool.py 的结果如下：\n\n```bash\n$ python flags_threadpool.py\nNG EG VN BR JP FR DE CN TR BD PK MX PH US RU IN ET CD ID IR \n20 flags downloaded in 2.12s\n\n$ python flags_threadpool.py\nBR IN DE FR TR RU EG NG JP CN ID ET PK MX PH US IR CD VN BD \n20 flags downloaded in 2.23s\n\n$ python flags_threadpool.py\nCN BR DE ID NG RU TR IN MX US IR BD VN CD PH EG FR JP ET PK \n20 flags downloaded in 1.18s\n\n```\n> 使用 concurrent.futures 后，下载10张图片平均需要2秒\n\n通过上边的结果我们发现使用 concurrent.futures 后，下载效率大幅提升。\n\n下边我们来看下这两段代码。\n\n同步执行的代码flags.py：\n\n```python\n#! -*- coding: utf-8 -*-\n\nimport os\nimport time\nimport sys\n\nimport requests  # <1>\n\nPOP20_CC = ('CN IN US ID BR PK NG BD RU JP '\n            'MX PH VN ET EG DE IR TR CD FR').split()  # <2>\n\nBASE_URL = 'http://flupy.org/data/flags'  # <3>\n\nDEST_DIR = 'images/'  # <4>\n\n\n# 保存图片\ndef save_flag(img, filename):  # <5>\n    path = os.path.join(DEST_DIR, filename)\n    with open(path, 'wb') as fp:\n        fp.write(img)\n\n\n# 下载图片\ndef get_flag(cc):  # <6>\n    url = '{}/{cc}/{cc}.gif'.format(BASE_URL, cc=cc.lower())\n    # 这里我们使用 requests 包，需要先通过pypi安装\n    resp = requests.get(url)\n    return resp.content\n\n\n# 显示一个字符串，然后刷新sys.stdout,目的是在一行消息中看到进度\ndef show(text):  # <7>\n    print(text, end=' ')\n    sys.stdout.flush()\n\n\ndef download_many(cc_list):  # <8>\n    for cc in sorted(cc_list):  # <9>\n        image = get_flag(cc)\n        show(cc)\n        save_flag(image, cc.lower() + '.gif')\n\n    return len(cc_list)\n\n\ndef main(download_many):  # <10>\n    t0 = time.time()\n    count = download_many(POP20_CC)\n    elapsed = time.time() - t0\n    msg = '\\n{} flags downloaded in {:.2f}s'\n    print(msg.format(count, elapsed))\n\n\nif __name__ == '__main__':\n    main(download_many)  # <11>\n```\n\n使用 concurrent.future 并发的代码 flags_threadpool.py\n\n```python\n#! -*- coding: utf-8 -*-\n\nfrom concurrent import futures\n\nfrom flags import save_flag, get_flag, show, main\n\n# 设定ThreadPoolExecutor 类最多使用几个线程\nMAX_WORKERS = 20\n\n\n# 下载一个图片\ndef download_one(cc):\n    image = get_flag(cc)\n    show(cc)\n    save_flag(image, cc.lower() + '.gif')\n    return cc\n\n\ndef download_many(cc_list):\n    # 设定工作的线程数量，使用约需的最大值与要处理的数量直接较小的那个值，以免创建多余的线程\n    workers = min(MAX_WORKERS, len(cc_list))  # <4>\n    # 使用工作的线程数实例化ThreadPoolExecutor类；\n    # executor.__exit__方法会调用executor.shutdown(wait=True)方法，\n    # 它会在所有线程都执行完毕前阻塞线程\n    with futures.ThreadPoolExecutor(workers) as executor:  # <5>\n        # map 与内置map方法类似，不过download_one 函数会在多个线程中并发调用；\n        # map 方法返回一个生成器，因此可以迭代，\n        # 迭代器的__next__方法调用各个Future 的 result 方法\n        res = executor.map(download_one, sorted(cc_list))\n\n    # 返回获取的结果数量；如果有现成抛出异常，会在这里抛出\n    # 这与隐式调用next() 函数从迭代器中获取相应的返回值一样。\n    return len(list(res))  # <7>\n    return len(results)\n\n\nif __name__ == '__main__':\n    main(download_many)\n```\n\n上边的代码，我们对 concurrent.futures 的使用有了大致的了解。但 future 在哪里呢，我们并没有看到。\n\nFuture 是 concurrent.futures 模块和 asyncio 包的重要组件。从Python3.4起，标准库中有两个为Future的类：concurrent.futures.Future 和 asyncio.Future。这两个Future作用相同。\n\nFuture 封装待完成的操作，可放入队列，完成的状态可以查询，得到结果（或抛出异常）后可以获取结果（或异常）。\nFuture 表示终将发生的事情，而确定某件事情会发生的唯一方式是执行的时间已经排定。因此只有把某件事交给 concurrent.futures.Executor 子类处理时，才会创建 concurrent.futures.Future 实例。\n\n> 例如，调用Executor.submit() 方法的参数是一个可调用的对象，调用这个方法后会为传入的可调用对象排期，并返回一个Future。\n\nFuture 有三个重要的方法：\n\n* .done()  返回布尔值，表示Future 是否已经执行\n* .add_done_callback() 这个方法只有一个参数，类型是可调用对象，Future运行结束后会回调这个对象。\n* .result() 如果 Future 运行结束后调用result(), 会返回可调用对象的结果或者抛出执行可调用对象时抛出的异常，如果是 Future 没有运行结束时调用 f.result()方法，这时会阻塞调用方所在的线程，直到有结果返回。此时result 方法还可以接收 timeout 参数，如果在指定的时间内 Future 没有运行完毕，会抛出 TimeoutError 异常。\n\n> asyncio.Future.result 方法不支持设定超时时间，如果想获取 Future 的结果，可以使用 yield from 结构\n\n\n为了加深对 Future 的理解，现在我们修改下 flags_threadpool.py download_many 函数。\n\n\n```python\ndef download_many(cc_list):\n    cc_list = cc_list[:5]\n    with futures.ThreadPoolExecutor(max_workers=3) as executor:\n        to_do = []\n        # 用于创建并排定 future\n        for cc in sorted(cc_list):\n            # submit 方法排定可调用对象的执行时间然后返回一个future，表示这个待执行的操作\n            future = executor.submit(download_one, cc)\n            to_do.append(future)\n            msg = 'Scheduled for {}: {}'\n            print(msg.format(cc, future))\n        \n        results = []\n        # 用于获取future 结果\n        # as_completed 接收一个future 列表，返回值是一个迭代器，在运行结束后产出future\n        for future in futures.as_completed(to_do):\n            res = future.result()\n            msg = '{} result: {!r}'\n            print(msg.format(future, res))\n            results.append(res)\n    \n    return len(results)\n\n```\n\n现在执行代码，运行结果如下：\n\n```python\nScheduled for BR: <Future at 0x10d43cb70 state=running>\nScheduled for CN: <Future at 0x10d4434a8 state=running>\nScheduled for ID: <Future at 0x10d443ef0 state=running>\nScheduled for IN: <Future at 0x10d443978 state=pending>\nScheduled for US: <Future at 0x10d44f748 state=pending>\nBR <Future at 0x10d43cb70 state=finished returned str> result: 'BR'\nIN <Future at 0x10d443978 state=finished returned str> result: 'IN'\nCN <Future at 0x10d4434a8 state=finished returned str> result: 'CN'\nID <Future at 0x10d443ef0 state=finished returned str> result: 'ID'\nUS <Future at 0x10d44f748 state=finished returned str> result: 'US'\n\n5 flags downloaded in 1.47s\n```\n\n从结果可以看到，future 的 repr() 方法会显示状态，前三个 是running 是因为我们设定了三个进程，所以后两个是pendding 状态。如果将max_workers参数设置为5，结果就会全都是 running。\n\n虽然，使用 future 的脚步比第一个脚本的执行速度快了很多，但由于受GIL的限制，下载并不是并行的。\n\n## GIL（Global Interpreter Lock）和阻塞型I/O\n\nCPython 解释器本身不是线程安全的，因此解释器被一个全局解释器锁保护着，它确保任何时候都只有一个Python线程执行。\n\n然而，Python标准库中所有执行阻塞型I/O操作的函数，在等待系统返回结果时都会释放GIL。这意味着I/O密集型Python程序能从中受益：一个Python线程等待网络响应时，阻塞型I/O函数会释放GIL，再运行一个线程。\n\n> Python 标准库中所有阻塞型I/O函数都会释放GIL，允许其他线程运行。time.sleep()函数也会释放GIL。\n\n**那么如何在CPU密集型作业中使用 concurrent.futures 模块绕开GIL呢？**\n\n答案是 使用 *ProcessPoolExecutor* 类。\n\n使用这个模块可以在做CPU密集型工作是绕开GIL，利用所有可用核心。\n\n\nThreadPoolExecutor 和 ProcessPoolExecutor 都实现了通用的 Executor 接口，所以，我们可以轻松的将基于线程的方案改为使用进程的方案。\n\n比如下边这样：\n\n```python\ndef download_many(cc_list):\n    workers = min(MAX_WORKERS, len(cc_list))\n    with futures.ThreadPoolExecutor(workers) as executor:\n        pass\n\n# 改成\ndef download_many(cc_list):\n    with futures.ProcessPoolExecutor() as executor:\n        pass\n```\n\n需要注意的是，ThreadPoolExecutor 需要指定 max_workers 参数，\n而 ProcessPoolExecutor 的这个参数是可选的默认值是 os.cup_count()(计算机cpu核心数)。\n\nProcessPoolExecutor 的价值主要体现在CPU密集型作业上。\n\n> 使用Python处理CPU密集型工作，应该试试PyPy，会有更高的执行速度。\n\n现在我们回到开始的代码，看下 Executor.map 函数。\n\n文档中对map函数的介绍如下。\n\n> map(func, *iterables, timeout=None, chunksize=1)\n\n> 等同于 map(func, *iterables)，不同的是 func 是异步执行的，并且可以同时进行对 func 的多个调用。如果调用 __next__()，则返回的迭代器提出 concurrent.futures.TimeoutError，并且在从 Executor.map() 的原始调用起的 timeout 秒之后结果不可用。 timeout 可以是int或float。如果未指定 timeout 或 None，则等待时间没有限制。如果调用引发异常，那么当从迭代器检索其值时，将引发异常。当使用 ProcessPoolExecutor 时，此方法将 iterables 分成多个块，它作为单独的任务提交到进程池。这些块的（近似）大小可以通过将 chunksize 设置为正整数来指定。对于非常长的迭代，与默认大小1相比，使用大值 chunksize 可以显着提高性能。使用 ThreadPoolExecutor，chunksize 没有效果。\n\n> 在 3.5 版更改: 添加了 chunksize 参数。\n\nExecutor.map 还有个特性比较有用，那就是这个函数返回结果的顺序于调用开始的顺序是一致的。如果第一个调用称其结果用时10秒，其他调用只用1秒，代码会阻塞10秒，获取map方法返回的生成器产出的第一个结果。\n\n如果不是获取到所有结果再处理，通常会使用 Executor.submit + Executor.as_completed 组合使用的方案。\n\nExecutor.submit + Executor.as_completed 这个组合更灵活，因为submit方法能处理不同的可调用对象和参数，而executor.map 只能处理参数不同的同一个可调用对象。此外，传给futures.as_completed 函数的期物集合可以来自不同的 Executor 实例。\n\n## future 的异常处理\n\nfutures 有三个异常类：\n\n* exception concurrent.futures.CancelledError  在future取消时引发。\n* exception concurrent.futures.TimeoutError 在future操作超过给定超时时触发。\n* exception concurrent.futures.process.BrokenProcessPool\n从 RuntimeError 派生，当 ProcessPoolExecutor 的一个工人以非干净方式终止（例如，如果它从外部被杀死）时，引发此异常类。\n\n我们先看一下，future.result() 出现异常的处理情况。代码改动如下：\n\n```python\n\n# 将第一个 CN 改为CN1 也可以是其它任意错误代码\nPOP20_CC = ('CN1 IN US ID BR PK NG BD RU JP '\n            'MX PH VN ET EG DE IR TR CD FR').split()\n\n\ndef get_flag(cc):  # <6>\n    url = '{}/{cc}/{cc}.gif'.format(BASE_URL, cc=cc.lower())\n    resp = requests.get(url)\n    if resp.status_code != 200:  # <1>\n        resp.raise_for_status() # 如果不是200 抛出异常\n    return resp.content\n\ndef download_one(cc):\n    try:\n        image = get_flag(cc)\n    # 捕获 requests.exceptions.HTTPError\n    except requests.exceptions.HTTPError as exc:  #\n        # 如果有异常 直接抛出\n        raise\n    else:\n        save_flag(image, cc.lower() + '.gif')\n    return cc\n\n```\n\n现在执行代码，会发现 download_one 中的异常传递到了download_many 中,并且导致抛出了异常，未执行完的其它future 也都中断。\n\n为了能保证其它没有错误的future 可以正常执行，这里我们需要对future.result() 做异常处理。\n\n改动结果如下：\n\n```python\ndef download_many(cc_list):\n    cc_list = cc_list[:5]\n    with futures.ThreadPoolExecutor(max_workers=20) as executor:\n        to_do_map = {}\n        for cc in sorted(cc_list):\n            future = executor.submit(download_one, cc)\n            to_do_map[future] = cc\n            msg = 'Scheduled for {}: {}'\n            print(msg.format(cc, future))\n\n        results = []\n        for future in futures.as_completed(to_do_map):\n            try:\n                res = future.result()\n            except requests.exceptions.HTTPError as exc:\n                # 处理可能出现的异常\n                error_msg = '{} result {}'.format(cc, exc)\n            else:\n                error_msg = ''\n            if error_msg:\n                cc = to_do_map[future]  # <16>\n                print('*** Error for {}: {}'.format(cc, error_msg))\n            else:\n                msg = '{} result: {!r}'\n                print(msg.format(future, res))\n                results.append(res)\n\n    return len(results)\n\n```\n\n这里我们用到了一个对 futures.as_completed 函数特别有用的惯用法：构建一个字典，把各个future映射到其他数据（future运行结束后可能用的）上。这样，虽然 future生成的顺序虽然已经乱了，依然便于使用结果做后续处理。\n\n一篇写完了没有总结总感觉少点什么，所以。\n\n## 总结\n\nPython 自 0.9.8 版就支持线程了，concurrent.futures 只不过是使用线程的最新方式。\n\nfutures.ThreadPoolExecutor 类封装了 threading 模块的组件，使使用线程变得更加方便。\n\n顺便再推荐一下 《流畅的python》，绝对值得一下。\n\n下一篇笔记应该是使用 asyncio 处理并发。\n\n------------\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "python并发 1：使用 futures 处理并发",
        "date": "2017-06-17 14:01:51",
        "tags": [
          "python",
          "tutorial",
          "读书笔记",
          "并发"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-concurrency-with-futures"
    },
    {
      "content": "\n> 最近找到一本python好书《流畅的python》，是到现在为止看到的对python高级特性讲述最详细的一本。\n> 看了协程一章，做个读书笔记，加深印象。\n\n## 协程定义\n\n协程的底层架构是在pep342 中定义，并在python2.5 实现的。\n\nHUGOMORE42\n\npython2.5 中，yield关键字可以在表达式中使用，而且\b生成器API中增加了 .send(value)方法。生成器可以使用\b.send(...)方法发送数据，发送的数据会成为生成器函数中yield表达式的值。\n\n协程是指一个过程，这个过程与调用方协作，\b产出有调用方提供的值。因此，生成器可以作为协程使用。\n\n> 除了 .send(...)方法，pep342 和添加了 .throw(...)（让调用方抛出异常，在生成器中处理）和.close()（终止生成器）方法。\n\npython3.3后，pep380对生成器函数做了两处改动：\n\n* \b生成器可以返回一个值；以前，如果生成器中给return语句提供值，会抛出SyntaxError异常。\n* 引入yield from 语法，使用它可以把复杂的生成器重构成小型的嵌套生成器，省去之前把生成器的工作委托给子生成器所需的大量模板代码。\n\n## 协程生成器的基本行为\n\n首先说明一下，协程有四个状态，可以使用inspect.getgeneratorstate(...)函数确定：\n\n* GEN_CREATED    # 等待开始执行\n* GEN_RUNNING    # 解释器正在执行（只有在多线程应用中才能看到这个状态）\n* GEN_SUSPENDED  # 在yield表达式处暂停\n* GEN_CLOSED     # 执行结束\n\n```python\n#! -*- coding: utf-8 -*-\nimport inspect\n\n# 协程使用生成器函数定义：定义体中有yield关键字。\ndef simple_coroutine():\n    print('-> coroutine started')\n    # yield 在表达式中使用；如果协程只需要从客户那里接收数据，yield关键字右边不需要加表达式（yield默认返回None）\n    x = yield\n    print('-> coroutine received:', x)\n\nmy_coro = simple_coroutine()\nmy_coro # 和创建生成器的方式一样，调用函数得到生成器对象。\n# 协程处于 GEN_CREATED (等待开始状态)\nprint(inspect.getgeneratorstate(my_coro))\n\nmy_coro.send(None)\n# 首先要调用next()函数，因为生成器还没有启动，没有在yield语句处暂停，所以开始无法发送数据\n# 发送 None 可以达到相同的效果 my_coro.send(None) \nnext(my_coro)\n# 此时协程处于 GEN_SUSPENDED (在yield表达式处暂停)\nprint(inspect.getgeneratorstate(my_coro))\n\n# 调用这个方法后，协程定义体中的yield表达式会计算出42；现在协程会恢复，一直运行到下一个yield表达式，或者终止。\nmy_coro.send(42)\nprint(inspect.getgeneratorstate(my_coro))\n```\n\n运行上述代码，输出结果如下\n\n```python\nGEN_CREATED\n-> coroutine started\nGEN_SUSPENDED\n-> coroutine received: 42\n\n# 这里，控制权流动到协程定义体的尾部，导致生成器像往常一样抛出StopIteration异常\nTraceback (most recent call last):\n  File \"/Users/gs/coroutine.py\", line 18, in <module> \n    my_coro.send(42)\nStopIteration\n```\n\n> send方法的参数会成为暂停yield表达式的值，所以，仅当协程处于暂停状态是才能调用send方法。\n> 如果协程还未激活（GEN_CREATED 状态）要调用next(my_coro) 激活协程，也可以调用my_coro.send(None)\n\n\n如果创建协程对象后立即把None之外的值发给它，会出现下述错误：\n\n```python\n>>> my_coro = simple_coroutine()\n>>> my_coro.send(123)\n\nTraceback (most recent call last):\n  File \"/Users/gs/coroutine.py\", line 14, in <module>\n    my_coro.send(123)\nTypeError: can't send non-None value to a just-started generator\n```\n仔细看错误消息\n\n> can't send non-None value to a just-started generator\n\n最先调用next(my_coro) 这一步通常称为”预激“（prime）协程---即，让协程向前执行到第一个yield表达式，准备好作为活跃的协程使用。\n\n#### 再看一个两个值得协程\n\n```python\ndef simple_coro2(a):\n    print('-> coroutine started: a =', a)\n    b = yield a\n    print('-> Received: b =', b)\n    c = yield a + b\n    print('-> Received: c =', c)\n\nmy_coro2 = simple_coro2(14)\nprint(inspect.getgeneratorstate(my_coro2))\n# 这里inspect.getgeneratorstate(my_coro2) 得到结果为 GEN_CREATED （协程未启动）\n\nnext(my_coro2)\n# 向前执行到第一个yield 处 打印 “-> coroutine started: a = 14”\n# 并且产生值 14 （yield a 执行 等待为b赋值）\nprint(inspect.getgeneratorstate(my_coro2))\n# 这里inspect.getgeneratorstate(my_coro2) 得到结果为 GEN_SUSPENDED （协程处于暂停状态）\n\nmy_coro2.send(28)\n# 向前执行到第二个yield 处 打印 “-> Received: b = 28”\n# 并且产生值 a + b = 42（yield a + b 执行 得到结果42 等待为c赋值）\nprint(inspect.getgeneratorstate(my_coro2))\n# 这里inspect.getgeneratorstate(my_coro2) 得到结果为 GEN_SUSPENDED （协程处于暂停状态）\n\nmy_coro2.send(99)\n# 把数字99发送给暂停协程，计算yield 表达式，得到99，然后把那个数赋值给c 打印 “-> Received: c = 99”\n# 协程终止，抛出StopIteration\n```\n\n运行上述代码，输出结果如下\n\n```python\nGEN_CREATED\n-> coroutine started: a = 14\nGEN_SUSPENDED\n-> Received: b = 28\n-> Received: c = 99\n\nTraceback (most recent call last):\n  File \"/Users/gs/coroutine.py\", line 37, in <module>\n    my_coro2.send(99)\nStopIteration\n```\n\nsimple_coro2 协程的执行过程分为3个阶段，如下图所示\n\n![](http://omuo4kh1k.bkt.clouddn.com/3b3UCuR_iYj3-r_V4PUErxrFm0v1uIo7p4yoplxnqaQt7PK4iUO8CAWlg7chZyW_)\n\n1. 调用next(my_coro2)，打印第一个消息，然后执行yield a，产出数字14.\n2. 调用my_coro2.send(28)，把28赋值给b，打印第二个消息，然后执行 yield a + b 产生数字42\n3. 调用my_coro2.send(99)，把99赋值给c，然后打印第三个消息，协程终止。\n\n## 使用装饰器预激协程\n\n我们已经知道，协程如果不预激，不能使用send() 传入非None 数据。所以，调用my_coro.send(x)之前，一定要调用next(my_coro)。\n为了简化，我们会使用装饰器预激协程。\n\n```python\nfrom functools import wraps\n\ndef coroutinue(func):\n    '''\n    装饰器： 向前执行到第一个`yield`表达式，预激`func`\n    :param func: func name\n    :return: primer\n    '''\n\n    @wraps(func)\n    def primer(*args, **kwargs):\n        # 把装饰器生成器函数替换成这里的primer函数；调用primer函数时，返回预激后的生成器。\n        gen = func(*args, **kwargs)\n        # 调用被被装饰函数，获取生成器对象\n        next(gen)  # 预激生成器\n        return gen  # 返回生成器\n    return primer\n\n\n# 使用方法如下\n\n@coroutinue\ndef simple_coro(a):\n    a = yield\n\nsimple_coro(12)  # 已经预激\n```\n\n## 终止协程和异常处理\n\n协程中，为处理的异常会向上冒泡，传递给next函数或send方法的调用方，未处理的异常会导致协程终止。\n\n看下边这个例子\n\n```python\n#! -*- coding: utf-8 -*-\n\nfrom functools import wraps\n\ndef coroutinue(func):\n    '''\n    装饰器： 向前执行到第一个`yield`表达式，预激`func`\n    :param func: func name\n    :return: primer\n    '''\n\n    @wraps(func)\n    def primer(*args, **kwargs):\n        # 把装饰器生成器函数替换成这里的primer函数；调用primer函数时，返回预激后的生成器。\n        gen = func(*args, **kwargs)\n        # 调用被被装饰函数，获取生成器对象\n        next(gen)  # 预激生成器\n        return gen  # 返回生成器\n    return primer\n\n\n@coroutinue\ndef averager():\n    # 使用协程求平均值\n    total = 0.0\n    count = 0\n    average = None\n    while True:\n        term = yield average\n        total += term\n        count += 1\n        average = total/count\n\ncoro_avg = averager()\nprint(coro_avg.send(40))\nprint(coro_avg.send(50))\nprint(coro_avg.send('123')) # 由于发送的不是数字，导致内部有异常抛出。\n```\n\n执行上述代码结果如下\n\n```python\n40.0\n45.0\nTraceback (most recent call last):\n  File \"/Users/gs/coro_exception.py\", line 37, in <module>\n    print(coro_avg.send('123'))\n  File \"/Users/gs/coro_exception.py\", line 30, in averager\n    total += term\nTypeError: unsupported operand type(s) for +=: 'float' and 'str'\n```\n\n出错的原因是发送给协程的'123'值不能加到total变量上。\n出错后，如果再次调用 coro_avg.send(x) 方法 会抛出 StopIteration 异常。\n\n由上边的例子我们可以知道，如果想让协程退出，可以发送给它一个特定的值。比如None和Ellipsis。（推荐使用Ellipsis，因为我们不太使用这个值）\n从Python2.5 开始，我们可以在生成器上调用两个方法，显式的把异常发给协程。\n这两个方法是throw和close。\n\n```python\ngenerator.throw(exc_type[, exc_value[, traceback]])\n```\n\n这个方法使生成器在暂停的yield表达式处抛出指定的异常。如果生成器处理了抛出的异常，代码会向前执行到下一个yield表达式，而产出的值会成为调用throw方法得到的返回值。如果没有处理，则向上冒泡，直接抛出。\n\n```python\ngenerator.close()\n```\n\n生成器在暂停的yield表达式处抛出GeneratorExit异常。\n如果生成器没有处理这个异常或者抛出了StopIteration异常，调用方不会报错。如果收到GeneratorExit异常，生成器一定不能产出值，否则解释器会抛出RuntimeError异常。\n\n#### 示例： 使用close和throw方法控制协程。\n\n```python\nimport inspect\n\n\nclass DemoException(Exception):\n    pass\n\n\n@coroutinue\ndef exc_handling():\n    print('-> coroutine started')\n    while True:\n        try:\n            x = yield\n        except DemoException:\n            print('*** DemoException handled. Conginuing...')\n        else:\n            # 如果没有异常显示接收到的值\n            print('--> coroutine received: {!r}'.format(x))\n    raise RuntimeError('This line should never run.')  # 这一行永远不会执行 \n\n\nexc_coro = exc_handling()\n\nexc_coro.send(11)\nexc_coro.send(12)\nexc_coro.send(13)\nexc_coro.close()\nprint(inspect.getgeneratorstate(exc_coro))\n```\n\n> raise RuntimeError('This line should never run.') 永远不会执行，因为只有未处理的异常才会终止循环，而一旦出现未处理的异常，协程会立即终止。\n\n执行上述代码得到结果为：\n\n```python\n-> coroutine started\n--> coroutine received: 11\n--> coroutine received: 12\n--> coroutine received: 13\nGEN_CLOSED    # 协程终止\n```\n\n上述代码，如果传入DemoException，协程不会中止，因为做了异常处理。\n\n```python\nexc_coro = exc_handling()\n\nexc_coro.send(11)\nexc_coro.send(12)\nexc_coro.send(13)\nexc_coro.throw(DemoException) # 协程不会中止，但是如果传入的是未处理的异常，协程会终止\nprint(inspect.getgeneratorstate(exc_coro))\nexc_coro.close()\nprint(inspect.getgeneratorstate(exc_coro))\n\n## output\n\n-> coroutine started\n--> coroutine received: 11\n--> coroutine received: 12\n--> coroutine received: 13\n*** DemoException handled. Conginuing...\nGEN_SUSPENDED\nGEN_CLOSED\n```\n\n如果不管协程如何结束都想做些处理工作，要把协程定义体重的相关代码放入try/finally块中。\n\n```python\n@coroutinue\ndef exc_handling():\n    print('-> coroutine started')\n    try:\n        while True:\n            try:\n                x = yield\n            except DemoException:\n                print('*** DemoException handled. Conginuing...')\n            else:\n                # 如果没有异常显示接收到的值\n                print('--> coroutine received: {!r}'.format(x))\n    finally:\n        print('-> coroutine ending')\n```\n\n上述部分介绍了：\n\n* 生成器作为协程使用时的行为和状态\n* 使用装饰器预激协程\n* 调用方如何使用生成器对象的 .throw(...)\b和.close() 方法控制协程\n\n下一部分将介绍：\n\n* 协程终止时如何返回值\n* yield新句法的用途和语义\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "python协程1：协程 10分钟入门",
        "date": "2017-06-12 09:22:49",
        "tags": [
          "python",
          "tutorial",
          "读书笔记"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-coroutine-1"
    },
    {
      "content": "\n> 这是CSS设计指南的读书笔记，用于加深学习效果。\n\n最近想做一个小程序，前端是必修课，那就从css开始吧。\n\n## css 工作原理\n每个html元素都有一组样式属性，可以通过css来设定。当html元素的同一个样式属性有多种样式值的时候，css就要靠层叠机智来决定最终应用哪种样式。\n\nHUGOMORE42\n\n### css规则\n规则实际上是一条完整的css指令，规则声明了要修改的元素和要应用给改元素的样式。\n\n#### 为文档添加样式的三种方法：\n1. 写在元素标签里（也叫行内样式，只能影响它所在的标签，会覆盖嵌入样式和链接样式）\n2. 写在\\<style> 标签里（也就嵌入样式，应用范围仅限于当前页面，页面样式会覆盖外部样式表中的样式，但会被行内样式覆盖）\n3. 写在单独css样式表中（也叫链接样式，样式表是一个扩展名为.css 的文件，可以在任意多个HTML页面链接同一个样式表文件。链接样式的作用范围是整个网站）\n\n\n除了这三种为页面添加样式的方法，还有一种在样式表中链接其他样式表的方法，使用@import 指令：例如\n\n```\n@import url(css/styles.css)\n```\n@import 指令必须出现在样式表中其他样式之前，否则@吹灭；@import引用的样式表不会被加载。\n![css 规则命名惯例](http://omuo4kh1k.bkt.clouddn.com/cpByY2yOl7gHv6vEFDL2CyMt8YJQ-0t0MRxo6itjABg0PeYrrqz6wrIV6q5kKsm8)\n\n对这个基本的结构有三种方法可以进行扩展\n\n**第一种方法：**多个声明包含在一条规则里。\n\n```css\np {color: red; font-size: 12px; font-weight: bold;}\n```\n**第二种方法：**多个选择器组合在一起。例如：如果想让\\<h1>、\\<h2>和\\<h3>的文本都变成蓝色粗体可以这么写：\n\n```css\nh1 {color: blue; font-weight: bold;}\nh2 {color: blue; font-weight: bold;}\nh3 {color: blue; font-weight: bold;}\n```\n\n也可以这么写：\n\n```css\nh1, h2, h3 {color: blue; font-weight: bold;}\n```\n\n**分组选择符以逗号作为分隔符**\n\n**第三种方法：** 多条规则应用给一个选择符。\n例如，写完上边的规则，还想把h3变成斜体，那么可以再为h3单独写一条规则：\n\n```css\nh1, h2, h3 {color: blue; font-weight: bold;}\nh3 {font-style: italic;}\n```\n\n### 选择特定元素的选择符\n\n用于选择特定元素的操作符有三种\n\n1. **上下文选择符**。基于祖先或者同胞元素选择一个元素。\n2. **ID和类选择符**。基于id和class属性的值选择元素。\n3. **属性选择符**。基于属性的有无和特征选择元素。\n\n#### 上下文选择符\n\n比如我们想给article中的段落设置不同的字号，可以使用上下文选择符来解决。\n\n上下文选择符的格式如下：\n\n> 标签1 标签2 {声明}\n\n其中**标签2** 是我们要选择的目标，而且只有在 **标签1**是其祖先元素的情况下才会被选中。\n\n上下文选择符，叫后代组合式选择符，就是一组以空格分隔的标签名。用于选择作为特定祖先元素后代的标签。\n\n```css\narticle p {font-weight: bold;}\n```\n\n上边例子中，只有article后代的p元素才会应用后边的样式。\n\n**上下文选择符以空格作为分隔符**\n\n##### 特殊的上下文选择符\n\n* 子选择符 >\n\n格式如下：\n\n> 标签1 > 标签2\n\n**标签1** 必须是 **标签2** 的**父元素**，不能是其它的祖先元素。\n\n```css\nsection > h2 {font-style: italic;}\n```\n\n* 紧邻同胞选择符+\n\n格式如下：\n\n> 标签1 + 标签2\n\n标签2 必须紧跟在期同胞标签1后面。\n\n```css\nh2 + p {font-variant: small-caps;}\n```\n\n标签 h2 和 p 为同一级标签，且标签p和 h2 相邻。(只应用到p标签）\n\n* 一般同胞选择符 ~\n\n格式如下：\n\n> 标签1 ~ 标签2\n\n**标签2** 必须跟在其 **同胞标签1** 后面（可以不相邻）。\n\n```css\nh2 ~ a {color: red;}\n```\n\n标签a 和 标签h2 同一级，且a标签在h2 标签之后。（只应用与a标签）\n\n* 通用选择符 *\n\n通用选择符 * 是一个通配符，它匹配任何元素。\n\n```css\n* {color: green;}\n```\n\n这条规则会将所有元素（文本和边框）都变成绿色。\n\n```css\np * {color: red;}\n```\n这条规则会把p包含的所有元素的文本都变成红色。\n\n```css\nsection * a {font-size: 1.3em;}\n```\n\n所有section标签的 非子标签（*是所有的子标签）的a标签字体设置为 1.3 em;\n\n#### ID和类选择符\n\n使用ID和类选择符，首先要在HTML标记中为元素添加id和class属性。\n\n> 可以给id和class属性设定任意值，但不能以数字或特殊符号开头\n\n##### 类属性\n\n给标签h1添加 specialtext 类。\n\n```css\n<h1 class=\"specialtext\">This is text</h1>\n```\n\n* 类选择符\n\n格式为：\n\n> .类名\n\n类选择符使用点(.)，紧跟类名。\n\n* 标签带类选择符\n\n格式为：\n> 标签1.类名\n\n比如：\n\n```css\np.specialtext {color: red;}\n```\n只对有 specialtext 类的p标签有效。\n\n* 多类选择符\n\n可以给元素添加多个类：\n\n```html\n<p class=\"specialtext featured\">Here the span tag <span> may or may not</span> be styled.</p>\n```\n多个类名放在同一对引号吃，用空格分隔。\n\n要选择同时存在这两个类名的元素可以这样写：\n\n```css\n.specialtext.featured {font-size: 120%;}\n```\nCSS 选择符的两个类名直接没有空格。如果加了，就变成祖先/后代关系的上下文选择符了。\n\n##### ID属性\n\nID属性与类写法类似，用#表示。\n\n```html\n<p id=\"specialtext\">This is text</p>\n```\n上边p标签就设置了ID属性specialtext。\n\n相应的ID选择符就这样写：\n\n```css\n#specialtext {css样式}\n```\n\n选择元素方式其余和class 一致。\n\n#### ID属性和类属性的区别\n\n* ID可以用于页面导航链接中。\n例如：\n\n```html\n<a href=\"#bio\">Biggraphy</a>\n``` \n用户点击这个链接会滚到ID值为bio的位置。如果href属性里只有一个#，那么点击链接会跳到顶部。\n\n* ID值需要时独一无二的。\n* 类的目的是为了标识一组具有相同特征的元素，以便我们为这些元素应用相同的css样式。\n\n#### 属性选择符\n\n##### 属性名选择符\n\n格式如下：\n\n> 标签名[属性名]\n\n选择任何带有属性名的标签名。\n\n比如：\n\n```css\nimg[title] {border: 2px solid blue;}\n```\n\n这个规则会选择带有title属性的HTML img元素，title是什么值都可以。\n\n##### 属性值选择符\n\n格式如下：\n\n> 标签名[属性名=\"属性值\"]（在html5中，属性值得引号可不加)\n\n例如：\n\n```css\nimg[title=\"red flower\"] {border: 2px solid blue;}\n```\n这个规则会选择带有title属性的HTML img元素，且title值为\"red flower\"。\n\n#### 伪类\n\n伪类分两种：\n1. UI伪类会在HTML元素处于某个状态时，为该元素应用CSS样式。\n2. 结构化伪类会在标记中存在某种结构上的关系时，为相应元素应用CSS样式。\n\n伪类使用:(冒号)作为选择符。\n两个冒号(::)表示新增的伪元素。\n\n#### UI伪类\n\nUI伪类会基于特定的HTML元素的状态应用样式。\n\n##### 链接伪类\n\n针对链接的伪类有4个：\n\n* Link。 此时，链接为被点击\n* Visited。用户点击过链接之后\n* Hover。鼠标悬停在链接上\n* Active。链接正在被点击\n\n使用方式举例：\n\n```css\na:link {color: black;}\na:visited {color: blue;}\na:hover {text-decoration: none;}\na:active {color: red;}\n```\n\nhover伪类可以应用在任何元素。\n\n```css\np:hover {background-color: gray;}\n```\n##### :focus 伪类\n\n可以应用于任何元素。\n\n点击时会或得焦点。\n\n##### :target 伪类\n\n可以应用于任何元素。\n如果用户点击一个指向页面中其他元素的链接，则那个元素就是目标，可以用:target 选中。\n\n比如：\n\n```html\n<a href=\"#more_info\">More Infomation</a>\n```\n应用上伪类后，ID为more_info的元素就是目标。点击a标签时，会应用css样式。\n\ncss规则如下：\n\n```css\n#more_info:target {background: #eee;}\n```\n\n#### 结构化伪类\n\n##### :first-child和:last-child\n\n* :first-child 代表一组同胞元素的第一个元素\n* :last-child 代表一组同胞元素的最后一个元素\n\n##### :nth-child\n\n规则如下：\n\n```css\ne:nth-child(n)\n```\n\ne表示元素名，n表示一个数值。\n\n比如：\n\n```css\nli:nth-child(3)\n```\n会选中一组列表的每个第三项。\n\n#### 伪元素\n\n伪元素是文档中若有实无的元素。\n常用的伪类如下：\n\n##### ::first-letter\n\n选择首字母，使用规则：\n\n```css\ne::first-letter\n```\n\n比如\n```css\np::first-letter {font-size:300%;}\n```\n会让首字母变大。\n\n##### ::first-line \n\n选择段落的第一行。\n\n```css\ne::first-line\n```\n##### ::before和::after\n\n使用规则如下：\n\n```css\ne::before\ne::after\n```\n可用于在特定的元素前面或者后面添加特殊内容。\n\n以上CSS选择符已经介绍完了，接下来讨论在一个大的样式表中，规则选择的问题。\n\nCSS提供了三种机制来决定那条规则会胜出：\n\n* 继承\n* 层叠\n* 特指\n\n### 继承\n\nCSS属性的值会向下传递。\n比如我们添加一条这样的规则：\n\n```css\nbody: {font-family: arial;}\n```\n\n那么文档的所有元素都将继承这个样式。\n\n### 层叠\n\n层叠，是样式在文档层次中逐层叠加的过程，目的是让浏览器面对某个标签特定属性值得多个来源，确定最终使用哪个值。\n\n#### 样式来源\n\n以下是浏览器层叠各个来源样式的顺序：\n\n1. 浏览器默认的样式表\n2. 用户的样式表\n3. 作者链接样式表（按照它们链接到页面的先后顺序）\n4. 作者嵌入样式\n5. 作者行内样式\n\n浏览器会按上述顺序依次检查每个来源的样式，并在有定义的情况下，更新对每个标签属性值得设定。整个检查更新过程结束后，再将每个标签已最终设定的样式显示出来。\n\n比如，如果作者链接样式表将p的字体设定为Helvetica，而页面中有一条嵌入规则以相同的选择符吧字体设定为Verdana，那么段落文本最终会以Verdana字体显示。**因为浏览器是在读取链接样式表之后读取嵌入样式。**\n\n#### 层叠规则\n\n**层叠规则一：**找到应用给每个元素和属性的所有声明。\n\n**层叠规则二：**按照顺序和权重排序。浏览器一次检查5个来源，并设定匹配的属性，如果匹配的属性在下一个来源有定义，则更新改属性值。\n\n声明也可以加权重。比如：\n\n```css\np {color: green !important; font-size: 12pt;}\n```\n空格!important分号(;) 用于加重声明的权重。\n\n这条规则加重了将文本设置为绿色的权重。所以就算层叠的下一来源给段落设定了其他颜色，最终的颜色仍然还是绿色。\n\n**层叠规则三：**按特指度排序。特指度是表示一条规则有多明确。\n\n比如某个样式表中包含如下规则：\n\n```css\np {font-size: 12px;}\np.largetext {font-size: 16px;}\n\n<p class=\"largetext\">A bit of text</p>\n```\n\n那么上边的p标签将显示16px 文本，因为第二条规则的选择符既包含标签名，又包含类名（特指度高）。\n\n如果是下边的样式：\n\n```css\np {font-size: 12px;}\n.largetext {font-size: 16px;}\n\n<p class=\"largetext\">A bit of text</p>\n```\n还是会显示16px像素，因为类的特指度高。\n\n**层叠规则四** 顺序决定权重。如果两条规则都影响某一元素的属性，特指度也相同，后出现的胜出。\n\n##### 计算特指度\n\n计算特指度有一个记分规则，被称为“ICE”公式：\n\n**I-C-E**\n\nI(ID)C(Class)E(Element)并非真正的三个数，但是 0-1-12比0-2-0 小。\n\nICE记分规则如下：\n\n1. 选择符中有一个ID，在I的位置上加1；\n2. 选择符中有一个类，在C的位置上加1；\n3. 选择符中有一个元素，在E的位置上加1；\n4. 得到一个三位数。\n\n好了，我们来看一个例子：\n\n\n选择符                   | 特指度\n----------------------- | -------\np                       | 0-0-1\np.largetext             |0-1-1\np#largetext             |1-0-1\nbody p#largetext        |1-0-2\nbody p#largetext ul.mylist| 1-1-3\nbody p#largetext ul.mylist li | 1-1-4\n\n\n##### 简化版层叠规则\n\n1. 包含ID的选择符胜过包含类的选择符，包含类的胜过包含标签的选择符。\n2. 如果几个不同来源都为同一个标签的同一个属性定义了样式，行内样式胜过嵌入样式，嵌入样式胜过链接样式。在链接样式表中，具有相同特指度的样式，后声明的优先。\n3. 规则一胜过规则二。\n4. 设定的样式胜过继承的样式。\n\n\n这一篇我们主要介绍了CSS规则，以及如何用它来为HTML应用样式。\n\n-------\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "CSS入门指南-1：工作原理",
        "date": "2017-05-27 09:22:49",
        "tags": [
          "css",
          "读书笔记",
          "前端",
          "html",
          "tutorial"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "css-learing-1-how-it-workds"
    },
    {
      "content": "\n安装使用 Elasticsearch 两种方法：\n\n### 方法1 手动安装 Elasticsearch\n\n##### 安装到ubuntu\n\nElasticsearch与Logstash需要Java作为运行环境\n\n## 安装Java 8\n\n将甲骨文Java PPA添加至apt：\n\n```shell\nsudo add-apt-repository -y ppa:webupd8team/java\n```\n\n更新apt软件包数据库：\n\n```shell\nsudo apt-get update\n```\n\nHUGOMORE42\n\n安装甲骨文Java 8的最新稳定版本，命令如下（在弹出的许可协议中点击接受）：\n\n```shell\nsudo apt-get -y install oracle-java8-installer\n```\n\n## 安装Elasticsearch\n\n### 方法1 通过添加Elastic的软件包源列表利用软件包管理器安装Elasticsearch。\n\n运行以下命令以将Elasticsearch公共GPG密钥导入apt：\n\n```shell\nwget -qO - https://packages.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -\n```\n接下来，创建Elasticsearch源列表：\n\n```shell\necho \"deb http://packages.elastic.co/elasticsearch/${ELASTICSEARCH_VERSION}/debian stable main\" | sudo tee -a /etc/apt/sources.list.d/elk.list\n```\n\n更新apt软件包数据库：\n\n```shell\nsudo apt-get update\n```\n安装Elasticsearch\n\n```shell\nsudo apt-get -y install elasticsearch\n```\n\nElasticsearch已经安装完成。下面编辑其配置文件：\n\n```shell\nsudo vi /etc/elasticsearch/elasticsearch.yml\n```\n\n限制来自外部的Elasticsearch实例访问活动（端口9200），找到指定network.host的一行，取消其注释并将其值替换为“localhost”：\n\n```shell\nelasticsearch.yml excerpt (updated)\n\nnetwork.host: localhost\n```\n启动elasticsearch\n\n```shell\nsudo service elasticsearch restart\n```\n\n也可以使用 脚本 安装\n\n```shell\n#!/bin/bash\n\n### USAGE\n###\n### ./ElasticSearch.sh 1.7 will install Elasticsearch 1.7\n### ./ElasticSearch.sh will fail because no version was specified (exit code 1)\n###\n### CLI options Contributed by @janpieper\n### Check http://www.elasticsearch.org/download/ for latest version of ElasticSearch\n\n### ElasticSearch version\nif [ -z \"$1\" ]; then\n  echo \"\"\n  echo \"  Please specify the Elasticsearch version you want to install!\"\n  echo \"\"\n  echo \"    $ $0 1.7\"\n  echo \"\"\n  exit 1\nfi\n\nELASTICSEARCH_VERSION=$1\n\nif [[ ! \"${ELASTICSEARCH_VERSION}\" =~ ^[0-9]+\\.[0-9]+ ]]; then\n  echo \"\"\n  echo \"  The specified Elasticsearch version isn't valid!\"\n  echo \"\"\n  echo \"    $ $0 1.7\"\n  echo \"\"\n  exit 2\nfi\n\n### Install Java 8\ncd ~\nsudo apt-get install python-software-properties -y\nsleep 1\nsudo add-apt-repository ppa:webupd8team/java -y\nsleep 1\nsudo apt-get update\nsleep 1\nsudo apt-get install oracle-java8-installer -y\n\n### Download and install the Public Signing Key\nwget -qO - https://packages.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -\n\n### Setup Repository\necho \"deb http://packages.elastic.co/elasticsearch/${ELASTICSEARCH_VERSION}/debian stable main\" | sudo tee -a /etc/apt/sources.list.d/elk.list\n\n### Install Elasticsearch\nsudo apt-get update && sudo apt-get install elasticsearch -y\n\n### Start ElasticSearch\nsudo service elasticsearch start\n\n### Lets wait a little while ElasticSearch starts\nsleep 5\n\n### Make sure service is running\ncurl http://localhost:9200\n\n### Should return something like this:\n# {\n#  \"status\" : 200,\n#  \"name\" : \"Storm\",\n#  \"version\" : {\n#    \"number\" : \"1.3.1\",\n#    \"build_hash\" : \"2de6dc5268c32fb49b205233c138d93aaf772015\",\n#    \"build_timestamp\" : \"2014-07-28T14:45:15Z\",\n#    \"build_snapshot\" : false,\n#    \"lucene_version\" : \"4.9\"\n#  },\n#  \"tagline\" : \"You Know, for Search\"\n# }\n\n```\n\n##### 安装到 Mac\n\n1. 到 https://www.elastic.co/downloads/elasticsearch 下载elasticsearch\n2. 解压 cd 到目录 执行\n\n```shell\nsudo bin/elasticsearch\n```\n\n### 方法2 使用 docker\n\n1. 下载 elasticsearch 镜像\n\n```shell\ndocker pull elasticsearch\n```\n2. 新建 docker-compose.yml 文件\n\n```yml\nes:\n   image: elasticsearch\n   volumes:\n     - /data:/usr/share/elasticsearch/data/\n   ports:\n     - \"9200:9200\"\n   mem_limit: 2g\n   environment:\n    ES_JAVA_OPTS: \"-Xmx1g -Xms1g\"\n```\n\n运行命令\n\n```shell\ndocker-compose -f es-docker-compose.yml up -d\n```\n\n启动 elasticsearch\n\n### 测试安装\n\n浏览器中访问http://localhost:9200/，看到一个json结果集，表明安装成功：\n\n```json\n{\n  \"name\" : \"g1WVNJ8\",\n  \"cluster_name\" : \"elasticsearch\",\n  \"cluster_uuid\" : \"RjwyeM4kRRajDZzE3Tcq8g\",\n  \"version\" : {\n    \"number\" : \"5.4.0\",\n    \"build_hash\" : \"780f8c4\",\n    \"build_date\" : \"2017-04-28T17:43:27.229Z\",\n    \"build_snapshot\" : false,\n    \"lucene_version\" : \"6.5.0\"\n  },\n  \"tagline\" : \"You Know, for Search\"\n}\n\n```\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "Elasticsearch 安装和使用",
        "date": "2017-05-18 06:22:49",
        "tags": [
          "工具",
          "tutorial"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "elasticsearch-install"
    },
    {
      "content": "\n> 上一节介绍了DynamoDB 的查询，本来计划这一节介绍使用索引的查询，不过随机看到了更新操作，就先写更新操作吧\n\n## update (修改表中的数据)\n\nSQL 语言提供用于修改数据的 UPDATE 语句。DynamoDB 使用 UpdateItem 操作完成类似的任务。\n\n### SQL\n\n在 SQL 中，可使用 UPDATE 语句修改一个或多个行。SET 子句为一个或多个列指定新值，WHERE 子句确定修改的行。示例如下：\n\n```sql\nUPDATE Music\nSET RecordLabel = 'Global Records'\nWHERE Artist = 'No One You Know' AND SongTitle = 'Call Me Today';\n```\n\nHUGOMORE42\n\n如果任何行均不匹配 WHERE 子句，则 UPDATE 语句不起作用。\n\n### DynamoDB\n\n在 DynamoDB 中，可使用 UpdateItem 操作修改单个项目。\n\nAPI 语法如下：\n\n```json\n{\n   \"AttributeUpdates\": {\n      \"string\" : {\n         \"Action\": \"string\",\n         \"Value\": {\n            \"B\": blob,\n            \"BOOL\": boolean,\n            \"BS\": [ blob ],\n            \"L\": [\n               \"AttributeValue\"\n            ],\n            \"M\": {\n               \"string\" : \"AttributeValue\"\n            },\n            \"N\": \"string\",\n            \"NS\": [ \"string\" ],\n            \"NULL\": boolean,\n            \"S\": \"string\",\n            \"SS\": [ \"string\" ]\n         }\n      }\n   },\n   \"ConditionalOperator\": \"string\",\n   \"ConditionExpression\": \"string\",\n   \"Expected\": {\n      \"string\" : {\n         \"AttributeValueList\": [\n            {\n               \"B\": blob,\n               \"BOOL\": boolean,\n               \"BS\": [ blob ],\n               \"L\": [\n                  \"AttributeValue\"\n               ],\n               \"M\": {\n                  \"string\" : \"AttributeValue\"\n               },\n               \"N\": \"string\",\n               \"NS\": [ \"string\" ],\n               \"NULL\": boolean,\n               \"S\": \"string\",\n               \"SS\": [ \"string\" ]\n            }\n         ],\n         \"ComparisonOperator\": \"string\",\n         \"Exists\": boolean,\n         \"Value\": {\n            \"B\": blob,\n            \"BOOL\": boolean,\n            \"BS\": [ blob ],\n            \"L\": [\n               \"AttributeValue\"\n            ],\n            \"M\": {\n               \"string\" : \"AttributeValue\"\n            },\n            \"N\": \"string\",\n            \"NS\": [ \"string\" ],\n            \"NULL\": boolean,\n            \"S\": \"string\",\n            \"SS\": [ \"string\" ]\n         }\n      }\n   },\n   \"ExpressionAttributeNames\": {\n      \"string\" : \"string\"\n   },\n   \"ExpressionAttributeValues\": {\n      \"string\" : {\n         \"B\": blob,\n         \"BOOL\": boolean,\n         \"BS\": [ blob ],\n         \"L\": [\n            \"AttributeValue\"\n         ],\n         \"M\": {\n            \"string\" : \"AttributeValue\"\n         },\n         \"N\": \"string\",\n         \"NS\": [ \"string\" ],\n         \"NULL\": boolean,\n         \"S\": \"string\",\n         \"SS\": [ \"string\" ]\n      }\n   },\n   \"Key\": {\n      \"string\" : {\n         \"B\": blob,\n         \"BOOL\": boolean,\n         \"BS\": [ blob ],\n         \"L\": [\n            \"AttributeValue\"\n         ],\n         \"M\": {\n            \"string\" : \"AttributeValue\"\n         },\n         \"N\": \"string\",\n         \"NS\": [ \"string\" ],\n         \"NULL\": boolean,\n         \"S\": \"string\",\n         \"SS\": [ \"string\" ]\n      }\n   },\n   \"ReturnConsumedCapacity\": \"string\",\n   \"ReturnItemCollectionMetrics\": \"string\",\n   \"ReturnValues\": \"string\",\n   \"TableName\": \"string\",\n   \"UpdateExpression\": \"string\"\n}\n```\n\n参数说明：\n\n- Key: 主键，用于定位项目\n- TableName：表名 （最小 3. 最大 255）\n- Expected：\n- AttributeUpdates： 遗留参数，已废弃\n- ConditionalOperator： 遗留参数，已废弃\n- ConditionExpression：条件表达式（仅在特定 ConditionExpression 的计算结果为 true 时成功完成）\n- ExpressionAttributeNames：条件表达式的名称的别名，比如 date 为保留字，可用别名定义为 #d\n- ExpressionAttributeValues：条件表达式的值\n- ReturnConsumedCapacity：显示使用的写入容量单位数\n    - TOTAL 会返回由表及其所有global secondary index占用的写入容量；\n    - INDEXES 仅返回由global secondary index占用的写入容量；\n    - NONE 表示您不需要返回任何占用容量统计数据。\n- ReturnValues: 更新后返回的数据.\n    - NONE - 如果没有特别说明，返回None (这个是默认值)\n    - ALL_OLD - 按在进行更新之前的情况，返回整个项目。\n    - ALL_NEW - 按在进行更新之后的情况，返回整个项目。\n    - UPDATED_OLD - 按在进行更新之前的情况，仅返回更新的值。\n    - UPDATED_NEW - 按在进行更新之后的情况，仅返回更新的值。\n- UpdateExpression：指定要修改的属性以及这些属性的新值，更新表达式还指定如何修改属性。下面是更新表达式的语法摘要：\n```\nupdate-expression ::=\nSET set-action , ...\n| REMOVE remove-action , ...  \n| ADD add-action , ...\n| DELETE delete-action , ...  \n```\n更新表达式由多个部分组成。每个部分以一个 SET、REMOVE、ADD 或 DELETE 关键字开头。您可在更新表达式中按任意顺序包含其中任意部分。但是，每个部分关键字只能出现一次。您可以同时修改多个属性。以下是更新表达式的一些示例：\n\n* SET list[0] = :val1\n* REMOVE #m.nestedField1, #m.nestedField2\n* ADD aNumber :val2, anotherNumber :val3\n* DELETE aSet :val4\n\n以下示例显示了带有多个部分的单个更新表达式：\n\n```json\nSET list[0] = :val1 REMOVE #m.nestedField1, #m.nestedField2 ADD aNumber :val2, anotherNumber :val3 DELETE aSet :val4\n```\n\n我们可以在更新表达式中使用任意属性名称，*第一个字符是 a-z 或 A-Z*，*第二个字符（如果存在）是 a-z、A-Z 或 0-9*。\n如果属性名称不满足此要求，则需要将表达式属性名称定义为占位符。更多信息参考（表达式属性名称）。\n\n要在更新表达式中指定文本值，可以使用表达式属性值。更多信息参考（表达式属性值）。\n\n------\n\n##### SET\n\n在更新表达式中使用 SET 操作可将一个或多个属性与值添加到项目。如果这些属性已存在，则更新。还可以使用 SET 来加或减数字类型的属性。对多个属性执行 SET 操作，使用逗号分隔。\n\nset语法如下：\n```\nset-action ::=\n    path = value\n\nvalue ::=\n    operand\n    | operand '+' operand\n    | operand '-' operand\n\noperand ::=\n    path | function\n```\n\n* path 元素是项目的文档路径。(比如项目中info 为字典 info 中 a 的路径为info['a'])\n* operand 元素可以为项目的文档路径，或者为函数。\n\nSET 操作支持以下函数：\n\n* if_not_exists (path, operand) - 如果项目在指定 path 中不包含属性，则 if_not_exists 的求值结果为 operand；否则求值结果为 path。您可以使用此函数来避免覆盖项目中已存在的属性。\n* list_append (operand, operand) - 此函数的求值结果为列表，新元素将添加到列表中。新元素必须包含在列表中，例如要向列表中添加 2，操作数将成为 [2]。您可以通过反转操作数的顺序，将新元素附加到列表的开头或结尾。\n\n以下是在这些函数中使用 SET 操作的一些示例。\n\n如果属性已存在，则以下示例不执行任何操作；否则它会将属性设置为默认值。\n```\nSET Price = if_not_exists(Price, 100)\n```\n以下示例将新元素添加到 FiveStar 评论列表。表达式属性名称 #pr 是 ProductReviews；属性值 :r 是只包含一个元素的列表。如果列表之前有两个元素 [0] 和 [1]，则新元素将为 [2]。\n```\nSET #pr.FiveStar = list_append(#pr.FiveStar, :r)\n```\n以下示例将另一个元素添加到 FiveStar 评论列表中，但此时元素将附加到列表开头的位置 [0] 处。列表中的所有其他元素将会移动一位。\n```\nSET #pr.FiveStar = list_append(:r, #pr.FiveStar)\n```\n\n##### REMOVE\n\n在更新表达式中使用 REMOVE 操作可从项目中删除一个或多个元素。要执行多个 REMOVE 操作，请使用逗号分隔。\n\n下面是更新表达式中的 REMOVE 的语法摘要。唯一的操作数是您要删除的属性的文档路径：\n\n```\nremove-action ::=\n    path\n```\n以下是使用 REMOVE 操作的更新表达式示例。从项目中删除多个属性：\n\n```\nREMOVE Title, RelatedItems[2], Pictures.RearView\n```\n对列表元素使用 REMOVE\n\n当删除现有列表元素时，剩余的元素将会移位。例如，考虑以下列表：\n```\nMyNumbers: { [\"Zero\",\"One\",\"Two\",\"Three\",\"Four\"] }\n```\n列表包含元素 [0]、[1]、[2]、[3] 和 [4]。现在，我们使用 REMOVE 操作删除两个元素：\n```\nREMOVE MyNumbers[1], MyNumbers[3]\n```\n剩余的元素会向右移位，生成带有元素 [0]、[1] 和 [2] 的列表，每个元素具有以下数据：\n```\nMyNumbers: { [\"Zero\",\"Two\",\"Four\"] }\n```\n> 如果您使用 REMOVE 来删除超出列表中最后一个元素位置的不存在项目，则将不执行任何操作：也就是不删除任何数据。例如，以下表达式对 MyNumbers 列表没有任何效果：\n\n```\nREMOVE MyNumbers[11]\n```\n\n##### ADD\n\n*ADD 操作仅支持数字和集数据类型。一般而言，我们建议使用 SET 而不是 ADD。*\n\n在更新表达式中使用 ADD 可执行以下任一操作：\n\n* 如果属性尚不存在，则将新属性及其值添加到项目。\n* 如果属性已存在，则 ADD 的行为取决于属性的数据类型：\n* 如果属性是数字，并且添加的值也是数字，则该值将按数学运算与现有属性相加。（如果该值为负数，则从现有属性减去该值。）\n* 如果属性是集，并且您添加的值也是集，则该值将附加到现有集中。\n* 要执行多个 ADD 操作，请使用逗号分隔。\n\n在以下语法摘要中：\n\n* path 元素是属性的文档路径。属性必须为数字或集数据类型。\n* value 元素是要与属性相加的值（对于数字数据类型），或者是要附加到属性中的集（对于集类型）。\n\n```\nadd-action ::=\n    path value\n```\n\n以下是使用 add 操作的一些更新表达式示例。\n\n以下示例对数字进行加运算。表达式属性值 :n 是数字，此值将与 Price 相加。\n```\nADD Price :n\n```\n以下示例将一个或多个值添加到 Color 集。表达式属性值 :c 是字符串集。\n```\nADD Color :c\n```\n\n##### DELETE\n\n*DELETE 操作只支持集数据类型。*\n\n在更新表达式中使用 DELETE 操作可从集中删除元素。要执行多个 DELETE 操作，请使用逗号分隔。\n\n在以下语法摘要中：\n\n* path 元素是属性的文档路径。该属性必须是集数据类型。\n* value 元素是集中要删除的元素。\n\n```\ndelete-action ::=\n    path value\n```\n\n以下示例使用 DELETE 操作从 Color 集中删除元素。表达式属性值 :c 是字符串集。\n\n```\nDELETE Color :c\n```\n\n#### UpdateItem 示例如下：\n\n```json\n{\n    TableName: \"Music\",\n    Key: {\n        \"Artist\":\"No One You Know\",\n        \"SongTitle\":\"Call Me Today\"\n    },\n    UpdateExpression: \"SET RecordLabel = :label\",\n    ExpressionAttributeValues: {\n        \":label\": \"Global Records\"\n    }\n}\n```\n\n* UpdateItem必须指定要修改的项目的 Key 属性和一个用于指定属性值的 UpdateExpression。\n* UpdateItem 替换整个项目，而不是替换单个属性。\n* UpdateItem 的行为与“upsert”操作的行为类似：如果项目位于表中，则更新项目，否则添加（插入）新项目。\n* UpdateItem只能修改单个项目，如果要修改多个项目，则必须使用多个 UpdateItem 操作。\n* UpdateItem 支持条件写入，在此情况下，操作仅在特定 ConditionExpression 的计算结果为 true 时成功完成。例如，除非歌曲的价格大于或等于 2.00，否则以下 UpdateItem 操作不会执行更新：\n\n#### 条件写入\n\n要执行条件更新，请使用更新表达式以及条件表达式来执行 UpdateItem 操作。要继续执行操作，条件表达式的求值结果必须为 true；否则操作将失败。\n\n假设您要将某项目的价格提高一定金额，如 :amt，但前提是结果不得超过最高价。为此，您可以计算当前允许提价的最高价，然后从最高价中减去提高的金额 :amt。将结果定义为 :limit，然后使用以下条件表达式：\n\n条件表达式：Price <= :limit)\n更新表达式：SET Price = Price + :amt\n现在假设您要为项目设置前视图图片，不过前提是该项目还没有任何图片，不希望覆盖任何现有元素。您可以使用以下表达式来执行操作：\n\n更新表达式：SET Pictures.FrontView = :myUR\n（假设 :myURL 是项目图片的位置，例如 http://example.com/picture.jpg。）\n条件表达式：attribute_not_exists(Pictures.FrontView)\n\n```python\n{\n    TableName: \"Music\",\n    Key: {\n        \"Artist\":\"No One You Know\",\n        \"SongTitle\":\"Call Me Today\"\n    },\n    UpdateExpression: \"SET RecordLabel = :label\",\n    ConditionExpression: \"Price >= :p\",\n    ExpressionAttributeValues: {\n        \":label\": \"Global Records\",\n        \":p\": 2.00\n    }\n}\n```\n\n* UpdateItem 还支持原子计数器或类型为 Number 的属性（可递增或递减）。原子计数器在很多方面都类似于 SQL 数据库中的顺序生成器、身份列或自递增字段。\n\n以下是一个 UpdateItem 操作的示例，它初始化一个新属性 (Plays) 来跟踪歌曲的已播放次数：\n\n```json\n{\n    TableName: \"Music\",\n    Key: {\n        \"Artist\":\"No One You Know\",\n        \"SongTitle\":\"Call Me Today\"\n    },\n    UpdateExpression: \"SET Plays = :val\",\n    ExpressionAttributeValues: {\n        \":val\": 0\n    },\n    ReturnValues: \"UPDATED_NEW\"\n}\n```\nReturnValues 参数设置为 UPDATED_NEW，这将返回已更新的任何属性的新值。在此示例中，它返回 0（零）。\n\n当某人播放此歌曲时，可使用以下 UpdateItem 操作来将 Plays 增加 1：\n\n```\n{\n    TableName: \"Music\",\n    Key: {\n        \"Artist\":\"No One You Know\",\n        \"SongTitle\":\"Call Me Today\"\n    },\n    UpdateExpression: \"SET Plays = Plays + :incr\",\n    ExpressionAttributeValues: {\n        \":incr\": 1\n    },\n    ReturnValues: \"UPDATED_NEW\"\n}\n```\n\n#### 总结一下\n\n* UpdateItem 一次只能更新一个项目\n* UpdateItem 更新更新整个项目而不是只修改特点的值\n* UpdateItem 支持条件写入\n\n> 这一节我们介绍了DynamoDB 项目的更新操作，下一节我们将介绍项目的删除操作（索引的查询又要延后了。。\n\n[原文链接](http://mp.weixin.qq.com/s?__biz=MzAwNjI5MjAzNw==&mid=2655751962&idx=1&sn=9d3e387c3fa946305598bc269b40fd3e&chksm=80b0b830b7c73126364b48cb33915d9a51552327afb4cc73388984f5449f99871fd44465baa6#rd)\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "Amazon DynamoDB 入门7：项目更新",
        "date": "2017-02-07 14:23:33",
        "tags": [
          "AWS",
          "nosql",
          "DynamoDB",
          "python",
          "database"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "Amazon-DynamoDB-UpdateItem"
    },
    {
      "content": "\n> 上一节我们介绍了DynamoDB索引的创建及管理，这一节我们将介绍query（查询）和scan（扫描）的使用。\n\n# 查询Query\n\nSQL 可使用 SELECT 语句查询关键列、非关键列或任意组合。WHERE 子句确定返回的行。\n\nDynamoDB Query 操作提供对存储数据的物理位置的快速高效访问。 可以将 Query 用于任何具有复合主键（分区键和排序键）的表。这里的表必须指定分区键的相等条件，并且可以选择性为排序键提供另一个条件。 KeyConditionExpression 参数指定要查询的键值。\n\nHUGOMORE42\n\n> 可使用可选 FilterExpression 在结果中的找出某些符号条件的项目。\n\n在 DynamoDB 中，必须使用 ExpressionAttributeValues 作为表达式参数（例如，KeyConditionExpression和 FilterExpression）中的占位符。这类似于在关系数据库中使用绑定变量，在运行时将实际值代入 SELECT语句。 下边是query的语法：\n\n```python\nresponse = table.query(\n    IndexName='string',\n    Select='ALL_ATTRIBUTES'|'ALL_PROJECTED_ATTRIBUTES'|'SPECIFIC_ATTRIBUTES'|'COUNT',\n    AttributesToGet=[\n        'string',\n    ],\n    Limit=123,\n    ConsistentRead=True|False,\n    ConditionalOperator='AND'|'OR',\n    ScanIndexForward=True|False,\n    ExclusiveStartKey={\n      'string': 'string'|123|Binary(b'bytes')|True|None|set(['string'])|set([123])|set([Binary(b'bytes')])|[]|{}\n    },\n    ReturnConsumedCapacity='INDEXES'|'TOTAL'|'NONE',\n    ProjectionExpression='string',\n    FilterExpression=Attr('myattribute').eq('myvalue'),\n    KeyConditionExpression=Key('mykey').eq('myvalue'),\n    ExpressionAttributeNames={\n        'string': 'string'\n    },\n    ExpressionAttributeValues={\n        'string': 'string'|123|Binary(b'bytes')|True|None|set(['string'])|set([123])|set([Binary(b'bytes')])|[]|{}\n    }\n)\n```\n\n参数说明：\n\n- ExclusiveStartKey: 起始查询的key，也就是上一页的最后一条数据\n- ConsistentRead: 是否使用强制一致性 默认False\n- ScanIndexForward: 索引的排序方式 True 为正序 False 为倒序 默认True\n- ReturnConsumedCapacity: DynamoDB 将返回条件写入期间使用的写入容量单位数\n\n  - TOTAL 会返回由表及其所有global secondary index占用的写入容量；\n  - INDEXES 仅返回由global secondary index占用的写入容量；\n  - NONE 表示您不需要返回任何占用容量统计数据。\n\n- ProjectionExpression: 用于指定要在扫描结果中包含的属性\n\n- FilterExpression: 指定一个条件，以便仅返回符合条件的项目\n\n- KeyConditionExpression: 要查询的键值\n\n- ExpressionAttributeNames: 提供名称替换功能\n- ExpressionAttributeValues: 提供值替换功能\n\n以下是 DynamoDB 中的几个 Query 示例：\n\n返回 Aritist = 'No One You Know' SongTitle='Call Me Today' 的歌曲：\n\n```json\n{\n    TableName: \"Music\",\n    KeyConditionExpression: \"Artist = :a and SongTitle = :t\",\n    ExpressionAttributeValues: {\n        \":a\": \"No One You Know\",\n        \":t\": \"Call Me Today\"\n    }\n}\n```\n\n返回 Aitist='No One You Know' 的所以歌曲：\n\n```json\n{\n    TableName: \"Music\",\n    KeyConditionExpression: \"Artist = :a\",\n    ExpressionAttributeValues: {\n        \":a\": \"No One You Know\"\n    }\n}\n```\n\n返回Aritist ='No One You Know' 并且 SongTitle 开头为Call 的所有歌曲：\n\n```json\n{\n    TableName: \"Music\",\n    KeyConditionExpression: \"Artist = :a and begins_with(SongTitle, :t)\",\n    ExpressionAttributeValues: {\n        \":a\": \"No One You Know\",\n        \":t\": \"Call\"\n    }\n}\n```\n\n返回Aritist ='No One You Know' 并且 SongTitle 开头为Today 并且价格小于1 的所有歌曲：\n\n```json\n{\n    TableName: \"Music\",\n    KeyConditionExpression: \"Artist = :a and contains(SongTitle, :t)\",\n    FilterExpression: \"price < :p\",\n    ExpressionAttributeValues: {\n        \":a\": \"No One You Know\",\n        \":t\": \"Today\",\n        \":p\": 1.00\n    }\n}\n```\n\n## Python Example\n\nboto3\n\n返回 Aitist='The Acme Band' 的所有歌曲：\n\n```python\n# ...\nfrom boto3.dynamodb.conditions import Key, Attr\n\ntable = db3.Table('Music')\n\nresponse = table.query(\n    KeyConditionExpression=Key('Artist').eq('The Acme Band')\n)\n\nitems = response['Items']\nprint(items)\n\n## output\n[\n{\n    u'Genre': u'Rock',\n    u'Price': Decimal('0.99'),\n    u'Artist': u'The Acme Band',\n    u'SongTitle': u'Look Out, World',\n    u'AlbumTitle': u'The Buck Starts Here'\n},\n{\n    u'Artist': u'The Acme Band',\n    u'Price': Decimal('2.47'),\n    u'AlbumTitle': u'The Buck Starts Here',\n    u'PromotionInfo': {\n        u'RadioStationsPlaying': [u'KHCR', u'KBQX', u'WTNR', u'WJJH'],\n        u'Rotation': u'Heavy',\n        u'TourDates': {u'Seattle': u'20150625', u'Cleveland': u'20150630'}\n    },\n    u'Genre': u'Rock', u'SongTitle': u'Still In Love'\n    }\n]\n```\n\n返回 Artist='No One You Know' 并且SongTitle='Somewhere Down The Road' 的所有歌曲：\n\n```python\nresponse = table.query(\n    KeyConditionExpression=Key('Artist').eq('No One You Know') & Key('SongTitle').eq('Somewhere Down The Road')\n)\nitems = response['Items']\nprint(items)\n\n## output\n\n[{\n    u'Artist': u'No One You Know',\n    u'AlbumTitle': u'Somewhat Famous',\n    u'CriticRating': Decimal('8.4'),\n    u'Year': Decimal('1984'),\n    u'Genre': u'Country',\n    u'SongTitle': u'Somewhere Down The Road'\n  }\n]\n```\n\n返回Aritist ='No One You Know' 并且 SongTitle 开头为 Call 的所有歌曲：\n\n```python\nresponse = table.query(\n    KeyConditionExpression=Key('Artist').eq('The Acme Band') & Key('SongTitle').begins_with('Look')\n)\nitems = response['Items']\nprint(items)\n\n## output\n\n[\n{\n    u'Genre': u'Rock',\n    u'Price': Decimal('0.99'),\n    u'Artist': u'The Acme Band',\n    u'SongTitle': u'Look Out, World',\n    u'AlbumTitle': u'The Buck Starts Here'\n}\n]\n```\n\n返回Aritist ='No One You Know' 并且 SongTitle 开头为Today 并且价格小于1 的所有歌曲：\n\n```python\nresponse = table.query(\n    KeyConditionExpression=Key('Artist').eq('The Acme Band'),\n    FilterExpression=Attr('Price').lt(1)\n)\nitems = response['Items']\nprint(items)\n\n## output\n[{\n    u'Genre': u'Rock',\n    u'Price': Decimal('0.99'),\n    u'Artist': u'The Acme Band',\n    u'SongTitle': u'Look Out, World',\n    u'AlbumTitle': u'The Buck Starts Here'\n},\n]\n```\n\n### Note\n\n特别注意： 如果筛选条件是排序键，则是先过滤再返回结果，和SQL中where 筛选类似。 如果排序值不是排序建，则先返回结果再过滤。\n\n例如：\n\n表结构和项目值如下：\n\n```\nTable Test:\n    a: hash_key\n    b: range_key\n    c: number\n\nfor i in range(10):\n    Test(a=1, b=i*10, c=i*20)\n```\n\n查询：\n\n```python\nresponse = table.query(\n    KeyConditionExpression=Key('a').eq('1') & Key('b').gt('40'),\n    Limit=2\n)\n\n查询结果为两个项目：\n\na=1, b=50, c=80\na=1, b=60, c=100\n\nresponse = table.query(\n    KeyConditionExpression=Key('a').eq('1'),\n    FilterExpression=Attr('c').gt('80'),\n    Limit=2\n)\n\n会发现查询没有结果。\n\n这是因为DynamoDB 会默认按照 b 正序排列，limit=2 则限定了结果为：\na=1, b=10, c=20\na=1, b=20, c=40\n\n可以看出，这个结果中并没有符合 c > 80 的项目。\n所以 结果为空。\n\n不过还是会占读取吞吐量。\n```\n\n## Scan\n\n在 SQL 中，不带 WHERE 子句的 SELECT 语句将返回表中的每个行。在 DynamoDB 中，Scan 操作可执行相同的工作。在这两种情况下，您都可以检索所有项目或部分项目。 无论您使用的是 SQL 还是 NoSQL 数据库，都应谨慎使用扫描操作，因为它们会占用大量系统资源\n\n在 SQL 中，可在不指定 WHERE 子句的情况下使用 SELECT 语句扫描表并检索其所有数据。您可以在结果中请求一个或多个列。或者，如果您使用通配符 (*)，则可请求所有列。 下面是一些示例：\n\n```sql\n/* Return all of the data in the table */\nSELECT * FROM Music;\n/* Return all of the values for Artist and Title */\nSELECT Artist, Title FROM Music;\n```\n\nDynamoDB 提供以相似方式工作的 Scan 操作。 下面是Scan 的语法示例：\n\n```python\nresponse = table.scan(\n    IndexName='string',\n    AttributesToGet=[\n        'string',\n    ],\n    Limit=123,\n    Select='ALL_ATTRIBUTES'|'ALL_PROJECTED_ATTRIBUTES'|'SPECIFIC_ATTRIBUTES'|'COUNT',\n    ConditionalOperator='AND'|'OR',\n    ExclusiveStartKey={\n        'string': 'string'|123|Binary(b'bytes')|True|None|set(['string'])|set([123])|set([Binary(b'bytes')])|[]|{}\n    },\n    ReturnConsumedCapacity='INDEXES'|'TOTAL'|'NONE',\n    TotalSegments=123,\n    Segment=123,\n    ProjectionExpression='string',\n    FilterExpression=Attr('myattribute').eq('myvalue'),\n    ExpressionAttributeNames={\n        'string': 'string'\n    },\n    ExpressionAttributeValues={\n        'string': 'string'|123|Binary(b'bytes')|True|None|set(['string'])|set([123])|set([Binary(b'bytes')])|[]|{}\n    },\n    ConsistentRead=True|False\n)\n```\n\n参数说明：\n\n- ExclusiveStartKey: 起始查询的key，也就是上一页的最后一条数据\n- ConsistentRead: 是否使用强制一致性 默认False\n- ScanIndexForward: 索引的排序方式 True 为正序 False 为倒序 默认True\n- ReturnConsumedCapacity: DynamoDB 将返回条件写入期间使用的写入容量单位数\n\n  - TOTAL 会返回由表及其所有global secondary index占用的写入容量；\n  - INDEXES 仅返回由global secondary index占用的写入容量；\n  - NONE 表示您不需要返回任何占用容量统计数据。\n\n- ProjectionExpression: 用于指定要在扫描结果中包含的属性\n\n- FilterExpression: 指定一个条件，以便仅返回符合条件的项目\n\n- KeyConditionExpression: 要查询的键值\n\n- ExpressionAttributeNames: 提供名称替换功能\n- ExpressionAttributeValues: 提供值替换功能\n\n> scan 的查询方式是先扫描所有数据，筛选条件也仅在扫描整个表后进行应用，所以会占用大量的读取吞吐量。\n\n下面是一些示例：\n\n```json\n// Return all of the data in the table\n{\n    TableName:  \"Music\"\n}\n// Return all of the values for Artist and Title\n{\n    TableName:  \"Music\",\n    ProjectionExpression: \"Artist, Title\"\n}\n```\n\nScan 操作还提供一个 FilterExpression 参数以过滤符合条件的项目。在扫描整个表后且结果返回之前，应用 FilterExpression。（建议不要对大型表这样做：即使仅返回几个匹配项目，仍需为整个 Scan 付费。会占用吞吐量）\n\n### Python Example\n\nboto3\n\n返回Aritist ='No One You Know' 并且 SongTitle 开头为Today 并且价格小于1 的所有歌曲：\n\n```python\nresponse = table.scan(\n    FilterExpression=Attr('Price').lt(2)&Key('Artist').eq('The Acme Band')\n)\nitems = response['Items']\nprint(items)\n\n## output\n[{\n    u'Genre': u'Rock',\n    u'Price': Decimal('0.99'),\n    u'Artist': u'The Acme Band',\n    u'SongTitle': u'Look Out, World',\n    u'AlbumTitle': u'The Buck Starts Here'\n},]\n```\n\n在代码中，请注意以下情况：\n\n- ProjectionExpression 用于指定要在扫描结果中包含的属性。\n- FilterExpression 用于指定一个条件，以便仅返回符合条件的项目。所有其他项目都将被舍弃。\n- scan 方法每次返回项目的一个子集（称为页面）。响应中的 LastEvaluatedKey 值随后通过 ExclusiveStartKey 参数传递给 scan 方法。当返回最后一页后，LastEvaluatedKey 将不是响应的一部分。\n\nNote\n\n- ExpressionAttributeNames 提供名称替换功能。我们使用此参数是因为 year 是 DynamoDB 中的保留字，您不能直接在任何表达式中使用它，包括 KeyConditionExpression。我们使用表达式属性名称 #yr 来解决此问题。\n- ExpressionAttributeValues 提供值替换功能。我们使用此参数是因为您不能在任何表达式中使用文字，包括 KeyConditionExpression。我们使用表达式属性值 :yyyy 来解决此问题。\n\n> 这一节我们介绍了DynamoDB query和scan的基本用法，下一节将介绍使用索引查询\n\ntips:\n从这几篇的介绍可以发现DynamoDB的查询语法比较繁琐，写起来非常麻烦，所以我模仿sqlalchemy 写了一个orm，欢迎使用[!https://github.com/gusibi/dynamodb-py](https://github.com/gusibi/dynamodb-py)\n\n[原文地址](http://mp.weixin.qq.com/s?__biz=MzAwNjI5MjAzNw==&mid=2655751959&idx=1&sn=ba71eac3e0113239031c326e421015ea&chksm=80b0b83db7c7312b0eaf427dee3abdf6a94a7694d9c58974912db368d88128900da77ab25aba#rd)\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "Amazon DynamoDB 入门6：query 和 scan",
        "date": "2017-01-31 09:46:28",
        "tags": [
          "AWS",
          "nosql",
          "DynamoDB",
          "python",
          "database"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "Amazon-DynamoDB-query-and-scan"
    },
    {
      "content": "\n> 上一节我们介绍了项目的添加、修改、获取、删除（CRUD）操作，这一节将介绍索引的创建及管理。\n\n### 创建索引\n\n#### SQL\n\n在关系数据库中，索引是一个数据结构，可对表中的不同的列执行快速查询。可以使用 CREATE INDEX SQL 语句将索引添加到现有表，并指定要建立索引的列。在创建索引后，可以照常查询表中的数据，但现在数据库可使用索引快速查找表中的指定行，而不是扫描整个表。\n\n在创建一个索引后，数据库将自动维护此索引。只要修改表中的数据，就会自动更改索引以反映表中的更改。\n\nHUGOMORE42\n\n在 MySQL 中，您可以创建如下所示的索引：\n\n```\nCREATE INDEX GenreAndPriceIndex\nON Music (genre, price);\n```\n#### DynamoDB\n\n在 DynamoDB 中，我们可以创建和使用secondary index来实现类似目的。\n\nDynamoDB 中的索引与其关系对应项不同。当我们创建secondary index时，必须指定其键属性 - 分区键和排序键。\n在创建secondary index后，我们可以对它执行 Query 或 Scan 操作，就如同对表执行这些操作一样。\nDynamoDB 没有查询优化程序，因此，仅在我们对secondary index执行 Query 或 Scan 操作时使用它。\n\nDynamoDB 支持两种不同的索引：\n\n* 全局二级索引 - 索引的主键可以是其表中的任意两个属性（**可以在创建表时创建，也可以向现有表添加新全局二级索引，或者删除现有的全局二级索引**）。\n* 本地二级索引 - 索引的分区键必须与其表的分区键相同。不过，排序键可以是任何其他属性（**是在创建表的同时创建的。不能向现有表添加本地二级索引，也不能删除已存在的任何本地二级索引**）。\n\n\nDynamoDB 确保secondary index中的数据最终与其表保持一致。我们可以请求对表或local secondary index**执行强一致性 Query 或 Scan 操作**。但是，**全局二级索引仅支持最终一致性**。\n\n可使用 UpdateTable 操作并指定 GlobalSecondaryIndexUpdates 来将global secondary index添加到现有表：\n\n```\n{\n    TableName: \"Music\",\n    AttributeDefinitions:[\n        {AttributeName: \"Genre\", AttributeType: \"S\"},\n        {AttributeName: \"Price\", AttributeType: \"N\"}\n    ],\n    GlobalSecondaryIndexUpdates: [\n        {\n            Create: {\n                IndexName: \"GenreAndPriceIndex\",\n                KeySchema: [\n                    {AttributeName: \"Genre\", KeyType: \"HASH\"}, //Partition key\n                    {AttributeName: \"Price\", KeyType: \"RANGE\"}, //Sort key\n                ],\n                Projection: {\n                    \"ProjectionType\": \"ALL\"\n                },\n                ProvisionedThroughput: {\n                    \"ReadCapacityUnits\": 1,\"WriteCapacityUnits\": 1\n                }\n            }\n        }\n    ]\n}\n```\n\n添加索引时必须向 UpdateTable 提供以下参数：\n\n* TableName – 索引将关联到的表。\n* AttributeDefinitions – 索引的键架构属性的数据类型。\n* GlobalSecondaryIndexUpdates – 有关要创建的索引的详细信息：\n\n    * IndexName - 索引的名称。\n    * KeySchema – 用于索引主键的属性。\n    * Projection - 表中要复制到索引的属性。在此情况下，ALL 意味着复制所有属性。\n    * ProvisionedThroughput – 每秒需对此索引执行的读取和写入次数。（它与表的预配置吞吐量设置是分开的。）\n\n在此操作中，会将表中的数据回填到新索引。在回填期间，表保持可用。但索引未准备就绪，直至其 Backfilling 属性从 true 变为 false。您可以使用 DescribeTable 操作查看此属性。\n\n#### python 示例\n\nboto3\n\n```\nimport boto3\ndb3 = boto3.resource('dynamodb', endpoint_url='http://localhost:8000',  region_name='us-west-2')\n\ntable = db3.meta.client.update_table(\n    TableName='Music',\n    AttributeDefinitions=[\n        {\n            'AttributeName': \"Genre\",\n            'AttributeType': \"S\"\n        },\n        {\n            'AttributeName': \"Price\",\n            'AttributeType': \"N\"\n        }\n    ],\n    GlobalSecondaryIndexUpdates=[\n        {\n            'Create': {\n                'IndexName': \"GenreAndPriceIndex\",\n                'KeySchema': [\n                    {'AttributeName': \"Genre\", 'KeyType': \"HASH\"},  # Partition key\n                    {'AttributeName': \"Price\", 'KeyType': \"RANGE\"}, # Sort key\n                ],\n                'Projection': {\n                    \"ProjectionType\": \"ALL\"\n                },\n                'ProvisionedThroughput': {\n                    \"ReadCapacityUnits\": 10,\"WriteCapacityUnits\": 10\n                }\n            }\n        }\n    ]\n)\n\ndb3.meta.client.describe_table(TableName='Music')\n```\n\n> output\n\n```\n{'ResponseMetadata': {'HTTPHeaders': {'content-length': '1082',\n   'content-type': 'application/x-amz-json-1.0',\n   'server': 'Jetty(8.1.12.v20130726)',\n   'x-amz-crc32': '3717567836',\n   'x-amzn-requestid': 'd63c0176-8257-428b-b6f3-af87219ba45b'},\n  'HTTPStatusCode': 200,\n  'RequestId': 'd63c0176-8257-428b-b6f3-af87219ba45b',\n  'RetryAttempts': 0},\n u'Table': {u'AttributeDefinitions': [{u'AttributeName': u'Artist',\n    u'AttributeType': u'S'},\n   {u'AttributeName': u'Price', u'AttributeType': u'N'},\n   {u'AttributeName': u'SongTitle', u'AttributeType': u'S'},\n   {u'AttributeName': u'Genre', u'AttributeType': u'S'}],\n  u'CreationDateTime': datetime.datetime(2017, 1, 14, 3, 9, 42, 63000, tzinfo=tzlocal()),\n  u'GlobalSecondaryIndexes': [{u'IndexArn': u'arn:aws:dynamodb:ddblocal:000000000000:table/Music/index/GenreAndPriceIndex',\n    u'IndexName': u'GenreAndPriceIndex',\n    u'IndexSizeBytes': 0,\n    u'IndexStatus': u'ACTIVE',\n    u'ItemCount': 0,\n    u'KeySchema': [{u'AttributeName': u'Genre', u'KeyType': u'HASH'},\n     {u'AttributeName': u'Price', u'KeyType': u'RANGE'}],\n    u'Projection': {u'ProjectionType': u'ALL'},\n    u'ProvisionedThroughput': {u'ReadCapacityUnits': 10,\n     u'WriteCapacityUnits': 10}}],\n  u'ItemCount': 0,\n  u'KeySchema': [{u'AttributeName': u'Artist', u'KeyType': u'HASH'},\n   {u'AttributeName': u'SongTitle', u'KeyType': u'RANGE'}],\n  u'ProvisionedThroughput': {u'LastDecreaseDateTime': datetime.datetime(1970, 1, 1, 8, 0, tzinfo=tzlocal()),\n   u'LastIncreaseDateTime': datetime.datetime(1970, 1, 1, 8, 0, tzinfo=tzlocal()),\n   u'NumberOfDecreasesToday': 0,\n   u'ReadCapacityUnits': 10,\n   u'WriteCapacityUnits': 10},\n  u'TableArn': u'arn:aws:dynamodb:ddblocal:000000000000:table/Music',\n  u'TableName': u'Music',\n  u'TableSizeBytes': 0,\n  u'TableStatus': u'ACTIVE'}}\n\n```\n---------\n### 索引扩展\n\n### 管理索引\n\n索引可以访问替代查询模式，并可以加快查询速度。\n\n无论使用的是关系数据库还是 DynamoDB，在创建索引时都应谨慎。只要对表进行写入，就必须更新表的所有索引。在具有大型表的写入密集型环境中，这会占用大量系统资源。\n\n为了对表中的数据进行高效访问，Amazon DynamoDB 对主键属性创建并维护索引。这可以让应用程序通过指定主键值快速地检索数据。\n可以对表创建一个或多个二级索引，然后对这些索引发出 Query 或 Scan 请求，以便通过主键以外的属性对数据进行高效访问。\n\nsecondary index 是一种数据结构，它包含表中属性的子集以及一个支持 Query 操作的替代键。我们可以使用 Query 从索引中检索数据，其方式与对表使用 Query 大致相同。一个表可以有多个secondary index，这样，应用程序可以访问许多不同的查询模式。\n\n> 也可以对索引使用 Scan，其方式与对表使用 Scan 大致相同。\n\nsecondary index中的数据由从表投影 或复制到索引中的属性组成。在创建secondary index时，可以定义索引的替代键以及要在索引中投影的任何其他属性。DynamoDB 将这些属性与表中的主键属性一起复制到索引中。然后，就可以像查询或扫描表一样查询或扫描该索引。\n\n每个secondary index都由 DynamoDB 自动维护。在表中添加、修改或删除项目时，表上的所有索引也会更新。\n\nDynamoDB 支持两种secondary index：\n\n* Global secondary index – 其分区键和排序键可以与表上的分区键和排序键不同的索引。global secondary index被视为“全局”，是因为对索引进行的查询可以跨表中所有分区的所有数据。\n* Local secondary index – 一种分区键与表中的相同但排序键与表中的不同的索引。local secondary index的含义是“本地”，表示local secondary index的每个分区的范围都限定为具有相同分区键值的表分区。\n\n\n下表是global secondary index与local secondary index的主要差异：\n\n-------\n\n性能 | 全局二级索引  | 本地二级索引\n---|---|---\n键架构|\tglobal secondary index的**主键可以是简单主键（分区键）或复合主键（分区键和排序键）**。\t|local secondary index的**主键必须是复合主键**（分区键和排序键）。\n键属性|\t索引分区键和排序键（如果有）可以是字符串、数字或二进制类型的任何表属性。\t|索引的分区键是与表的分区键相同的属性。排序键可以是字符串、数字或二进制类型的任何表属性。\n每个分区键值的大小限制|\tglobal secondary index**没有大小限制**。\t|对于每个分区键值，**所有索引项目的大小总和必须为 10GB 或更小**。\n在线索引操作|\t可以在创建表时创建Global secondary index。也可以向现有表添加新global secondary index，或者删除现有global secondary index。|Local secondary index是在**创建表的同时创建的**。不能向现有表添加local secondary index，也不能删除已存在的任何local secondary index。\n查询和分区|\t通过global secondary index，**可以跨所有分区查询整个表**。\t|借助local secondary index，**可以对查询中分区键值指定的单个分区进行查询**。\n读取一致性|\t对global secondary index进行的查询**仅支持最终一致性**。\t|查询local secondary index时，**可以选择最终一致性或强一致性**。\n预配置吞吐量使用|\t每个global secondary index都**有自己的用于读取和写入活动的预配置吞吐量设置**。对global secondary index进行的查询或扫描会占用索引（而非表）的容量单位。global secondary index更新也是如此，因为会进行表写入。\t|对local secondary index进行的查询或扫描**会占用表的读取容量单位**。向表写入时，其local secondary index也会更新；这些更新会占用表的写入容量单位。\n投影属性|\t对于global secondary index查询或扫描，**只能请求投影到索引中的属性**。DynamoDB 不从表提取任何属性。\t|如果您查询或扫描local secondary index，可以**请求未投影到索引中的属性**。DynamoDB 自动从表提取这些属性。\n\n-------\n\n> 如果要创建多个含有secondary index的表，必须按顺序执行此操作。例如，先创建第一个表，等待其状态变为 ACTIVE，创建下一个表，等待其状态变为 ACTIVE，依此类推。如果我们尝试同时创建多个含有secondary index的表，DynamoDB 会返回 LimitExceededException。\n\n对于每个secondary index，必须指定以下内容：\n\n* 要创建的索引的类型 – global secondary index或local secondary index。\n* 索引的名称。索引的命名规则与表的命名规则相同，对于听一个表的不同索引，索名称必须是唯一的，不过，与不同的表的索引的名称可以相同。\n* 索引的键架构。索引键架构中的每个属性必须是类型为字符串、数字或二进制的顶级属性。其他数据类型，包括文档和集，均不受支持。键架构的其他要求取决于索引的类型：\n    * 对于global secondary index，分区键可以是任何标量表属性。排序键是可选的，也可以是任何标量表属性。\n    * 对于local secondary index，分区键必须与表的分区键相同，排序键必须是非键表属性。\n* 从表投影到索引中的其他属性（如果有）必须是除表键属性之外的属性。（表键属性会自动投影到每个索引）\n* 索引的预配置吞吐量设置（如有必要）：\n    * 对于global secondary index，必须指定读取和写入容量单位设置。这些预配置吞吐量设置独立于表的设置。\n    * 对于local secondary index，无需指定读取和写入容量单位设置。对local secondary index进行的读取和写入操作会占用其父表的预配置吞吐量设置。\n\n> 为获得最大查询灵活性，您可以为每个表创建最多 5 个 global secondary index和最多 5 个local secondary index。\n\n可以使用 DescribeTable 操作获取表上secondary index的详细列表。DescribeTable 返回表上每个secondary index的名称、存储大小和项目数。**系统并不会实时更新这些值，但会大约每隔六个小时刷新一次**。\n\n[原文地址](http://mp.weixin.qq.com/s?__biz=MzAwNjI5MjAzNw==&mid=2655751953&idx=1&sn=13195866ffc6106d90bb60df86347101&chksm=80b0b83bb7c7312d00c186d2603835ff7f49a6c0fb77c1c94c3ee7cd30b45f7661c7b8c03e42#rd)\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "Amazon DynamoDB 入门5：索引创建及管理",
        "date": "2017-01-18 13:55:39",
        "tags": [
          "AWS",
          "nosql",
          "DynamoDB",
          "python",
          "database"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "Amazon-DynamoDB-Indexes"
    },
    {
      "content": "\n> 上一节我们介绍了DynamoDB 表的操作，这一节将介绍项目的添加 修改 获取 删除操作。\n\n## 创建项目\n\nAmazon DynamoDB 提供了 PutItem 和 BatchWriteItem 两种方式写入数据\n\n### 添加单个项目\n\n在 Amazon DynamoDB 中，使用 PutItem 操作向表添加项目：\n\nHUGOMORE42\n\n```\n{\n    TableName: \"Music\",\n    Item: {\n        \"Artist\":\"No One You Know\",\n        \"SongTitle\":\"Call Me Today\",\n        \"AlbumTitle\":\"Somewhat Famous\",\n        \"Year\": 2015,\n        \"Price\": 2.14,\n        \"Genre\": \"Country\",\n        \"Tags\": {\n            \"Composers\": [\n                  \"Smith\",\n                  \"Jones\",\n                  \"Davis\"\n            ],\n            \"LengthInSeconds\": 214\n        }\n    }\n}\n```\n\n此表的主键包含 Artist 和 SongTitle。您必须为这些属性指定值。\n以下是要了解的有关此 PutItem 示例的几个关键事项：\n\n* DynamoDB 使用 JSON 提供对文档的本机支持。这使得 DynamoDB 非常适合存储半结构化数据，例如 Tags。您也可以从 JSON 文档中检索和操作数据。\n\n* 除了主键（Artist 和 SongTitle），Music 表没有预定义的属性。\n\n* 大多数 SQL 数据库是面向事务的。当您发出 INSERT 语句时，数据修改不是永久性的，直至您发出 COMMIT 语句。利用 Amazon DynamoDB，当 DynamoDB 通过 HTTP 200 状态代码 (OK) 进行回复时，PutItem 操作的效果是永久性的。\n\n\n#### Python Example\n\nboto3\n\n```\n# ...\ntable = db3.Table('Music')\ntable.put_item(\n      Item = {\n        \"Artist\": \"No One You Know\",\n        \"SongTitle\": \"My Dog Spot\",\n        \"AlbumTitle\": \"Hey Now\",\n        \"Price\": Decimal('1.98'),\n        \"Genre\": \"Country\",\n        \"CriticRating\": Decimal('8.4')\n    }\n)\n\nOut[98]:\n{'ResponseMetadata': {'HTTPHeaders': {'content-length': '2',\n   'content-type': 'application/x-amz-json-1.0',\n   'server': 'Jetty(8.1.12.v20130726)',\n   'x-amz-crc32': '2745614147',\n   'x-amzn-requestid': 'c7c6be12-9752-403f-97b1-a9ac451a0a98'},\n  'HTTPStatusCode': 200,\n  'RequestId': 'c7c6be12-9752-403f-97b1-a9ac451a0a98',\n  'RetryAttempts': 0}}\n\ntable.put_item(\n      Item = {\n        \"Artist\": \"No One You Know\",\n        \"SongTitle\": \"Somewhere Down The Road\",\n        \"AlbumTitle\":\"Somewhat Famous\",\n        \"Genre\": \"Country\",\n        \"CriticRating\": Decimal('8.4'),\n        \"Year\": 1984\n    }\n)\ntable.put_item(\n      Item = {\n        \"Artist\": \"The Acme Band\",\n        \"SongTitle\": \"Still In Love\",\n        \"AlbumTitle\":\"The Buck Starts Here\",\n        \"Price\": Decimal('2.47'),\n        \"Genre\": \"Rock\",\n        \"PromotionInfo\": {\n            \"RadioStationsPlaying\":[\n                 \"KHCR\", \"KBQX\", \"WTNR\", \"WJJH\"\n            ],\n            \"TourDates\": {\n                \"Seattle\": \"20150625\",\n                \"Cleveland\": \"20150630\"\n            },\n            \"Rotation\": \"Heavy\"\n        }\n    }\n)\n\ntable.put_item(\n      Item = {\n        \"Artist\": \"The Acme Band\",\n        \"SongTitle\": \"Look Out, World\",\n        \"AlbumTitle\":\"The Buck Starts Here\",\n        \"Price\": Decimal('0.99'),\n        \"Genre\": \"Rock\"\n    }\n)\n\n```\nNote\n\n* PutItem 是覆盖操作，如果主键相同，第二次执行将覆盖掉之前的数据\n* 除了 PutItem 之外，Amazon DynamoDB 还支持同时写入多个（最多25个）项目的 BatchWriteItem 操作。\n\n### 添加多个项目\n\n#### Python Example\n\nboto3\n\n```\n# ...\ntable = db3.Table('Music')\n\nwith table.batch_writer() as batch:\n    batch.put_item(\n        Item = {\n            \"Artist\": \"The Acme Band\",\n            \"SongTitle\": \"Look Out, World\",\n            \"AlbumTitle\":\"The Buck Starts Here\",\n            \"Price\": Decimal('0.99'),\n            \"Genre\": \"Rock\"\n        }\n    )\n    batch.put_item(\n        Item = {\n            \"Artist\": \"The Acme Band 0\",\n            \"SongTitle\": \"Look Out, World\",\n            \"AlbumTitle\":\"The Buck Starts Here\",\n            \"Price\": Decimal('1.99'),\n            \"Genre\": \"Rock\"\n        }\n    )\n    batch.put_item(\n        Item = {\n            \"Artist\": \"The Acme Band 1\",\n            \"SongTitle\": \"Look Out, World\",\n            \"AlbumTitle\":\"The Buck Starts Here\",\n            \"Price\": Decimal('2.99'),\n            \"Genre\": \"Rock\"\n        }\n    )\n    batch.put_item(\n        Item = {\n            \"Artist\": \"The Acme Band 1\",\n            \"SongTitle\": \"Look Out, World\",\n            \"AlbumTitle\":\"The Buck Starts Here\",\n        }\n    )\n```\n\nBatchWriteItem 使用 overwrite_by_pkeys=['partition_key','sort_key'] 参数去除项目中重复的部分。\n\n```\nwith table.batch_writer(overwrite_by_pkeys=['partition_key', 'sort_key']) as batch:\n    batch.put_item(\n        Item={\n            'partition_key': 'p1',\n            'sort_key': 's1',\n            'other': '111',\n        }\n    )\n    batch.put_item(\n        Item={\n            'partition_key': 'p1',\n            'sort_key': 's1',\n            'other': '222',\n        }\n    )\n```\n去重后，等同于:\n\n```\nwith table.batch_writer(overwrite_by_pkeys=['partition_key', 'sort_key']) as batch:\n    batch.put_item(\n        Item={\n            'partition_key': 'p1',\n            'sort_key': 's1',\n            'other': '222',\n        }\n    )\n```\n\n\n## 读取数据\n\n\n利用 SQL，我们可以使用 SELECT 语句从表中检索一个或多个行。可使用 WHERE 子句来确定返回给您的数据\n\nDynamoDB 提供以下操作来读取数据：\n\n* GetItem - 从表中检索单个项目。这是读取单个项目的最高效方式，因为它将提供对项目的物理位置的直接访问。（DynamoDB 还提供 BatchGetItem 操作，在单个操作中执行最多 100 个 GetItem 调用。）\n* Query - 检索具有特定分区键的所有项目。在这些项目中，您可以将条件应用于排序键并仅检索一部分数据。Query提供对存储数据的分区的快速高效的访问。\n* Scan - 检索指定表中的所有项目。\n\nNote\n\n利用关系数据库，您可以使用 SELECT 语句联接多个表中的数据并返回结果。联接是关系模型的基础。要确保联接高效执行，应持续优化数据库及其应用程序的性能。\nDynamoDB 是一个非关系 NoSQL 数据库且不支持表联接。相反，应用程序一次从一个表中读取数据。\n\n### 使用项目的主键读取项目\n\nDynamoDB 提供 GetItem 操作来按项目的主键检索项目。\n\n默认情况下，GetItem 将返回整个项目及其所有属性。\n\n```\n{\n    TableName: \"Music\",\n    Key: {\n        \"Artist\": \"No One You Know\",\n        \"SongTitle\": \"Call Me Today\"\n    }\n}\n```\n\n可以添加 ProjectionExpression 参数以仅返回一些属性：\n\n```\n{\n    TableName: \"Music\",\n    Key: {\n        \"Artist\": \"No One You Know\",\n        \"SongTitle\": \"Call Me Today\"\n    },\n    \"ProjectionExpression\": \"AlbumTitle, Price\"\n}\n```\n\n* DynamoDB GetItem 操作非常高效：此操作使用主键值确定相关项目的准确存储位置，并直接此位置检索该项目。\n* SQL SELECT 语句支持多种查询和表扫描。DynamoDB 通过其 Query 和 Scan 操作提供相似功能，如查询表和扫描表中所述。\n* SQL SELECT 语句可执行表联接，这允许您同时从多个表中检索数据。DynamoDB 是一个非关系数据库。因此，它不支持表联接。\n\n> Query 和 Scan 操作将在之后的章节详细介绍。\n\n#### Python Example\n\nboto3\n\n```\n# ...\ntable = db3.Table('Music')\nresponse = table.get_item(\n    Key={\n        \"Artist\": \"The Acme Band\",\n        \"SongTitle\": \"Still In Love\"\n    }\n)\nitem = response['Item']\nprint(item)\n\n# output\n{\n        \"Artist\": \"The Acme Band\",\n        \"SongTitle\": \"Still In Love\",\n        \"AlbumTitle\":\"The Buck Starts Here\",\n        \"Price\": Decimal('2.47'),\n        \"Genre\": \"Rock\",\n        \"PromotionInfo\": {\n            \"RadioStationsPlaying\":[\n                 \"KHCR\", \"KBQX\", \"WTNR\", \"WJJH\"\n            ],\n            \"TourDates\": {\n                \"Seattle\": \"20150625\",\n                \"Cleveland\": \"20150630\"\n            },\n            \"Rotation\": \"Heavy\"\n        }\n    }\n\nresponse = table.get_item(\n    Key={\n        \"Artist\": \"The Acme Band\",\n        \"SongTitle\": \"Still In Love\"\n    },\n    ProjectionExpression = \"AlbumTitle, Price\"\n)\nitem = response['Item']\nprint(item)\n{\n    'AlbumTitle': u'The Buck Starts Here',\n    'Price': Decimal('2.47')\n}\n```\n## 更新\n\nSQL 语言提供用于修改数据的 UPDATE 语句。DynamoDB 使用 UpdateItem 操作完成类似的任务。\n\n在 DynamoDB 中，可使用 UpdateItem 操作修改单个项目。（如果要修改多个项目，则必须使用多个 UpdateItem 操作。）\n示例如下：\n\n```\n{\n    TableName: \"Music\",\n    Key: {\n        \"Artist\":\"No One You Know\",\n        \"SongTitle\":\"Call Me Today\"\n    },\n    UpdateExpression: \"SET RecordLabel = :label\",\n    ExpressionAttributeValues: {\n        \":label\": \"Global Records\"\n    }\n}\n```\n\n* 必须指定要修改的项目的 Key 属性和一个用于指定属性值的 UpdateExpression。\n* UpdateItem 替换整个项目，而不是替换单个属性。\n* UpdateItem 的行为与**“upsert”操作的行为类似**：如果项目位于表中，则更新项目，否则添加（插入）新项目。\n* UpdateItem 支持条件写入，在此情况下，操作仅在特定 ConditionExpression 的计算结果为 true 时成功完成\n\n```\n{\n    TableName: \"Music\",\n    Key: {\n        \"Artist\":\"No One You Know\",\n        \"SongTitle\":\"Call Me Today\"\n    },\n    UpdateExpression: \"SET RecordLabel = :label\",\n    ConditionExpression: \"Price >= :p\",\n    ExpressionAttributeValues: {\n        \":label\": \"Global Records\",\n        \":p\": 2.00\n    }\n}\n```\n\n* UpdateItem 还支持原子计数器或类型为 Number 的属性（可递增或递减）。\n\n以下是一个 UpdateItem 操作的示例，它初始化一个新属性 (Plays) 来跟踪歌曲的已播放次数：\n\n```\n{\n    TableName: \"Music\",\n    Key: {\n        \"Artist\":\"No One You Know\",\n        \"SongTitle\":\"Call Me Today\"\n    },\n    UpdateExpression: \"SET Plays = :val\",\n    ExpressionAttributeValues: {\n        \":val\": 0\n    },\n    ReturnValues: \"UPDATED_NEW\"\n}\n\n```\n\nReturnValues 参数设置为 UPDATED_NEW，这将返回已更新的任何属性的新值。在此示例中，它返回 0（零）。\n\n当某人播放此歌曲时，可使用以下 UpdateItem 操作来将 Plays 增加 1：\n\n```\n{\n    TableName: \"Music\",\n    Key: {\n        \"Artist\":\"No One You Know\",\n        \"SongTitle\":\"Call Me Today\"\n    },\n    UpdateExpression: \"SET Plays = Plays + :incr\",\n    ExpressionAttributeValues: {\n        \":incr\": 1\n    },\n    ReturnValues: \"UPDATED_NEW\"\n}\n```\n#### Python Example\n\nboto3\n使用 UpdateItem 操作修改单个项目\n\n```\nimport boto3\nimport json\nimport decimal\n\nclass DecimalEncoder(json.JSONEncoder):\n    def default(self, o):\n        if isinstance(o, decimal.Decimal):\n            if o % 1 > 0:\n                return float(o)\n            else:\n                return int(o)\n        return super(DecimalEncoder, self).default(o)\n\ndb3 = boto3.resource('dynamodb', region_name='us-west-2', endpoint_url=\"http://localhost:8000\")\n\ntable = db3.Table('Music')\n\nresponse = table.update_item(\n    Key={\n        \"Artist\":\"No One You Know\",\n        \"SongTitle\":\"Call Me Today\"\n    },\n    UpdateExpression=\"SET RecordLabel = :label\",\n    ExpressionAttributeValues={\n        \":label\": \"Global Records\"\n    },\n    ReturnValues=\"UPDATED_NEW\"\n)\n\nprint(json.dumps(response, indent=4, cls=DecimalEncoder))\n```\n\nUpdateItem 条件写入 价格大于或等于 2.00 UpdateItem 执行更新\n\n```\ntable = db3.Table('Music')\n\nresponse = table.update_item(\n    Key={\n        \"Artist\":\"No One You Know\",\n        \"SongTitle\":\"Call Me Today\"\n    },\n    UpdateExpression=\"SET RecordLabel = :label\",\n    ConditionExpression=\"Price >= :p\",\n    ExpressionAttributeValues={\n        \":label\": \"Global Records\",\n        \":p\": 2.00\n    },\n    ReturnValues=\"UPDATED_NEW\"\n)\n\n```\nUpdateItem 操作的示例，它初始化一个新属性 (Plays) 来跟踪歌曲的已播放次数\n\n```\ntable = db3.Table('Music')\n\nresponse = table.update_item(\n    Key={\n        \"Artist\":\"No One You Know\",\n        \"SongTitle\":\"Call Me Today\"\n    },\n    UpdateExpression=\"SET Plays = :val\",\n    ExpressionAttributeValues={\n        \":val\": 0\n    },\n    ReturnValues=\"UPDATED_NEW\"\n)\n\n```\n使用 UpdateItem 操作来将 Plays 增加 1\n\n```\ntable = db3.Table('Music')\n\nresponse = table.update_item(\n    Key={\n        \"Artist\":\"No One You Know\",\n        \"SongTitle\":\"Call Me Today\"\n    },\n    UpdateExpression=\"SET Plays = Plays + :incr\",\n    ExpressionAttributeValues={\n        \":incr\": 1\n    },\n    ReturnValues=\"UPDATED_NEW\"\n)\n\n```\n\n## 删除项目\n\n在 SQL 中，DELETE 语句从表中删除一个或多个行。DynamoDB 使用 DeleteItem 操作一次删除一个项目。\n\n在 DynamoDB 中，可使用 DeleteItem 操作从表中删除数据（一次删除一个项目）。您必须指定项目的主键值。示例如下：\n\n```\n{\n    TableName: \"Music\",\n    Key: {\n        Artist: \"The Acme Band\",\n        SongTitle: \"Look Out, World\"\n    }\n}\n```\n\nNote\n\n除了 DeleteItem 之外，Amazon DynamoDB 还支持同时删除多个项目的 BatchWriteItem 操作。\n\nDeleteItem 支持条件写入，在此情况下，操作仅在特定 ConditionExpression 的计算结果为 true 时成功完成。例如，以下 DeleteItem 操作仅在项目具有 RecordLabel 属性时删除项目：\n\n```\n{\n    TableName: \"Music\",\n    Key: {\n        Artist: \"The Acme Band\",\n        SongTitle: \"Look Out, World\"\n    },\n   ConditionExpression: \"attribute_exists(RecordLabel)\"\n}\n```\n\n#### Python Example\n\nboto3\n\n```\ntable = db3.Table('Music')\ntable.delete_item(\n    Key={\n        'AlbumTitle': 'Hey Now'\n        'Artist': 'No One You Know'\n    }\n)\n\n```\n\n> 这一节我们介绍了项目的基本操作（CRUD），下一节将介绍索引的创建和管理。\n\n[原文地址](http://mp.weixin.qq.com/s?__biz=MzAwNjI5MjAzNw==&mid=2655751948&idx=1&sn=22046f0c62fa0e3a740306b5f106488a&chksm=80b0b826b7c73130e0f65057f83aebea9b41c5edcdccd3230a07fe24f5864c5ed11e89f0ae05#rd)\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "Amazon DynamoDB 入门4：项目的基本操作（CRUD）",
        "date": "2017-01-18 13:53:38",
        "tags": [
          "AWS",
          "nosql",
          "DynamoDB",
          "python",
          "database"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "Amazon-DynamoDB-Item-CRUD"
    },
    {
      "content": "\n> 之前两篇文章介绍了DynamoDB如何在本地安装以及基本的工作原理和API，这一节主要介绍如何使用DynamoDB。\n\n基本的DynamoDB 操作包括表操作、项目操作和索引管理。\n\n首先是链接数据库。和关系型数据库不同，**DynamoDB 是一项 Web 服务，与其进行的交互是无状态的。应用程序不需要维护持久性网络连接。相反，与 DynamoDB 的交互是通过 HTTP(S) 请求和响应进行的。**\n\nHUGOMORE42\n\n执行某项操作的步骤为：\n\n1. **应用程序将 HTTP(S) 请求发送到 DynamoDB。该请求包含要执行的 DynamoDB 操作的名称和参数。DynamoDB 将立即执行请求。**\n2. **DynamoDB 返回一个包含操作结果的 HTTP(S) 响应。如果出错，DynamoDB 将返回 HTTP 错误状态和消息。**\n\n大多数情况下，我们编写应用程序代码访问DynamoDB。同时还可以使用 AWS 管理控制台或 AWS Command Line Interface (AWS CLI) 向 DynamoDB 发送临时请求并查看结果。\n\n剩下的就让我们用代码展示吧！\n\n## 表操作\n\n我们知道，关系模型需要一个明确定义的架构，其中，数据将标准化为表、列和行。此外，在表、列、索引和其他数据库元素之间定义所有关系。但 DynamoDB 不同，**DynamoDB 没有架构。每个表必须具有一个用来唯一标识每个数据项目的主键，但对其他非键属性没有类似的约束。DynamoDB 可以管理结构化或半结构化的数据，包括 JSON 文档。**\n\n表是关系数据库和 DynamoDB 中的基本数据结构。关系数据库管理系统 (RDBMS) 要求在创建表时定义表的架构。相比之下，DynamoDB 表没有架构 - 与主键不同，我们在创建表时无需定义任何属性或数据类型。\n\n### 新建表\n\nDynamoDB 使用 CreateTable 操作创建表，并指定参数，请求语法如下所示：\n\n```\n{\n   \"AttributeDefinitions\": [\n      {\n         \"AttributeName\": \"string\",\n         \"AttributeType\": \"string\"\n      }\n   ],\n   \"GlobalSecondaryIndexes\": [\n      {\n         \"IndexName\": \"string\",\n         \"KeySchema\": [\n            {\n               \"AttributeName\": \"string\",\n               \"KeyType\": \"string\"\n            }\n         ],\n         \"Projection\": {\n            \"NonKeyAttributes\": [ \"string\" ],\n            \"ProjectionType\": \"string\"\n         },\n         \"ProvisionedThroughput\": {\n            \"ReadCapacityUnits\": number,\n            \"WriteCapacityUnits\": number\n         }\n      }\n   ],\n   \"KeySchema\": [\n      {\n         \"AttributeName\": \"string\",\n         \"KeyType\": \"string\"\n      }\n   ],\n   \"LocalSecondaryIndexes\": [\n      {\n         \"IndexName\": \"string\",\n         \"KeySchema\": [\n            {\n               \"AttributeName\": \"string\",\n               \"KeyType\": \"string\"\n            }\n         ],\n         \"Projection\": {\n            \"NonKeyAttributes\": [ \"string\" ],\n            \"ProjectionType\": \"string\"\n         }\n      }\n   ],\n   \"ProvisionedThroughput\": {\n      \"ReadCapacityUnits\": number,\n      \"WriteCapacityUnits\": number\n   },\n   \"StreamSpecification\": {\n      \"StreamEnabled\": boolean,\n      \"StreamViewType\": \"string\"\n   },\n   \"TableName\": \"string\"\n}\n\n\n```\n\n必须向 CreateTable 提供以下参数：\n\n* TableName – 表名称。\n* KeySchema – 用于主键的属性。有关更多信息，请参阅 表、项目和属性 和 主键。\n* AttributeDefinitions – 键架构属性的数据类型。\n* ProvisionedThroughput – 每秒需对此表执行的读取和写入次数。DynamoDB 将保留足量的存储和系统资源，以便始终满足吞吐量要求。也可在创建之后使用 UpdateTable 操作后更改这些设置。存储分配完全由 DynamoDB 管理，我们无需指定表的存储要求。\n\nAttributeType 的定义中：\n\n* S - 字符串类型\n* N - 数字类型\n* B - 二进制类型\n\n\n#### Python Example\n\nboto3\n\n```\nimport boto3\ndb3 = boto3.resource('dynamodb', endpoint_url='http://localhost:8000',  region_name='us-west-2')\n\n\ntable = db3.create_table(\n    TableName='Music',\n    KeySchema=[\n        {\n            'AttributeName': \"Artist\",\n            'KeyType': \"HASH\"\n        },\n        {\n            'AttributeName': \"SongTitle\",\n            'KeyType': \"RANGE\"\n        }\n    ],\n    AttributeDefinitions=[\n        {\n            'AttributeName': \"Artist\",\n            'AttributeType': \"S\"\n        },\n        {\n            'AttributeName': \"SongTitle\",\n            'AttributeType': \"S\"\n        }\n    ],\n    ProvisionedThroughput={       \n        'ReadCapacityUnits': 1,\n        'WriteCapacityUnits': 1\n    }\n)\n\n\n# Wait until the table exists.\ntable.meta.client.get_waiter('table_exists').wait(TableName='Music')\n\n# Print out some data about the table.\nprint(table.item_count)\n\n```\n此表的主键包括 Artist（分区键）和 SongTitle（排序键）。\n\n### 获取有关表的信息\n\n表建好后，我们可以使用 DescribeTable 命令查看表的信息。\n唯一的参数是表名称，如下所示：\n\n```\n{\n    TableName : \"Music\"\n}\n```\n\n来自 DescribeTable 回复如下所示：\n\n```\n{\n  \"Table\": {\n    \"AttributeDefinitions\": [\n      {\n        \"AttributeName\": \"Artist\",\n        \"AttributeType\": \"S\"\n      },\n      {\n        \"AttributeName\": \"SongTitle\",\n        \"AttributeType\": \"S\"\n      }\n    ],\n    \"TableName\": \"Music\",\n    \"KeySchema\": [\n      {\n        \"AttributeName\": \"Artist\",\n        \"KeyType\": \"HASH\"  //Partition key\n      },\n      {\n        \"AttributeName\": \"SongTitle\",\n        \"KeyType\": \"RANGE\"  //Sort key\n      }\n    ],\n\n    ...remaining output omitted...\n```\n\nDescribeTable 还将返回有关表中的索引、预配置的吞吐量设置、大约项目数和其他元数据的信息。\n\n#### Python Example\n\nboto3\n\n```\nimport boto3\ndb3 = boto3.resource('dynamodb', endpoint_url='http://localhost:8000',  region_name='us-west-2')\n\ndb3.meta.client.describe_table(TableName='Music')\n```\n```\n# 返回结果如下\n\n{'ResponseMetadata': {'HTTPHeaders': {'content-length': '569',\n   'content-type': 'application/x-amz-json-1.0',\n   'server': 'Jetty(8.1.12.v20130726)',\n   'x-amz-crc32': '2801025854',\n   'x-amzn-requestid': '2dafeeab-8d79-4b32-ad1f-03983624ab41'},\n  'HTTPStatusCode': 200,\n  'RequestId': '2dafeeab-8d79-4b32-ad1f-03983624ab41',\n  'RetryAttempts': 0},\n u'Table': {u'AttributeDefinitions': [{u'AttributeName': u'Artist',\n    u'AttributeType': u'S'},\n   {u'AttributeName': u'SongTitle', u'AttributeType': u'S'}],\n  u'CreationDateTime': datetime.datetime(2016, 12, 28, 11, 25, 12, 657000, tzinfo=tzlocal()),\n  u'ItemCount': 0,\n  u'KeySchema': [{u'AttributeName': u'Artist', u'KeyType': u'HASH'},\n   {u'AttributeName': u'SongTitle', u'KeyType': u'RANGE'}],\n  u'ProvisionedThroughput': {u'LastDecreaseDateTime': datetime.datetime(1970, 1, 1, 8, 0, tzinfo=tzlocal()),\n   u'LastIncreaseDateTime': datetime.datetime(1970, 1, 1, 8, 0, tzinfo=tzlocal()),\n   u'NumberOfDecreasesToday': 0,\n   u'ReadCapacityUnits': 1,\n   u'WriteCapacityUnits': 1},\n  u'TableArn': u'arn:aws:dynamodb:ddblocal:000000000000:table/Music',\n  u'TableName': u'Music',\n  u'TableSizeBytes': 0,\n  u'TableStatus': u'ACTIVE'}}\n```\n\n### 删除表\n\n当不再需要一个表并希望将它永久性丢弃时，可使用 DeleteTable：\n\n表一经删除便无法恢复。（一些关系数据库允许撤消 DROP TABLE 操作）\n\n```\n{\n    TableName: \"Music\"\n}\n```\n\n#### Python Example\n\nboto3\n\n ```\nfrom __future__ import print_function # Python 2/3 compatibility\nimport boto3\n\ndynamodb = boto3.resource('dynamodb', region_name='us-west-2', endpoint_url=\"http://localhost:8000\")\n\ntable = dynamodb.Table('Music')\n\ntable.delete()\n\n## output\n\n{'ResponseMetadata': {\n    'HTTPHeaders': {\n        'content-length': '1012',\n        'content-type': 'application/x-amz-json-1.0',\n        'server': 'Jetty(8.1.12.v20130726)',\n        'x-amz-crc32': '2473676771',\n        'x-amzn-requestid': '84938373-870f-420f-b19e-4de2c6301743'},\n    'HTTPStatusCode': 200,\n    'RequestId': '84938373-870f-420f-b19e-4de2c6301743',\n    'RetryAttempts': 0},\n    u'TableDescription': {\n    ...\n    }\n}\n ```\n\n### 修改表\n\n当一个表创建好之后如果想要调整，可以使用UpdateTable命令\n\n修改表时我们一次只可以做一个操作:\n\n\t* 修改预设的吞吐量。\n\t* 开启或者停止使用Streams。\n\t* 删除一个全局耳机索引。\n\t* 创建一个全局的二级索引。当索引开始后台执行时，可以使用UpdateTable进行下一个操作。\n\n> UpdateTable 是一个异步操作; 当它开始执行时，表的状态将由 ACTIVE 变为 UPDATING。\n\n请求语法为：\n\n```\n{\n   \"AttributeDefinitions\": [\n      {\n         \"AttributeName\": \"string\",\n         \"AttributeType\": \"string\"\n      }\n   ],\n   \"GlobalSecondaryIndexUpdates\": [\n      {\n         \"Create\": {\n            \"IndexName\": \"string\",\n            \"KeySchema\": [\n               {\n                  \"AttributeName\": \"string\",\n                  \"KeyType\": \"string\"\n               }\n            ],\n            \"Projection\": {\n               \"NonKeyAttributes\": [ \"string\" ],\n               \"ProjectionType\": \"string\"\n            },\n            \"ProvisionedThroughput\": {\n               \"ReadCapacityUnits\": number,\n               \"WriteCapacityUnits\": number\n            }\n         },\n         \"Delete\": {\n            \"IndexName\": \"string\"\n         },\n         \"Update\": {\n            \"IndexName\": \"string\",\n            \"ProvisionedThroughput\": {\n               \"ReadCapacityUnits\": number,\n               \"WriteCapacityUnits\": number\n            }\n         }\n      }\n   ],\n   \"ProvisionedThroughput\": {\n      \"ReadCapacityUnits\": number,\n      \"WriteCapacityUnits\": number\n   },\n   \"StreamSpecification\": {\n      \"StreamEnabled\": boolean,\n      \"StreamViewType\": \"string\"\n   },\n   \"TableName\": \"string\"\n}\n\n```\n\n#### Python Example\n\nboto3\n\n```\nimport boto3\ndb3 = boto3.resource('dynamodb', endpoint_url='http://localhost:8000',  region_name='us-west-2')\n\n\ntable = db3.meta.client.update_table(\n    TableName='Music',\n    AttributeDefinitions=[\n        {\n            'AttributeName': \"Artist\",\n            'AttributeType': \"S\"\n        },\n        {\n            'AttributeName': \"SongTitle\",\n            'AttributeType': \"S\"\n        }\n    ],\n    ProvisionedThroughput={       \n        'ReadCapacityUnits': 10,\n        'WriteCapacityUnits': 10\n    }\n)\n\ndb3.meta.client.describe_table(TableName='Music')\n\n```\n\n现在查看Music 表会发现预设的吞吐量都已经修改为了10\n\n[DynamoDB UpdateTable 操作](http://docs.aws.amazon.com/zh_cn/amazondynamodb/latest/APIReference/API_UpdateTable.html)\n\n> 下一篇我们将要结束DynamoDB 最常用的部分，**项目的基本操作（CRUD）**。\n\n[原文链接](http://mp.weixin.qq.com/s?__biz=MzAwNjI5MjAzNw==&mid=2655751935&idx=3&sn=7dac29e441ebaabfbf70600fee042bd3&chksm=80b0b9d5b7c730c390dd96fc1c4853219fd8d39a634506081631b41e147faaee38f0e8d35730#rd)\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "Amazon DynamoDB 入门3： 表的基本操作",
        "date": "2017-01-14 10:13:42",
        "tags": [
          "AWS",
          "nosql",
          "DynamoDB",
          "python",
          "database"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "Amazon-DynamoDB-table-operator"
    },
    {
      "content": "\n\n## Amazon DynamoDB 入门2： 工作原理、API和数据类型介绍\n\n:::tip\n本节主要介绍DynamoDB 基本概念、核心组件、数据结构、Api\n:::\n\n\n\n## DynamoDB 基本概念\n\nDynamoDB 是 AWS 独有的完全托管的 NoSQL Database。它的思想来源于 Amazon 2007 年发表的一篇论文：Dynamo: Amazon’s Highly Available Key-value Store。在这篇论文里，Amazon 介绍了如何使用 Commodity Hardware 来打造高可用、高弹性的数据存储。想要理解 DynamoDB，首先要理解 Consistent Hashing。Consistent Hashing 的原理如下图所示：\n![](http://note.youdao.com/yws/public/resource/b99dcbe9b4a2069a3337badbeafe4b29/xmlnote/WEBRESOURCEb477b81f1e511ee919b14f3393326749/470)\n\nHUGOMORE42\n\n它的概念是：\n\n1. 我有一个足够大的Keyspace（2的160次方，比较一下：IPv6是2的128次方），我们记作X。\n2. 然后将X放在一个环形的空间里划分成大小相等的Y个 Partition，依次循环排列（如图），每个 Partition 由一个Vnode（Riak的概念）管理，\n3. 当你有M个Database Server（Node），Y个Vnode再平均映射到M个Node上。\n4. 当数据要插入时，将其主键（Hash Key）映射到K中的一个地址（Addr），对应到某个Vnode，再进一步对应到某个Node，如果这个数据需要N个Replica，则将数据写入Addr（Vnode a），Addr + 1（Vnode b）， …，Add + N（Vnode n）。\n5. 这里，M就是你的Shards，N是Replica。\n\n以后添加新的Node时，映射发生变化，只需要把相应的变化了的Vnode迁移到新的Node上即可。在这种结构下，Sharding/Replica对程序员基本上是透明的。\n\n\n## DynamoDB 核心组件\n\n基本 DynamoDB 组件包括：表、项目、属性\n\n* 表 - 类似于其他数据库系统，DynamoDB将数据存储在表中。表是数据的集合。（类似于关系型数据库中的表）\n* 项目 - 每个表包含多个项目。项目是一组属性，具有不同于所有其他项目的唯一标识。（类似于其他数据库系统中的行、记录或元组。）\n* 属性 - 每个项目包含一个或多个属性。属性是基础的数据元素，无需进一步分解。（类似于其他数据库系统中的字段或列。）\n\n下图是一个名为 People 的表，其中显示了一些示例项目和属性：\n\n![image](http://note.youdao.com/yws/public/resource/b99dcbe9b4a2069a3337badbeafe4b29/xmlnote/WEBRESOURCEe0de7341429c0ba6408f2a3b1a60d214/100)\n\n请注意有关 People 表的以下内容：\n\n* 表中的每个项目都有一个唯一的标识符或主键，用于将项目与表中的所有其他内容区分开来。在 People 表中，主键包含一个属性 (PersonID)。\n* 与主键外不同，People表是无架构的，这表示属性及其数据类型都不需要预先定义。每个项目都能拥有其自己的独特属性。\n* 大多数属性是标量类型的，这表示它们只能具有一个值。字符串和数字是标量的常见示例。\n* 某些项目具有嵌套属性 (Address)。DynamoDB 支持最高 32级深度的嵌套属性。\n\n这里，我们将看到第一个概念：主键。\n\n### 主键\n\n创建表时，除表名称外，您还必须指定表的主键。主键唯一标识表中的每个项目，因此，任意两个项目的主键都不相同。\nDynamoDB 支持两种不同类型的主键：\n\n* 分区键 - 简单的主键，由一个称为分区键的属性组成。\n\n> 如果表具有简单主键（只有分区键），DynamoDB 将根据其分区键值存储和检索各个项目。同时，DynamoDB 使用分区键的值作为内部哈希函数的输入值，从而将项目写入表中。哈希函数的输出值决定了项目将要存储在哪个分区。\n要从表中读取某个项目，必须为该项目指定分区键值。DynamoDB 使用此值作为其哈希函数的输入值，从而生成可从中找到该项目的分区。**（此时，分区键必须是唯一的，不可重复。）**\n\n下图显示了名为 Pets 的表，该表跨多个分区。表的主键为 AnimalType（仅显示此键属性）。在这种情况下，DynamoDB 会根据字符串 Dog 的哈希值，使用其哈希函数决定新项目的存储位置。请注意，项目并非按排序顺序存储的。每个项目的位置由其分区键的哈希值决定。\n\n![简单分区示例](http://note.youdao.com/yws/public/resource/49e3721094381363857f5112db30fa65/xmlnote/WEBRESOURCE26a15082f1205bda684be3d5b68f5058/329)\n\n* 分区键和排序键 - 称为复合主键，此类型的键由两个属性组成。第一个属性是分区键，第二个属性是排序键。\n\n> DynamoDB 使用分区键值作为对内部哈希函数的输入。来自哈希函数的输出决定了项目将存储到的分区（DynamoDB 内部的物理存储）。具有相同分区键的所有项目按排序键值的排序顺序存储在一起。两个项目可具有相同的分区键值，**但这两个项目必须具有不同的排序键值。**\n\n为将某个项目写入表中，DynamoDB 会计算分区键的哈希值以确定该项目的存储分区。在该分区中，可能有几个具有相同分区键值的项目，因此 DynamoDB 会按排序键的升序将该项目存储在其他项目中。\n\n要读取表中的某个项目，您必须为该项目指定分区键值和排序键值。DynamoDB 会计算分区键的哈希值，从而生成可从中找到该项目的分区。\n\n如果我们查询的项目具有相同的分区键值，则可以通过单一操作 (Query) 读取表中的多个项目。DynamoDB 将返回具有该分区键值的所有项目。或者，也可以对排序键应用某个条件，以便它仅返回特定值范围内的项目。\n\n假设 Pets 表具有由 AnimalType（分区键）和 Name（排序键）构成的复合主键。\n\n下图显示了 DynamoDB 写入项目的过程，分区键值为 Dog、排序键值为 Fido。\n\n![](http://note.youdao.com/yws/public/resource/49e3721094381363857f5112db30fa65/xmlnote/WEBRESOURCE264adc571f86df9053404818d240230f/337)\n\n> * 为读取 Pets 表中的同一项目，DynamoDB 会计算 Dog 的哈希值，从而生成这些项目的存储分区。然后，DynamoDB 会扫描这些排序键属性值，直至找到 Fido。\n> * 要读取 AnimalType 为 Dog 的所有项目，您可以执行 Query 操作，无需指定排序键条件。默认情况下，这些项目会按存储顺序（即按排序键的升序）返回。或者，您也可以请求以降序返回。\n> * 要仅查询某些 Dog 项目，您可以对排序键应用条件（例如，仅限 Name 在 A 至 K 范围内的 Dog 项目）。\n\n\n#### Note\n* 每个主键属性必须为标量（表示它只能具有一个值）。主键属性唯一允许的数据类型是字符串、数字和二进制。对于其他非键属性没有任何此类限制。\n* DynamoDB 会自动分配足够的存储，每个分区键值的非重复排序键值无数量上限。所以即使需要在 Dog 表中存储数十亿 Pets项目，DynamoDB 也能这一需求。\n\n### 二级索引\n\nDynamoDB支持在一个表上创建一个或多个二级索引。利用 secondary index，除了可对主键进行查询外，还可使用替代键查询表中的数据。\n\nDynamoDB 支持两种索引：\n\n* Global secondary index - 一种带有可能与表中不同的分区键和排序键的索引。\n* Local secondary index - 一种分区键与表中的相同但排序键与表中的不同的索引。\n\n**最多可以为每个表定义 5 个全局二级索引和 5 个本地二级索引。**\n\n下图显示了示例 Music 表，该表包含一个名为 GenreAlbumTitle 的新索引\n\n![image](http://note.youdao.com/yws/public/resource/b99dcbe9b4a2069a3337badbeafe4b29/xmlnote/WEBRESOURCE829a617865ac76c1bb9a564e5789079d/125)\n\n对于Music表，我们不仅可以按 Artist（分区键）或按 Artist 和 SongTitle（分区键和排序键）查询数据项。还可以按 Genre 和 AlbumTitle 查询数据。\n\n#### Note\n\n请注意有关 GenreAlbumTitle 索引的以下内容：\n\n* 每个索引属于一个表（称为索引的基表）。在上述示例中，Music 是 GenreAlbumTitle 索引的基表。\n* DynamoDB 将自动维护索引。当添加、更新或删除基表中的某个项目时，DynamoDB 会添加、更新或删除属于该表的任何索引中的对应项目。\n* 当创建索引时，可指定哪些属性将从基表复制或投影到索引。DynamoDB 至少会将键属性从基表投影到索引中。对于 GenreAlbumTitle 也是如此，只不过此时只有 Music 表中的键属性会投影到索引中。\n\n## DynamoDB 数据类型\n\nDynamoDB 对表中的属性支持很多不同的数据类型。可按以下方式为属性分类：\n\n* 标量类型 - 标量类型可准确地表示一个值。标量类型包括**数字、字符串、二进制、布尔值和 null。**\n* 文档类型 - 文档类型可表示具有嵌套属性的复杂结构。文档类型包括列表和映射。\n* 集类型 - 集类型可表示多个标量值。集类型包括字符串集、数字集和二进制集。\n\n**当创建表或secondary index时，必须指定每个主键属性（分区键和排序键）的名称和数据类型。此外，每个主键属性必须定义为字符串、数字或二进制类型。**\n\n### 标量类型\n\n标量类型包括数字、字符串、二进制、布尔值和 null。\n\n数据类型 | 说明 | 示例\n---|---|---\n字符串 |  字符串是使用 UTF-8 二进制编码的 Unicode。字符串的长度必须大于零且受限于最大 DynamoDB 项目大小 400 KB。| \"Bicycle\"\n数字   | 数字可为正数、负数或零。数字最多可精确到 38 位 - 超过此位数将导致意外 | 300\n二进制 | 二进制类型属性可以存储任意二进制数据，如压缩文本、加密数据或图像。DynamoDB 会在比较二进制值时将二进制数据的每个字节视为无符号。二进制属性的长度必须大于零且受限于最大 DynamoDB 项目大小 400 KB。| 这是一个采用 Base64 编码文本的二进制属性： dGhpcyB0ZXh0IGlzIGJhc2U2NC1lbmNvZGVk\n布尔值 | 布尔类型属性可以存储 true 或 false。| true\n空     | 空代表属性具有未知或未定义状态。    | NULL\n\n### 字符串\n\n如果将主键属性定义为字符串类型属性，以下附加限制将适用：\n* 对于简单的主键，第一个属性值（分区键）的最大长度为 2048 字节。\n* 对于复合主键，第二个属性值（排序键）的最大长度为 1024 字节\n\n> DynamoDB 使用基础的 UTF-8 字符串编码字节整理和比较字符串。例如，“a”(0x61) 大于“A”(0x41)，“¿”(0xC2BF) 大于“z”(0x7A)。\n\n可使用字符串数据类型表示日期或时间戳。执行此操作的一种方法是使用 ISO 8601 字符串，如以下示例所示：\n\n* 2016-02-15\n* 2015-12-21T17:42:34Z\n* 20150311T122706Z\n\n**也可以使用数字数据类型表示日期或时间戳**\n\n### 数字\n\n数字范围\n\n* 正数范围：1E-130 到 9.9999999999999999999999999999999999999E+125\n* 负数范围：-9.9999999999999999999999999999999999999E+125 到 -1E-130\n\n> 在 DynamoDB 中，数字以可变长度形式表示。系统会删减开头和结尾的 0。\n\n所有数字将作为字符串通过网络发送到 DynamoDB，以最大程度地提高不同语言和库之间的兼容性。但是，DynamoDB 会将它们视为数字类型属性以方便数学运算。\n\n**Note**\n\n如果数字精度十分重要，则应使用从数字类型转换的字符串将数字传递给 DynamoDB。\n\n### 二进制\n\n如果将主键属性定义为二进制类型属性，以下附加限制将适用：\n\n* 对于简单的主键，第一个属性值（分区键）的最大长度为 2048 字节。\n* 对于复合主键，第二个属性值（排序键）的最大长度为 1024 字节。\n\n> 在将二进制值发送到 DynamoDB 之前，我们必须采用 Base64 编码格式对其进行编码。收到这些值后，DynamoDB 会将数据解码为无符号字节数组，将其用作二进制属性的长度。\n\n### 文档类型\n\n文档类型包括列表和映射。这些数据类型可以互相嵌套，用来表示深度最多为 32 层的复杂数据结构。\n只要包含值的项目大小在 DynamoDB **项目大小限制 (400 KB) 内**，列表或映射中值的数量就没有限制。\n\n数据类型| 说明 | 示例\n---|---|---\n列表 | 列表类型属性可存储值的有序集合。列表用方括号括起：[ ... ]。列表类似于 JSON 数组。列表元素中可以存储的数据类型没有限制，列表元素中的元素也不一定为相同类型。| FavoriteThings: [\"Cookies\", \"Coffee\", 3.14159]\n映射 | 映射类型属性可以存储名称/值对的无序集合。映射用大括号括起：{ ... }。映射类似于 JSON 对象。映射元素中可以存储的数据类型没有限制，映射中的元素也不一定为相同类型。|示例如下\n\n```\n{\n    Day: \"Monday\",\n    UnreadEmails: 42,\n    ItemsOnMyDesk: [\n        \"Coffee Cup\",\n        \"Telephone\",\n        {\n            Pens: { Quantity : 3},\n            Pencils: { Quantity : 2},\n            Erasers: { Quantity : 1}\n        }\n    ]\n}\n```\n\n#### Note\n\n> DynamoDB 让您可以使用映射/列表中的单个元素\n\n### 集\n\nDynamoDB 支持表示数字、字符串或二进制值集的类型。集中的所有元素必须为相同类型（\n\n集中的每个值必须是唯一的。集中的值的顺序不会保留。不支持空集。\n\n**Example （字符串集、数字集和二进制集）**\n\n```\n# 必须是相同的数据类型\n# 字符串集\n[\"Black\", \"Green\" ,\"Red\"]\n# 数字集\n[42.2, -19, 7.5, 3.14]\n# 二进制集\n[\"U3Vubnk=\", \"UmFpbnk=\", \"U25vd3k=\"]\n```\n\n## DynamoDB API\n\nDynamoDB 的api操作主要用于控制层面、数据层面和DynamoDB Streams。\n\n### 控制层面\n\n控制层面 操作可让我们可以创建和管理DynamoDB表。它们还可让我们可以使用依赖于表的索引、流和其他对象。\n\n* CreateTable - 创建新表。或者，也可以创建一个或多个二级索引并为表启用 DynamoDB Streams。\n* DescribeTable - 返回有关表的信息，例如，表的主键架构、吞吐量设置、索引信息等。\n* ListTables - 返回列表中所有表的名称。\n* UpdateTable - 修改表或其索引的设置、创建或删除表上的新索引或修改表的 DynamoDB Streams 设置。\n* DeleteTable - 从 DynamoDB 中删除表及其所有依赖对象。\n\n### 数据层面\n\n**数据层面**操作可让我们对表中的数据执行创建、读取、更新和删除（也称为 CRUD）操作。某些数据层面操作还可让我们可以从secondary index中读取数据。\n\n#### 创建数据\n\n* PutItem - 将单个项目写入到表中。您必须指定主键属性，但不必指定其他属性。\n* BatchWriteItem - 将最多 25 个项目写入到表中。\n\n#### 读取数据\n\n* GetItem - 从表中检索单个项目。我们必须为所需的项目指定主键。我们可以检索整个项目，也可以仅检索其属性的子集。\n* BatchGetItem - 从一个或多个表中检索最多 100 个项目。\n* Query - 检索具有特定分区键的所有项目。我们必须指定分区键值。\n\n  > 可以检索整个项目，也可以仅检索其属性的子集。或者，也可以对排序键值应用条件，以便只检索具有相同分区键的数据子集。我们可以对表使用此操作，前提是该表同时具有分区键和排序键。还可以对索引使用此操作，前提是该索引同时具有分区键和排序键。\n\n* Scan - 检索指定表或索引中的所有项目。我们可以检索整个项目，也可以仅检索其属性的子集。或者，我们也可以应用筛选条件以仅返回感兴趣的值并放弃剩余的值。\n\n\n#### 更新数据\n\n* UpdateItem - 修改项目中的一个或多个属性。必须为要修改的项目指定主键。\n\n  > 可以添加新属性以及修改或删除现有属性。还可以执行有条件更新。也可以实施一个原子计数器，该计数器可在不干预其他写入请求的情况下递增或递减数字属性。\n\n#### 删除数据\n\n* DeleteItem - 从表中删除单个项目。您必须为要删除的项目指定主键。\n* BatchWriteItem - 从一个或多个表中删除最多 25 个项目\n\n#### Note\n> Batch 操作比调用多次单个请求（DeleteItem, GetItem, PutItem)更有效，因为秩序一个网络请求即可操作多个项目。\n\n### DynamoDB Streams\n\nDynamoDB Streams 操作可对表启用或禁用流，并能允许对包含在流中的数据修改记录的访问。\n\n* ListStreams - 返回所有流的列表，或仅返回特定表的流。\n* DescribeStream - 返回有关流的信息，例如，流的 Amazon 资源名称 (ARN) 和您的应用程序可开始读取前几条流记录的位置。\n* GetShardIterator - 返回一个分区迭代器，这是我们的应用程序用来从流中检索记录的数据结构。\n* GetRecords - 使用给定分区迭代器检索一条或多条流记录。\n\n\n## 命名规则\n\nDynamoDB 中的表、属性和其他对象必须具有名称。名称应该简明扼要 - 例如，Products、Books 和 Authors 之类的名称是都是不言而喻的。\n\n下面是 DynamoDB 的命名规则：\n\n* 所有名称都必须使用 UTF-8 进行编码，并且区分大小写。\n* 表名称和索引名称的长度必须介于 3 到 255 个字符之间，而且只能包含以下字符：\n    - a-z\n    - A-Z\n    - 0-9\n    - _（下划线）\n    - -（短划线）\n    - .（圆点）\n* 属性名称的长度必须介于 1 到 255 个字符之间。\n\n\n### 保留关键字和特殊字符\n\n与很多其他数据库管理系统相似，DynamoDB 也具有一系列保留关键字和特殊字符。\n\n* 有关 DynamoDB 中的保留关键字的完整列表，请参阅 [DynamoDB 中的保留关键字](http://docs.aws.amazon.com/zh_cn/amazondynamodb/latest/developerguide/ReservedWords.html)。\n* #（哈希）和 :（冒号）在 DynamoDB 中具有特殊含义\n\nDynamoDB允许使用这些关键字和特殊符号用于命名，但我们不建议这么做\n\n有关更多信息，请参阅 [为属性名称和值使用占位符](http://docs.aws.amazon.com/zh_cn/amazondynamodb/latest/developerguide/ExpressionPlaceholders.html)。\n\n\n## 读取一致性\n\nAmazon DynamoDB 在全世界多个 AWS 区域可用。每个区域均与其他 AWS 区域完全独立和隔离。\n\n例如，如果我们在 us-east-1 区域有一个名为 People 的表，并在 us-west-2 区域有另一个名为 People 的表，则这两个表将被视为完全独立的表。\n\n每个 AWS 区域包含多个不同的称为“可用区”的位置。每个可用区都被设计成不受其他可用区故障的影响，并提供低价、低延迟的网络连接，以连接到同一区域其他可用区。此设计可保证我们可以在某个区域的多个可用区中快速复制数据。\n\n当我们将某个数据写入 DynamoDB 表并收到 HTTP 200 响应 (OK) 时，该数据的所有副本都会更新。但是，要将数据传播到当前 AWS 区域内的所有存储位置需要耗费一定的时间。该数据最终将在上述所有存储位置中保持一致，通常只需一秒或更短时间。\n\n为了支持各种应用程序要求，DynamoDB 同时支持**最终一致性** **读取和强一致性** 读取。\n\n#### 最终一致性读取\n\n当我们从 DynamoDB 表中读取数据时，返回的可能不是刚刚完成的写入操作的结果。响应可能包含某些旧的数据。但是，如果我们在短时间后重复读取请求，响应将返回最新的数据。\n\n#### 强一致性读取\n\n当我们请求强一致性读取时，DynamoDB 会返回具有最新数据的响应，从而反映来自所有已成功的之前写入操作的更新。但是，**如果网络延迟或中断，可能会无法执行强一致性读取**。\n\n##### Note\n\nDynamoDB 默认使用最终一致性读取。读取操作（例如 GetItem、Query 和 Scan）提供了一个 ConsistentRead 参数：此参数设置为 true，DynamoDB 将在操作过程中使用强一致性读取。\n\n示例：\n\n```\n{\n    TableName: \"Music\",\n    Key: {\n        \"Artist\": \"No One You Know\",\n        \"SongTitle\": \"Call Me Today\"\n    },\n    ConsistentRead: true\n}\n```\n\n#### python 示例\n\n```\ntable = db3.Table('Music')\nresponse = table.get_item(\n    Key={\n        \"Artist\": \"The Acme Band\",\n        \"SongTitle\": \"Still In Love\"\n    },\n    ConsistentRead=True\n)\n```\n\n[原文链接](http://mp.weixin.qq.com/s?__biz=MzAwNjI5MjAzNw==&mid=2655751935&idx=2&sn=23943243c2f5a5a1efdff4fb5308e8ab&chksm=80b0b9d5b7c730c3e7d1115665d63cb47c79ad514a070de205ade4312048598f3c05b0067caa#rd)\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "Amazon DynamoDB 入门2： 工作原理、API和数据类型介绍",
        "date": "2017-01-09 14:37:11",
        "tags": [
          "AWS",
          "nosql",
          "DynamoDB",
          "python",
          "database"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "Amazon-DynamoDB-how-it-works"
    },
    {
      "content": "\n### 本节主要介绍AmazonDynamoDB 安装配置及Python开发示例\"\n\n## 什么是 Amazon DynamoDB\nAmazon DynamoDB 是一种完全托管的 NoSQL 数据库服务，提供快速而可预测的性能，能够实现无缝扩展。使用 DynamoDB，您可以免除操作和扩展分布式数据库的管理工作负担，因而无需担心硬件预置、设置和配置、复制、软件修补或集群扩展等问题。\n\n使用 DynamoDB，您可以创建数据库表来存储和检索任意量级的数据，并提供任意级别的请求流量。您可以扩展或缩减您的表的吞吐容量，而不会导致停机或性能下降，还可以使用 AWS 管理控制台来监控资源使用情况和各种性能指标。\n\nHUGOMORE42\n\n## Amazon DynamoDB 特点\n\nDynamoDB 会自动将数据和流量分散到足够数量的服务器上，以满足吞吐量和存储需求，同时保持始终如一的高性能。所有数据均存储在固态硬盘 (SSD) 中，并会自动复制到 AWS 区域中的多个可用区中，从而提供内置的高可用性和数据持久性。\n\nDynamoDB 是 NoSQL 数据库并且无架构，这意味着，与主键属性不同，无需在创建表时定义任何属性或数据类型。与此相对，关系数据库要求在创建表时定义每个列的名称和数据类型。\n\n## Amazon DynamoDB 使用\n\n### AWS 配置\n\n1. 注册 Amazon Web Services 并创建访问密钥\n2. 创建 AWS 凭证文件\n3. 开启DynamoDB 服务\n\n### 在计算机上运行 DynamoDB\n\n除了 Amazon DynamoDB Web 服务之外，AWS 还提供可本地运行的可下载版本的 DynamoDB。\n使用本地版本，在开发应用程序时无需 Internet 连接。\n\n#### 方法1 直接在计算机上安装\n\n> 需要安装java环境\n\n1. 下载 DynamoDB\n2. 解压，并将解压后的目录复制到某个位置\n3. 打开命令提示符窗口，打开 DynamoDBLocal.jar 的目录，并输入以下命令：\n\n```\njava -Djava.library.path=./DynamoDBLocal_lib -jar DynamoDBLocal.jar -sharedDb\n```\n\n现在就可以使用了\n\n**命令行选项**\n\nDynamoDB 接受以下命令参数：\n\n* -cors value - 启用适用于 JavaScript 的 CORS 支持（跨源资源共享）。您必须提供特定域的逗号分隔“允许”列表。-cors 的默认设置是星号 (*)，这将允许公开访问。\n* -dbPath value - DynamoDB 将用于写入其数据库文件的目录。如果不指定此选项，则文件将写入当前目录。请注意，不能同时指定 -dbPath 和 -inMemory。\n* -delayTransientStatuses - 使 DynamoDB 为某些操作引入延迟。DynamoDB 几乎可以即时执行某些任务，例如，对表和索引执行创建/更新/删除操作；但是，实际 DynamoDB 服务需要更多时间才能完成这些任务。设置此参数有助于 DynamoDB 更逼真地模拟 Amazon DynamoDB Web 服务的行为。（目前，此参数仅为处于 CREATING 或 DELETING 状态的global secondary index引入延迟。）\n* -help – 打印使用摘要和选项。\n* -inMemory – DynamoDB 将在内存中运行，而不使用数据库文件。停止 DynamoDB 时，不会保存任何数据。请注意，不能同时指定 -dbPath 和 -inMemory。\n* -optimizeDbBeforeStartup – 在计算机上启动 DynamoDB 之前优化底层数据库表。使用此参数时，必须还要指定 -dbPath。\n* -port value - DynamoDB 将用于与应用程序通信的端口号。如果不指定此选项，则默认端口是 8000\n* -sharedDb - DynamoDB 将使用单个数据库文件，而不是针对每个证书和区域使用不同的文件。如果指定 -sharedDb，那么所有 DynamoDB 客户端都将与同一组表交互，无论其区域和证书配置如何。\n\n[详细配置可参考官方文档](http://docs.aws.amazon.com/zh_cn/amazondynamodb/latest/developerguide/DynamoDBLocal.html?shortFooter=true)\n\n#### 方法2 使用docker安装\n\n> 需要安装docker\n\n方法一需要我们手动配置，操作也麻烦，如果喜欢docker，可以直接使用docker快速搭建本地环境\n\n```\n1. 下载镜像\n\ndocker pull ryanratcliff/dynamodb\n\n2. 启动\n\ndocker run -d -p 8000:8000 ryanratcliff/dynamodb\n\n```\n\n[详细配置可参考](https://github.com/RyanRatcliff/docker_dynamodb)\n\n\n### Python 使用 DynamoDB\n\n我们可以使用适用于 Python (Boto 3) 的 AWS 开发工具包进行开发。\n\n1. 安装boto3\n\n```\npip install boto3\n```\n\n2. 使用 AWS CLI 配置秘钥\n\n```\n# 安装awscli\nsudo pip install awscli\n# 测试awscli 安装\naws help\n# 输入命令\naws configure\n# 配置 Access Key ID 和 Secret Access Key\n\nAWS Access Key ID [None]: AKIAIOSFODNN7EXAMPLE\nAWS Secret Access Key [None]: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY\nDefault region name [None]: us-west-2\nDefault output format [None]: ENTER\n# 要更新任何设置，只需再次运行 aws configure 并根据需要输入新值。\n```\n\nCLI 将使用 aws configure 指定的证书存储在您主目录中名为 .aws 的文件夹中名为 credentials 的本地文件中\n可以使用 以下命令列出 .aws 文件夹内容：\nLinux, OS X, or Unix\n```\n$ ls  ~/.aws\n```\n[具体配置参考官方文档](http://docs.aws.amazon.com/zh_cn/cli/latest/userguide/cli-chap-getting-started.html?shortFooter=true)\n\n\n3. 使用以下代码测试 DynamoDB 是否可用\n\n```\nimport boto3\ndb3 = boto3.resource('dynamodb', endpoint_url='http://localhost:8000', aws_secret_access_key='ticTacToeSampleApp', aws_access_key_id='ticTacToeSampleApp', region_name='us-west-2')\n\ndb3.meta.client.list_tables()\n\n# output\n\n{\n\t'ResponseMetadata': {\n\t    'HTTPHeaders': {\n\t    \t'content-length': '32',\n            'content-type': 'application/x-amz-json-1.0',\n            'server': 'Jetty(8.1.12.v20130726)',\n            'x-amz-crc32': '2024476575',\n            'x-amzn-requestid': '5f0a974a-8900-470d-8b28-a4207247c65e'\n\t    },\n        'HTTPStatusCode': 200,\n        'RequestId': '5f0a974a-8900-470d-8b28-a4207247c65e',\n        'RetryAttempts': 0\n\t},\n    'TableNames': []\n}\n\n```\n\n如果输出以上内容，则说明DynamoDB 正常。\n\n[原文链接](http://mp.weixin.qq.com/s?__biz=MzAwNjI5MjAzNw==&mid=2655751935&idx=1&sn=21e6b4ebe22a18b65c6f5e7b457782f9&chksm=80b0b9d5b7c730c308ef87f324b814d9bdfd573bfdfc68c4c3b9e9f014f68b2bb19d87cdc06b#rd)\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "Amazon DynamoDB 入门1：配置（本地）及python示例",
        "date": "2017-01-07 14:57:39",
        "tags": [
          "AWS",
          "nosql",
          "DynamoDB",
          "python",
          "database"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "Amazon-DynamoDB-install-and-setting"
    },
    {
      "content": "\n# 从表中删除数据\n\n> 上一篇介绍了DynamoDB 的更新，这一篇将会介绍项目删除操作和dynamoab-py\n\n\n在 SQL 中，DELETE 语句从表中删除一个或多个行。*DynamoDB 使用 DeleteItem 操作一次删除一个项目。*\n\n### SQL\n\n在 SQL 中，可使用 DELETE 语句删除一个或多个行。WHERE 子句确定要修改的行。示例如下：\n\nDELETE FROM Music\nWHERE Artist = 'The Acme Band' AND SongTitle = 'Look Out, World';\n我们可以修改 WHERE 子句以删除多个行。例如，删除某个特殊艺术家的所有歌曲，如下所示：\n\nDELETE FROM Music WHERE Artist = 'The Acme Band'\n\n#### Note\n如果省略 WHERE 子句，则数据库会尝试从表中删除所有行。\n\n### DynamoDB\n\n在 DynamoDB 中，可使用 DeleteItem 操作修改单个项目。\n\n(http://docs.aws.amazon.com/zh_cn/amazondynamodb/latest/APIReference/API_DeleteItem.html?shortFooter=true)[API 语法如下]：\n\n```json\n{\n   \"ConditionExpression\": \"string\",\n   \"ExpressionAttributeNames\": {\n      \"string\" : \"string\"\n   },\n   \"ExpressionAttributeValues\": {\n      \"string\" : {\n         \"B\": blob,\n         \"BOOL\": boolean,\n         \"BS\": [ blob ],\n         \"L\": [\n            \"AttributeValue\"\n         ],\n         \"M\": {\n            \"string\" : \"AttributeValue\"\n         },\n         \"N\": \"string\",\n         \"NS\": [ \"string\" ],\n         \"NULL\": boolean,\n         \"S\": \"string\",\n         \"SS\": [ \"string\" ]\n      }\n   },\n   \"Key\": {\n      \"string\" : {\n         \"B\": blob,\n         \"BOOL\": boolean,\n         \"BS\": [ blob ],\n         \"L\": [\n            \"AttributeValue\"\n         ],\n         \"M\": {\n            \"string\" : \"AttributeValue\"\n         },\n         \"N\": \"string\",\n         \"NS\": [ \"string\" ],\n         \"NULL\": boolean,\n         \"S\": \"string\",\n         \"SS\": [ \"string\" ]\n      }\n   },\n   \"ReturnConsumedCapacity\": \"string\",\n   \"ReturnItemCollectionMetrics\": \"string\",\n   \"ReturnValues\": \"string\",\n   \"TableName\": \"string\"\n}\n```\n\n参数说明：\n\n- Key: 主键，用于定位项目\n- TableName：表名 （最小 3. 最大 255）\n- ConditionExpression：条件表达式（仅在特定 ConditionExpression 的计算结果为 true 时成功完成）\n- ExpressionAttributeNames：条件表达式的名称的别名，比如 date 为保留字，可用别名定义为 #d\n- ExpressionAttributeValues：条件表达式的值\n- ReturnConsumedCapacity：显示使用的写入容量单位数\n    - TOTAL 会返回由表及其所有global secondary index占用的写入容量；\n    - INDEXES 仅返回由global secondary index占用的写入容量；\n    - NONE 表示您不需要返回任何占用容量统计数据。\n- ReturnValues: 更新后返回的数据.\n    - NONE - 如果没有特别说明，返回None (这个是默认值)\n    - ALL_OLD - 按在进行更新之前的情况，返回整个项目。\n- ReturnItemCollectionMetrics： Determines whether item collection metrics are returned. If set to SIZE , the response includes statistics about item collections, if any, that were modified during the operation are returned in the response. If set to NONE (the default), no statistics are returned.\n\n(http://boto3.readthedocs.io/en/stable/reference/services/dynamodb.html?highlight=dynamodb#DynamoDB.Table.delete_item)[boto3语法如下]\n\n```python\nresponse = table.delete_item(\n    Key={\n        'string': 'string'|123|Binary(b'bytes')|True|None|set(['string'])|set([123])|set([Binary(b'bytes')])|[]|{}\n    },\n    ConditionalOperator='AND'|'OR',\n    ReturnValues='NONE'|'ALL_OLD'|'UPDATED_OLD'|'ALL_NEW'|'UPDATED_NEW',\n    ReturnConsumedCapacity='INDEXES'|'TOTAL'|'NONE',\n    ReturnItemCollectionMetrics='SIZE'|'NONE',\n    ConditionExpression=Attr('myattribute').eq('myvalue'),\n    ExpressionAttributeNames={\n        'string': 'string'\n    },\n    ExpressionAttributeValues={\n        'string': 'string'|123|Binary(b'bytes')|True|None|set(['string'])|set([123])|set([Binary(b'bytes')])|[]|{}\n    }\n)\n```\n\n在 DynamoDB 中，可使用 DeleteItem 操作从表中删除数据（一次删除一个项目）。必须指定项目的主键值。示例如下：\n\n```python\n{\n    TableName: \"Music\",\n    Key: {\n        Artist: \"The Acme Band\",\n        SongTitle: \"Look Out, World\"\n    }\n}\n```\n\n#### Note\n\n除了 DeleteItem 之外，Amazon DynamoDB 还支持同时删除多个项目的 BatchWriteItem 操作。\n\nDeleteItem 支持条件写入，在此情况下，操作仅在特定 ConditionExpression 的计算结果为 true 时成功完成。例如，以下 DeleteItem 操作仅在项目具有 RecordLabel 属性时删除项目：\n\n```python\n{\n    TableName: \"Music\",\n    Key: {\n        Artist: \"The Acme Band\",\n        SongTitle: \"Look Out, World\"\n    },\n   ConditionExpression: \"attribute_exists(RecordLabel)\"\n}\n```\n\n删除操作就这么简单，下边是福利时间。\n\n是不是每次用boto3 操作DynamoDB 都有种痛不欲生的感觉，下边我们介绍一个新工具。\n\n### [dynamodb-py](https://github.com/gusibi/dynamodb-p)\n\ndynamodb-py  是模仿sqlalchemy 编写的DynamoDB ORM 它的使用方法特别简单，下边来看几个示例：\n\n##### 表的操作\n\n```python\nfrom dynamodb.model import Model\nfrom dynamodb.fields import CharField, IntegerField, FloatField, DictField\nfrom dynamodb.table import Table\n\nclass Movies(Model):\n\n    __table_name__ = 'Movies'\n\n    ReadCapacityUnits = 10\n    WriteCapacityUnits = 10\n\n    year = IntegerField(name='year', hash_key=True)\n    title = CharField(name='title', range_key=True)\n    rating = FloatField(name='rating', indexed=True)\n    rank = IntegerField(name='rank', indexed=True)\n    release_date = CharField(name='release_date')\n    info = DictField(name='info', default={})\n\n# create_table\nTable(Movies()).create()\n\n# update_table\nTable(Movies()).update()\n\n# delete_table\nTable(Movies()).delete()\n\n```\n\n##### 查询项目\n\n```python\n# query without index\nitems = Movies.query().where(Movies.year.eq(year)).all()\nitems = Movies.query().where(Movies.year.eq(1985)).limit(10).all()\nitems = (Movies.query()\n        .where(Movies.year.eq(1992),\n               Movies.title.between('A', 'L'))\n        .all())\n\n# query with index\nitems = (Movies.query()\n        .where(Movies.year.eq(1992),\n               Movies.title.between('A', 'L'))\n        .order_by(Movies.rating, asc=False)\n        .all())\n```\n\n##### 更新项目\n\n\n```python\nitem = Movies.get(year=year, title=title)\n\nitem.update(rank=2467, rating=7.1)\n```\n\n##### 删除项目\n\n```python\nitem = Movies.get(year=year, title=title)\n\nitem.delete()\n```\n\n就是这么方便。\n\n不过[dynamodb-py](https://github.com/gusibi/dynamodb-p) 还在开发中，欢迎试用，也欢迎贡献自己的力量。\n\n> 终于，下一节介绍索引的查询\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "Amazon DynamoDB 入门8：删除项目",
        "date": "2017-01-03 14:37:11",
        "tags": [
          "AWS",
          "nosql",
          "DynamoDB",
          "python",
          "database"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "Amazon-DynamoDB-Delete-Item"
    },
    {
      "content": "\n## 控制流\n\n上一篇我们了解了golang 的变量、函数和基本类型，这一篇将介绍一下控制流\n\n现在我们看一个复杂点的例子:\n\nHUGOMORE42\n\n### fibonacci(递归版)\n\n```go\n    01 package main\n    02\n    03 import \"fmt\"\n    04\n    05 func main() {\n    06     result := 0\n    07     for i := 0; i <= 10; i++ {\n    08\t     result = fibonacci(i)\n    09\t     fmt.Printf(\"fibonacci(%d) is: %d\\n\", i, result)\n    10\t  }\n    11 }\n    12\n    13 func fibonacci(n int) (res int) {\n    14     if n <= 1 {\n    15         res = 1\n    16 \t   } else {\n    17 \t       res = fibonacci(n-1) + fibonacci(n-2)\n    18 \t   }\n    19 \treturn\n    20 }\n\n    // outputs\n\n    fibonacci(0) is: 1\n    fibonacci(1) is: 1\n    fibonacci(2) is: 2\n    fibonacci(3) is: 3\n    fibonacci(4) is: 5\n    fibonacci(5) is: 8\n    fibonacci(6) is: 13\n    fibonacci(7) is: 21\n    fibonacci(8) is: 34\n    fibonacci(9) is: 55\n    fibonacci(10) is: 89\n```\n\n\n* for i := 0; i <= 10; i++ {} 第7行是一个循环结构 这里for 循环是一个控制流\n\n### 控制流\n#### For\n\nGo 只有一种循环接口-- for 循环\n\nFor 支持三种循环方式,包括类 while 语法\n\n#### 1 基本for循环 支持初始化语句\n```go\n    s := \"abc\"\n    for i, n := 0, len(s); i < n; i++ {\n    \t// i, n 为定义的变量 只在for 循环内作用\n        println(s[i])\n    }\n```\n\n*基本的 for 循环包含三个由分号分开的组成部分：*\n\n* 初始化语句：在第一次循环执行前被执行\n* 循环条件表达式：每轮迭代开始前被求值\n* 后置语句：每轮迭代后被执行\n\n#### 2 替代 while (n > 0) {}\nC 的 while 在 Go 中叫做 for\n```go\n    n := len(s)\n\t// 循环初始化语句和后置语句都是可选的。\n    for n > 0 { // 等同于 for (; n > 0;) {}\n        println(s[n])\n        n--\n    }\n```\n\n#### 3 死循环\n```go\n    for { // while true\n        println(s)\n    }\n```\n\n#### IF\n\n> 就像 for 循环一样，Go 的 if 语句也不要求用 ( ) 将条件括起来，同时， { } 还是必须有的\n\n* 可省略条件表达式括号\n* 支持初始化语句,可定义代码块局部变量\n* 代码块左大括号必须在条件表达式尾部\n\n```go\n    x := 0\n\n    // if x > 10  // Error: missing condition in if statement(左大括号必须在条件表达式尾部)\n    // {\n    // }\n\n    if n := \"abc\"; x > 0 {  // 初始化语句(在这里是定义变量)\n    \tprintln(n[2])\n    } else if x < 0 {\n    \tprintln(n[1])\n    } else {\n    \tprintln(n[0])\n    }\n```\n\n> if 语句定义的变量作用域仅在if范围之内(包含else语句)\n> 不支持三元操作符 \"a > b ? a : b\"\n\n以上是上段代码出现的两个控制流，剩下的控制流还有\n\n* Switch\n* Range\n* Goto, Break, Continue, defer\n\n#### Switch\n\nswitch 语法如下：\n\n```go\n    switch optionalStatement; optionalExpression{\n\t\tcase expressionList1: block1\n\t\t...\n\t\tcase expressionListN: blockN\n\t\tdefault: blockD\n\t}\n```\n\n先看一个例子:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n)\n\nfunc main() {\n\tfmt.Print(\"Go runs on \")\n\tswitch os := runtime.GOOS; os {\n\t\tcase \"darwin\":\n\t\t\tfmt.Println(\"OS X.\")\n\t\tcase \"linux\":\n\t\t\tfmt.Println(\"Linux.\")\n\t\tdefault:\n\t\t\t// freebsd, openbsd,\n\t\t\t// plan9, windows...\n\t\t\tfmt.Printf(\"%s.\", os)\n\t\t}\n}\n```\n\n* 如果有可选语句声明, 分号是必要的, 无论后边的可选表达式语句是否出现(如果可选语句没有出现默认为true)\n* 每一个case 语句必须要有一个表达式列表，多个用分号隔开\n* switch 语句自上而下执行，当匹配成功后执行case分支的代码块，执行结束后退出switch\n```go\n    switch i {\n        case 0: // 空分支，只有当 i == 0 时才会进入分支\n        case 1:\n            f() // 当 i == 0 时函数不会被调用\n    }\n```\n\n* 如果想要在执行完每个分支的代码后还继续执行后续的分支代码，可以使用fallthrough 关键字达到目的\n\n```go\n    package main\n\n    import \"fmt\"\n\n    func switch1(n int) {\n    \tswitch { // 这里用的是没有条件的switch 语句会直接执行\n    \tcase n == 0:\n    \t\tfmt.Println(0)\n    \t\tfallthrough\n    \tcase n == 1: // 如果匹配到0 这里会继续执行\n    \t\tfmt.Println(1)\n    \tcase n == 2: // fallthrough 不会对这里有作用\n    \t\tfmt.Println(2)\n    \tdefault:\n    \t\tfmt.Println(\"default\")\n    \t}\n    }\n\n    func main() {\n    \tswitch1(0)\n    }\n    # output\n    0\n\t1\n```\n* 用 default 可以指定当其他所有分支都不匹配的时候的行为\n```go\n    switch i {\n    \tcase 0:\n    \tcase 1:\n    \t\tf()\n    \tdefault:\n    \t\tg()  // 当i不等于0 或 1 时调用\n    }\n```\n\n#### Range\n\n> Range 类似迭代器的操作，返回(索引，值)或(健，值)\n\n它可以迭代任何一个集合（包括数组和 map）\n\n基本语法如下:\n```go\nfor ix, val := range coll {\n...\n}\n\n```\n\nval 始终为集合中对应索引的值拷贝，因此它一般只具有只读性质，对它所做的任何修改都不会影响到集合中原有的值（译者注：如果 val 为指针，则会产生指针的拷贝，依旧可以修改集合中的原值\n一个字符串是 Unicode 编码的字符（或称之为 rune）集合，因此您也可以用它迭代字符串\n\n下面是每种数据类型使用range时 ix和val 的值\n\n|            |ix       |val       | 值类型\n|:-------    |:------  |:-------  |:-------      |\n|string      | index   | s[index] | unicode, rune\n|array/slice | index   | s[index] |\n|map         | key     | m[index] |\n|channel     | element |          |\n\n\n#### Break continue\n\nbreak 和 continue 都可在多级嵌套循环中跳出 (和python中的用法基本一致)\n\n> break 可用于 for、switch、select,  continue 仅能 于 for 循环\n\n\n#### defer\n\ndefer 语句会延迟函数的执行直到上层函数返回\n\n延迟调用的参数会立刻生成，但是在上层函数返回前函数都不会被调用\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tdefer fmt.Println(\"world\")\n\n\tfmt.Println(\"hello\")\n}\n\n// output\nhello\nworld\n```\n\n*defer 栈*\n\n延迟的函数调用被压入一个栈中。当函数返回时， 会按照后进先出的顺序调用被延迟的函数调用。\ndefer 常用来定义简单的方法\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"counting\")\n\n\tfor i := 0; i < 10; i++ {\n\t\t\tdefer fmt.Println(i)\n\t\t}\n\n\t\tfmt.Println(\"done\")\n}\n// 可以想一下会输出什么\n// 代码执行 https://tour.go-zh.org/flowcontrol/13\n```\n\n*关键字 defer 允许我们进行一些函数执行完成后的收尾工作，例如：*\n\n* 关闭文件流：\n\n    // open a file defer file.Close()\n\n* 解锁一个加锁的资源\n\n    mu.Lock() defer mu.Unlock()\n\n* 打印最终报告\n\n    printHeader() defer printFooter()\n\n* 关闭数据库链接\n\n\t// open a database connection defer disconnectFromDB()\n\n合理使用 defer 语句能够使得代码更加简洁。\n\n下面的代码展示了在调试时使用 defer 语句的手法\n\n```go\npackage main\n\nimport (\n\t\"io\"\n    \"log\"\n)\n\nfunc func1(s string) (n int, err error) {\n    defer func() {\n\t        log.Printf(\"func1(%q) = %d, %v\", s, n, err)\n\t    }()\n    return 7, io.EOF\n}\n\nfunc main() {\n    func1(\"Go\")\n}\n\n// 输出\nOutput: 2016/04/25 10:46:11 func1(\"Go\") = 7, EOF\n```\n\n[更多defer 的用法](https://blog.go-zh.org/defer-panic-and-recover)\n\n#### goto\n\ngoto 语句可以配合标签（label）形式的标识符使用，即某一行第一个以冒号（:）结尾的单词\n\n```go\npackage main\n\nfunc main() {\n    i:=0\n    HERE:\n\t    print(i)\n\t\ti++\n        if i==5 {\n\t        return\n\t    }\n        goto HERE\n}\n# output 01234\n```\n\n> 使用标签和 goto 语句是不被鼓励的：它们会很快导致非常糟糕的程序设计，而且总有更加可读的替代方案来实现相同的需求。\n\nfor、switch 或 select 语句都可以配合标签（label）形式的标识符使用\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\nLABEL1:\n    for i := 0; i <= 5; i++ {\n\t\tfor j := 0; j <= 5; j++ {\n\t\t\tif j == 4 {\n\t\t\t\tcontinue LABEL1\n\t\t\t}\n\t\t\tfmt.Printf(\"i is: %d, and j is: %d\\n\", i, j)\n\t\t}\n\t}\n}\n\n```\n\n> continue 语句指向 LABEL1，当执行到该语句的时候，就会跳转到 LABEL1 标签的位置\n\n\n### 参考链接\n\n[Go 指南](https://tour.go-zh.org/flowcontrol/1)\n[The way to go -- 控制结构](https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/05.0.md)\n[Effective Go](https://golang.org/doc/effective_go.html)\n\n到这里简单的控制流用法讲解就结束了\n\n下节将会是golang 数据结构部分, 会用到的代码为\n\n### fibonacci(内存版)\n\n```go\n    package main\n\n    import (\n        \"fmt\"\n        \"time\"\n    )\n\n    const LIM = 41\n\n    var fibs [LIM]uint64\n\n    func main() {\n        var result uint64 = 0\n        start := time.Now()\n        for i := 0; i < LIM; i++ {\n    \t\tresult = fibonacci(i)\n    \t\tfmt.Printf(\"fibonacci(%d) is: %d\\n\", i, result)\n        }\n        end := time.Now()\n        delta := end.Sub(start)\n        fmt.Printf(\"longCalculation took this amount of time: %s\\n\", delta)\n    }\n    func fibonacci(n int) (res uint64) {\n        // memoization: check if fibonacci(n) is already known in array:\n        if fibs[n] != 0 {\n    \t\tres = fibs[n]\n    \t\treturn\n        }\n        if n <= 1 {\n    \t\tres = 1\n        } else {\n    \t\tres = fibonacci(n-1) + fibonacci(n-2)\n        }\n        fibs[n] = res\n        return\n    }\n```\n\n---------------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "跟着代码学go 002 -- 控制流",
        "date": "2016-04-26 07:49:35",
        "tags": [
          "golang",
          "读书笔记"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "golang-learning-by-code-002"
    },
    {
      "content": "\n## 变量&函数\n\n最近在学习golang，写下学习笔记提升记忆。\n为了看起来不是那么枯燥，本学习笔记采用分析代码的形式。\n\n首先搬出我们最经典的第一段代码:\n\n\n### hello world\n\n```go\n    package main // 0\n\n    import \"fmt\" // 1实现格式化的 I/O\n\n    /* Print something */ // 2\n    func main() { // 3\n    \tfmt.Println(\"Hello, world; or καλημε ́ρα κóσμε; orこんにちは 世界\") // 4\n    }\n```\n\n首先我们要认识到\n> 每个Go 程序都是由包组成，程序的运行入口是包main\n\n0. 首行这个是必须的。所有的 Go 文件以 package <something> 开头,对于独立运行的执行文件必须是 package main;\n1. 这是说需要将fmt加入到main。不是main 的包被称为库 末尾以 // 开头的内容是单行注释 Package fmt包含有格式化I/O函数，类似于C语言的printf和scanf\n2. 这也是注释，表示多行注释。\n3. package main 必须首先出现,紧跟着是 import。在 Go 中,package 总是首先出现, 然后是 import,然后是其他所有内容。当 Go 程序在执行的时候,首先调用的函数 是 main.main(),这是从 C 中继承而来。这里定义了这个函数\n4. 调用了来自于 fmt 包的函数打印字符串到屏幕。字符串由 \" 包裹,并且可以包含非 ASCII 的字符。这里使用了希腊文和日文、中文\"\n\n### 编译和运行代码\n\n构建 Go 程序的最佳途径是使用 go 工具。 构建 helloworld 只需要:\n\n```\n    1. go build helloworld.go\n    # 结果是叫做 helloworld 的可执行文件。\n    2. ./helloworld\n    # Hello, world; or καλημε ́ρα κóσμε; or こんにちは世界\n```\n\n\n### 变量\n\nGo 是静态类型语言 ,不能在运行期改变变量类型。\n\n自动初始化为零值。如果提供初始化值,可省略变量类型,由编译器自动推断。\n\n```go\n    var x int\n    // 使用关键字 var 定义变量, 跟函数的参数列表一样，类型在后面。\n    var c, python, java bool\n    // 多个相同类型的变量可以写在一行。\n    var f float32 = 1.6\n    var i, j int = 1, 2\n    // 变量定义可以包含初始值，每个变量对应一个。\n    var s = \"abc\"\n    // 如果初始化是使用表达式，则可以省略类型；变量从初始值中获得类型。\n```go\n\n变量在定义时没有明确的初始化时会赋值为*零值* 。\n\n零值是：\n\n* 数值类型为 0 ，\n* 布尔类型为 false ，\n* 字符串为 \"\" （空字符串）。\n\n在函数内部,可用更简略的 \":=\"  式定义变量。\n\n```go\n    func main() {\n        n, s := 12, \"Hello, World!\"\n        println(s, n)\n    }\n```\n\n> 函数外的每个语句都必须以关键字开始（ var 、 func 、等等）， := 结构不能使用在函数外。\n\n可一次定义多个变量。\n\n```go\n    var x, y, z int\n    var s, n = \"abc\", 123\n    var (\n    \ta int\n    \tb float32\n    )\n\n    func main() {\n        n, s := 0x1234, \"Hello, World!\"\n        println(x, s, n)\n    }\n```go\n\n一个特殊的变量名是 \\_(下划线)。任何赋给它的值都被丢弃。在这个例子中,将 35 赋值给 b,同时丢弃 34。\n\n```go\n    _, b := 34, 35\n```go\n\nGo 的编译器会对声明却未使用的变量报错\n\n```go\n    var s string // 全局变量没问题。\n\n    func main() {\n        i := 0 // Error: i declared and not used。(可使  \"_ = i\" 规避)\n    }\n```go\n\n定义完之后的变量可以被重新赋值 比如第8行，将计算结果赋值给result\n\n#### 常量\n\n> 常量值必须是编译期可确定的数字、字符串、布尔值。\n\n常量的定义与变量类似，只不过使用 const 关键字\n\n```go\n    const x, y int = 1, 2\n    const s = \"Hello, World!\"\n    // 多常量初始化 // 类型推断\n    // 常量组\n    const (\n    \ta, b = 10, 100\n    \tc bool = false\n    )\n\n    func main() _{\n    \tconst x = 'xxx'      // 未使用局部常量不会引发编译错误\n    }\n```go\n\n在常量中，如果不提供类型和初始化值，那么被看作和上一常量相同\n\n```go\n    const (\n\t\ts = \"abc\"\n\t\tx           // x = \"abc\"\n\t)\n```go\n\n#### 基本类型\n\nGo 有明确的数字类型命名, 支持 Unicode, 支持常用数据结构\n\n|类型          | 长度   | 默认值| 说明|\n|:-------      |:-----  | :---- | :----   |\n|bool          | 1      | false |\n|byte          | 1      | 0     | unit8\n|rune          | 4      | 0     | int32 的别名 代表一个Unicode 码\n|int, unit     | 4 或 8 | 0     | 32 或 64\n|int8, unit8   | 1      | 0     | -128 ~ 127, 0~255\n|int16, unit16 | 2      | 0     | -32768 ~ 32767, 0 ~ 65535\n|int32, unit32 | 4      | 0     | -21亿~ 21亿, 0 ~ 42亿\n|int64, unit64 | 8      | 0     |\n|float32       | 4      | 0.0   |\n|float64       | 8      | 0.0   |\n|complex64     | 8      |       |\n|complex128    | 16     |       |\n|unitptr       | 4或8   |       | 足以存储指针的unit32 或unit64 整数\n|array         |        |       | 值类型\n|struct        |        |       | 值类型\n|string        |        | \"\"    | UTF-8 字符串\n|slice         |        | nil   | 引用类型\n|map           |        | nil   | 引用类型\n|channel       |        | nil   | 引用类型\n|interface     |        | nil   | 接口\n|function      |        | nil   | 函数\n\n> int，uint 和 uintptr 类型在32位的系统上一般是32位，而在64位系统上是64位。当你需要使用一个整数类型时，你应该首选 int，仅当有特别的理由才使用定长整数类型或者无符号整数类型。\n> 引用类型包括 slice、map 和 channel。它们有复杂的内部结构,除了申请内存外,还需要初始化相关属性\n\n\n#### 类型转换\n\n不支持隐式的类型转换\n\n表达式 T(v) 将值 v 转换为类型 T 。\n\n```go\n\nvar b byte = 100\n// var n int = b // Error: cannot use b (type byte) as type int in assignment\nvar n int = int(b) // 显式转换\n\n```go\n\n不能将其他类型当 bool 值使用\n\n```go\na := 100\nif a {                  // Error: non-bool a (type int) used as if condition\n    println(\"true\")\n}\n```\n\n### 函数\n\n首先看下面这段代码\n\n```go\n    package main\n\n    import \"fmt\"\n\n    func add(x int, y int) int {\n    \treturn x + y\n    }\n\n    func main() {\n    \tfmt.Println(add(42, 13))\n    }\n```\n\n#### 函数定义\n\n> 使用关键字 func 定义函数,左大括号不能另起一行\n\ngolang中符合规范的函数一般写成如下的形式：\n\n```go\n    func functionName(parameter_list) (return_value_list) {\n       …\n    }\n\n    // parameter_list 是参数列表\n    // return_value_list 是返回值列表 下边有详细的讲解\n```\n\n#### 函数的特性\n\n* 无需声明原型。 (1)\n* 支持不定长变参。\n* 支持多返回值。\n* 支持命名返回参数。\n* 支持匿名函数和闭包。\n* 不支持 嵌套 (nested)、重载 (overload) 和 默认参数 (default parameter)\n\n```go\n    func test(x int, y int, s string) (r int, s string) { // 类型相同的相邻参数可合并\n        n := x + y                                    // 多返回值必须用括号。\n        return n, fmt.Sprintf(s, n)\n    }\n\n    /*\n    关键字 func 用于定义一个函数\n    test 是你函数的名字\n    int类型的变量x, y 和string类型的变量s作为输入参数 参数用pass-by-value方式传递,意味着它们会被复制\n    当两个或多个连续的函数命名参数是同一类型，则除了最后一个类型之外，其他都可以省略。\n\n    在这个例子中：\n\n        x int, y int\n\n    被缩写为\n\n        x, y int\n\n    变量 r 和 s 是这个函数的 命名返回值。在 Go 的函数中可以返回多个值\n    如果不想对返回的参数命名,只需要提供类型:(int, string)。 如果只有一个返回值,可以省略圆括号。如果函数是一个子过程,并且没有任何返回值,也可以省略这些内容\n    函数体。注意 return 是一个语句,所以包裹参数的括号是可选的\n    */\n```\n\n不定长参数其实就是slice，只能有一个，且必须是最后一个\n\n```go\n    func test(s string, n ...int) string {\n        var x int\n    \t\tfor _, i := range n {\n    \t\t\t x += i\n    \t\t}\n    \treturn fmt.Sprintf(s, x)\n    }\n    // 使用slice 做变参时，必须展开\n    func main() {\n        s := []int{1, 2, 3}\n        println(test(\"sum: %d\", s...))\n    }\n```\n\n> 函数是第一类对象,可作为参数传递\n\n就像其他在 Go 中的其他东西一样,函数也是值而已。它们可以像下面这样赋值给变量:\n\n```go\n    func main() {\n        a := func() {                  // 定义一个匿名函数,并且赋值给 a\n    \t\tprintln(\"Hello\")\n    \t}                              // 这里没有 ()\n        a()                            // 调用函数\n    }\n```\n\n如果使用 fmt.Printf(\"\\%T\\n\", a) 打印 a 的类型,输出结果是 func()\n\n#### 返回值\n\n函数可以返回任意数量返回值\n\nGo 函数的返回值或者结果参数可以指定一个名字,并且像原始的变量那样使用,就像 输入参数那样。如果对其命名,在函数开始时,它们会用其类型的零值初始化\n\n```go\n    package main\n\n    import \"fmt\"\n\n    func swap(x, y string) (string, string) {\n    \treturn y, x\n    }\n\n    func main() {\n    \ta, b := swap(\"hello\", \"world\")\n    \tfmt.Println(a, b)\n    }\n\n    /*\n       函数可以返回任意数量返回值\n       swap 函数返回了两个字符串\n    */\n\n```\n\nGo 的返回值可以被命名，并且就像在函数体开头声明的变量那样使用。\n\n```go\n    package main\n\n    import \"fmt\"\n\n    func split(sum int) (x, y int) { // 初始化返回值为 x,y\n    \tx = sum * 4 / 9              // x,y 已经初始化，可以直接赋值使用\n    \ty = sum - x\n    \treturn                       // 隐式返回x,y(裸返回)\n    }\n\n    func main() {\n    \tfmt.Println(split(17))\n    }\n\n    /*\n       在长的函数中这样的裸返回会影响代码的可读性。\n    */\n```\n\n> 有返回值的函数,必须有明确的return 语句,否则会引发编译错误\n\n### 名词解释\n\n函数原型\n\n> 函数声明由函数返回类型、函数名和形参列表组成。形参列表必须包括形参类型,但是不必对形参命名。这三个元素被称为函数原型,函数原型描述了函数的接口\n函数原型类似函数定义时的函数头，又称函数声明。为了能使函数在定义之前就能被调用，C++规定可以先说明函数原型，然后就可以调用函数。函数定义可放在程序后面。 由于函数原型是一条语句，因此函数原型必须以分号结束。函数原型由函数返回类型、函数名和参数表组成，它与函数定义的返回类型、函数名和参数表必须一致。函数原型必须包含参数的标识符（对函数声明而言是可选的）注意：函数原型与函数定义必须一致，否则会引起连接错误\n\n### 参考链接\n\n[Go 指南](https://tour.go-zh.org/basics/4)\n[The way to go -- 变量](https://github.com/Unknwon/the-way-to-go_ZH_CN/blob/master/eBook/04.4.md)\n[Effective Go](https://golang.org/doc/effective_go.html)\n\n变量和函数部分暂时这些，有更新还会补充。下一篇将会是控制流\n将会用到的代码为:\n\n```go\n    package main\n\n    import \"fmt\"\n\n    func main() {\n        result := 0\n        for i := 0; i <= 10; i++ {\n          result = fibonacci(i)\n          fmt.Printf(\"fibonacci(%d) is: %d\\n\", i, result)\n       }\n    }\n\n    func fibonacci(n int) (res int) {\n        if n <= 1 {\n            res = 1\n    \t   } else {\n    \t       res = fibonacci(n-1) + fibonacci(n-2)\n    \t   }\n    \treturn\n    }\n```\n\n---------\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "跟着代码学go 001 -- 变量&函数",
        "date": "2016-04-25 06:53:47",
        "tags": [
          "golang",
          "读书笔记"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "golang-learning-by-code-001"
    },
    {
      "content": "\n## 1. Golang 是什么\n\nGo 官方说明：\n> Go 编程语言是一个使得程序员更加有效率的开源项目。Go 是有表达力、简 洁、清晰和有效率的。它的并行机制使其很容易编写多核和网络应用,而新的类型系统允许构建有 性的模块化程序。Go 编译到机器码非常快 速,同时具有便利的垃圾回收和强大的运行时反射。它是快速的、静态类 型编译语言,但是感觉上是动态类型的,解释型语言\n\nHUGOMORE42\n\n## 2. 为什么要开发这个语言\n\n### Go 语言的发展目标\n\n* Go 语言的主要目标是将静态语言的安全性和高效性与动态语言的易开发性进行有机结合\n* Go 语言是一门类型安全和内存安全的编程语言。虽然 Go 语言中仍有指针的存在，但并不允许进行指针运算。\n* Go 语言的另一个目标是对于网络通信、并发和并行编程的极佳支持，从而更好地利用大量的分布式和多核的计算机\n* Go 语言中另一个非常重要的特性就是它的构建速度（编译和链接到机器代码的速度），一般情况下构建一个程序的时间只需要数百毫秒到几秒。\n* Go 语言实现高效快速的垃圾回收（使用了一个简单的标记-清除算法）。\n\n\n## 3. 有什么特性&&用途\n\n### 语言的特性\n\n* 清晰并且简洁\n\n> Go 努力保持小并且优美,你可以在短短几行代码里做许多事情;\n\n* 并行\n\n> Go 语言从本质上（程序和结构方面）来实现并发编程。\n> Go 让函数很容易成为非常轻量的线程。这些线程在 Go 中被叫做 goroutines\n\n* Channel\n\n> 这些 goroutines 之间的通讯由 channel[18, 25] 完成\n\n* 快速\n\n> 编译很快,执行也很快。目标是跟 C 一样快。编译时间用秒计算;\n> Go 的可执行文件都比相对应的源代码文件要大很多，这恰恰说明了 Go 的 runtime 嵌入到了每一个可执行文件当中。当然，在部署到数量巨大的集群时，较大的文件体积也是比较头疼的问题。但总得来说，Go 的部署工作还是要比 Java 和 Python 轻松得多。因为 Go 不需要依赖任何其它文件，它只需要一个单独的静态文件，这样你也不会像使用其它语言一样在各种不同版本的依赖文件之间混淆。\n\n* 安全\n\n> 当转换一个类型到另一个类型的时候需要显式的转换并遵循严格的规则。Go 有 垃圾收集（使用了一个简单的标记-清除算法）,在 Go 中无须 free(),语言会处理这一切;\n> 值得注意的是，因为垃圾回收和自动内存分配的原因，Go 语言不适合用来开发对实时性要求很高的软件。\n\n* 标准格式化\n\n> Go 程序可以被格式化为程序员希望的(几乎)任何形式,但是官方格式是存在的。标准也非常简单:gofmt 的输出就是官方认可的格式;\n\n* 类型后置\n\n> 类型在变量名的后面,像这样 var a int,来代替 C 中的 int a;\n\n* UTF-8\n\n> 任何地方都是 UTF-8 的,包括字符串以及程序代码。你可以在代码中使用 Φ = Φ + 1;\n\n* 开源\n\n> Go 的许可证是完全开源的,参阅 Go 发布的源码中的 LICENSE 文件;\n\n* 尽管 Go 编译器产生的是本地可执行代码，这些代码仍旧运行在 Go 的 runtime（这部分的代码可以在 runtime 包中找到）当中。这个 runtime 类似 Java 和 .NET 语言所用到的虚拟机，它负责管理包括内存分配、垃圾回收（第 10.8 节）、栈处理、goroutine、channel、切片（slice）、map 和反射（reflection）等等。\n\n### 有什么用途\n\nGo 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发特别适用。\n\n[使用 Go 的组织](http://go-lang.cat-v.org/organizations-using-go)\n\n\n## 4. 有什么缺点\n\n* 为了简化设计，不支持函数重载和操作符重载\n* 为了避免在 C/C++ 开发中的一些 Bug 和混乱，不支持隐式转换\n* Go 语言通过另一种途径实现面向对象设计来放弃类和类型的继承\n> 举例说明用什么途径实现继承\n\n* 尽管在接口的使用方面可以实现类似变体类型的功能，但本身不支持变体类型\n* 不支持动态加载代码\n* 不支持动态链接库\n* 不支持泛型\n* 通过 recover 和 panic 来替代异常机制\n> 举个异常处理的例子\n\n* 不支持断言\n* 不支持静态变量\n\n\n## 5. 安装\n\nGo 的源代码有以下三个分支：\n\n* Go release：最新稳定版，实际开发最佳选择\n* Go weekly：包含最近更新的版本，一般每周更新一次\n* Go tip：永远保持最新的版本，相当于内测版\n\n现在release 是1.6 可以按照自己的需求安装\n\n### ubuntu & debian\n\n```bash\nsudo apt-get update && apt-get install -y --no-install-recommends \\\n    g++ gcc libc6-dev make\n\nGOLANG_VERSION=1.6\nGOLANG_DOWNLOAD_URL=https://golang.org/dl/go$GOLANG_VERSION.linux-amd64.tar.gz\nGOLANG_DOWNLOAD_SHA256=5470eac05d273c74ff8bac7bef5bad0b5abbd1c4052efbdbc8db45332e836b0b\n\nsudo curl -fsSL \"$GOLANG_DOWNLOAD_URL\" -o golang.tar.gz \\\n    && echo \"$GOLANG_DOWNLOAD_SHA256  golang.tar.gz\" | sha256sum -c - \\\n    && tar -C /usr/local -xzf golang.tar.gz \\\n    && rm golang.tar.gz\n\n## 也可以直接 sudo apt-get install go 版本可能不是1.6\n```\n\n### Mac\n\n```sh\nbrew install go\n```\n\n### Windows\n\n点击下载页面直接下载安装吧 [下载链接] (http://golang.org/dl/)\n\n## 6. 环境配置&编辑器\n\nGOROOT GO语言安装的路径\nGOPATH 表示代码包所在的地址，可以设置多个\nPATH 可执行程序的路径，在命令行执行命令时，系统默认会在PATH中指定路径里寻找\n\n```sh\n# 将以下环境变量加到 .bashrc 或者 .zshrc 文件\n# Mac 配置\nexport GOROOT='/usr/local/Cellar/go/1.6/libexec'\nexport GOPATH=$HOME/Golang\nexport PATH=$PATH:$HOME/go/bin:$GOPATH/bin\n\n# ubuntu 配置\nexport GOROOT='/usr/local/go'\nexport GOPATH=/go\nexport PATH=$PATH:$HOME/go/bin:$GOPATH/bin\n\n```\n\n### 编辑器\n\n* vim\n* atom\n* pyCharm\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "golang 介绍",
        "date": "2016-04-14 14:44:40",
        "tags": [
          "golang",
          "读书笔记"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "golang-description"
    },
    {
      "content": "\n### Hello Hugo\n\nHugo 常用命令 基本配置\n\n\n### hugo 常用命令\n\n```shell script\nhugo help\nhugo version\nhugo new site sitename  # 新建一个站点\nhugo new post/good-to-great.md  # 添加到content/post 目录\nhugo server # 启动server\nhugo server --buildDrafts # 预览草稿\nhugo undraft content/post/good-to-great.md # 发布一篇文章\nhugo server --theme=hugo_zen # 以zen 主题启动server\nhugo --theme=hugo_zen 以zen # 主题生成草稿\n```\n\n*语法高亮*\n\n[Syntax Highlighting](https://gohugo.io/extras/highlighting/)\n\n```python\n# print hello world\nprint \"hello world\"\n```\n\n\n### Front Matter Example (in TOML)\n\n[front-matter] (https://gohugo.io/content/front-matter/)\n\n```json\n+++\ntitle = \"Hugo: A fast and flexible static site generator\"\ndescription = \"Hugo: A fast and flexible static site generator\"\ntags = [ \"Development\", \"Go\", \"fast\", \"Blogging\" ]\ncategories = [ \"Development\" ]\ndate = \"2012-04-06\"\nseries = [ \"Go Web Dev\" ]\nslug = \"hugo-可以替代url\"\nproject_url = \"https://github.com/spf13/hugo\"\n+++\n```\n\n### Markdown 语法说明\n\n[Markdown 语法说明 (简体中文版)] (http://wowubuntu.com/markdown/)\n\n\n### 参考链接\n\n* [Hugo Quickstart Guide] (https://gohugo.io/overview/quickstart/)\n* [Hugo静态网站生成器中文教程] (http://nanshu.wang/post/2015-01-31/)\n* [使用hugo搭建个人博客站点] (http://blog.coderzh.com/2015/08/29/hugo/)\n* [Hugo中文文档] (http://www.gohugo.org/)\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "hugo 使用",
        "date": "2016-04-11 02:47:47",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "first"
    },
    {
      "content": "\n> 程序员 后端\n\n\n### 公号\n\n> 公号：四月（hiiiapril）\n![hiiiapril](http://media.gusibi.mobi/WDz3v4cU4LQq1oyKX-fYK1LxIThzZ1hK931ZaPRC8CdcB0t2oTYJciMDuAws70FY)\n\n### 社交帐号\n\n* [掘金](https://juejin.im/user/592291eb570c350069bad8f1)\n* [segmentfault](https://segmentfault.com/u/goodspeed)\n* [github](https://www.github.com/gusibi)\n* [twitter](https://twitter.com/amazing_gs)\n\n\n### 作品\n\n#### 小程序\n\n> 蒙太奇拼图\n\n![](http://media.gusibi.mobi/P60XX2Lf1n8Mj6lSoj2YKlLvNUrd8BN_1e4AQdJ7MhxuTJHDZbIYE7s2OjFHw4HF)\n\n\n> 定投账本\n\n![](http://media.gusibi.mobi/0iu2yg9c_HC9cVA67EG5mLdqqNVDwvlNgLBFX__j8hM2QHT1Su-PdjeuvRnf3_Cu)\n\n\n#### Github 项目\n\n* [python-weixin-sdk](https://github.com/gusibi/python-weixin)\n* [微信聊天机器人](https://github.com/gusibi/momo)\n* [Amazon DynamoDB ORM By Python](https://github.com/gusibi/dynamodb-py)\n\n\n#### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "关于我-顾斯比",
        "date": "2016-04-05 12:29:39",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "about"
    },
    {
      "content": "\n##\n\n### \n\n## 参考链接\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "date": "",
        "title": "title",
        "author": "goodspeed",
        "permalink": "/post/url-path",
        "description": "description",
        "tags": [
          "xx",
          "xxxx"
        ],
        "categories": [
          "xxx",
          "xxxx"
        ],
        "published": false,
        "hideInList": false,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "gc-copying"
    },
    {
      "content": "> **“Does developer convenience really trump correctness, scalability, performance, separation of concerns, extensibility, and accidental complexity?” Vinoski (2008)**\n>\n> 开发者的便利性真的比正确性、可扩展性、性能、关注点分离、可扩展性和偶然复杂度更重要吗？\n\n\n## RPC 介绍\n\n\n\n远程过程调用(Remote Procedure Call，RPC)是一种允许两个实体通过通用**请求/响应**机制的通信通道进行通信的设计范例。RPC 的定义在过去三十年中发生了重大的变化和演变，因此 这里RPC 范式是一个广义的分类术语，指的是过去四十年中出现的所有 RPC 式系统。RPC 的定义经过几十年的发展。它已经从一个简单的客户端-服务器设计转移到一组相互连接的服务。虽然最初的 RPC 实现被设计为将计算外包给分布式系统中的服务器的工具，但 RPC 经过多年的发展，已经构建了一个与语言无关的应用程序生态系统。RPC 范式已经成为创建真正革命性的分布式系统的驱动力的一部分，并且在不同系统之间产生了各种通信方案和协议。\n\n\n\n\n\n\n\n![45366c44f775abfd0ac3b43bccc1abc3_720w.jpg](http://media.gusibi.mobi/ghNK6n_mtljVYk0tNrZTRm2wGibEA-IdZ6Q3kWsxqAo2u9QLgeoAXZpf611puv4B)\n\n最简单的 RPC 实现如图1所示。在这种情况下，客户端(或调用方)和服务器(或被调用方)被一个物理网络分开。系统的主要组件是客户端例程/程序、客户端存根、服务器例程/程序、服务器存根和网络例程。存根是一个小程序，通常用作较大程序的替代程序(或接口)。客户端存根向客户端例程公开服务器例程提供的功能，而服务器存根向服务器例程提供类似于客户端的程序。客户端存根从客户端程序获取输入参数并返回结果，而服务器存根向服务器程序提供输入参数并获取结果。客户端程序只能与客户端存根交互，后者为客户端提供远程服务器的接口。这个存根还序列化客户端例程发送到存根的输入参数。类似地，服务器存根为服务器例程提供客户端接口，并处理发送到客户端的数据序列化。\n\n\n\n当客户端例程执行远程过程时，它调用客户端存根，该存根序列化输入参数。这个序列化数据使用 OS 网络例程(TCP/IP)发送到服务器。然后，服务器存根将数据反序列化，并使用给定的参数提供给服务器例程。来自服务器例程的返回值再次序列化，并通过网络发送回客户端，在那里客户端存根对其进行反序列化，并显示给客户端例程。这个远程过程通常对客户端例程隐藏，并作为本地过程显示给客户端。RPC 服务还需要一个发现服务/主机解析机制来引导客户端和服务器之间的通信。\n\n\n\n**完整的 RPC 框架**\n\n\n在一个典型 RPC 的使用场景中，包含了服务发现、负载、容错、网络传输、序列化等组件，其中“RPC 协议”就指明了程序如何进行网络传输和序列化。\n\n\n\n![rpc-2021-01-30-1635.png](http://media.gusibi.mobi/5QsjweGQnwmBsWdVcFO2sZ-QGKpthTwB_3wzkyfEYVGW3mglxPl7It2f8WUMo8ar)\n\n## RPC 的发展历程\n\n\n\n### 1969年11月，ARPAnet 开始建立。\n\n\n\n1996年，美国国防部高级研究计划管理局（ARPA全称：Advanced Research Projects Agency）开始建立一个命名为ARPAnet的网络。最开始只有4个结点，分别是洛杉矶的[加利福尼亚州](https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=25050&ss_c=ssc.citiao.link)大学洛杉矶分校、加州大学圣巴巴拉分校、[斯坦福大学](https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=527469&ss_c=ssc.citiao.link)、犹他州大学四所大学的4台[大型计算机](https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=7909857&ss_c=ssc.citiao.link)。选择这四个节点的一个原因是要测试不同类型主机联网的兼容性。\n\n\n\n### 1974年：Jon Postel 和 Jim White发表了RFC674\n\n\n\n过程调用最早可以追溯到 Jon Postel 和 Jim White 在1974 年发表的 Procedure Call Protocol Documents Version 2（RFC674）。这个协议试图定义一种通用的方法，用于解决 NSW 项目中多个计算节点通信的问题。\n\n\n\n协议发表后，引起了非常大的争议，1975年，RFC674的注释篇RFC684 发布。\n\n\n\n### 1975年：RFC684 作为RFC 674 的注释发表，对RFC 674 的争议进行回复\n\n\n\nRFC 684 不是一个独立的协议， 主要对 RFC674 的争议进行讨论。讨论内容可以总结为以下几点：\n\n\n\n- RFC674 认为过程调用应该是一个原语操作，它应该在操作系统底层进行操作\n\n- - 原语是在操作系统中调用核心层子程序的指令。与一般广义指令的区别在于它是不可中断的，而且总是作为一个基本单位出现。\n\n- 本地调用和远程调用是不同的，远程调用可能会发生故障，并且发生故障后可能无法恢复。\n- 异步消息传递，或者显示的声明什么时候需要同步等待消息返回应该是一个更好的模型。\n\n\n\n从这几点出发，关于这个编程范型的担忧成了RPC40多年历史中一个永恒的话题，即：\n\n\n\n- 故障或错误后怎么恢复？重试、抛出异常？\n- 顺序操作非常困难。比如一系列同步请求，如果其中某些请求失败，怎么保证错误的请求重新执行，以及请求还是顺序的？\n- RPC 请求是同步模型，方法被调用后会等待响应，但是由于请求是同步的，在系统负载高时如果希望优先响应优先级高的请求则变成了非常困难的事情。\n\n- - 同步更多地是针对一对一的调用和返回，而不是针对单个请求的异步特性和多个返回。此外，低优先级、可抢占的后台任务也不太可能在过程调用中实现。\n\n\n\n> 此时的协议还是基于阿帕网（ARPANET），互联网还没有出现，已经在讨论分布式系统间调用的问题了。\n\n\n\n### 1976年：RFC 707 发布\n\n\n\n> 由于远程和本地调用的成本差异，应用程序程序员必须谨慎使用远程资源，即使远程资源的使用机制将被 RTE 大大简化。与虚拟内存一样，过程调用模型提供了极大的便利，也提供了强大的能力，于此同时也应该对可能产生的滥用有合理警觉\n\n\n\nRFC 707 概括了 RFC 684 的思想，并讨论了诸如 TELNET 和 FTP 等服务的资源共享问题，这些服务中的每一个都提供了与之交互的不同接口，这就要求操作员知道与该服务交互的具体协议。针对这种问题，作者提出了一个新的想法：与其需要知道远程计算机上所有可用的命令和协议，我们能否定义一个通用的接受参数并遵循调用/响应模型的接口来执行一个远程过程。\n\n\n\n### 1983年1月1日，ARPA网将其网络核心协议由网络控制程序改变为 TCP/IP 协议\n\n\n\n1983年1月1日，ARPA网将其网络核心协议由网络控制程序改变为 TCP/IP 协议，互联网的种子开始发芽。\n\n\n\n### 1984年：论文 《Implementing remote procedure calls》发表\n\n\n\nRPC 是远程过程调用（Remote Procedure Call）的缩写形式，Birrell 和 Nelson 在 1984 发表于 ACM Transactions on Computer Systems 的论文《Implementing remote procedure calls》对 RPC 做了经典的诠释。RPC 是指计算机 A 上的进程，调用另外一台计算机 B 上的进程，其中 A 上的调用进程被挂起，而 B 上的被调用进程开始执行，当值返回给 A 时，A 进程继续执行。调用方可以通过使用参数将信息传送给被调用方，而后可以通过传回的结果得到信息。而这一过程，对于开发人员来说是透明的。之后的几年RPC一直被认为是建立分布式操作系统的最合适的范式。\n\n\n\n> RPC（Remote Procedure Call，远程过程调用）是建立在Socket之上的一种多进程间的通信机制。不同于复杂的Socket通信方式，RPC的初心是设计一套远程通信的通用框架，这个框架能够自动处理通信协议、对象序列化、网络传输等复杂细节，并且希望开发者使用这个框架以后，调用一个远程机器上的接口的代码与以本地方法调用的代码“看起来没什么区别”，从而大大减小分布式系统的开发难度，使得不懂网络编程的程序员也能比较容易地开发分布式系统。\n\n\n\n![20160630-rpc.png](http://media.gusibi.mobi/_41U9sOVjUPiYpGcWjJDTL4FrDu-X3Y_8Mm0NRst05Jcp5z1Ui2_u9cuADXjNnKz)\n\n这是论文中的rpc架构图，可以看到user，uset-sub和其中一个RPCRuntime的实例在调用者机器上执行；server，server-sub和另外一个RPCRuntime实例在被调用者机器上执行。当user发起远程调用时，其实是执行了一个完全正常的本地调用，而这个调用会去调用user-stub中相应的程序。user-stub负责将目标程序的规范和参数放置在一个或多个包中（打包），并请求RPCRuntime将这些包可靠地传输给被调用者机器。一旦接收到这些包，被调用者机器上的RPCRuntime就这些包传送给server-stub。server-stub将它们解包，像是执行一个完全正常的本地调用一样，该本地调用会调用server中对应的程序。与此同时，调用者机器上的调用进程将被挂起，并等待结果包的返回。当server中的调用完成时，它将结果返回给user-stub打包，然后结果包将由RPCRuntime再传送回给调用者机器上挂起的进程（RCPCRuntime负责重传，确认，数据包路由和加密）。这些包将被user-stub解包并返回给user。除去多机器间机器绑定或者通信失败的影响，调用就仿佛user直接在server上调用程序一样。确实是这样，如果user和server的代码放置在同一个机器上，并被直接绑定在一起（无需stub），程序将仍能工作。\n\n\n\n### 1987年：《A Critique of the Remote Procedure Call Paradigm》发表\n\n###  \n\n1987年，Tanenbaum 和 Renesse发表文章《A Critique of the Remote Procedure Call Paradigm》，讨论了RPC 模型的概念问题、实现技术问题、客户端和服务端崩溃后的处理问题、不同系统间的问题以及性能等多方面的问题，并对存在的问题进行了分析。\n\n\n\n> 一个通用的范例不应该要求程序员将自己限制在所选择的编程语言的一个子集中，或者强迫他们采用某种编程风格（例如，不要一刀切的使用指针，因为 RPC 不能处理它们）\n\n\n\n在这篇评论中，作者举了一个例子：\n\n\n\n> 假设两个程序员在一个项目上工作。程序员1正在编写主程序。程序员2编写一个被主程序调用的过程集合。RPC 的主题从未被提及，两个程序员都认为他们的所有代码将被编译并链接成一个单一的可执行二进制程序，并在独立的计算机上运行，不连接任何网络。\n>\n> \n>\n> 在最后一分钟，在所有的代码都经过了彻底的测试、调试和记录之后，两个程序员都辞职离开了这个国家，代码部署在充满意外的分布式系统上运行。主程序和过程代码在不同的计算机上运行。\n>\n> \n>\n> 我们的论点是，由于 RPC 试图使远程过程调用看起来与本地过程调用完全一样，但无法完美地完成，调用过程中可能会出现大量的错误。虽然许多问题可以通过修改代码来解决，但是这样就失去了透明性。一旦我们承认真正的透明性是不可能的，并且程序员必须知道哪些调用是远程的，哪些是本地的，我们就会面临这样一个问题: 在根本没有尝试使远程计算看起来像本地的前提下，部分透明的机制是否真的比专门为远程访问设计的机制更好。\n\n\n\n同时，还讨论了以下几个问题：\n\n\n\n#### 两军问题\n\n\n\n> 网络是不可靠的，无法保证数据可以100%无误的通过网络传递。\n\n\n\n#### 参数问题\n\n\n\n> 参数编组，参数顺序，参数传递等。特别是指针类型的参数传递。\n>\n> 现代RPC 通常使用----------------------\n\n\n\n#### 全局变量\n\n\n\n> 既然是RPC 可以像本地调用一样使用，那么全局变量是否可以通用？\n\n\n\n#### 性能问题\n\n\n\n#### 异常处理\n\n\n\n> 通常当主程序调用过程时，如果代码是正确的，那么该过程最终将返回给调用者。如果机器崩溃，主程序和程序都会死亡，整个程序必须重新运行。因此，基本上有两种操作模式: 整个程序工作或整个程序失败。\n>\n> RPC 引入了另一种故障模式: 客户端工作正常，但服务器崩溃。如果一个主程序调用一个过程，但是没有响应，那么应该怎么做呢？在某些系统中，客户端会永远挂起。\n>\n> 另一种可能是让客户端存根在向服务器发送消息时启动计时器。如果在某个时间间隔之后没有响应，它会一次又一次地尝试。在 n 次重试之后，依然失败那么则返回一个错误码标识服务不可用。\n\n\n\n#### 幂等问题\n\n\n\n### 1988年，RFC 1057 发布，ONC RPC 被定义为标准的RPC 规范\n\n\n\n> Sun 公司是第一个提供商业化 RPC 库和 RPC 编译器。在1980年代中期， Sun 计算机提供 RPC，并在 Sun Network File System(NFS) 得到支持。该协议被主要以 Sun 和 AT&T 为首的 Open Network Computing （开放网络计算）作为一个标准来推动。这是一个非常轻量级 RPC 系统，可用在大多数 POSIX 和类 POSIX 操作系统中使用，包括 Linux、SunOS、OS X 和各种发布版本的 BSD。这样的系统被称为 Sun RPC 或 ONC RPC。最终sun成功了，sunrpc 成了第一个rpc的标准。\n\n\n\n> ONC RPC 提供了一个编译器，需要一个远程过程接口的定义来生成客户端和服务器的存根函数。这个编译器叫做 rpcgen。在运行此编译器之前，程序员必须提供接口定义。包含函数声明的接口定义，通过版本号进行分组，并被一个独特的程序编码来标识。该程序编码能够让客户来确定所需的接口。版本号是非常有用的,即使客户没有更新到最新的代码仍然可以连接到一个新的服务器，只要该服务器还支持旧接口。\n\n![90dc3e7458138e6f2fd79297c50f347d.jpg-wh_600x-s_771365725.jpg](http://media.gusibi.mobi/GDG3SRhCn3zFDd0kf23qFfNqh2S25w96i2XKGB5GCDI-DeayrzzEOOG-KhhRy97k)\n\n#### RPC的调用流程\n\n\n\n1. 服务消费方（client）以本地调用方式调用服务。\n2. client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体。\n3. client stub找到服务地址，并将消息发送到服务端。\n4. server stub收到消息后进行解码。\n5. server stub根据解码结果调用本地服务。\n6. 本地服务执行并将结果返回给server stub。\n7. server stub将返回结果打包成消息并发送至消费方。\n8. client stub接收到消息并进行解码。\n9. 服务消费方得到最终结果。\n\n\n#### 服务发现\n\n![20160630-rpc-onc_lookup.png](http://media.gusibi.mobi/htLdzMhUJ1v7952Zl7zmE-WMpTWN9uTrqymWdBC_uNOrmcni5vEOaIg_Oj58vZIY)\n\n\nONC RPC 通过服务端的一个 portmapper 来实现服务发现。服务端在启动时向 portmapper 注册，portmapper 的端口是大家都知道的，所以客户端可以通过 portmapper 找到服务端。\n\n\n\nONC RPC 作为最早的 RPC 框架，还是有很多问题的\n\n\n\n1. **协议格式要求严格**：需要客户端和服务端的压缩格式**完全一致**。\n2. **协议修改不灵活**：客户端和服务端都要做修改，如果只有一方做了修改， 那 RPC 就会有错误。这导致版本更新的问题，每一次的版本更新，客户端和服务端基本是耦合的，必须同时作出更改，如果服务器没有运行，客户端是无法连接到远程过程进行调用的。管理员必须要确保在任何客户端试图连接到服务器之前将服务器启动。如果一个新服务或接口添加到了系统，客户端是不能发现的。这就要求开发客户端和服务端的需要是同一批人，或者至少要有密切的交流。\n3. **面向函数**：面向对象的语言开始在1980年代末兴起，面向函数的ONC RPC 没有提供任何支持诸如从远程类实例化远程对象、跟踪对象的实例或提供支持多态性。现有的 RPC 机制虽然可以运作，但他们仍然不支持自动、透明的方式的面向对象编程技术。\n\n\n\n### 1989年：Tim Berners-Lee 创建了万维网\n\n\n\n1989年，[蒂姆·伯纳斯-李](https://zh.wikipedia.org/wiki/蒂姆·伯纳斯-李)发明了万维网。第二年9月，开发了第一个网页浏览器。到1990年圣诞节，蒂姆·伯纳斯-李创建运行万维网所需的所有工具：超文本传输协议（HTTP）、超文本标记语言（HTML）、第一个网页浏览器、第一个网页服务器和第一个网站，实现了[超文本传输协议](https://zh.wikipedia.org/wiki/超文本传输协议)客户端与服务器的第一次通讯。他也因此而获得了2016年的**图灵奖**。\n\n\n\n到1995年，互联网在美国已完全商业化。\n\n\n\n### 1991年：OMG 发布CORBA 1.0\n\n\n\n> OMG成立于1989年，作为一个非营利性组织，集中致力于开发在技术上具有先进性、在商业上具有可行性并且独立于厂商的软件互联规范，推广面向对象模型技术，增强软件的可移植性(Portability)、可重用性(Reusability)和互操作性(Interoperability)。该组织成立之初，成员包括Unisys、Sun、Cannon、Hewlett-Packard和Philips等在业界享有声誉的软硬件厂商，目前该组织拥有800多家成员。\n\n\n\nCORBA（Common Object Request Broker Architecture） 是面向对象语言的一个抽象，由 C++ 开发，它允许你在不同的语言和不同的机器上运行的不同的地址空间之间进行通信。CORBA 依赖于使用接口定义语言(IDL)来指定远程对象类的接口; 这种 IDL 用于生成远程系统对象接口在本地机器上的接口。这些 IDL 将用于生成 IDL 提供的抽象接口与 C++ 和 Java 等语言的实际实现之间的映射。\n\n\n\nCORBA 试图为应用程序开发人员提供几个好处: **语言独立性、操作系统独立性、体系结构独立性、通过 IDL 中的抽象类型映射到这些类型的机器和语言特定实现的静态类型，以及对象传输，其中对象可以通过不同机器之间的连接进行迁移**。CORBA 的承诺是，通过使用映射，远程调用可以作为本地调用出现，分布式系统相关的异常可以映射到本地异常，并由本地异常处理机制处理。\n\n\n\n### 1994年：A Note on Distributed Computing 发布\n\n\n\nJim Waldo 等人发表了一篇 名为 《**A Note on Distributed Computing》的论文。**  这篇论文详细讨论了为什么 RPC 模型扩展到对象，是有问题的。\n\n\n\n在这篇论文中，作者认为忽视本地和分布式计算之前的差异是很危险的，同时它还讨论了一个统一的对象视图，并列举了在 RPC 中将这些对象划分为分布式计算的4个主要问题: 通信延迟、解决空间分离、部分故障和并发问题(由于通过两个并发的客户端请求访问同一个远程对象而导致)。这些问题中的大多数(除了部分故障)都与分布式计算本身有着内在的联系，但是对于 RPC 系统来说，部分故障即意味着 RPC 系统并不总是可用的。\n\n\n\n同时，作者也认为分布式计算的难题不在于如何在线上或者线下进行操作，**并且每隔10年，我们就会试图统一本地计算和远程计算，并且每次都会遇到同样的问题：远程计算和本地计算是不同的**。\n\n\n\n作者认为，远程计算的问题主要有以下内容：\n\n\n\n#### 延迟\n\n\n\n本地调用和远程调用最明显的区别应该是延迟问题: 如果忽略延迟，最终将直接影响软件性能。他指出，“依赖于底层硬件稳步增长的速度”是错误的，并且使用 “真正的子弹” 并不总是可能进行测试。性能分析和重定位是非常重要的，在某一点上是最优的设计不一定保持最优。\n\n\n\n#### 部分失败\n\n\n\n在本地计算机中，故障是可以检测到的，并且主程序有足够的控制权。但对于分布式计算来说，情况并非如此: 远程组件可能失败，如果发生了部分失败、连接失败与远程处理器失败无法区分。\n\n\n\nWaldo 认为，如果想要实现统一对象模型，只有两条道路。\n\n\n\n1. 将所有对象视为本地对象\n2. 将所有对象视为远程对象。\n\n\n\n> **但最重要的问题不是“你能让远程方法调用看起来像本地方法调用吗？而是使远程方法调用与本地方法调用相同的代价是什么？**\n\n\n\n\n\n这是一个不能忽略的问题。\n\n\n\n\n\n> 到这里为止我们看到针对RPC 的讨论基本都是在讨论设计、实现、面向对象、性能、分布式问题如何解决。有一点好像被忽略了，那就是易用性。为什么呢？是因为当时的程序员喜欢复杂的技术么？\n>\n> \n>\n> 我以前老大有一次分享的时候说，他认为并不是所有的开发者都是合格的程序员，合格的程序员应该是像林纳斯、丹尼斯、蒂姆那样，尝试改变世界并且为之努力的人。互联网早期，开发者数量较少，程序员是一个相对小众精英的团体，这种程序员占得比例也大，协议制定的时候更多考虑的也是如何压榨计算机性能，易用性可能也不在第一优先级范围内。\n>\n> \n>\n> 而到了90年代后期，互联网已经开始普及，随着web 开发的兴起，开发者也以指数的速度增长，这时开发框架就不仅仅要考虑小部分人的使用体验而是要照顾大多数人的使用体验了。\n\n\n\n### 1996年：HTTP/1.x 版本发布\n\n\n\n1996 年，HTTP/1.0 版本发布，大大丰富了 HTTP 的传输内容，除了文字，还可以发送图片、视频等，这为互联网的发展奠定了基础。\n\n相比 HTTP/0.9，HTTP/1.0 主要有如下特性：\n\n-  请求与响应支持 HTTP 头，增加了状态码，响应对象的一开始是一个响应状态行\n-  协议版本信息需要随着请求一起发送，支持 HEAD，POST 方法\n-  支持传输 HTML 文件以外其他类型的内容\n\n在 HTTP/1.0 发布几个月后，HTTP/1.1 就发布了。HTTP/1.1 更多的是作为对 HTTP/1.0 的完善\n\n\n\n### 1997年：OMG发布CORBA2.0 \n\n\n\n1994年12月，CORBA 2.0 就已经发布规范，该规范希望能够解决不同厂商根据COBRA规范所开发的产品“互联互不通”的严重问题，但直到1997年，Corba2.0 才正式发布，但是最后还是失败了。至于COBRA失败的原因，COBRA阵营的技术大牛、COBRA技术的推动者，即后来加入反COBRA阵营的Michi Henning，在他的《The rise and fall of CORBA》书里做了如下深刻的总结。\n\n\n\n- **规范巨大而复杂**：许多特性都未曾被实现，甚至概念性的证明都没有做过；有些技术特性根本不可能实现，即使实现，也无法提供可移植性。\n- **CORBA学习曲线陡峭**：平台的学习曲线陡峭，技术复杂，不容易正确使用，这些因素导致开发周期长、易出错。早期的实现常常充满Bug并且缺乏有质量的文档，有经验的CORBA程序员稀缺。\n- **编程开发过于复杂**：有经验的CORBA开发者发现编写实用的CORBA应用程序相当困难。许多API都很复杂、不一致，甚至让人感觉神秘，使得开发者必须关注许多细节问题。相比之下，组件模型的简单性，例如同时代的EJB，使得编程简单很多。\n- **费用昂贵**：使用商用CORBA产品时，开发者一般都需要花费几千美元购买开发者License，此外，部署CORBA产品与部署Oracle数据库一样，还需要客户支付企业License费用，而且这个费用很可能与部署在CORBA平台上的应用数量挂钩，因此对很多潜在的客户来说，CORBA这样的平台太昂贵了。\n- **Sun与Java成为COBRA最大的竞争对手**：商业公司转向了Sun的Java与新兴的Web，并且开始构建基于Web浏览器、Java和EJB的电子商务基础设施。\n- **XML技术的兴起加速了COBRA的没落**：20世纪90年代后期，XML成为计算机工业新的银弹，几乎所有定义为XML的东西都是好的。在放弃了DCOM之后，微软并没有把电子商务市场留给竞争对手，没有再参与一场不可能打赢的战争，而是使用XML开辟了新的战场。\n\n\n\n> ### **2002年：ZeroC Ice 发布**\n>\n> \n>\n> 最初参与CORBA 的一批技术专家不满CORBA 的设计，另起炉灶打造了新的RPC---即 ZeroC Ice，ICE 最初的广告语为“反叛之冰”。它也一直延续至今，发展成了一个强大的微服务架构平台。\n\n\n\n\n\n### 1999年： SOAP 发布\n\n\n\n1998 年 XML 1.0 发布，被 W3C (World Wide Web Consortium) 推荐为标准的描述语言。同年，微软和DevelopMentor发布SOAP（Simple Object Access Protocol），随后提交给W3C作为标准。SOAP**是一个严格定义的信息交换协议，**使用XML作为RPC新的对象序列化机制，**用于在Web Service中把远程调用和返回封装成机器可读的格式化数据。**\n\n\n\n#### 协议约定\n\n\n\nSOAP 的协议约定用的是 WSDL (Web Service Description Language) ，这是一种 Web 服务描述语言，在服务的客户端和服务端开发者不用面对面交流，只要用的是 WSDL 定义的格式，客户端知道了 WSDL 文件，就知道怎么去封装请求，调用服务。\n\n\n\n#### 传输协议\n\n\n\nSOAP 是用 HTTP 进行传输的，信息有 Header 和 Body，SOAP 的请求和回复都放在消息中，进行传递。\n\n\n\n#### 服务发现\n\n\n\nSOAP 的服务发现用的是 **UDDI**（Universal Description, Discovery, Integration) 统一描述发现集成，相当于一个注册中心，服务提供方将 WSDL 文件发布到注册中心，使用方可以到这个注册中心查找。\n\n\n\nSOAP严格意义上是属于XML-RPC（XML Remote Procedure Call）技术的一个变种，一个XML-RPC请求消息就是一个HTTP-POST请求消息，其请求消息主体基于XML格式。客户端发送XML-RPC请求消息到服务端，调用服务端的远程方法并在服务端上运行远程方法。远程方法执行完毕后返回响应消息给客户端，其响应消息主体同样基于XML格式。远程方法的参数支持数字、字符串、日期等，也支持列表数组和其他复杂结构类型，SOAP是第一次真正成功地解决了多语言多平台支持的开放性RPC标准。\n\n\n\n不过SOAP也有很多不足：\n\n\n\n1. 效率低。因为报文基于XML，报文内容除了数据以外，还有很多荣冗余在格式的定义上，并且对于XML的序列化和反序列化解析速度也慢。\n2. 它脱离了简单的初衷，开始添加一层又一层脱离了简单方法调用的一些附加概念：添加了异常处理、 事务支持、安全性和数字签名，人们感觉 SOA 已经变成了一个复杂协议。\n\n\n\n这又和 Waldo 的经典结论保持了一致：\n\n\n\n**尝试让远程调用的行为像本地调用的代价是不可忽略的。**\n\n\n\n之后，大家开始慢慢抛弃SOAP标准中过程化、分层的概念，开始转向更简单的Rest传输方式。\n\n\n\n### 2000年：Roy Thomas Fielding 发表 RESTful 架构的博士论文\n\n\n\n2000年，[Roy Thomas Fielding](http://en.wikipedia.org/wiki/Roy_Fielding) 博士在他的博士论文 《[Architectural Styles and the Design of Network-based Software Architectures](https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm)》首次提出了 REST 这个词。\n\n\n\n> REST提供了一系列架构约束，当作为整体使用时，它强调组件交互的可扩展性、接口的通用性、组件的独立部署，以及那些能减少交互延迟的中间件，它强化了安全性，也能封装遗留系统。\n>\n> ​                         ---- Roy Fielding\n\n\n\nREST 不是协议而是一种使用HTTP 协议的进程间通信机制。REST非常简单，无需客户端stub 代码 和服务端 stub代码，且所有语言都可以集成实现。HTTP REST慢慢侵占了RPC大部分应用领地的“异类”，并且导致了一度盛行的XML-RPC的灭绝，但同时促进了正统RPC技术走向一个新的发展阶段，追求更高的性能及增加对多语言多平台的支持，成为越来越多的开源RPC框架的目标，典型的代表为Thrift、Apache Avro等新生的开源框架，这些框架在大数据系统、大型分布式系统及移动互联网应用方面被越来越多的公司使用。\n\n\n\n\n\n\n\n**2008年，Vinoski 在他的论文中提出了我们开头的提问：“开发者的便利性真的比正确性、可扩展性、性能、关注点分离、可扩展性和偶然复杂度更重要吗？”**\n\n\n\n我看先看下2020 年度语言排行榜，可能能得到一些答案：\n\n\n\n这张图是2020年开发者最爱的语言：\n\n![loved.png](http://media.gusibi.mobi/wFVum_ExBQVUuPT2tUcgwjCTXs7XJAFyfpU36aZO47tu70vBKP0TPIKkGS43JVuo)\n\n\n\n这张图是2020年最流行的语言\n\n![截屏2021-01-30 下午5.49.05.png](http://media.gusibi.mobi/sAqTnXotN05PxIqVBJA0C4WKQiofqWWg4AODSnQyPSJskW13yUOln-2OD9dnaTd4)\n\n\n\n> 为什么学习曲线陡峭、设计复杂的Rust 是程序员的最爱？\n>\n> 为什么易学易用但有各种语言缺陷的JavaScript 能成为最流行的语言呢？\n\n\n\n**开发者的便利性真的比正确性、可扩展性、性能、关注点分离、可扩展性和偶然复杂度更重要吗？**\n\n**\n**\n\n**从开发者的选择来看，答案应该是YES！**\n\n\n\n可以看到自90年代后期进入了web 开发的时代，web1.0、web2.0、web3.0 相继出现。以 http 为基础的请求/响应方案（XML、REST） 开始流行并占领了大部分的市场。RPC也开逐渐被开发者抛弃，进入了沉默期。\n\n\n\n当然，RPC 并没有消失，而是在特定的领域继续生长。比如：Sun 微系统的网络文件系统 (NFS) 就是建立在 RPC 之上，是最早获得普及的分布式文件系统之一。\n\n\n\n而随着互联网的指数扩张，微服务架构开始成了业界的“银弹”，分布式系统开始变的无处不在，基于HTTP的RESTful的缺点开始放大：\n\n1. 只支持请求/响应方式的通信\n2. 单个请求中获取多个资源具有挑战性\n3. 有时很难将更多操作映射到HTTP动词\n4. 基于JSON或者XML 的消息冗余严重，性能底下。\n\n\n\n而天生就是为分布式计算出现的RPC也开始重新走入开发者的视野。\n\n\n\n### 2008年：Google 开源 Protocol Buffer\n\n\n\nProtocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据序列化，很适合做数据存储或 RPC 数据交换格式。它可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。\n\n\n\n### 2008年：FaceBook 开源 thrift\n\n\n\nThrift 是一个跨语言的服务部署框架，最初由Facebook于2007年开发，2008年进入Apache开源项目。Thrift通过一个中间语言(IDL, 接口定义语言)来定义RPC的接口和数据类型，然后通过一个编译器生成不同语言的代码（目前支持C++,Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, Smalltalk和OCaml）,并由生成的代码负责RPC协议层和传输层的实现。\n\n\n\n> Thrift 和 Protocol Buffer 不同，它不仅仅是一个数据序列化工具，而是一个完整的RPC 框架。另一个不同点在于，Protobuf 标准化了单一的二进制编码方式，但Thrift 则包含了多种不同的序列化方式（Thirft 称之为协议）。\n\n\n\n### 2010年5月： Avro脱离Hadoop项目，成为Apache顶级项目。 \n\n\n\n[Avro](http://avro.apache.org/) 是一个基于二进制数据传输高性能的中间件，在2009年成为 Hadoop 中的一个子项目，并与2015年脱离Hadoop，加入Apache成为一个独立的项目。\n\n\n\nAvro 同样支持跨编程语言实现（C, C++, C#，Java, Python, Ruby, PHP），Avro 提供着与诸如 Thrift 和 Protocol Buffers 等系统相似的功能，但是在一些基础方面还是有区别的，主要是：\n\n1. 动态类型：Avro 并不需要生成代码，模式和数据存放在一起，而模式使得整个数据的处理过程并不生成代码、静态数据类型等等。这方便了数据处理系统和语言的构造。\n2. 未标记的数据：由于读取数据的时候模式是已知的，那么需要和数据一起编码的类型信息就很少了，这样序列化的规模也就小了。\n3. 不需要用户指定字段号：即使模式改变，处理数据时新旧模式都是已知的，所以通过使用字段名称可以解决差异问题。\n\n\n\nAvro 和动态语言结合后，读/写数据文件和使用 RPC 协议都不需要生成代码，而代码生成作为一种可选的优化只需要在静态类型语言中实现。\n\n当在 RPC 中使用 Avro 时，服务器和客户端可以在握手连接时交换模式。服务器和客户端有着彼此全部的模式，因此相同命名字段、缺失字段和多余字段等信息之间通信中需要解决的一致性问题就可以容易解决。\n\n还有，Avro 模式是用 JSON（一种轻量级的数据交换模式）定义的，这样对于已经拥有 JSON 库的语言可以容易实现。\n\n\n\n> 可以看到的是，avro 相对pb 和 thrift 来说更简单一点。\n\n\n\n### 2015年：HTTP/2.0 发布\n\n\n\n虽然 HTTP/1.1 已经优化了很多点，作为一个目前使用最广泛的协议版本，已经能够满足很多网络需求，但是随着网页变得越来越复杂，甚至演变成为独立的应用，HTTP/1.1 逐渐暴露出了一些问题：\n\n-  在传输数据时，每次都要重新建立连接，对移动端特别不友好\n-  传输内容是明文，不够安全\n-  header 内容过大，每次请求 header 变化不大，造成浪费\n-  keep-alive 给服务端带来性能压力\n\n\n\n在 2010 年到 2015 年，谷歌通过实践一个实验性的 SPDY 协议，证明了一个在客户端和服务器端交换数据的另类方式。其收集了浏览器和服务器端的开发者的焦点问题，明确了响应数量的增加和解决复杂的数据传输。SPDY 最终进化成了HTTP2.0 并与2015年发布。\n\nhttp2.0 有以下特点：\n\n- 使用二进制分帧层：在应用层与传输层之间增加一个二进制分帧层，以此达到在不改动 HTTP 的语义，HTTP 方法、状态码、URI 及首部字段的情况下，突破HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。在二进制分帧层上，HTTP2.0 会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，其中 HTTP1.x 的首部信息会被封装到 Headers 帧，而我们的 request body 则封装到 Data 帧里面。\n\n-  多路复用：对于 HTTP/1.x，即使开启了长连接，请求的发送也是串行发送的，在带宽足够的情况下，对带宽的利用率不够，HTTP/2.0 采用了多路复用的方式，可以并行发送多个请求，提高对带宽的利用率。\n\n-  数据流优先级：由于请求可以并发发送了，那么如果出现了浏览器在等待关键的 CSS 或者 JS 文件完成对页面的渲染时，服务器却在专注的发送图片资源的情况怎么办呢？HTTP/2.0 对数据流可以设置优先值，这个优先值决定了客户端和服务端处理不同的流采用不同的优先级策略。\n-  服务端推送：在 HTTP/2.0 中，服务器可以向客户发送请求之外的内容，比如正在请求一个页面时，服务器会把页面相关的 logo，CSS 等文件直接推送到客户端，而不会等到请求来的时候再发送，因为服务器认为客户端会用到这些东西。这相当于在一个 HTML 文档内集合了所有的资源。\n-  头部压缩：使用首部表来跟踪和存储之前发送的键值对，对于相同的内容，不会再每次请求和响应时发送。\n\n\n### 2015年：Google 开源gRPC\n\n\n\n2015 年，Google 将**gRPC**框架开源，gRPC 使用 PB 作为序列化的解决方案，而在传输的介质上使用了 HTTP/2而不是常见的TCP。gRPC 是一个多路复用、双向流式 RPC 协议。在一般的 RPC 机制中，客户端发起到服务器的连接，只有客户端可以请求，而服务器只能响应传入的请求。然而，在双向 gRPC 流中，虽然初始连接是由客户端发起的(称为端点1) ，但是一旦建立连接，服务器(称为端点2)和端点1都可以发送请求和接收响应。这极大地简化了两个端点相互通信的开发(如网格计算)。由于两个数据流都是独立的，这也省去了在端点之间创建两个独立连接的麻烦(一个从端点1到端点2，另一个从端点2到端点1)。![grpc_concept_diagram_00.png](http://media.gusibi.mobi/oS1I1Y0rCGWI_WHon15Cffe7a2bQeUWGekTcrfVldIzbNpa6PwY5dmzx9xEaalH_)\n\n\n\n\n## 总结\n\n\n\n- 分布式调用的历史比互联网的历史还要久远\n- RPC 的发展方向是易用性，异步\n- 易用性可能真的比扩展性、性能、关注点分离、可扩展性和偶然复杂度更重要\n- 让远程调用向本地调用一样的代价是不可忽略的\n\n\n\n\n\n\n\n### 参考链接：\n\n\n\n[CORBA](https://baike.so.com/doc/6881614-7099104.html)\n\n[Implementing Remote Procedure Calls 中文版](https://www.jianshu.com/p/91be39f72c74)\n\n[花了一个星期，我终于把RPC框架整明白了](https://developer.51cto.com/art/201906/597963.htm)\n\n[RPC原理详解](https://www.cnblogs.com/metoy/p/4321311.html)\n\n[理解Rest和Rpc](https://www.cnblogs.com/houkai/p/9772111.html)\n\n[谁能用通俗的语言解释一下什么是 RPC 框架？](https://www.zhihu.com/question/25536695)\n\n[什么是Rpc](https://www.jianshu.com/p/052913a386b7)\n\n[什么是Rpc](https://www.jianshu.com/p/7d6853140e13)\n\n[微服务通信](https://developer.ibm.com/zh/articles/j-cn-java-and-microservice-3/)\n\n[寻根溯源：微服务模式发展简史](https://developer.ibm.com/zh/articles/cl-evolution-microservices-patterns/)\n\nhttps://thrift.apache.org\n\nhttp://avro.apache.org\n\nhttps://insights.stackoverflow.com/survey/2020#overview",
      "data": {
        "title": "RPC 前世今生",
        "date": "2021-01-30 18:21:41",
        "tags": [
          "grpc",
          "后端",
          "微服务"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/rpc-history.jpg",
        "isTop": true
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "rpc-history"
    },
    {
      "content": "\n### 使用腾讯云 serverless 部署语雀飞书机器人\n\n> 1. 语雀很好用，但是没有App，无法通知\n> 2. 飞书群自定义机器人很方便，但是不知道用来干啥\n> 3. 腾讯云函数计算有免费额度，是不是可以利用一下？\n> 4. 那是不是可以把语雀的webhook 使用飞书通知，部署在腾讯云上呢？\n> 5. 好主意\n\n代码地址：[https://github.com/gusibi/yuque_webhook](https://github.com/gusibi/yuque_webhook)\n\n### 使用方式\n\n1. 在飞书群中添加自定义机器人，复制webhook 地址，拿到其中的 hook_id\n2. 执行代码build 中 scf_build.sh 脚本，得到 api.zip 包\n3. 在腾讯云云函数中创建云函数，\n    * 选择golang\n    * 选择本地zip 包\n    * 选择上一步生成的 api.zip\n    * 超时时间为3S\n    * 创建云函数\n4. 新建API网关服务\n    * 新建API\n    * 路径为 /api/webhook\n    * 请求方法为POST\n    * 免鉴权\n    * 后端配置，后端类型为云函数SCF\n    * 选择上一步创建的云函数\n    * 超时时间为3S\n    * 启用响应集成\n    * 响应结果返回类型为JSON\n    * 完成选择发布\n    * 从网关基础配置中拿到公网访问地址，host\n5. 打开想要添加webhook的语雀知识库\n    * 知识库设置，开发者，添加webhook，命名为飞书机器人\n    * URL为 host/api/webhook（这里host 为上一步得到的host地址，包含80 或者 443)\n    \nDONE\n",
      "data": {
        "title": "使用腾讯云 serverless 部署语雀飞书机器人",
        "date": "2020-12-27 22:24:41",
        "tags": [
          "工具"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": true
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "yuque_webhook_feishu"
    },
    {
      "content": "\n> 周末尝试做了鱼香肉丝，口味还不错\n\n## 材料\n\n猪肉（瘦肉）200g、青笋50g、干黑木耳10个、胡萝卜半根（50g）、\n葱一段（10cm）、姜10g、蒜半头、朝天椒3根、\n豆瓣酱、料酒、生抽、盐、糖、淀粉\n\n## 步骤\n\n1. 木耳用温水泡开（现在可以先处理肉）\n2. 瘦肉清水洗净切丝、加入生抽3勺（10g）、料酒2勺（10g）、盐一小勺（3g）、鸡精3g，蛋清（也可以是鸡蛋）一个 朝一个方向搅拌一分钟，然后加入淀粉一勺，腌制10分钟以上\n3. 蒜切成沫，姜切成沫、葱切沫\n4. 胡萝卜、青笋切丝\n5. 泡开的木耳切成小块\n6. 取小碗加入糖10g（喜欢甜可多加）、醋10g、生抽5g、料酒5g、盐3g（豆瓣酱比较咸也可以不加盐）、淀粉10g 勾兑成酱料备用（也可以加少量水，这样更容易搅拌）\n7. 大火热锅加油，放入腌制好的肉丝（因为肉丝有淀粉，建议用不粘锅，也可以多加油，小火），将肉丝炒成白色的肉条盛出备用\n8. 放入胡萝卜丝翻炒，加入一勺豆瓣酱（咸不要太多），加入木耳笋丝继续翻炒\n9. 半分钟后加入刚炒一半的肉丝，翻炒2分钟（时间可自己控制，注意控制火候\n10. 加入勾兑好的酱料，继续翻炒3分钟，然后收汁\n\n> 在炒的过程中注意试一下咸淡，可适量调整\n> 猪肉换成茄子就是鱼香茄子🤡",
      "data": {
        "title": "鱼香肉丝",
        "date": "2020-07-05 22:45:25",
        "tags": [
          "菜谱"
        ],
        "published": true,
        "hideInList": false,
        "feature": "http://media.gusibi.mobi/8s1pRa4Le83ziXdaK3ldcjHzcxv3fxSwuZpq8nLAGrL3p3cTrMiBGoIbk8yyajy4",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "yu-xiang-rou-si"
    },
    {
      "content": "\n\n### 介绍\n\n\nVuePress 是一个静态网站生成器，包含由Vue驱动的主题系统和插件API，同时还包含一个为书写技术文档而优化的默认主题。此篇文章只介绍如何使用VuePress 搭建个人博客的部分。\n\n### 安装\n\n\n> 前置条件：VuePress 需要 Node.js >= 8.6\n\n\n##### 安装 vuepress\n\nVuePress 安装毕竟简单，可以使用以下命令直接安装：\n\n```shell\nyarn add -D vuepress # npm install -D vuepress\n```\n\n\n\n#### 验证安装\n\n\n\n为了验证VuePress 的效果，首先创建一篇文档\n\n\n```shell\nmkdir docs && echo '# Hello VuePress' > README.md\n```\n\n\n在当前目录下创建 `package.json` 文件，添加以下内容：\n\n\n```json\n{\n  \"scripts\": {\n    \"dev\": \"vuepress dev docs\",\n    \"build\": \"vuepress build docs\"\n  }\n}\n```\n\n\n\n在本地启动服务器\n\n```shell\nvuepress dev .\n```\n\n\nVuePress 会在 [http://localhost:8080](http://localhost:8080/) 启动一个热重载的开发服务器。\n\n如果没有报错，可在浏览器打开[http://localhost:8080](http://localhost:8080/)，默认加载内容为 README.md 中内容。\n\n\n\n### VuePress 目录结构\n\n\nVuePress 遵循 **“约定优于配置”** 的原则，推荐的目录结构如下：\n\n\n\n```shell\n.\n├── blog\n│   ├── .vuepress (可选的)\n│   │   ├── components (可选的)\n│   │   ├── theme (可选的)\n│   │   │   └── Layout.vue\n│   │   ├── public (可选的)\n│   │   ├── styles (可选的)\n│   │   │   ├── index.styl\n│   │   │   └── palette.styl\n│   │   ├── templates (可选的, 谨慎配置)\n│   │   │   ├── dev.html\n│   │   │   └── ssr.html\n│   │   ├── config.js (可选的)\n│   │   └── enhanceApp.js (可选的)\n│   │ \n│   ├── README.md\n│   └──_post\n│       ├── about.md\n│       └── README.md \n│ \n└── package.json\n```\n\n\n\n这里`blog`目录被称作 `targetDir` ，目录下的文件都是相对于 `blog` 目录的。比如此目录下文件的路由地址如下：\n\n\n\n| 文件相对路径     | 页面路由地址      |\n| ---------------- | ----------------- |\n| /README.md       | /                 |\n| /_post/README.md | /_post/           |\n| /_post/about.md  | /_post/about.html |\n\n\n\n### 基本配置\n\n\n\n现在 VuePress 已经可以运行，现在添加一些基本的配置。首先在当前目录下创建 `.vuepress` 目录（所有 VuePress 相关的文件都放在此目录下），然后在 `.vuepress` 目录下创建 `config.js` 文件（也可以使用YAML (`.vuepress/config.yml`) 或是 TOML (`.vuepress/config.toml`) 格式的配置文件）。\n\n\n\n添加以下配置到config.js：\n\n\n\n```javascript\nmodule.exports = {\n  title: '顾斯比',  // 网站的标题，它将会被用作所有页面标题的前缀。\n  description: '顾斯比的博客', // 网站的描述，它将会以 <meta> 标签渲染到当前页面的 HTML 中。\n}\n```\n\n####  \n\n其它详细配置参考官方文档：https://vuepress.vuejs.org/zh/config/\n\n\n\n### 主题\n\n因为是使用 `VuePress` 作为静态博客使用，需要替换掉默认的主题。这里使用官方主题： `@vuepress/theme-blog` 。\n\n#### 安装\n\n\n```shell\nyarn add @vuepress/theme-blog -D\n# OR npm install @vuepress/theme-blog -D\n```\n\n\n#### 使用&配置\n\n\n在config.js 中添加主题相关配置：\n\n```javascript\n // .vuepress/config.js\nmodule.exports = {\n  title: '顾斯比',\n  description: '顾斯比的博客 gusibi goodspeed',\n  theme: '@vuepress/blog',\n  themeConfig: {\n     nav: [     // 导航条相关配置\n            { text: '首页', link: '/' },\n            { text: '标签', link: '/tag/'},\n            { text: '关于 ', link: '/about/' },\n            { text: 'github ', link: 'https://github.com/gusibi/', target:'_blank' },\n        ],\n        /**\n       * Ref: https://vuepress-theme-blog.ulivz.com/config/#globalpagination\n       */\n        globalPagination: {\n          lengthPerPage: 10,\n        },\n\n        /**\n         * Ref: https://vuepress-theme-blog.ulivz.com/config/#sitemap\n         */\n        sitemap: {\n            hostname: 'http://blog.gusibi.mobi/'\n        },\n  }\n}\n```\n\n\n\n#### 目录\n\n\n\n默认情況下，所有内容都必须放在 `_posts` 目录內，文件名为`标题.md`，例如`about.md`。\n\n```shell\n└── _posts\n    ├── ...\n    └── about.md\n```\n\n\n\n\n\n#### 博客内容设置\n\n\n\nFront matter 是用于指定博客文件的变量，必须放在博客文件的最上方。并且必须采用在三点划线之间书写的有效的 YAML。 这是一个基本的例子：\n\n\n\n```yaml\n---\ntitle: Blogging Like a Hacker # 博客标题\ndate: 2020-06-14              # 博客发布日期\ntags:                         # 文章标签\n    - 前端\n  - dart\n  - flutter\n  - vue\nsummary: 这里是文章的摘要\n---\n```\n\n####  \n\n其它变量：https://vuepress.vuejs.org/zh/guide/frontmatter.html\n\n\n\n##### URL\n\n默认情况下，path 路径则为文件目录的相对路径，比如：\n\n```shell\n├── package.json\n└── source\n    ├── _post\n    │   └── intro-vuepress.md\n    ├── index.md\n    └── tags.md\n```\n\n\n\n那么你就会获得以下的可用页面：\n\n```shell\n/source/\n/source/tags.html\n/source/_post/intro-vuepress.html\n```\n\n\n\n推荐使用 `permalink` 指定文章的永久链接，可以使用全局配置来向所有页面应用永久链接：\n\n```JavaScript\n// .vuepress/config.js\nmodule.exports = {\n  permalink: \"/:year/:month/:day/:slug\"\n};\n```\n\n另外，你也可以只为单独一个页面去设置永久链接。这种方式比全局配置拥有更高的优先级。\n\n📝 **hello.md**:\n\n```yaml\n---\ntitle: Hello World\npermalink: /hello-world\n---\nHello!\n```\n\n\n\n##### 内容\n\n\n\n博客内容格式为 markdown，markdown 语法参考：https://www.markdownguide.org/\n\n### 插件\n\n\n\n#### 搜索\n\n\n\n`VuePress` 内置搜索，可以通过设置 `themeConfig.search: false` 来禁用默认的搜索框，或是通过 `themeConfig.searchMaxSuggestions` 来调整默认搜索框显示的搜索结果数量：\n\n\n\n```\nmodule.exports = {\n  themeConfig: {\n    search: false,\n    searchMaxSuggestions: 10\n  }\n}\n```\n\n你可以通过[在页面的 frontmatter 中设置 `search`](https://vuepress.vuejs.org/zh/guide/frontmatter.html#search) 来对单独的页面禁用内置的搜索框：\n\n```\n---\nsearch: false\n---\n```\n\n\n**⚠️提示**\n\n**内置搜索只会为页面的标题、****`h2`** **、** **`h3`** **以及** **`tags`** **构建搜索索引。 如果你需要全文搜索，你可以使用** [**Algolia 搜索**](https://vuepress.vuejs.org/zh/theme/default-theme-config.html#algolia-搜索)**。**\n\n\n#### google-analytics\n\ngoogle-analytics是著名互联网公司Google为网站提供的数据统计服务。可以对目标网站进行访问数据统计和分析，并提供多种参数供网站拥有者使用。这里推荐安装：\n\n##### 安装\n\n使用以下命令安装\n\n```\nyarn add -D @vuepress/plugin-google-analytics\n# OR npm install -D @vuepress/plugin-google-analytics\n```\n\n\n##### 使用\n\n将ga 配置添加到配置文件\n\n```JavaScript\nmodule.exports = {\n  plugins: [\n    [\n      '@vuepress/google-analytics',\n      {\n        'ga': '' // UA-00000000-0\n      }\n    ]\n  ]\n}\n```\n\n\n更多配置参考文档：https://vuepress.vuejs.org/zh/theme/default-theme-config.html\n\n\n#### RSS\n\n\n`vuepress` 包含rss 插件，可以直接在配置中添加以下内容启用：\n\n```JavaScript\nmodule.exports = {\n    ...\n    themeConfig: {\n      ...\n      feed: {\n         canonical_base: 'http://blog.gusibi.mobi/',\n      },\n    },\n  };\n```\n\n\n\n### 部署到Github\n\n\n1. 在 docs/.vuepress/config.js 中设置正确的 base。\n\n\n> 如果你打算发布到 https://.github.io/，则可以省略这一步，因为 base 默认即是 \"/\"。\n\n\n1. 在你的项目中，创建一个如下的 `deploy.sh` 文件:\n\n\n```\n#!/usr/bin/env sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件\nvuepress build --dest ./public\n\n# 进入生成的文件夹\ncd public\n\n# 如果是发布到自定义域名\n# echo 'blog.gusibi.mobi' > CNAME\n\ngit add -A\ngit commit -m 'deploy'\n\n# 发布到 https://<USERNAME>.github.io\ngit push -f git@github.com:gusibi/gusibi.github.io.git master\n\n# 如果发布到 https://<USERNAME>.github.io/<REPO>\n# git push -f git@github.com:<USERNAME>/<REPO>.git master:gh-pages\n\ncd -\n```\n\n> 也以使用github ci 在每次提交代码的时候自动部署到github.io，具体步骤可以自行搜索配置\n\n\n###  \n\n### 参考链接\n\n\n1. Intro to VuePress 1.x： https://ulivz.com/2019/06/09/intro-to-vuepress-1-x/\n2. 默认主题配置： https://vuepress.vuejs.org/zh/theme/default-theme-config.html\n3. https://www.markdownguide.org/\n4. VuePress front matter 配置： https://vuepress.vuejs.org/zh/guide/frontmatter.html\n5. VuePress 配置： https://vuepress.vuejs.org/zh/config/\n\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/WDz3v4cU4LQq1oyKX-fYK1LxIThzZ1hK931ZaPRC8CdcB0t2oTYJciMDuAws70FY)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)\n",
      "data": {
        "title": "使用VuePress 搭建个人博客",
        "date": "2020-06-14 07:48:04",
        "tags": [
          "教程",
          "tutorial"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "vuepress-build-blog-to-github"
    },
    {
      "content": "\n[[TOC]]\n\n## 祈祷式编程\n\n### 祈祷式编程\n\n如果代码中包含以下代码\n\n![](http://media.gusibi.mobi/hZPxabAhNvjs0RBsFX2UYcWceM6hASMsuiUtsNRI1zcC_cARLqu_flemSEpRdHT2)\n\n或者上线后进行这种活动\n\n![](http://media.gusibi.mobi/vgTOaVcTBjWjIDs7hL3XA388F7gZvklpH5UjwqpuePotN3Q5NcHJ1PecTn50Um2m)\n\n那么这种编程方式就是祈祷式编程。\n\n\n用流程图表示基本就是这个样子。\n\n![](http://media.gusibi.mobi/ZEkOQqFT-JnOR9YJ9FVhLEgptWS73yo2XYO19M_Yz0X1MZOhQtCjjLXA1XFiekCG)\n\n祈祷式编程有什么危害呢？\n\n1. 累，每次写完代码还需要再祈祷\n2. 不受控，代码运行结果主要看运气，大仙忙的时候可能保佑不了\n\n解决这个问题有好多种方法，单元测试是其中之一。\n\n## 单元测试\n\n### 什么是单元测试\n\n> 单元测试是由开发人员编写的，用于对软件基本单元进行测试的可执行的程序。\n> 单元（unit）是一个应用程序中最小的课测试部分。（比如一个函数，一个类\n\ngoogle 把测试分成小型测试、中型测试和大型测试。单元测试基本和小型测试的作用类似，但是通常也会使用mock或者stub 的方式模拟外部服务。\n\n![](http://media.gusibi.mobi/Wn7YW9mDHRpI_3DO2eVFdk1Xx-s_jw5iJogwT0G7ED2UFpXsCYaTqICzqButt02I)\n\n\n理想情况下，单元测试应该是相互独立、可自动化运行的。\n\n**目的：** 通常用单元测试来验证代码逻辑是否符合预期。完整可靠的单元测试是代码的`安全网`，可以在代码修改或重构时验证业务逻辑是否正确，提前发现代码错误，减少调试时间。设计良好的单元测试某些情况下可以比文档更能反应出代码的功能和作用。\n\n单元测试这么多优点为什么有人不喜欢写单元测试呢？\n\n1. 单元测试太费时间了，对于编写单元测试不熟练的新手来说，编写单元测试可能比写代码的还费时间\n2. 单元测试运行时间太长（这通常是单元测试设计不合理或者代码可测试性较差造成的\n3. 祖传代码，看都看不懂怎么写单元测试（这个确实优点棘手。。可以考虑先给新代码加单元测试\n4. 不会写单元测试\n\n这篇文章主要关注第四个问题，如何写单元测试。\n\n### 单元测试的结构\n\n首先看一下单元测试的结构，一个完整的单元测试主要包括**Arrange-Act-Assert（3A）** 三部分。\n\n* Arrange--准备数据\n* Act--运行代码\n* Assert--判断结果是否符合预期\n\n比如我们要给下面这段代码（golang）加单元测试：\n\n```go\n\nfunc Add(x, y int) int {\n\treturn x + y\n}\n\n```\n\n单元测试代码如下：\n\n```go\nimport \"testing\"\n\nfunc TestAdd(t *testing.T) {\n    // arrange 准备数据\n\tx, y := 1, 2\n    // act   运行\n\tgot := Add(x, y)\n    //assert  断言\n\tif got != 3 {\n\t\tt.Errorf(\"Add() = %v, want %v\", got, 3)\n\t}\n}\n```\n\n### 如何编写好的单元测试\n\n> 什么样的单元测试才是好的单元测试呢？\n\n先看一个例子：\n\n\n```go\npackage ut\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc isNumber(num string) (int, error) {\n\tnum = strings.TrimSpace(num)\n\tn, err := strconv.Atoi(num)\n\treturn n, err\n}\n\nfunc multiply(x string, y int) string {\n    // 如果x 去除前后的空格后是数字，返回 数字的乘积\n    //     比如 x=\"2\" y=3 return \"6\"\n    // 如果x 去除前后的空格后不是数字，则返回字符串的x的y倍 \n    //     比如 x=\"a\" y=2 return \"aa\"\n\tnum, err := isNumber(x)\n\tif err == nil {\n\t\treturn fmt.Sprintf(\"%d\", num*y)\n\t}\n\tresult := \"\"\n\tfor i := 0; i < y; i++ {\n\t\tresult = fmt.Sprintf(\"%s%s\", result, x)\n\t}\n\treturn result\n}\n```\n\n测试代码可能是这个样子。\n\n```go\n\n// 测试方法的名字不直观，并不能看出具体要测试什么\nfunc Test_multiply(t *testing.T) {\n\ttype args struct {\n\t\tx string\n\t\ty int\n\t}\n    // 一个测试方法中有太多的测试用例\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant string\n\t}{\n\t\t{\n\t\t\t\"return nil\",\n\t\t\targs{\n\t\t\t\t\"\",\n\t\t\t\t2,\n\t\t\t},\n\t\t\t\"\",\n\t\t},\n\t\t{\n\t\t\t\"return 2\",\n\t\t\targs{\n\t\t\t\t\"1\",\n\t\t\t\t2,\n\t\t\t},\n\t\t\t\"2\",\n\t\t},\n\t\t{// 测试数据有点奇葩，不直观\n\t\t\t\"return aaa\",\n\t\t\targs{\n\t\t\t\t\"aaaaaaaaaa\",\n\t\t\t\t6,\n\t\t\t},\n\t\t\t\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := multiply(tt.args.x, tt.args.y); got != tt.want {\n               // 数据错误的时候有明确标明测试数据，期望结果和实际结果，这一点还是有用的\n\t\t\t\tt.Errorf(\"multiply() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\n```\n\n这个单元测试代码有什么问题呢？\n\n1. 代码比较长（这里只列出来了三个用例，实际上并没有完整覆盖全部结果）\n2. 测试方法如果出错了并不容易定位位置(三个测试数据都在一个方法，任何一个错误都会指向到同一个位置\n3. 有个测试的数据比较长，不太能直观判断测试数据是否正确\n4. 输入值并不完整，比如包含空格的数字字符串\" 1\" 、\" 1 \"、 \"1 \"并没有测试。\n\n\n结合上面我们对**单元测试目的**的描述，**一个好的单元测试应该满足以下几个条件**：\n\n1. 单元测试越简单越好，一个单元测试只做一件事\n2. 对错误易于追踪，如果测试失败，错误提示应该容易帮我我们定位问题\n3. 测试函数的命名符合特定的规则 `Test_{被测方法}_{输入}_{期望输出}`\n4. 有用的失败消息\n5. 输入简单且能够完整运用代码的输入(包含边界值、特殊情况\n\n比如，上边的单元测试我们改成这样：\n\n```go\n// 测试特殊值 “空字符串”\nfunc Test_multiply_empty_returnEmpty(t *testing.T) {\n    // 用例简单，只包含输入、执行和判断 \n\tx, y, want := \"\", 1, \"\"\n\tgot := multiply(x, y)\n\tif got != want {\n       // 有效的失败消息\n\t\tt.Errorf(\"multiply() = %v, want %v\", got, want)\n\t}\n}\n\n// 测试包含空格的数字 边界值\nfunc Test_multiply_numberWithSpace_returnNumber(t *testing.T) {\n\tx, y, want := \" 2\", 3, \"6\"\n\tgot := multiply(x, y)\n\tif got != want {\n\t\tt.Errorf(\"multiply() = %v, want %v\", got, want)\n\t}\n}\n// 测试正常数据\nfunc Test_multiply_number_returnNumber(t *testing.T) {\n\tx, y, want := \"2\", 3, \"6\"\n\tgot := multiply(x, y)\n\tif got != want {\n\t\tt.Errorf(\"multiply() = %v, want %v\", got, want)\n\t}\n}\n// 测试非数字字符 \nfunc Test_multiply_String_returnString(t *testing.T) {\n    // 输入简单的字符串就可以测试，没必要用太奇怪或者太长或者太大的数据数据\n\tx, y, want := \"a\", 3, \"aaa\"\n\tgot := multiply(x, y)\n\tif got != want {\n\t\tt.Errorf(\"multiply() = %v, want %v\", got, want)\n\t}\n}\n// 测试空格 边界值\nfunc Test_multiply_space_returnSpace(t *testing.T) {\n\tx, y, want := \" \", 3, \"   \"\n\tgot := multiply(x, y)\n\tif got != want {\n\t\tt.Errorf(\"multiply() = %v, want %v\", got, want)\n\t}\n}\n```\n\n当然这个数据也并不完整，还可以再加入：\n\n* 包含空格的非数字字符\n* 数字右侧包含空格的字符串\n* 数字两侧都有空格的字符串\n\n既然好的单元测试需要能完整的测试代码，那么有什么方法可以保证单元测试可以完整覆盖被测代码呢？\n\n基于代码路径进行分析编写单元测试是一个方法。\n\n#### 单元测试路径\n\n设计测试路径时可以使用流程图的方式来分析，拿上边`multiply`的例子进行分析，这段代码的路径如下：\n\n![](http://media.gusibi.mobi/D-Ve2XrZs8zq4sRpVcRv4quYrcv0X2bVJHlcCUNoxZuoL6Cy3HIV4tsiYBUOorKA)\n\n当然，每个路径的测试数据并不是只有一种，比如`x为前后包含空格的数字字符串`这个路径中就包含三种情况：\n\n* 左边有空格\n* 右边有空格\n* 两边都有空格\n\n#### 单元测试数据\n\n合理的设计测试数据非常重要，测试除了符合上边说的要简单直观以外还要着重考虑边界值。\n\n设计测试数据通常是把可能的输入数据分成多个子集，然后从每个子集中选取具有代表性的数据作为测试用例。\n比如一段代码的作用是计算个税，我们就应该按照个税不同的等级来设计测试数据，比如：\n\n* 年收入0-36000部分\n* 年收入36000-144000 部分\n* 年收入144000-300000部分\n* 年收入300000-420000部分\n* ...\n\n\n然后在这个子集的基础上在针对边界值做一些检查，比如36000、144000 等。\n\n### 私有方法如何测试\n\n通常情况下，如果私有方法在公有方法中有被调用，通过测试公有方法就已经可以间接测试到私有方法。\n\n也有些私有方法写的不合理，比如私有方法没有被使用或者私有方法的功能和类的相关性不大，这个时候就建议把私有方法单独提取成新的函数或者类来测试。\n\n### 外部服务如何测试\n\n当然现实世界中的代码并不会这么简单，通常都会包含外部请求或者对于其它类的调用。\n在编写单元测试时，对于外部依赖我们通常使用Mock和Stub的方式来模拟外部依赖。\n\nMock和Stub 的区别：\n\n![](http://media.gusibi.mobi/qS_I1IXOCN1KJSbqD0TucScwusxpXW6C2V9_dewdTniGhvvuw5e1MlaWR7mzew2k)\n\n* Mock是在测试代码中创建一个模拟对象，模拟被测方法的执行。测试使用模拟对象来验证结果是否正确\n\n![](http://media.gusibi.mobi/n8_BO2UKcDLlUQ6atxb7CaZ6ndGpuwA_ewjxj_QdCb9LuRLhDsC7UNWr4wLD2wTW)\n\n* Stub是在测试包中创建一个模拟方法，用于替换被测代码中的方法，断言针对被测类执行。\n\n下面是代码示例：\n\n#### Mock\n\n实际代码：\n\n```go\n//auth.go\n//假设我们有一个依赖http请求的鉴权接口\ntype AuthService interface{    \n    Login(username string,password string) (token string,e error)   \n    Logout(token string) error\n}\n```\nMock代码：\n```go\n//auth_test.go\ntype authService struct {}\nfunc (auth *authService) Login (username string,password string) (string,error){\n    return \"token\", nil\n}\nfunc (auth *authService) Logout(token string) error{    \n    return nil\n}\n\n```\n\n在测试代码中使用 authService实现了AuthService 接口，这样测试时可以模拟外部的网络的请求，解除依赖。\n\n\n> 这里使用的是golang 代码，golang 不支持重载，这样使用的问题是会产生大量重复的代码。\n> 如果是python、java等支持重载的面向对象语言，可以简单的继承父类，只重载包含外部请求的代码就可以实现Mock的需求。\n\n#### Stub\n\n\n```go\npackage ut\n\nfunc notifyUser(username string){\n\t// 如果是管理员，发送登录提醒邮件\n}\n\ntype AuthService struct{}\n\nfunc (auth *AuthService) Login(username string, password string) (string, error) {\n    notifyUser(username)\n\treturn \"token\", nil\n}\nfunc (auth *AuthService) Logout(token string) error {\n\treturn nil\n}\n```\n\n\n对于这段代码想要测试其实是比较困难的，因为Login 中调用了notifyUser，如果想测试这段代码：\n* 一个方式是使用Mock的形式，定义authService 接口，然后实现接口 TestAuthService，在 TestAuthService Login中 替换掉notifyUser。这种做法改动比较大，同时重复代码也比较多（当然如果是python java等支持重载的语言可以只重载Login接口即可。\n* 还有一种方法就是重构Login方法，把notifyUser 作为参数传入其中，这样，我们只需在测试代码中重新定义notifyUser，然后作为参数传入到Login即可模拟发送邮件提醒的功能。\n\n第二种就是stub 的方式。\n\n通过这个例子我们也可以看到，如果想要代码容易测试，代码在设计时就应该考虑可测试性。\n\n### 编写可测试代码\n\n> Writing Testable Code 中提到一个非常实用的观点：在开发时，多想想如何使得自己的代码更方便去测试。如果考虑到这些，那么通常你的代码设计也不会太差。\n\n如果代码中出现了以下情况，那么通常是不易于测试的：\n\n1. 在构造函数或成员变量中出现new关键字\n2. 在构造函数或成员变量中使用static方法\n3. 在构造函数中有除了字段赋值外的其它操作\n4. 在构造函数中使用条件语句或者循环\n5. 在构造函数中没有使用builder或factory方法，二十使用object graph来构造\n6. 增加或使用初始化代码\n\n这篇文章地址为：http://misko.hevery.com/attachments/Guide-Writing%20Testable%20Code.pdf 推荐阅读。\n\n> 也可以在公号回复 「test」 获取pdf\n\n## 总结\n\n总结一下就是编写可测试代码，使用高质量单元测试（命名清晰、功能简单、路径完整、数据可靠）保证代码质量。\n\n## 参考文章\n\n* [搞定Go单元测试（一）——基础原理](https://juejin.im/post/5ce93447e51d45775746b8b0)\n* [Guide Writing Testable Code](http://misko.hevery.com/attachments/Guide-Writing%20Testable%20Code.pdf)\n* [Selective Unit Testing – Costs and Benefits](http://blog.stevensanderson.com/2009/11/04/selective-unit-testing-costs-and-benefits/)\n* [版本上线拜哪个神仙比较灵验？](https://www.zhihu.com/question/52985744)\n\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n",
      "data": {
        "title": "学习单元测试，告别祈祷式编程",
        "date": "2019-10-07 01:48:04",
        "tags": [
          "golang",
          "tutorial"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "unit-test"
    },
    {
      "content": "\n1. Docker 终端UI： [https://github.com/jesseduffield/lazydocker](htps://github.com/jesseduffield/lazydocker)\n\n![](http://media.gusibi.mobi/demo3.gif)\n\n2. 宝数据库内核月报：[http://mysql.taobao.org/monthly/](htp://mysql.taobao.org/monthly/)\n\n比较深入的数据库源码分析\n\n3. 手机号码归属地查询：https://apis-mp.gusibi.mobi/mobile/location?mobile=18512345678\n\n使用serverless部署，无需服务器。源码地址：[https://github.com/gusibi/oneplus/tree/master/mobile-attribution](https://github.com/gusibi/oneplus/tree/master/mobile-attribution)\n\n\n4. 手绘风格CSS：[https://www.getpapercss.com/](https://www.getpapercss.com/)\n\n![6336b6d107a91081d7abb93525425bd6.png](evernotecid://49E50F6F-983A-4D9E-90FA-7763241410D1/appyinxiangcom/8460937/ENResource/p5740)\n![](http://media.gusibi.mobi/%E6%89%8B%E7%BB%98css.png)\n\n5. Image-to-Image Demo： [https://affinelayer.com/pixsrv/](https://affinelayer.com/pixsrv/)\n\n6. 学霸用左边，学渣用右边：[https://www.plainlanguage.gov/guidelines/words/use-simple-words-phrases/](https://www.plainlanguage.gov/guidelines/words/use-simple-words-phrases/)\n\n> 美国政府的一个网页，有几百条单词建议，指导你怎么写出简单的文章，不要用复杂的单词。\n\n比如说，“a和b可以同时使用，也可以单独使用”，不要用 a and/or b，而要用 a or b or both。\n\n7. 微软上线了一套 Python 教程[《Develop with Python on Windows》](https://docs.microsoft.com/zh-cn/windows/python/)\n\n微软上线了一套 Python 教程《Develop with Python on Windows》。\n\n8. 百度网盘下载器：[https://github.com/b3log/baidu-netdisk-downloaderx](https://github.com/b3log/baidu-netdisk-downloaderx)\n\n 一款图形界面的百度网盘不限速下载器，支持 Windows、Linux 和 Mac。 \n\n\n## 参考链接\n\n[1] 《Develop with Python on Windows》: https://docs.microsoft.com/zh-cn/windows/python/\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "每周分享第4期",
        "date": "2019-08-04 10:05:15",
        "tags": [
          "每周分享",
          "python",
          "教程",
          "工具"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "weekly-04"
    },
    {
      "content": "\n* [【资料】史上最全的编程学习资料合集（持续更新）](https://github.com/toutiaoio/weekly.manong.io)\n* [【资料】一周 GitHub 开源项目推荐：阿里、腾讯、陌陌、bilibili……](https://mp.weixin.qq.com/s/eYn1buoKXOCNgRv2-coDmA)\n* [【资料】常用的 Go 框架、库和软件中文收录大全](https://juejin.im/post/5d14a319e51d4577407b1d77)\n* [【教程】高性能 Go 代码工坊](https://dave.cheney.net/high-performance-go-workshop/gopherchina-2019.html)（英文）\n* [【文章】我用了10年 从深圳流水线厂妹做到纽约高薪程序员](https://mp.weixin.qq.com/s/tv6S0VmDtbdSW8-qKjERiA)\n* [【文章】2009年最热门的 iPhone 应用程序](https://www.fastcompany.com/90356079/whatever-happened-to-the-hottest-iphone-apps-of-2009)（英文）\n> 苹果公司的应用商店即将满十周年，本文回顾了2009年最热门的付费应用和免费应用\n* [【语言】v语言-语法综合了python和go](https://github.com/vlang/v)\n* [【工具】weixin python sdk 支持小程序云开发](https://github.com/gusibi/python-weixin)\n* [【工具】网站收录了估值达到 10 亿美元的创业公司，实时更新](https://dujiaoshou.io/)\n* [【工具】简洁的 Mac 图床客户端 uPic](https://github.com/gee1k/uPic)\n\n### References\n\n[1] 【资料】史上最全的编程学习资料合集（持续更新）: https://github.com/toutiaoio/weekly.manong.io\n[2] 【资料】常用的 Go 框架、库和软件中文收录大全: https://juejin.im/post/5d14a319e51d4577407b1d77\n[3] 【教程】高性能 Go 代码工坊: https://dave.cheney.net/high-performance-go-workshop/gopherchina-2019.html\n[4] 【文章】2009年最热门的 iPhone 应用程序: https://www.fastcompany.com/90356079/whatever-happened-to-the-hottest-iphone-apps-of-2009\n[5] 【语言】v语言-语法综合了python和go: https://github.com/vlang/v\n[6] 【工具】weixin python sdk 支持小程序云开发: https://github.com/gusibi/python-weixin\n[7] 【工具】网站收录了估值达到 10 亿美元的创业公司，实时更新: https://dujiaoshou.io/\n[8] 【工具】简洁的 Mac 图床客户端 uPic: https://github.com/gee1k/uPic\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "每周分享第3期-史上最全的编程学习资料合集",
        "date": "2019-06-29 10:05:15",
        "tags": [
          "每周分享",
          "python",
          "教程",
          "工具"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "weekly-03"
    },
    {
      "content": "\n1 宇宙模拟器 ：[http://spaceengine.org](http://spaceengine.org)\n2 APIJSON：[https://github.com/APIJSON/APIJSON](https://github.com/APIJSON/APIJSON)\n\n> APIJSON是一种为API而生的 JSON网络传输协议 以及 基于这套协议实现的ORM库。\n> 后端接口和文档自动化，前端(客户端) 定制返回JSON的数据和结构\n\n3 【文章】小火箭对SpaceX星链计划低轨巨型星座的分析：[https://mp.weixin.qq.com/s/NNmI_cqwo4ba0ViJ9O7f3Q](https://mp.weixin.qq.com/s/NNmI_cqwo4ba0ViJ9O7f3Q)\n> 这篇对SpaceX 星链计划 可行性进行了详细的分析，共11575字，101图。预计阅读时间：1小时15分钟\n\n4 微软与 Google 共同开设的量子算法课程：[https://brilliant.org/courses/quantum-computing/](https://brilliant.org/courses/quantum-computing/)\n\n> 通过浏览器模拟的量子计算环境，学习量子算法\n\n5 一个VPS搜索工具: [https://anothervps.com/vps/](https://anothervps.com/vps/)\n> 可怜我linode 都用不了了\n\n6 一些有趣的网站：\n  * https://www.ctolib.com Github开源项目收集网站\n  * http://www.nicetool.net 实用工具比较多\n  * http://www.mvyxws.com/ 以视频方式分享医学知识的网站\n  * https://www.tikitiki.cn 自由的音乐，能够试听并下载全网音乐\n  * https://showmore.com/zh/ 在线录制屏幕的工具\n  * https://weibomiaopai.com 视频下载\n\n7 PySnooper：[https://github.com/cool-RR/PySnooper](https://github.com/cool-RR/PySnooper)\n> python DeBug工具\n\n8 pyecharts：[https://github.com/pyecharts/pyecharts](https://github.com/pyecharts/pyecharts)\n> Echarts 是一个由百度开源的数据可视化，pycharts 是Echarts 的python版。\n\n9 LeetCodeAnimation：[https://github.com/MisterBooo/LeetCodeAnimation](https://github.com/MisterBooo/LeetCodeAnimation)\n> 用动画的形式呈现解LeetCode题目的思路\n\n10 ColorUI：[https://www.color-ui.com/](https://www.color-ui.com/)\n> 鲜亮的高饱和色彩，专注视觉的小程序组件库\n\n\niPhone X怎么强制关机？\n\niPhone X强制关机有三步：\n1. 按下音量+键然后松开；\n2. 按下音量-键然后松开；\n3. 之后按住侧边按钮（即电源键）直到iPhone X黑屏。\n\n> 升级了iOS13，打电话的时候就停留在了通话界面，再也退不出去了。。只能用强制关机的方式。\n> 才知道是这么个方式\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "每周分享第2期-宇宙模拟器",
        "date": "2019-06-22 10:05:15",
        "tags": [
          "每周分享",
          "python",
          "教程",
          "工具"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "weekly-02"
    },
    {
      "content": "\n在stackoverflow 看到一个问题，[Redis strings vs Redis hashes to represent JSON: efficiency?](https://stackoverflow.com/questions/16375188/redis-strings-vs-redis-hashes-to-represent-json-efficiency)内容如下：\n\n> I want to store a JSON payload into redis. There's really 2 ways I can do this:\n>\n> 1. One using a simple string keys and values.\n>\n>    key:user, value:payload (the entire JSON blob which can be 100-200 KB)\n>\n>    SET user:1 payload\n>\n> 2. Using hashes\n> \n>     HSET user:1 username \"someone\"\n>     HSET user:1 location \"NY\"\n>     HSET user:1 bio \"STRING WITH OVER 100 lines\"\n> \n> Keep in mind that if I use a hash, the value length isn't predictable. They're not all short such as the bio example above.\n> Which is more memory efficient? Using string keys and values, or using a hash?\n\n### string 和 hash 直观测试\n\n首先我们先测试用数据测试一下，测试数据结构如下：\n\n\n\n```json\nvalues = {\n    \"name\": \"gs\",\n    \"age\": 1\n}\n```\n\n\n\n使用for 生成10w个key，key的生成规则为：\n\n\n\n```python\nfor i in range(100000):\n    key = \"object:%d\" % i\n```\n\n\n\n把数据分别以hash 和 string（values 使用 json encode 为string ）的形式存入redis。\n\n结果如下：\n\n\n\n>  hash 占用 10.16M\n>\n> string 占用 10.15M\n\n\n\n**这看起来和我们印象中hash 占空间比较大的观念不太一致，这是为什么呢？**\n\n这里是因为Redis 的hash 对象有两种编码方式：\n\n1. ziplist（2.6之前是zipmap）\n2. hashtable\n\n当哈希对象可以同时满足以下两个条件时， 哈希对象使用 ziplist 编码：\n\n1. 哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；\n2. 哈希对象保存的键值对数量小于 512 个；\n\n不能满足这两个条件的哈希对象需要使用 hashtable 编码。上述测试数据满足这两个条件，所以这里使用的是ziplist来存储的数据，而不是hashtable。\n\n\n\n> `注意`\n> 这两个条件的上限值是可以修改的， 具体请看配置文件中关于 hash-max-ziplist-value 选项和 hash-max-ziplist-entries 选项的说明。\n>\n> hash-max-ziplist-entries for Redis >= 2.6\n> hash-max-ziplist-value for Redis >= 2.6\n\n\n\n#### ziplist\n\n**ziplist 编码的数据底层是使用压缩列表作为底层数据结构，结构如下：**\n\n![ziplist](http://media.gusibi.mobi/Ir11LH8z_BiQW8eVl2OXaKERDyO5V5cXkx1OqNaeGWBuqo1Z6WZRss_YP98mnJuc)\n\n![ziplist 底层实现](http://media.gusibi.mobi/EinQ3TgdfGywd8GtAk93ksSzJeZsf7cBSBxEMgtrt9SM2MAvQcLoxvuGeQSdFS7W)\n\n\n\nhash 对象使用ziplist 保存时，程序会将保存了键的ziplist节点推入到列表的表尾，然后再将保存了值的ziplist节点推入列表的表尾。\n\n使用这种方式保存时，并不需要申请多余的内存空间，而且每个Key都要存储一些关联的系统信息（如过期时间、LRU等），因此和String类型的Key/Value相比，Hash类型极大的减少了Key的数量(大部分的Key都以Hash字段的形式表示并存储了)，从而进一步优化了存储空间的使用效率。\n\n在这篇[redis memory optimization](https://redis.io/topics/memory-optimization)官方文章中，作者强烈推荐使用hash存储数据\n\n\n\n> ### Use hashes when possible\n>\n>  Small hashes are encoded in a very small space, so you should try representing your data using hashes every time it is possible. For instance if you have objects representing users in a web application, instead of using different keys for name, surname, email, password, use a single hash with all the required fields.\n> \n>  But many times hashes contain just a few fields. When hashes are small we can instead just encode them in an O(N) data structure, like a linear array with length-prefixed key value pairs. Since we do this only when N is small, the amortized time for HGET and HSET commands is still O(1): the hash will be converted into a real hash table as soon as the number of elements it contains will grow too much (you can configure the limit in redis.conf).\n>\n>  This does not work well just from the point of view of time complexity, but also from the point of view of constant times, since a linear array of key value pairs happens to play very well with the CPU cache (it has a better cache locality than a hash table).\n\n\n\n#### hashtable\n\n `hashtable` 编码的哈希对象使用字典作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存：\n\n- 字典的每个键都是一个字符串对象， 对象中保存了键值对的键；\n- 字典的每个值都是一个字符串对象， 对象中保存了键值对的值。\n\n**hashtable 编码的对象如下所示：**\n\n![](http://media.gusibi.mobi/uxuYAXAcsW_18WeIiiwGNTbMqWbncG6Vd143kyizERZgYMmBggKd4EK_zkIva7AQ)\n\n### 第二次测试\n\n\n\n```json\nvalues = {\n    \"name\": \"gs\",\n    \"age\": 1,\n    \"intro\": \"long..long..long..string\"\n}\n```\n\n\n\n第二次测试方式和第一次一样，只是把测试数据中加了一个大的字符串，以保证hash 使用hashtable 的方式存储数据\n\n结果如下：\n\n\n\n> hashtable： 1.13G\n>\n> string：        1.13G\n\n基本一样，这里应该主要是Hash类型极大的减少了Key的数量(大部分的Key都以Hash字段的形式表示并存储了)，从而进一步优化了存储空间的使用效率。\n\n\n\n**NOTE:** 读取和写入的速度基本一致，差别不大\n\n\n\n回到这个问题，对于string 和 hash 该如何选择呢？\n\n我比较赞同下面这个答案：\n\n![](http://media.gusibi.mobi/5v4pyfA4GAF4q-BnGujmFveL24N6uGWuhISE5RXYThGUtZlot_-H5OTymX4ANnNr)\n\n具体使用哪种数据结构，其实是需要看你要存储的数据以及使用场景。\n\n如果存储的都是比较结构化的数据，比如用户数据缓存，或者经常需要操作数据的一个或者几个，特别是如果一个数据中如果filed比较多，但是每次只需要使用其中的一个或者少数的几个，使用hash是一个好的选择，因为它提供了hget 和 hmget，而无需取出所有数据再在代码中处理。\n\n反之，如果数据差异较大，操作时常常需要把所有数据都读取出来再处理，使用string 是一个好的选择。\n\n\n\n> 当然，也可以听Redis 的，放心的使用hash 吧。\n\n\n\n还有一种场景：如果一个hash中有大量的field（成千上万个），需要考虑是不是使用string来分开存储是不是更好的选择。\n\n\n### References\n\n[1] Redis strings vs Redis hashes to represent JSON: efficiency?: https://stackoverflow.com/questions/16375188/redis-strings-vs-redis-hashes-to-represent-json-efficiency\n[2] redis memory optimization: https://redis.io/topics/memory-optimization\n[3] Redis 设计与实现： http://redisbook.com/preview/object/hash.html\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n",
      "data": {
        "title": "Redis 选择hash还是string 存储数据？",
        "date": "2019-06-22 03:29:15",
        "tags": [
          "redis",
          "nosql",
          "database"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "redis-string-or-hash-to-represent-json"
    },
    {
      "content": "\n**每周分享，分享看到的一些有意思的文章和项目**\n\n1 中国表情包大集合 [https://zhaoolee.github.io/ChineseBQB/](https://zhaoolee.github.io/ChineseBQB/)\n\n表情包目录(共收录2298张表情包)Emoticon package directory (commonly included 2298 emoticon pack)\n\n2 谷歌产品替代品\n\n一批谷歌产品的替代方案\n\n[https://nomoregoogle.com/](https://nomoregoogle.com/)\n\n3 Redis作者：开源维护者的挣扎和无奈\n\n英文作者是著名开源项目 Redis 的开发者 antirez。截至 2019-06-04 为止，Redis 项目在 GitHub 将近有 37,000 Star，Fork 数达 14000。\n\n[https://mp.weixin.qq.com/s/6C7-4Fp46rxfn0J34ebKyg](https://mp.weixin.qq.com/s/6C7-4Fp46rxfn0J34ebKyg)\n\n4 一个分享 GitHub 上 有趣、入门级的开源项目网站\n\n[https://hellogithub.com](https://hellogithub.com)\n\n5 Saber - 新一代静态网站生成系统\n\n[https://saber.land](https://saber.land)\n\n6 star-history: 帮助用户查看 github 项目 star 数目的历史\n\nstar-history 帮助用户查看 github 项目 star 数目的历史, 判断项目发展情况，项目地址：[https://github.com/timqian/star-history](https://github.com/timqian/star-history)\n\n7 一个分类收集 GitHub 开源项目的网站，并对项目的热度和活跃度进行分析\n\n项目地址：[https://www.ctolib.com/](https://www.ctolib.com/)\n\n8 git 提交信息规范检测工具 git-commit-msg-linter\n\n项目地址：[https://www.npmjs.com/package/git-commit-msg-linter](https://www.npmjs.com/package/git-commit-msg-linter)\n\n9 编码一时爽，重写火葬场？这些公司都重写了软件，结局却不同。\n\n> 生存，还是死亡，这是一个问题。重写，还是不重写，这是导致生存或死亡的另一个问题。\n\n[https://mp.weixin.qq.com/s/SqxPoIDPuvKlrlqZmubpXA](https://mp.weixin.qq.com/s/SqxPoIDPuvKlrlqZmubpXA)\n \n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "每周分享第1期-常用表情包收录",
        "date": "2019-06-07 10:05:15",
        "tags": [
          "每周分享",
          "python",
          "教程",
          "工具"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "weekly-01"
    },
    {
      "content": "\n### json 简介\n\nJSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 **它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集**。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。\n\nJSON支持两种数据结构存在：\n\n* 对象（object）：一个对象包含一系列非排序的名称／值对(pair)，一个对象以{开始，并以}结束。每个名称／值对之间使用 **:** 分割。\n* 数组 (array)：一个数组是一个值(value)的集合，一个数组以 **[** 开始，并以]结束。数组成员之间使用 **,** 分割。\n具体的格式如下：\n\n```json\n[value1, value2, value3]\n```\n\n* 名称／值（pair）：名称和值之间使用 **:** 隔开，格式如下：\n\n```json\n{name:value}\n```\n\n> 名称必须是字符串类型； \n> 值(value)必须是可以是字符串(string)，数值(number)，对象(object)，有序列表(array)，或者 false， null， true 的其中一种。\n\nJSON的格式描述可以参考RFC 4627。\n\n\n### 为什么JSON不支持 int64 类型？\n\n通过上面的介绍有两个关键点：\n\n1. JSON 是基于 JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集\n2. JSON 支持number 类型\n\nJavascript的数字存储使用了IEEE 754中规定的双精度浮点数数据类型，而这一数据类型能够安全存储 -(2^53-1) 到 2^53-1 之间的数值（包含边界值）。JSON 是Javascript 的一个子集，所以它也遵守这个规则。\n\n以下是rfc7159的说明：\n\n> Note that when such software is used, numbers that are integers and\n   are in the range [-(2^53)+1, (2^53)-1] are interoperable in the\n   sense that implementations will agree exactly on their numeric\n   values.\n\n\n> 这两个边界值可以通过 JavaScript 的 Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER 获取。\n\n![](http://media.gusibi.mobi/json1.png)\n\n> 安全存储的意思是指能够准确区分两个不相同的值，比如，253 - 1 是一个安全整数，它能被精确表示，在任何 IEEE-754 舍入模式（rounding mode）下，没有其他整数舍入结果为该整数。作为对比，253 就不是一个安全整数，它能够使用 IEEE-754 表示，但是 253 + 1 不能使用 IEEE-754 直接表示，在就近舍入（round-to-nearest）和向零舍入中，会被舍入为 253。\n> Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2 将得到 true的结果，而这在数学上是错误的。\n> 同样 105308320612483198 === 105308320612483200 结果也是true\n\nint64 类型的数值范围是 -(2^63-1) 到 2^63-1。使用int64 类型json 对于超出范围的数字，会出现解析错误的情况。\n\n![](http://media.gusibi.mobi/json2.png)\n\n\n一个建议：对于大数字来说，使用str 是一个好的选择。或者用类似这样的结构：\n\n```json\n{\"int\": 105308320612483198, \"int_str\": \"105308320612483198\"}\n```\n\n在json 中使用的时候 使用 int_str 属性。\n\n### python 对json 的处理\n\npython 中 int 类型值远远超过IEEE 754 中定义的双精度值的范围，所以对于在python中使用的json数据，可以使用放心使用 int64 类型（python中的long ）。但是如果序列化后的数据要被其它语言的解析器（比如：JavaScript的解析器）解析的时候，就要当心数值是不是超出了安全数的范围。如果超出，这里推荐使用字符串类型来代替数值类型。\n\n\n\n\n\n## 参考链接\n\n* [RFC7159](https://tools.ietf.org/html/rfc7159.html)\n* [介绍JSON](http://www.json.org/json-zh.html)\n* [IEEE 754](https://zh.wikipedia.org/zh-hans/IEEE_754)\n\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "为什么json 不能使用 int64类型",
        "date": "2019-06-03 13:14:10",
        "tags": [
          "前端",
          "JavaScript",
          "development"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "why-json-not-support-int64"
    },
    {
      "content": "\n> `问题：`有一个糖果公司需要设计一个糖果售卖机，控制流程如下图，需要怎么实现？\n\n![1b0d0134acf9ab9b2240066f847412f1.png](http://media.gusibi.mobi/5aI8Zy9kkfNI8jzRA8VYMGrFpaGx30W6zSA3ZZAWN6AX0TWWb0SvlbKdJeWJpslF)\n\n这是一个状态图，每个圆圈都是一种状态。很明显，有`有25分钱`、 `没有25分钱`、 `售出糖果`、 `糖果售罄`**四个状态**，同时也对应**四个动作**：`投入25分钱`，`退回25分钱`，`转动曲柄`和`发放糖果`。\n\n那如何从状态图得到真正的代码呢？\n\n简单代码实现如下：\n\n```python\n#! -*- coding: utf-8 -*-\n\nclass GumballMachine:\n\n    # 找出所有状态，并创建实例变量来持有当前状态，然后定义状态的值\n    STATE_SOLD_OUT = 0\n    STATE_NO_QUARTER = 1\n    STATE_HAS_QUARTER = 2\n    STATE_SOLD = 3\n\n    state = STATE_SOLD_OUT\n\n    def __init__(self, count=0):\n        self.count = count\n        if count > 0:\n            self.state = self.STATE_NO_QUARTER\n\n    def __str__(self):\n        return \"Gumball machine current state: %s\" % self.state\n\n    def insert_quarter(self):\n        # 投入25分钱\n        if self.state == self.STATE_HAS_QUARTER: # 如果已经投过\n            print(\"You can't insert another quarter\")\n        elif self.state == self.STATE_NO_QUARTER: # 如果没有投过\n            self.state = self.STATE_HAS_QUARTER\n            print(\"You inserted a quarter\")\n        elif self.state == self.STATE_SOLD_OUT: # 如果已经售罄\n            print(\"You can't insert a quarter, the machine is sold out\")\n        elif self.state == self.STATE_SOLD: # 如果刚刚买了糖果\n            print(\"Please wait, we're already giving you a gumball\")\n\n    def eject_quarter(self):\n        # 退回25分\n        if self.state == self.STATE_HAS_QUARTER:\n            print(\"Quarter returned\")\n            self.state = self.STATE_NO_QUARTER\n        elif self.state == self.STATE_NO_QUARTER:\n            print(\"You haven't inserted a quarter\")\n        elif self.state == self.STATE_SOLD:\n            print(\"Sorry, you alread turned the crank\")\n        elif self.state == self.SOLD_OUT:\n            print(\"You can't eject, you haven't inserted\")\n\n    def turn_crank(self):\n        # 转动曲柄\n        if self.state == self.STATE_SOLD:\n            print(\"Turning twice doesn't get you another gumball\")\n        elif self.state == self.STATE_NO_QUARTER:\n            print(\"You turned but there's no quarter\")\n        elif self.state == self.STATE_SOLD_OUT:\n            print(\"You turned, but there are no gumballs\")\n        elif self.state == self.STATE_HAS_QUARTER:\n            print(\"You turned...\")\n            self.state = self.STATE_SOLD\n            self.dispense()\n    \n    def dispense(self):\n        # 发放糖果\n        if self.state == self.STATE_SOLD:\n            print(\"A gumball comes rolling out the slot\")\n            self.count -= 1\n            if self.count == 0:\n                self.state = self.STATE_SOLD_OUT\n            else:\n                self.state = self.STATE_NO_QUARTER\n        elif self.state == self.STATE_NO_QUARTER:\n            print(\"You need to pay first\")\n        elif self.state == self.STATE_SOLD_OUT:\n            print(\"No gumball dispensed\")\n        elif self.state == self.STATE_HAS_QUARTER:\n            print(\"No gumball dispensed\")\n\n\nif __name__ == \"__main__\":\n    # 以下是代码测试\n    gumball_machine = GumballMachine(5) # 装入5 个糖果\n    print(gumball_machine)\n\n    gumball_machine.insert_quarter() # 投入25分钱\n    gumball_machine.turn_crank() # 转动曲柄\n    print(gumball_machine)\n\n    gumball_machine.insert_quarter() #投入25分钱\n    gumball_machine.eject_quarter()  # 退钱\n    gumball_machine.turn_crank()     # 转动曲柄\n\n    print(gumball_machine)\n    \n    gumball_machine.insert_quarter() # 投入25分钱\n    gumball_machine.turn_crank() # 转动曲柄 \n    gumball_machine.insert_quarter() # 投入25分钱 \n    gumball_machine.turn_crank()  # 转动曲柄\n    gumball_machine.eject_quarter() # 退钱\n\n    print(gumball_machine)\n```\n\n这段代码有几个问题：\n\n1. 没有遵守开放-关闭原则\n2. 更像是面向过程的设计\n3. 状态转化被埋藏在条件语句中\n4. 未来加入新的需求，需要改动的较多，不易维护，可能会出bug\n\n\n如何改进呢？\n\n> 考虑**封装变化**，把每个状态的行为都放在各自的类中，每个状态只要实现自己的动作，用加入新类的方式来实现新状态的加入。\n\n1. 定义State 父类，在这个类中，糖果机的每个动作都有一个应对的方法\n2. 为机器中的每个状态实现状态类，这些类将负责在对应的状态下进行机器的行为\n3. 摆脱旧的条件代码，将动作委托到状态类\n\n新的实现代码如下：\n\n```python\n#! -*- coding: utf-8 -*-\n\nclass State:\n    # 定义state基类\n    def insert_quarter(self):\n        pass\n\n    def eject_quarter(self):\n        pass\n\n    def turn_crank(self):\n        pass\n\n    def dispense(self):\n        pass\n\n\nclass SoldOutState(State):\n    # 继承State 类\n    def __init__(self, gumball_machine):\n        self.gumball_machine = gumball_machine\n\n    def __str__(self):\n        return \"sold_out\"\n\n    def insert_quarter(self):\n        print(\"You can't insert a quarter, the machine is sold out\")\n\n    def eject_quarter(self):\n        print(\"You can't eject, you haven't inserted a quarter yet\")\n\n    def turn_crank(self):\n        print(\"You turned, but ther are no gumballs\")\n\n    def dispense(self):\n        print(\"No gumball dispensed\")\n\n\nclass SoldState(State):\n    # 继承State 类\n    def __init__(self, gumball_machine):\n        self.gumball_machine = gumball_machine\n\n    def __str__(self):\n        return \"sold\"\n\n    def insert_quarter(self):\n        print(\"Please wait, we're already giving you a gumball\")\n\n    def eject_quarter(self):\n        print(\"Sorry, you already turned the crank\")\n\n    def turn_crank(self):\n        print(\"Turning twice doesn't get you another gumball\")\n\n    def dispense(self):\n        self.gumball_machine.release_ball()\n        if gumball_machine.count > 0:\n            self.gumball_machine.state = self.gumball_machine.no_quarter_state\n        else:\n            print(\"Oops, out of gumballs!\")\n            self.gumball_machine.state = self.gumball_machine.soldout_state\n\n\nclass NoQuarterState(State):\n    # 继承State 类\n    def __init__(self, gumball_machine):\n        self.gumball_machine = gumball_machine\n\n    def __str__(self):\n        return \"no_quarter\"\n\n    def insert_quarter(self):\n        # 投币 并且改变状态\n        print(\"You inserted a quarter\")\n        self.gumball_machine.state = self.gumball_machine.has_quarter_state\n\n    def eject_quarter(self):\n        print(\"You haven't insert a quarter\")\n\n    def turn_crank(self):\n        print(\"You turned, but there's no quarter\")\n\n    def dispense(self):\n        print(\"You need to pay first\")\n\n\nclass HasQuarterState(State):\n    # 继承State 类\n    def __init__(self, gumball_machine):\n        self.gumball_machine = gumball_machine\n\n    def __str__(self):\n        return \"has_quarter\"\n\n    def insert_quarter(self):\n        print(\"You can't insert another quarter\")\n\n    def eject_quarter(self):\n        print(\"Quarter returned\")\n        self.gumball_machine.state = self.gumball_machine.no_quarter_state\n\n    def turn_crank(self):\n        print(\"You turned...\")\n        self.gumball_machine.state = self.gumball_machine.sold_state\n\n    def dispense(self):\n        print(\"No gumball dispensed\")\n\n\nclass GumballMachine:\n\n    def __init__(self, count=0):\n        self.count = count\n        # 找出所有状态，并创建实例变量来持有当前状态，然后定义状态的值\n        self.soldout_state = SoldOutState(self)\n        self.no_quarter_state = NoQuarterState(self)\n        self.has_quarter_state = HasQuarterState(self)\n        self.sold_state = SoldState(self)\n        if count > 0:\n            self.state = self.no_quarter_state\n        else:\n            self.state = self.soldout_state\n\n    def __str__(self):\n        return \">>> Gumball machine current state: %s\" % self.state\n\n    def insert_quarter(self):\n        # 投入25分钱\n        self.state.insert_quarter()\n\n    def eject_quarter(self):\n        # 退回25分\n        self.state.eject_quarter()\n        # print(\"state\", self.state, type(self.state))\n\n    def turn_crank(self):\n        # 转动曲柄\n        # print(\"state\", self.state, type(self.state))\n        self.state.turn_crank()\n\t    self.state.dispense()\n    \n    def release_ball(self):\n        # 发放糖果\n        print(\"A gumball comes rolling out the slot...\")\n        if self.count > 0:\n            self.count -= 1\n        \n        \nif __name__ == \"__main__\":\n    # 以下是代码测试\n    gumball_machine = GumballMachine(5) # 装入5 个糖果\n    print(gumball_machine)\n\n    gumball_machine.insert_quarter() # 投入25分钱\n    gumball_machine.turn_crank() # 转动曲柄\n    print(gumball_machine)\n\n    gumball_machine.insert_quarter() #投入25分钱\n    gumball_machine.eject_quarter()  # 退钱\n    gumball_machine.turn_crank()     # 转动曲柄\n\n    print(gumball_machine)\n    \n    gumball_machine.insert_quarter() # 投入25分钱\n    gumball_machine.turn_crank() # 转动曲柄 \n    gumball_machine.insert_quarter() # 投入25分钱 \n    gumball_machine.turn_crank()  # 转动曲柄\n    gumball_machine.eject_quarter() # 退钱\n\n    print(gumball_machine)\n```\n\n重构后的代码相对于之前的代码做了哪些事情呢？\n\n1. 将每个状态的行为局部话到自己的类中\n2. 删除if 语句\n3. 将`状态类`对修改关闭，对糖果季类对`扩展开放`\n\n下图是刚初始状态图示：\n\n![](http://media.gusibi.mobi/JR9i8dFfJU6cVB2NGvZh0BtL8IwXfODdcURvHOl-VI_L805iSpbq3p0heRCN5BIm)\n\n上面重构部分代码使用的就是状态模式：\n\n### 定义\n\n> `状态模式`: 状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。\n\n状态模式的类图如下：\n\n![](http://media.gusibi.mobi/_UOHaXfAO3xSgJJws_AoNGSDKWxCz6sD-N3xKvcY1hq_ZttIir68g9Ql295f8vED)\n\n> 状态模式是将多个行为封装在状态对象中， context 的行为随时可委托到其中一个状态中。当前状态在不同的状态对象中改变，以反映出context 内部的状态，context 的行为也会随之改变。\n\n\n\n### 扩展\n\n> 如果，现在要在这四个状态的基础上再加一个状态（购买糖果后，有10%的概率再得一个），该如何实现呢？\n\n\n```python\n# 添加WinnerState 类，只有dispense 方法不同，可以从SoldState 类继承\nclass WinnerState(SoldState):\n    \n    def __str__(self):\n        return \"winner\"\n\n    def dispense(self):\n        print(\"You're a WINNER! You get two gumballs for your quarter\")\n        self.gumball_machine.release_ball()\n        if gumball_machine.count == 0:\n            self.gumball_machine.state = self.gumball_machine.soldout_state\n        else:\n            self.gumball_machine.release_ball()\n            if gumball_machine.count > 0:\n                self.gumball_machine.state = self.gumball_machine.no_quarter_state\n            else:\n                print(\"Oops, out of gumballs!\")\n                self.gumball_machine.state = self.gumball_machine.soldout_state\n\n# 修改turn_crank 方法\nclass HasQuarterState(State):\n    ...\n    def turn_crank(self):\n        print(\"You turned...\")\n        winner = random.randint(0, 9)\n        if winner == 4 and self.gumball_machine.count > 1: # 如果库存大于 1 并且随机数等于4（可以是0到9任意值）\n            self.gumball_machine.state = self.gumball_machine.winner_state\n        else:\n            self.gumball_machine.state = self.gumball_machine.sold_state\n\n\n# 在 GumballMachine 中初始化\nclass GumballMachine:\n\n    def __init__(self, count=0):\n        self.count = count\n        # 找出所有状态，并创建实例变量来持有当前状态，然后定义状态的值\n        ...\n        self.winner_state = WinnerState(self)\n        ...\n```\n\n### 总结\n\n1. 状态模式允许一个对象给予内部状态而拥有不同的行为\n2. 状态模式用类代表状态\n3. Context 会将行为委托给当前状态对象\n4. 通过将每状态封装进一个类，把改变局部化\n5. 状态装欢可以由State 类或Context 类控制\n6. 使用状态模式会增加类的数目\n7. 状态类可以被多个Context 实例共享\n\n------\n\n> 本文例子来自《Head First 设计模式》。\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![](http://media.gusibi.mobi/ah0mqMXMtdJb9Yj03suu-NGEyVRxyEuOIT5bXSv7ip5aqtHkiRjTTl8SMRMv3Qp5)\n",
      "data": {
        "title": "python设计模式-状态模式",
        "date": "2018-12-31 04:59:39",
        "tags": [
          "python",
          "读书笔记",
          "设计模式"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-design-pattern-state-pattern"
    },
    {
      "content": "\n首先先介绍一下咖啡和茶的冲泡方法：\n\n**茶**\n\n```\n1. 把水煮沸\n2. 用沸水浸泡茶叶\n3. 把茶放到杯子里\n```\n\n**咖啡**\n\n```\n1. 把水煮沸\n2. 用沸水冲泡咖啡\n3. 把咖啡倒进杯子\n4. 加糖和牛奶\n```\n\n用python代码实现冲泡方法大概是这个样子：\n\n```python\n# 茶的制作方法\nclass Tea:\n\n    def prepare_recipe(self):\n        # 在下边实现具体步骤\n        self.boil_water()\n        self.brew_tea_bag()\n        self.pour_in_cup()\n        \n    def boil_water(self):\n        print(\"Boiling water\")\n        \n    def brew_tea_bag(self):\n        print(\"Steeping the tea\")\n        \n    def pour_in_cup(self):\n        print(\"Pouring into cup\")\n```\n\n```python\n# 咖啡的制作方法\nclass Coffee:\n\n    def prepare_recipe(self):\n        # 在下边实现具体步骤\n        self.boil_water()\n        self.brew_coffee_grinds()\n        self.pour_in_cup()\n        self.add_sugar_and_milk()\n        \n    def boil_water(self):\n        print(\"Boiling water\")\n        \n    def brew_coffee_grinds(self):\n        print(\"Dripping Coffee through filter\")\n        \n    def pour_in_cup(self):\n        print(\"Pouring into cup\")\n        \n    def add_sugar_and_milk(self):\n        print(\"Adding Sugar and Milk\")\n```\n\n仔细看上边两端代码会发现，茶和咖啡的实现方式基本类似，都有`prepare_recipe`，`boil_water`，`pour_in_cup` 这三个方法。\n\n> `问题：`如何重新设计这两个类来让代码更简洁呢？\n\n首先看一下两个类的类图：\n\n![2bd637fbc0532bd0bafbf861005fabd3.png](http://media.gusibi.mobi/jom4jOc8uWezDNwLSyqUYcOF5pXzLTh4ztvglMCIajscrtcrp3T5eyH7YnOgZbwD)\n\n1. 每个类中都有 `prepare_recipe() boil_water() pour_in_cup()`方法。\n2. 每个类中`prepare_recipe()`方法的实现都不一样。\n\n\n现在把`prepare_recipe() boil_water() pour_in_cup()`三个方法抽取出来做成一个父类`CoffeineBeverage()`，`Tea` 和 `Coffee` 都继自`CoffeineBeverage()`。\n\n\n![ce3e56409c313d4ce42e9878f3b5c8f4.png](http://media.gusibi.mobi/GTzGMHTGpxLF8o69DDykX4MCpkoy2Xf-uuGFWOIgARmWqv9xLnP5g74QKmgYf95d)\n\n> 因为每个类中`prepare_recipe()`实现的方法不一样，所以`Tea` 和 `Coffee` 类都分别实现了 `prepare_recipe()`。\n> `问题`: 那么，有没有办法将`prepare_recipe()`也抽象化？\n\n\n\n对比 `Tea` 和 `Coffee` 的`prepare_recipe()` 方法会发现，他们之间的差异主要是：\n\n```python\n\ndef prepare_recipe(self):\n    # 相同部分隐藏\n    # self.boil_water()\n    self.brew_tea_bag()  # 差异1\n    #self.pour_in_cup()\n        \ndef prepare_recipe(self):\n    # 相同部分隐藏\n    # self.boil_water()\n    self.brew_coffee_grinds() # 差异1\n    # self.pour_in_cup()\n    self.add_sugar_and_milk() # 差异2\n\n```\n\n这里的实现思路是，将两处差异分别用新的方法名代替，替换后结果如下：\n\n```python\n\ndef prepare_recipe(self):\n    # 新的实现方法\n    self.boil_water()\n    self.brew() # 差异1 使用brew 代替 brew_tea_bag 和 brew_coffee_grinds\n    self.pour_in_cup()\n    self.add_condiments() # 差异2 Tea 不需要此方法，可以用空的实现代替\n\n```\n\n新的类图如下：\n\n![bff9cea3d8f8226b6a9bb29c1deb8d88.png](http://media.gusibi.mobi/Fqusr6qE_RUIHrwJIoNIvR64HEE8LSNWndLIz3gmtNXNqdGw0nJ12GR9-l4SvD7T)\n\n现在，类 `Tea` 和 `Coffee` 只需要实现具体的 `brew()`和 `add_condiments()` 方法即可。代码实现如下：\n\n```python\n\nclass CoffeineBeverage:\n\n    def prepare_recipe(self):\n        # 新的实现方法\n        self.boil_water()\n        self.brew() \n        self.pour_in_cup()\n        self.add_condiments()\n        \n    def boil_water(self):\n        print(\"Boiling water\")\n        \n    def brew(self):\n        # 需要在子类实现\n        raise NotImplementedError\n        \n    def pour_in_cup(self):\n        print(\"Pouring into cup\")\n        \n    def add_condiments(self):\n        # 这里其实是个钩子方法，子类可以视情况选择是否覆盖\n        # 钩子方法是一个可选方法，也可以让钩子方法作为某些条件触发后的动作\n        pass\n\n# 茶的制作方法\nclass Tea(CoffeineBeverage):\n        \n    def brew(self):\n        # 父类中声明了 raise NotImplementedError，这里必须要实现此方法\n        print(\"Steeping the tea\")\n        \n    # Tea 不需要 add_condiments 方法，所以这里不需要实现\n\n# 咖啡的制作方法\nclass Coffee(CoffeineBeverage):\n        \n    def brew(self):\n        # 父类中声明了 raise NotImplementedError，这里必须要实现此方法\n        print(\"Dripping Coffee through filter\")\n        \n    def add_condiments(self):\n        print(\"Adding Sugar and Milk\")\n```\n\n### 模板方法\n\n\n上述抽象过程使用的就是模板方法。模板方法定义了一个算法的步骤，并且允许子类为一个或多个步骤提供实现。在这个例子中，`prepare_recipe` 就是一个模板方法。\n\n> `定义：`模板方法牧师在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。\n\n#### 优点\n\n1. 使用模板方法可以将代码的复用最大化\n2. 子类只需要实现自己的方法，将算法和实现的耦合降低。\n\n\n#### 好莱坞原则\n\n模板方法使用到了一个原则，`好莱坞原则`。\n\n> `好莱坞原则`，别调用我，我会调用你。\n\n![好莱坞原则](http://media.gusibi.mobi/F62XbVcTYD9i-4swfqL5_sgS8SYXCfyB_2h2pEJq2BIZ8LikiEF2Yulq3HIxvISz)\n在这个原则之下，允许低层组件将自己挂钩到系统上，但是由高层组件来决定什么时候使用这些低层组件。\n\n在上边的例子中，CoffeineBeverage 是高层组件，Coffee和Tea 是低层组件，他们不会之间调用抽象类（CoffeineBeverage）。\n\n\n### 一个例子🌰\n\nPython 第三方表单验证包 wtforms 的表单验证部分就使用到了模板方法模式。Field 类中`validate`方法就是一个模板方法，在这个方法中，会调用 `pre_validate`， `_run_validation_chain`，`post_validate`方法来验证表单，这些方法也都可以在子类中重新实现。具体实现可以参考以下源码。\n\n源码地址：[https://github.com/wtforms/wtforms/blob/master/src/wtforms/fields/core.py](https://github.com/wtforms/wtforms/blob/master/src/wtforms/fields/core.py#L225)\n\n## 参考链接\n* [https://github.com/wtforms/wtforms/blob/master/src/wtforms/fields/core.py](https://github.com/wtforms/wtforms/blob/master/src/wtforms/fields/core.py#L225)\n\n------\n> 本文例子来自《Head First 设计模式》\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![](http://media.gusibi.mobi/ah0mqMXMtdJb9Yj03suu-NGEyVRxyEuOIT5bXSv7ip5aqtHkiRjTTl8SMRMv3Qp5)\n",
      "data": {
        "title": "python设计模式-模板方法模式",
        "date": "2018-12-02 09:23:56",
        "tags": [
          "python",
          "读书笔记",
          "设计模式"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-design-pattern-template-pattern"
    },
    {
      "content": "\n上一篇[《python设计模式-适配器模式》](https://mp.weixin.qq.com/s/69j6WbV_NoSumRuLj_gGug)介绍了如何将一个类的接口转换成另一个符合期望的接口。这一篇将要介绍需要一个为了简化接口而改变接口的新模式-外观模式（Facade-Pattern）。\n\n### 问题\n\n> `问题`：如果你组装了一套家庭影院，内含播放器、投影机、自动屏幕、立体声音响、爆米花机等。如何设计一个遥控器，可以简单的操作这个系统中的各个组件呢？\n\n首先来看一下最笨方式观赏电影的步骤：\n\n1. 打开爆米花机\n2. 开始爆米花\n3. 将灯光调暗\n4. 放下屏幕\n5. 打开投影仪\n6. 将投影机的输入切换到播放器\n7. 将投影及设置在宽屏模式\n8. 打开功放\n9. 将功放的输入设置为播放器\n10. 将攻防设置为环绕立体声\n11. 将攻防音量调到适中\n12. 打开播放器\n13. 播放电影\n\n写成类和方法的调用大概是以下的样子：\n\n\n```python\n\n# 打开爆米花机，开始爆米花\npoper.on()\npoper.pop()\n# 灯光调暗\nlights.dim(10)\n\n# 放下屏幕\nscreen.down()\n\n# 打开投影仪，设置为宽屏模式\nprojector.on()\nprojector.setInput(dvd)\nprojector.wideScreenMode()\n\n# 打开功放 设置为DVD 调整成环绕立体声模式，音量调到5\namp.on()\namp.setDvd(dvd)\namp.setSurroundSound()\namp.setVolume(5)\n\n# 打开dvd 播放器\ndvd.on()\ndvd.play(movie)\n```\n\n可以看到代码中涉及到6个不同的类，而且电影看完后还需要回退，一切都要再反着重来一遍。怎样简化一下操作呢？\n现在，外观模式就可以大展身手了。\n> 使用外观模式，可以通过实现一个提供更合理的接口的外观类，将子系统变得更容易使用。当然，原来的接口还在。\n\n### 解决方法\n\n**先来看一下外观模式如何运作**\n\n![外观模式类图](http://media.gusibi.mobi/gqxnhAKcJZ7wYLGuWwls8NkjFUsAqou-lwHvR7I9Jrhk5sXtQv6xAqhqMnbO2ITW)\n\n1. 这里为家庭影院系统创建了一个新的外观类`HomeTheaterFacade`，这个类暴露出来几个简单的方法，比如`watchMovie`，`endMovie`。\n2. 这个外观类将家庭影院的多个组件看作一个子系统，通过调用这个子系统来实现`watchMovie`方法。\n3. 外观只提供了一个更直接的操作方式，并没有将原来的子系统隔离，子系统的功能还可以使用\n\n\n> `注意：`\n> 1. 可以有多个外观\n> 2. 外观提供简化的接口，但不隔离子系统\n> 3. 外观将实现从子系统中解耦，比如：现在有个子系统的组件需要升级换代，只需要把外观代码做相应的修改就可以实现\n> 4. 外观和适配器都可以包装多个类，但是`外观的意图时简化接口的调用`，而`适配器的意图是将接口转换成不同的接口`。\n\n\n### 示例\n\n```python\n\nclass HomeTheaterFacade(object):\n\n    #先声明需要用的子组件\n    amp = Amplifier()\n    tuner = Tuner()\n    dvd = DvdPlayer()\n    cd = CdPlayer()\n    projector = Projector()\n    lights = TheaterLights()\n    screen = Screen()\n    popper = PopcornPopper()\n    \n    def watchMovie(self, movie):\n        # watchMovie 将之前需要手动处理的任务批量处理\n        print(\"Get ready to watch a movie...\")\n        # 打开爆米花机，开始爆米花\n        self.poper.on()\n        self.poper.pop()\n        # 灯光调暗\n        self.lights.dim(10)\n\n        # 放下屏幕\n        self.screen.down()\n\n        # 打开投影仪，设置为宽屏模式\n        self.projector.on()\n        self.projector.setInput(dvd)\n        self.projector.wideScreenMode()\n\n        # 打开功放 设置为DVD 调整成环绕立体声模式，音量调到5\n        self.amp.on()\n        self.amp.setDvd(dvd)\n        self.amp.setSurroundSound()\n        self.amp.setVolume(5)\n\n        # 打开dvd 播放器\n        self.dvd.on()\n        self.dvd.play(movie)\n    \n    def endMovie(self):\n        # endMovie 负责关闭一切，由子系统中的组件完成\n        print(\"Shutting movie theater down...\")\n        self.popper.off()\n        self.lights.on()\n        self.screen.up()\n        self.projector.off()\n        self.amp.off()\n        self.dvd.stop()\n        self.dvd.eject()\n        self.dvd.off()\n```\n\n##### 代码使用\n\n```python\ndef main():\n    home_theater = HomeTheaterFacade() # 实例化外观\n    home_theater.watchMovice() # 使用简化方法开启 关闭电影ß\n    home_theater.endMovice()\n```\n### 定义\n\n> `定义：`外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。\n\n![外观模式类图](http://media.gusibi.mobi/LTw5Md09LS2JDhLP5TKFay5jNCGUK93PgDVhpB3clEv-8RzKOfyOFCvLlIzn4D0V)\n\n从类图也可以了解到，外观模式的主要意图是提供一个更简单易用的接口。\n\n\n#### 最少知识原则（least Knowledge）\n\n`最少知识原则`的意思是减少对象之间的交互，只和几个特定的对象交互。\n> 这个原则是希望在设计中，不要耦合太多的类，以免修改系统时，会影响到其它部分。\n\n比如：如果想从DVD播放器获取音响的音量，可以在Dvd播放器中加入一个方法，用来像音响请求当前音量，而不是先返回音响对象，再从音响对象返回音量。\n\n```python\n# 不好的实践\ndef get_volume():\n    tuner = dvd.tuner()\n    return tuner.get_volume\n    \n\n# 好的实践\ndef get_volume():\n    # 这里要给dvd 对象加一个get_volume方法\n    return dvd.get_volume\n```\n\n> `缺点：`虽然这个原则减少了对象之间的依赖，但是也会导致更多的包装被制造出来（比如上边例子中，就需要给`dvd 加一个 get_volume`方法），这也可能会导致系统更复杂。\n\n再回顾一下外观模式的例子，会发现外观模式符合`最少知识原则`，客户端只有`HomeTheaterFacade`这一个交互对象。它的存在让系统调用变的更简单，并且如果需要子系统有模块需要升级，只需要修改`HomeTheaterFacade`这个类就可以完成升级。\n\n------\n\n> 本文例子来自《Head First 设计模式》。\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![](http://media.gusibi.mobi/ah0mqMXMtdJb9Yj03suu-NGEyVRxyEuOIT5bXSv7ip5aqtHkiRjTTl8SMRMv3Qp5)\n",
      "data": {
        "title": "python设计模式-外观模式",
        "date": "2018-11-25 09:23:56",
        "tags": [
          "python",
          "读书笔记",
          "设计模式"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-design-pattern-facade-pattern"
    },
    {
      "content": "\n> `问题`：假设有一个软件系统，你希望它能在不改变现有代码的前提下和一个新的厂商类库搭配使用，但是这个新厂商所设计出来的接口不同于旧厂商的接口\n\n![](http://media.gusibi.mobi/ggjMjkbHdiBnU8YUY0iNQe3I9XXxZ_OYE0o7uI2Gxw8CXzOP1_WyHjcVrbXiDvcc)\n\n**这个问题和下图的问题类似**\n\n![](http://media.gusibi.mobi/TWyhF3_0rCaiR4WVmmmVQN05VLUR0pVgbHL28bV4ce2Kim_i74yFICJDqEnoVi2L)\n\n美国标准的插头🔌无法在欧洲标准的插座上使用，通常的做法是什么呢？\n\n> 添加一个插头适配器，适配器的作用是将欧式插头转换成美式插座，以便于让美式插头可以使用。\n\n### 解决方案\n\n所以，面对一个有全新接口的类库而又不能改变现有代码时，最先想到的做法是，在这两个系统之间添加一个适配器。\n\n![](http://media.gusibi.mobi/VxXkkbIoWmKptVX2qSd_WNGrO2KdVgnrmMpe_sPdhuMk6xeVqLnJd3TN2qTY7k1q)\n\n### 简单的例子\n\n> 有一个系统，需要一个鸭子🦆对象，但是现在只有一个火鸡🦃对象。鸭子和火鸡对象的功能简单描述如下：\n\n```python\n\n# 鸭子的简单描述\nclass Duck:\n    def quack(self):\n        # 会呱呱叫\n        print(\"Quack\")\n    \n    def fly(self):\n        # 飞的能力\n        print(\"I'm flying\")\n        \n# 火鸡的简单描述\nclass Turkey:\n    def gobble(self):\n        # 不会呱呱叫，只会咯咯叫\n        print(\"Gobble gobble\")\n    \n    def fly(self):\n        # 飞的能力 但是飞不远\n        print(\"I'm flying a short distance\")\n    \n```\n\n因为现在没有鸭子对象，只能那火鸡对象冒充。由于鸭子对象和火鸡对象功能不同，不能直接拿来用，现在就需要使用适配器来完成这个功能：\n\n```python\nclass TurkeyAdapter(Duck):\n    turkey = Turkey()  # 这里实际使用的是火鸡对象\n    \n    # 实现鸭子对象拥有的quack方法\n    def quack(self):\n        self.turkey.gobble()\n    \n    def fly(self):\n        # 假设火鸡比鸭子飞的短，为了模拟鸭子的动作，多飞几次\n        for i in range(5):\n            turkey.fly()\n```\n\n接下来调用就可以像使用鸭子对象一样使用火鸡适配后的对象。\n\n```python\n# test\n\nduck = Duck()\nduck.quack()\nduck.fly()\n\nturkey_adapter = Duck()\nturkey_adapter.quack()\nturkey_adapter.fly()\n```\n\n**现在再来看一下适配器使用的过程：**\n\n![](http://media.gusibi.mobi/Y5ID_UHcjlr0row8knQGM5vb8KNtRSlH_-6k-SrVOgvbAsE-iH7kweMC-mgvIGnM)\n\n1. 客户通过被适配者实现的接口调用适配器\n2. 适配器将请求转换为被适配者可以响应的请求\n3. 被适配者响应，把结果返回给适配器，然后适配器再将结果响应给客户。\n\n通过这个例子，接下来看一下适配器模式的正式定义\n\n### 定义\n\n> `适配器模式：`将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作。\n\n#### 优点\n\n* 可以通过创建适配器进行接口转换，让不兼容的接口兼容，让客户从实现的接口的解耦。\n* 使用对象组合，以修改的接口包装被适配者\n* 被适配的子类可以搭配着适配器使用\n* 满足开放/封闭原则（open/close principle）\n\n> `开放/封闭原则`是面向对象设计的基本原则之一，声明一个软件实体应该对扩展是开放的，对修改是关闭的。\n\n\n\n### 真实世界中的适配器\n\n* xmltodict 可以将 xml 转换为 json\n* grpc 也可以认为是一种适配器，提供了跨语言调用能力\n* sqlalchemy 可以在不改变代码的情况下对接多种数据库\n\n\n> 本文例子来自《Head First 设计模式》。\n\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "python设计模式-适配器模式",
        "date": "2018-11-03 13:23:56",
        "tags": [
          "python",
          "读书笔记",
          "设计模式"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-design-pattern-adapter-pattern"
    },
    {
      "content": "\n>  Solidity是以太坊的主要编程语言，它是一种静态类型的 JavaScript-esque 语言，是面向合约的、为实现智能合约而创建的高级编程语言，设计的目的是能在以太坊虚拟机（EVM）上运行。\n>  \n>  `本文基于CryptoZombies，教程地址为：https://cryptozombies.io/zh/lesson/2`\n\n\n### 地址（address）\n\n以太坊区块链由 account (账户)组成，你可以把它想象成银行账户。一个帐户的余额是以太 （在以太坊区块链上使用的币种），你可以和其他帐户之间支付和接受以太币，就像你的银行帐户可以电汇资金到其他银行帐户一样。\n\n每个帐户都有一个“地址”，你可以把它想象成银行账号。这是账户唯一的标识符，它看起来长这样：\n\n```\n0x0cE446255506E92DF41614C46F1d6df9Cc969183\n```\n\n> 这是 CryptoZombies 团队的地址，为了表示支持CryptoZombies，可以赞赏一些以太币！\n\n\n`address`：地址类型存储一个 20 字节的值（以太坊地址的大小）。 地址类型也有成员变量，并作为所有合约的基础。\n\n\n> `address` 类型是一个160位的值，且不允许任何算数操作。这种类型适合存储合约地址或外部人员的密钥对。\n\n\n\n\n### 映射（mapping）\n\n>  Mappings 和[哈希表](https://en.wikipedia.org/wiki/Hash_table)类似，它会执行虚拟初始化，以使所有可能存在的键都映射到一个字节表示为全零的值。\n\n映射是这样定义的：\n\n```javascript\n//对于金融应用程序，将用户的余额保存在一个 uint类型的变量中：\nmapping (address => uint) public accountBalance;\n//或者可以用来通过userId 存储/查找的用户名\nmapping (uint => string) userIdToName;\n```\n\n映射本质上是存储和查找数据所用的键-值对。在第一个例子中，键是一个 address，值是一个 uint，在第二个例子中，键是一个uint，值是一个 string。\n\n> 映射类型在声明时的形式为 mapping(_KeyType => _ValueType)。 其中 _KeyType 可以是除了映射、变长数组、合约、枚举以及结构体以外的几乎所有类型。 _ValueType 可以是包括映射类型在内的任何类型。\n\n对映射的取值操作如下：\n\n```javascript\nuserIdToName[12]\n// 如果键12 不在 映射中，得到的结果是0\n```\n\n\n> 映射中，实际上并不存储 key，而是存储它的 keccak256 哈希值，从而便于查询实际的值。所以**映射是没有长度的，也没有 key 的集合或 value 的集合的概念。**，你不能像操作`python`字典那应该获取到当前 Mappings 的所有键或者值。\n\n\n### 特殊变量\n\n在 Solidity 中，在全局命名空间中已经存在了（预设了）一些特殊的变量和函数，他们主要用来提供关于区块链的信息或一些通用的工具函数。\n\n#### msg.sender\n\n msg.sender指的是当前调用者（或智能合约）的 address。\n\n> 注意：在 Solidity 中，功能执行始终需要从外部调用者开始。 一个合约只会在区块链上什么也不做，除非有人调用其中的函数。所以对于每一个**外部函数**调用，包括 msg.sender 和 msg.value 在内所有 msg 成员的值都会变化。这里包括对库函数的调用。\n\n\n以下是使用 msg.sender 来更新 mapping 的例子：\n\n```javascript\nmapping (address => uint) favoriteNumber;\n\nfunction setMyNumber(uint _myNumber) public {\n  // 更新我们的 `favoriteNumber` 映射来将 `_myNumber`存储在 `msg.sender`名下\n  favoriteNumber[msg.sender] = _myNumber;\n  // 存储数据至映射的方法和将数据存储在数组相似\n}\n\nfunction whatIsMyNumber() public view returns (uint) {\n  // 拿到存储在调用者地址名下的值\n  // 若调用者还没调用 setMyNumber， 则值为 `0`\n  return favoriteNumber[msg.sender];\n}\n```\n\n在这个小小的例子中，任何人都可以调用 setMyNumber 在我们的合约中存下一个 uint 并且与他们的地址相绑定。 然后，他们调用 whatIsMyNumber 就会返回他们存储的 uint。\n\n使用 msg.sender 很安全，因为它具有以太坊区块链的安全保障 —— 除非窃取与以太坊地址相关联的私钥，否则是没有办法修改其他人的数据的。\n\n以下是其它的一些特殊变量。\n\n#### 区块和交易属性\n\n- block.blockhash(uint blockNumber) returns (bytes32)：指定区块的区块哈希——仅可用于最新的 256 个区块且不包括当前区块；而 blocks 从 0.4.22 版本开始已经不推荐使用，由 blockhash(uint blockNumber) 代替\n- block.coinbase (address): 挖出当前区块的矿工地址\n- block.difficulty (uint): 当前区块难度\n- block.gaslimit (uint): 当前区块 gas 限额\n- block.number (uint): 当前区块号\n- block.timestamp (uint): 自 unix epoch 起始当前区块以秒计的时间戳\n- gasleft() returns (uint256)：剩余的 gas\n- msg.data (bytes): 完整的 calldata\n- msg.gas (uint): 剩余 gas - 自 0.4.21 版本开始已经不推荐使用，由 gesleft() 代替\n- msg.sender (address): 消息发送者（当前调用）\n- msg.sig (bytes4): calldata 的前 4 字节（也就是函数标识符）\n- msg.value (uint): 随消息发送的 wei 的数量\n- now (uint): 目前区块时间戳（block.timestamp）\n- tx.gasprice (uint): 交易的 gas 价格\n- tx.origin (address): 交易发起者（完全的调用链）\n\n\n### 错误处理\n\nSolidity 使用状态恢复异常来处理错误。这种异常将撤消对当前调用（及其所有子调用）中的状态所做的所有更改，并且还向调用者标记错误。 \n\n函数 `assert` 和 `require` 可用于检查条件并在条件不满足时抛出异常。\n\n* assert 函数只能用于测试内部错误，并检查非变量。 \n* require 函数用于确认条件有效性，例如输入变量，或合约状态变量是否满足条件，或验证外部合约调用返回的值。\n\n这里主要介绍 `require`\n\nrequire使得函数在执行过程中，当不满足某些条件时抛出错误，并停止执行：\n\n```javascript\nfunction sayHiToVitalik(string _name) public returns (string) {\n  // 比较 _name 是否等于 \"Vitalik\". 如果不成立，抛出异常并终止程序\n  // (敲黑板: Solidity 并不支持原生的字符串比较, 我们只能通过比较\n  // 两字符串的 keccak256 哈希值来进行判断)\n  require(keccak256(_name) == keccak256(\"Vitalik\"));\n  // 如果返回 true, 运行如下语句\n  return \"Hi!\";\n}\n```\n\n如果你这样调用函数 `sayHiToVitalik(\"Vitalik\")` ,它会返回“Hi！”。而如果调用的时候使用了其他参数，它则会抛出错误并停止执行。\n\n因此，在调用一个函数之前，用 require 验证前置条件是非常有必要的。\n\n> 注意：在 Solidity 中，关键词放置的顺序并不重要\n\n```javascript\n// 以下两个语句等效\nrequire(keccak256(_name) == keccak256(\"Vitalik\"));\nrequire(keccak256(\"Vitalik\") == keccak256(_name));\n```\n\n### 外/内部函数\n\n除 public 和 private 属性之外，Solidity 还使用了另外两个描述函数可见性的修饰词：internal（内部） 和 external（外部）。\n\n`internal` 和 `private` 类似，不过，如果某个合约继承自其父合约，这个合约即可以访问父合约中定义的`“内部(internal)”函数`。\n\n`external` 与`public` 类似，只不过`external`函数只能在合约之外调用 - 它们不能被合约内的其他函数调用。\n\n声明函数 internal 或 external 类型的语法，与声明 private 和 public类 型相同：\n\n```javascript\ncontract Sandwich {\n  uint private sandwichesEaten = 0;\n\n  function eat() internal {\n    sandwichesEaten++;\n  }\n}\n\ncontract BLT is Sandwich {\n  uint private baconSandwichesEaten = 0;\n\n  function eatWithBacon() public returns (string) {\n    baconSandwichesEaten++;\n    // 因为eat() 是internal 的，所以我们能在这里调用\n    eat();\n  }\n}\n```\n\nSolidity 有两种函数调用（内部调用不会产生实际的 EVM 调用或称为`消息调用`，而外部调用则会产生一个 EVM 调用）， 函数和状态变量有四种可见性类型。 函数可以指定为 external ，public ，internal 或者 private，默认情况下函数类型为 public。 对于状态变量，不能设置为 external ，默认是 internal 。\n\n* `external ：`\n外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。 一个外部函数 f 不能从内部调用（即 f 不起作用，但 this.f() 可以）。 当收到大量数据的时候，外部函数有时候会更有效率。\n\n* `public ：`\npublic 函数是合约接口的一部分，可以在内部或通过消息调用。对于公共状态变量， 会自动生成一个 getter 函数。\n\n* `internal ：`\n这些函数和状态变量只能是内部访问（即从当前合约内部或从它派生的合约访问），不使用 this 调用。\n\n* `private ：`\nprivate 函数和状态变量仅在当前定义它们的合约中使用，并且不能被派生合约使用。\n\n> 合约中的所有内容对外部观察者都是可见的。设置一些 private 类型只能阻止其他合约访问和修改这些信息， 但是对于区块链外的整个世界它仍然是可见的。\n\n\n可见性标识符的定义位置，对于状态变量来说是在类型后面，对于函数是在参数列表和返回关键字中间。\n\n```javascript\npragma solidity ^0.4.16;\n\ncontract C {\n    // 对于函数是在参数列表和返回关键字中间。\n    function f(uint a) private pure returns (uint b) { return a + 1; }\n    function setData(uint a) internal { data = a; }\n    uint public data;  // 对于状态变量来说是在类型后面\n}\n```\n\n### 函数多值返回\n\n和 python 类似，Solidity 函数支持多值返回，比如：\n\n```javascript\n\nfunction multipleReturns() internal returns(uint a, uint b, uint c) {\n  return (1, 2, 3);\n}\n\nfunction processMultipleReturns() external {\n  uint a;\n  uint b;\n  uint c;\n  // 这样来做批量赋值:\n  (a, b, c) = multipleReturns();\n}\n\n// 或者如果我们只想返回其中一个变量:\nfunction getLastReturnValue() external {\n  uint c;\n  // 可以对其他字段留空:\n  (,,c) = multipleReturns();\n}\n\n```\n\n> 这里留空字段使用`,`的方式太不直观了，还不如 python/go 使用下划线`_`代替无用字段。\n\n\n### Storage与Memory\n\n在 Solidity 中，有两个地方可以存储变量 —— storage 或 memory。\n\nStorage 变量是指永久存储在区块链中的变量。 Memory 变量则是临时的，当外部函数对某合约调用完成时，内存型变量即被移除。 你可以把它想象成存储在你电脑的硬盘或是RAM中数据的关系。\n\n> storage 和 memory 放到状态变量名前边，在类型后边，格式如下：\n> `变量类型 <storage|memory> 变量名`\n\n大多数时候都用不到这些关键字，默认情况下 Solidity 会自动处理它们。 状态变量（在函数之外声明的变量）默认为“存储”形式，并永久写入区块链；而在函数内部声明的变量是“内存”型的，它们函数调用结束后消失。\n\n然而也有一些情况下，你需要手动声明存储类型，主要用于处理函数内的 `结构体` 和 `数组` 时：\n\n```javascript\ncontract SandwichFactory {\n  struct Sandwich {\n    string name;\n    string status;\n  }\n\n  Sandwich[] sandwiches;\n\n  function eatSandwich(uint _index) public {\n    // Sandwich mySandwich = sandwiches[_index];\n\n    // ^ 看上去很直接，不过 Solidity 将会给出警告\n    // 告诉你应该明确在这里定义 `storage` 或者 `memory`。\n\n    // 所以你应该明确定义 `storage`:\n    Sandwich storage mySandwich = sandwiches[_index];\n    // ...这样 `mySandwich` 是指向 `sandwiches[_index]`的指针\n    // 在存储里，另外...\n    mySandwich.status = \"Eaten!\";\n    // ...这将永久把 `sandwiches[_index]` 变为区块链上的存储\n\n    // 如果你只想要一个副本，可以使用`memory`:\n    Sandwich memory anotherSandwich = sandwiches[_index + 1];\n    // ...这样 `anotherSandwich` 就仅仅是一个内存里的副本了\n    // 另外\n    anotherSandwich.status = \"Eaten!\";\n    // ...将仅仅修改临时变量，对 `sandwiches[_index + 1]` 没有任何影响\n    // 不过你可以这样做:\n    sandwiches[_index + 1] = anotherSandwich;\n    // ...如果你想把副本的改动保存回区块链存储\n  }\n}\n```\n\n如果你还没有完全理解究竟应该使用哪一个，也不用担心 —— 在本教程中，我们将告诉你何时使用 storage 或是 memory，并且当你不得不使用到这些关键字的时候，Solidity 编译器也发警示提醒你的。\n\n现在，只要知道在某些场合下也需要你显式地声明 storage 或 memory就够了！\n\n\n\n### 继承\n\n\nSolidity 的继承和 Python 的继承相似，支持多重继承。\n看下面这个例子：\n\n```javascript\ncontract Doge {\n  function catchphrase() public returns (string) {\n    return \"So Wow CryptoDoge\";\n  }\n}\n\ncontract BabyDoge is Doge {\n  function anotherCatchphrase() public returns (string) {\n    return \"Such Moon BabyDoge\";\n  }\n}\n\n// 可以多重继承。请注意，Doge 也是 BabyDoge 的基类，\n// 但只有一个 Doge 实例（就像 C++ 中的虚拟继承）。\ncontract BlackBabyDoge is Doge, BabyDoge {\n  function color() public returns (string) {\n    return \"Black\";\n  }\n}\n\n```\n\n`BabyDoge` 从 `Doge` 那里 `inherits（继承)`过来。 这意味着当编译和部署了 `BabyDoge`，它将可以访问 catchphrase() 和 anotherCatchphrase()和其他我们在 Doge 中定义的其他公共函数（private 函数不可访问）。\n\nSolidity使用 is 从另一个合约派生。派生合约可以访问所有非私有成员，包括内部函数和状态变量，但无法通过 `this` 来外部访问。\n\n#### 基类构造函数的参数\n\n派生合约需要提供基类构造函数需要的所有参数。这可以通过两种方式来完成:\n\n```javascript\npragma solidity ^0.4.0;\n\ncontract Base {\n    uint x;\n    // 这是注册 Base 和设置名称的构造函数。\n    function Base(uint _x) public { x = _x; }\n}\n\ncontract Derived is Base(7) {\n    function Derived(uint _y) Base(_y * _y) public {\n    }\n}\n\ncontract Derived1 is Base {\n    function Derived1(uint _y) Base(_y * _y) public {\n    }\n}\n```\n一种方法直接在继承列表中调用基类构造函数（`is Base(7)`）。 另一种方法是像 `修饰器 modifier` 使用方法一样， 作为派生合约构造函数定义头的一部分，（`Base(_y * _y)`)。 如果构造函数参数是常量并且定义或描述了合约的行为，使用第一种方法比较方便。 如果基类构造函数的参数依赖于派生合约，那么必须使用第二种方法。 如果像这个简单的例子一样，两个地方都用到了，优先使用 修饰器modifier 风格的参数。\n\n### 抽象合约\n\n合约函数可以缺少实现，如下例所示（请注意函数声明头由 **;** 结尾）:\n\n```javascript\npragma solidity ^0.4.0;\n\ncontract Feline {\n    function utterance() public returns (bytes32);\n}\n```\n这些合约无法成功编译（即使它们除了未实现的函数还包含其他已经实现了的函数），但他们可以用作基类合约:\n\n```javascript\npragma solidity ^0.4.0;\n\ncontract Feline {\n    function utterance() public returns (bytes32);\n}\n\ncontract Cat is Feline {\n    function utterance() public returns (bytes32) { return \"miaow\"; }\n}\n```\n如果合约继承自抽象合约，并且没有通过重写来实现所有未实现的函数，那么它本身就是抽象的。\n\n### 接口（Interface）\n\n接口类似于抽象合约，但是它们不能实现任何函数。还有进一步的限制：\n\n* 无法继承其他合约或接口。\n* 无法定义构造函数。\n* 无法定义变量。\n* 无法定义结构体\n* 无法定义枚举。\n\n首先，看一下一个interface的例子：\n\n```javascript\n\ncontract NumberInterface {\n  function getNum(address _myAddress) public view returns (uint);\n}\n```\n\n请注意，这个过程虽然看起来像在定义一个合约，但其实内里不同：\n\n* 首先，只声明了要与之交互的函数 —— 在本例中为 getNum —— 在其中没有使用到任何其他的函数或状态变量。\n* 其次，并没有使用大括号（{ 和 }）定义函数体，单单用分号（`;`）结束了函数声明。这使它看起来像一个合约框架。\n\n编译器就是靠这些特征认出它是一个接口的。\n\n> 就像继承其他合约一样，合约可以继承接口。\n\n可以在合约中这样使用接口：\n\n```javascript\ncontract MyContract {\n  address NumberInterfaceAddress = 0xab38...;\n  // ^ 这是FavoriteNumber合约在以太坊上的地址\n  NumberInterface numberContract = NumberInterface(NumberInterfaceAddress);\n  // 现在变量 `numberContract` 指向另一个合约对象\n\n  function someFunction() public {\n    // 现在我们可以调用在那个合约中声明的 `getNum`函数:\n    uint num = numberContract.getNum(msg.sender);\n    // ...在这儿使用 `num`变量做些什么\n  }\n}\n```\n\n通过这种方式，只要将合约的可见性设置为`public`(公共)或`external`(外部)，它们就可以与以太坊区块链上的任何其他合约进行交互。\n\n\n### 与其他合约的交互\n\n如果一个合约需要和区块链上的其他的合约会话，则需先定义一个 interface (接口)。\n\n先举一个简单的栗子。 假设在区块链上有这么一个合约：\n\n```javascript\ncontract LuckyNumber {\n  mapping(address => uint) numbers;\n\n  function setNum(uint _num) public {\n    numbers[msg.sender] = _num;\n  }\n\n  function getNum(address _myAddress) public view returns (uint) {\n    return numbers[_myAddress];\n  }\n}\n```\n\n这是个很简单的合约，可以用它存储自己的幸运号码，并将其与调用者的以太坊地址关联。 这样其他人就可以通过地址查找幸运号码了。\n\n现在假设我们有一个外部合约，使用 getNum 函数可读取其中的数据。\n\n首先，我们定义 LuckyNumber 合约的 interface ：\n\n```javascript\n\ncontract NumberInterface {\n  function getNum(address _myAddress) public view returns (uint);\n}\n```\n\n使用这个接口，合约就知道其他合约的函数是怎样的，应该如何调用，以及可期待什么类型的返回值。\n\n\n下面是一个示例代码，会用到上边的知识点：\n\n```javascript\npragma solidity ^0.4.19;\n\ncontract ZombieFactory {\n\n    event NewZombie(uint zombieId, string name, uint dna);\n\n    uint dnaDigits = 16;\n    uint dnaModulus = 10 ** dnaDigits;\n\n    struct Zombie {\n        string name;\n        uint dna;\n    }\n\n    Zombie[] public zombies;\n\n    // 创建一个叫做 zombieToOwner 的映射。其键是一个uint，值为 address。映射属性为public\n    mapping (uint => address) public zombieToOwner;\n    // 创建一个名为 ownerZombieCount 的映射，其中键是 address，值是 uint\n    mapping (address => uint) ownerZombieCount;\n\n    function _createZombie(string _name, uint _dna) private {\n        uint id = zombies.push(Zombie(_name, _dna)) - 1;\n        zombieToOwner[id] = msg.sender;\n        ownerZombieCount[msg.sender]++;\n        NewZombie(id, _name, _dna);\n    }\n\n    function _generateRandomDna(string _str) private view returns (uint) {\n        uint rand = uint(keccak256(_str));\n        return rand % dnaModulus;\n    }\n\n    function createRandomZombie(string _name) public {\n        // 我们使用了 require 来确保这个函数只有在每个用户第一次调用它的时候执行，用以创建初始僵尸\n        require(ownerZombieCount[msg.sender] == 0);\n        uint randDna = _generateRandomDna(_name);\n        _createZombie(_name, randDna);\n    }\n\n}\n\n// CryptoKitties 合约提供了getKitty 函数，它返回所有的加密猫的数据，包括它的“基因”（僵尸游戏要用它生成新的僵尸）。\n// 一个获取 kitty 的接口\ncontract KittyInterface {\n  \n  // 在interface里定义了 getKitty 函数 在 returns 语句之后用分号\n  function getKitty(uint256 _id) external view returns (\n    bool isGestating,\n    bool isReady,\n    uint256 cooldownIndex,\n    uint256 nextActionAt,\n    uint256 siringWithId,\n    uint256 birthTime,\n    uint256 matronId,\n    uint256 sireId,\n    uint256 generation,\n    uint256 genes\n  );\n}\n\n//ZombieFeeding继承自 `ZombieFactory 合约\ncontract ZombieFeeding is ZombieFactory {\n  \n  // CryptoKitties 合约的地址\n  address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;\n  // 创建一个名为 kittyContract 的 KittyInterface，并用 ckAddress 为它初始化 \n  KittyInterface kittyContract = KittyInterface(ckAddress);\n  \n  function feedAndMultiply(uint _zombieId, uint _targetDna, string _species) public {\n      // 确保对自己僵尸的所有权\n      require(msg.sender == zombieToOwner[_zombieId]);\n      // 声明一个名为 myZombie 数据类型为Zombie的 storage 类型本地变量\n      Zombie storage myZombie = zombies[_zombieId];\n      _targetDna = _targetDna % dnaModulus;\n      uint newDna = (myZombie.dna + _targetDna) / 2;\n      // Add an if statement here\n      if (keccak256(_species) == keccak256(\"kitty\")){\n          newDna = newDna - newDna％100 + 99;\n      }\n      _createZombie(\"NoName\", newDna);\n  }\n  \n  function feedOnKitty(uint _zombieId, uint _kittyId) public {\n    uint kittyDna;\n    // 多值返回，这里只需要最后一个值\n    (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);\n    feedAndMultiply(_zombieId, kittyDna, \"kitty\");\n  }\n}\n\n```\n\n> 这段代码看起来内容有点多，可以拆分一下，把 `ZombieFactory`代码提取到一个新的文件`zombiefactory.sol`，现在就可以使用 import 语句来导入另一个文件的代码。\n\n### import\n\n在 Solidity 中，当你有多个文件并且想把一个文件导入另一个文件时，可以使用 import 语句：\n\n```javascript\n\nimport \"./someothercontract.sol\";\n\ncontract newContract is SomeOtherContract {\n\n}\n```\n\n这样当我们在合约（contract）目录下有一个名为 someothercontract.sol 的文件（ ./ 就是同一目录的意思），它就会被编译器导入。\n\n> 这一点和 go 类似，在同一目录下文件中的内容可以直接使用，而不用使用 **xxx.name** 的形式。\n\n\n### 测试调用\n\n\n编译和部署 ZombieFeeding，就可以将这个合约部署到以太坊了。最终完成的这个合约继承自 ZombieFactory，因此它可以访问自己和父辈合约中的所有 public 方法。\n\n下面是一个与ZombieFeeding合约进行交互的例子， 这个例子使用了 JavaScript 和 web3.js：\n\n```javascript\nvar abi = /* abi generated by the compiler */\nvar ZombieFeedingContract = web3.eth.contract(abi)\nvar contractAddress = /* our contract address on Ethereum after deploying */\nvar ZombieFeeding = ZombieFeedingContract.at(contractAddress)\n\n// 假设我们有我们的僵尸ID和要攻击的猫咪ID\nlet zombieId = 1;\nlet kittyId = 1;\n\n// 要拿到猫咪的DNA，我们需要调用它的API。这些数据保存在它们的服务器上而不是区块链上。\n// 如果一切都在区块链上，我们就不用担心它们的服务器挂了，或者它们修改了API，\n// 或者因为不喜欢我们的僵尸游戏而封杀了我们\nlet apiUrl = \"https://api.cryptokitties.co/kitties/\" + kittyId\n$.get(apiUrl, function(data) {\n  let imgUrl = data.image_url\n  // 一些显示图片的代码\n})\n\n// 当用户点击一只猫咪的时候:\n$(\".kittyImage\").click(function(e) {\n  // 调用我们合约的 `feedOnKitty` 函数\n  ZombieFeeding.feedOnKitty(zombieId, kittyId)\n})\n\n// 侦听来自我们合约的新僵尸事件好来处理\nZombieFactory.NewZombie(function(error, result) {\n  if (error) return\n  // 这个函数用来显示僵尸:\n  generateZombie(result.zombieId, result.name, result.dna)\n})\n```\n\n### 参考链接\n\n- [Solidity 文档：https://solidity-cn.readthedocs.io/zh/develop/index.html](https://solidity-cn.readthedocs.io/zh/develop/index.html)\n- [cryptozombie-lessons2 僵尸攻击人类：https://cryptozombies.io/zh/lesson/2](https://cryptozombies.io/zh/lesson/2)\n- [Solidity 简易教程](https://mp.weixin.qq.com/s/1MaIc7uNqBMx-_eO4WGQgA)\n\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![](http://media.gusibi.mobi/ah0mqMXMtdJb9Yj03suu-NGEyVRxyEuOIT5bXSv7ip5aqtHkiRjTTl8SMRMv3Qp5)\n",
      "data": {
        "title": "Solidity 简易教程0x001",
        "date": "2018-10-22 13:36:53",
        "tags": [
          "区块链",
          "以太坊",
          "tutorial"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "solidity-sample-guide-0x001"
    },
    {
      "content": "\nSQLAlchemy in 空列表问题\n\n### 问题场景\n\n有model `Account`，SQLAlchemy 查询语句如下：\n\n```python\nquery = Account.query.filter(Account.id.in_(account_ids)).order_by(Account.date_created.desc())\n```\n\n这里 account_ids 如果为空，执行查询会有如下警告：\n\n```bash\n/usr/local/lib/python2.7/site-packages/sqlalchemy/sql/default_comparator.py:35: SAWarning: The IN-predicate on \"account.id\" was invoked with an empty sequence. This results in a contradiction, which nonetheless can be expensive to evaluate.  Consider alternative strategies for improved performance.\n  return o[0](self, self.expr, op, *(other + o[1:]), **kwargs)\n```\n\n> 这里的意思是使用一个空的列表会花费较长的时间，需要优化以提高性能。\n\n**为什么会有这个提示呢？一个空列表为什么会影响性能呢？**\n\n首先打印 query 可得到如下 sql 语句：\n\n```sql\nSELECT *   // 字段使用 “*” 代替\nFROM account\nWHERE account.id != account.id ORDER BY account.date_created DESC\n```\n\n会发现生成的语句中过滤条件是 `WHERE account.id != account.id`，使用 `PostgreSQL Explain ANALYZE 命令`，\n\n* EXPLAIN：显示PostgreSQL计划程序为提供的语句生成的执行计划。\n* ANALYZE：收集有关数据库中表的内容的统计信息。\n\n分析查询成本结果如下：\n\n```bash\npostgres=> EXPLAIN ANALYZE SELECT *\nFROM account\nWHERE account.id != account.id ORDER BY account.date_created DESC;\n                                    QUERY PLAN\n----------------------------------------------------------------------------------\n Sort  (cost=797159.14..808338.40 rows=4471702 width=29) (actual time=574.002..574.002 rows=0 loops=1)\n   Sort Key: date_created DESC\n   Sort Method: quicksort  Memory: 25kB\n   ->  Seq Scan on account  (cost=0.00..89223.16 rows=4471702 width=29) (actual time=573.991..573.991 rows=0 loops=1)\n         Filter: (id <> id)\n         Rows Removed by Filter: 4494173\n Planning time: 0.162 ms\n Execution time: 574.052 ms\n(8 rows)\n```\n\n先看Postgresql提供的语句生成的执行计划，通过结果可以看到，虽然返回值为空，但是查询成本却还是特别高，执行计划部分几乎所有的时间都耗费在排序上，但是和执行时间相比，查询计划的时间可以忽略不计。（结果是先遍历全表，查出所有数据，然后再使用 `Filter: (id <> id)` 把所有数据过滤。）\n\n按照这个思路，有两种查询方案：\n\n1. 如果 account_ids 为空，那么直接返回空列表不进行任何操作，查询语句变为：\n\n```python\nif account_ids:\n    query = Account.query.filter(Account.id.in_(account_ids)).order_by(Account.date_created.desc())\n```\n\n2. 如果 account_ids 为空，那么过滤方式，查询语句变为：\n\n```python\nquery = Account.query\nif account_ids:\n    query = query.filter(Account.id.in_(account_ids))\nelse:\n    query = query.filter(False)\n    \nquery = query.order_by(Account.date_created.desc())\n```\n\n如果 account_ids 为空，此时生成的 SQL 语句结果为：\n\n```sql\nSELECT *\nFROM account\nWHERE 0 = 1 ORDER BY account.date_created DESC\n```\n\n分析结果为：\n\n```sql\npostgres=> EXPLAIN ANALYZE SELECT *\nFROM account\nWHERE 0 = 1 ORDER BY account.date_created DESC;\n                                            QUERY PLAN\n---------------------------------------------------------------------------------------------------\n Sort  (cost=77987.74..77987.75 rows=1 width=29) (actual time=0.011..0.011 rows=0 loops=1)\n   Sort Key: date_created DESC\n   Sort Method: quicksort  Memory: 25kB\n   ->  Result  (cost=0.00..77987.73 rows=1 width=29) (actual time=0.001..0.001 rows=0 loops=1)\n         One-Time Filter: false\n         ->  Seq Scan on account  (cost=0.00..77987.73 rows=1 width=29) (never executed)\n Planning time: 0.197 ms\n Execution time: 0.061 ms\n(8 rows)\n```\n\n可以看到，查询计划和执行时间都有大幅提高。\n\n\n#### 一个测试\n\n> 如果只是去掉方案1排序，查看一下分析结果\n\n使用 `PostgreSQL Explain ANALYZE 命令`分析查询成本结果如下：\n\n```sh\npostgres=> EXPLAIN ANALYZE SELECT *\nFROM account\nWHERE account.id != account.id;\n                                 QUERY PLAN\n----------------------------------------------------------------------------\n Seq Scan on account  (cost=0.00..89223.16 rows=4471702 width=29) (actual time=550.999..550.999 rows=0 loops=1)\n   Filter: (id <> id)\n   Rows Removed by Filter: 4494173\n Planning time: 0.134 ms\n Execution time: 551.041 ms\n```\n\n可以看到，时间和有排序时差别不大。\n\n### 如何计算查询成本\n\n执行一个分析，结果如下：\n\n```sql\npostgres=> explain select * from account where date_created ='2016-04-07 18:51:30.371495+08';\n                                      QUERY PLAN\n--------------------------------------------------------------------------------------\n Seq Scan on account  (cost=0.00..127716.33 rows=1 width=211)\n   Filter: (date_created = '2016-04-07 18:51:30.371495+08'::timestamp with time zone)\n(2 rows)\n```\nEXPLAIN引用的数据是：\n\n 1. 0.00 预计的启动开销(在输出扫描开始之前消耗的时间，比如在一个排序节点里做排续的时间)。\n 2. 127716.33 预计的总开销。\n 3. 1 预计的该规划节点输出的行数。\n 4. 211 预计的该规划节点的行平均宽度(单位：字节)。 \n\n这里开销(cost)的计算单位是磁盘页面的存取数量，如1.0将表示一次顺序的磁盘页面读取。其中上层节点的开销将包括其所有子节点的开销。这里的输出行数(rows)并不是规划节点处理/扫描的行数，通常会更少一些。一般而言，顶层的行预计数量会更接近于查询实际返回的行数。\n这里表示的就是在只有单 CPU 内核的情况下，评估成本是127716.33;\n\n#### 计算成本，Postgresql 首先看表的字节数大小\n\n这里 account 表的大小为：\n\n```sql\npostgres=> select pg_relation_size('account');\n\npg_relation_size\n------------------\n        737673216\n(1 row)\n```\n\n#### 查看块的大小\n\nPostgresql 会为每个要一次读取的快添加成本点，使用 `show block_size`查看块的大小：\n\n```sql\npostgres=> show block_size;\n\nblock_size\n------------\n 8192\n(1 row)\n```\n\n#### 计算块的个数\n\n\n可以看到每个块的大小为8kb，那么可以计算从表从读取的顺序块成本值为：\n\n```\nblocks = pg_relation_size/block_size = 90048\n```\n\n`90048` 是account 表所占用块的数量。\n\n\n#### 查看每个块需要的成本\n\n```sql\npostgres=> show seq_page_cost;\n seq_page_cost\n---------------\n 1\n(1 row)\n```\n\n这里的意思是 Postgresql 为每个块分配一个成本点，也就是说上面的查询需要从90048个成本点。\n\n#### 处理每条数据 cpu 所需时间\n\n* cpu_tuple_cost：处理每条记录的CPU开销（tuple：关系中的一行记录）\n* cpu_operator_cost：操作符或函数带来的CPU开销。\n\n```sql\npostgres=> show cpu_operator_cost;\n cpu_operator_cost\n-------------------\n 0.0025\n(1 row)\n\npostgres=> show cpu_tuple_cost;\n cpu_tuple_cost\n----------------\n 0.01\n(1 row)\n```\n\n#### 计算\n\ncost 计算公式为：\n\n> cost = 磁盘块个数 * 块成本（1） + 行数 * cpu_tuple_cost（系统参数值）+ 行数 * cpu_operator_cost\n\n现在用所有值来计算explain 语句中得到的值：\n\n```python\nnumber_of_records = 3013466  # account 表 count\n\nblock_size = 8192  # block size in bytes\n\npg_relation_size=737673216\n\nblocks = pg_relation_size/block_size = 90048\n\nseq_page_cost = 1\ncpu_tuple_cost = 0.01\ncpu_operator_cost = 0.0025\n\ncost = blocks * seq_page_cost + number_of_records * cpu_tuple_cost + number_of_records * cpu_operator_cost\n```\n\n#### 如何降低查询成本？\n\n直接回答，使用索引。\n\n```sql\npostgres=> explain select * from account where id=20039;\n                                       QUERY PLAN\n----------------------------------------------------------------------------------------\n Index Scan using account_pkey on account  (cost=0.43..8.45 rows=1 width=211)\n   Index Cond: (id = 20039)\n(2 rows)\n```\n\n通过这个查询可以看到，在使用有索引的字段查询时，查询成本显著降低。\n\n> 索引扫描的计算比顺序扫描的计算要复杂一些。它由两个阶段组成。\nPostgreSQL会考虑random_page_cost和cpu_index_tuple_cost 变量，并返回一个基于索引树的高度的值。\n\n### 参考链接\n\n* [sqlalchemy-and-empty-in-clause](https://stackoverflow.com/questions/23523147/sqlalchemy-and-empty-in-clause)\n* [PostgreSQL查询性能分析和优化](https://www.linuxidc.com/Linux/2017-07/145768.htm)\n* [PostgreSQL学习手册(性能提升技巧)](http://www.cnblogs.com/stephen-liu74/archive/2011/12/25/2301064.html)\n* [PostgreSQL 查询成本模型](https://mp.weixin.qq.com/s/iBbVfmrTCxINlrbBS9u1Qw)\n* [PostgreSQL 查询计划时间的计算详解](https://blog.csdn.net/luojinbai/article/details/43085383)\n\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![](http://media.gusibi.mobi/ah0mqMXMtdJb9Yj03suu-NGEyVRxyEuOIT5bXSv7ip5aqtHkiRjTTl8SMRMv3Qp5)\n",
      "data": {
        "title": "SQLAlchemy in 空列表问题分析",
        "date": "2018-10-04 13:36:53",
        "tags": [
          "后端",
          "python",
          "development"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "sqlalchemy_in_empty_list_analyze"
    },
    {
      "content": "\n>  Solidity是以太坊的主要编程语言，它是一种静态类型的 JavaScript-esque 语言，是面向合约的、为实现智能合约而创建的高级编程语言，设计的目的是能在以太坊虚拟机（EVM）上运行。\n>  \n>  本文基于CryptoZombies，教程地址为：https://cryptozombies.io/zh/\n\n\n###  合约\n\n\nSolidity 的代码都包裹在**合约**里面. 一份`合约`就是以太应币应用的基本模块， 所有的变量和函数都属于一份合约, 它是你所有应用的起点.\n\n一份名为 `HelloWorld` 的空合约如下:\n\n```javascript\ncontract HelloWorld {\n\n}\n```\n\n\n#### hello world\n\n首先看一个简单的智能合约。\n\n```javascript\npragma solidity ^0.4.0;\n\ncontract SimpleStorage {\n    uint storedData; // 声明一个类型为 uint (256位无符号整数）的状态变量，叫做 storedData\n\n    function set(uint x) public {\n        storedData = x; // 状态变量可以直接访问，不需要使用 this. 或者 self. 这样的前缀\n    }\n\n    function get() public view returns (uint) {\n        return storedData;\n    }\n}\n```\n\n\n\n\n所有的 Solidity 源码都必须冠以 \"version pragma\" — 标明 Solidity 编译器的版本. 以避免将来新的编译器可能破坏你的代码。\n\n例如: `pragma solidity ^0.4.0;` (当前 Solidity 的最新版本是 0.4.0).\n\n> 关键字 `pragma` 的含义是，一般来说，pragmas（编译指令）是告知编译器如何处理源代码的指令的（例如， [pragma once](https://en.wikipedia.org/wiki/Pragma_once) ）。\n\n\n\nSolidity中合约的含义就是一组代码（它的 *函数* )和数据（它的 *状态* ），它们位于以太坊区块链的一个特定地址上。\n\n该合约能完成的事情并不多：它能允许任何人在合约中存储一个单独的数字，并且这个数字可以被世界上任何人访问，且没有可行的办法阻止你发布这个数字。当然，任何人都可以再次调用 `set` ，传入不同的值，覆盖你的数字，但是这个数字仍会被存储在区块链的历史记录中。\n\n\n\n> Solidity 语句以分号（**;**）结尾\n\n\n\n### 状态变量\n\n**状态变量**是被永久地保存在合约中。也就是说它们被写入以太币区块链中，想象成写入一个数据库。\n\n\n\n```javascript\ncontract HelloWorld {\n   // 这个无符号整数将会永久的被保存在区块链中\n   uint myUnsignedInteger = 100;\n}\n```\n\n\n在上面的例子中，定义 `myUnsignedInteger` 为 `uint` 类型，并赋值100。\n\n> `uint` 无符号数据类型， 指**其值不能是负数**，对于有符号的整数存在名为 `int` 的数据类型。\n>\n> Solidity中， `uint` 实际上是 `uint256`代名词， 一个256位的无符号整数。\n\n\n\n程序有时需要对不同类型的数据进行操作，因为 Solidity 是静态类型语言，对不同类型的数据进行运算会抛出异常，比如：\n\n```go\nuint8 a = 5;\nuint b = 6;\n// 将会抛出错误，因为 a * b 返回 uint, 而不是 uint8:\nuint8 c = a * b;\n```\n\n`a * b` 返回类型是 `uint`, 但是当我们尝试用 `uint8` 类型接收时, 就会造成潜在的错误。这时，就需要显式的进行数据类型转换：\n\n```go\n// 我们需要将 b 转换为 uint8:\nuint8 c = a * uint8(b);\n```\n\n\n\n> 把它的数据类型转换为 `uint8`, 就可以了，编译器也不会出错。\n\n\n\nSolidity 支持多种数据类型，比如：\n\n* string（字符串）：字符串用于保存任意长度的 UTF-8 编码数据\n* fixedArray（静态数组）：固定长度的数组\n* dynamicArray（动态数组）：长度不固定，可以动态添加元素的数组\n* enum（枚举）\n* mapping\n* 等\n\n\n\n### 数学运算\n\n\n\n在 Solidity 中，数学运算很直观明了，与其它程序设计语言相同:\n\n- 加法: `x + y`\n- 减法: `x - y`,\n- 乘法: `x * y`\n- 除法: `x / y`\n- 取模 / 求余: `x % y` *(例如, 13 % 5 余 3, 因为13除以5，余3)*\n- 乘方: `x ** y`\n\n\n\n### 结构体\n\n\n\nSolidity 提供了 `结构体`，用来表示更复杂的数据类型。\n\n\n\n```c\nstruct Person {\n  uint age;\n  string name;\n}\n```\n\n结构体允许你生成一个更复杂的数据类型，它有多个属性。\n\n创建结构体方式为：\n\n\n\n```go\n// 创建一个新的Person:\nPerson satoshi = Person(172, \"Satoshi\");\n```\n\n\n\n### 数组\n\nSolidity 提供两种类型的数组：`静态数组`和`动态数组`。\n\n\n\n```go\n// 固定长度为2的静态数组:\nuint[2] fixedArray;\n// 固定长度为5的string类型的静态数组:\nstring[5] stringArray;\n// 动态数组，长度不固定，可以动态添加元素:\nuint[] dynamicArray;\n```\n\n使用 push 函数向数组中添加值：\n\n```javascript\nfixedArray.push[123] \nfixedArray.push[234]\n// fixedArray 值为 [123, 234]\n```\n\n> `array.push()` 在数组的 **尾部** 加入新元素 ，所以元素在数组中的顺序就是添加的顺序\n> `array.push()` 会返回数组的长度。\n\n\nSolidity 数组支持多种类型，比如结构体：\n\n\n```c\nstruct Person {\n  uint age;\n  string name;\n}\n\nPerson[] people; // dynamic Array, we can keep adding to it\n```\n\n\n\n结构体类型的数组添加值的方式为：\n\n```c\npeople.push(Person(16, \"Vitalik\"));\n// 也可以使用下面的方式，推荐使用上述一行简洁的方式\n\nPerson satoshi = Person(172, \"Satoshi\");\npeople.push(satoshi);\n```\n\n\n\n#### 公共数组\n\n\n\n也可以使用`public`定义公共数组，Solidity 会自动创建`getter`方法。语法如下：\n\n```c\nstruct Person {\n  uint age;\n  string name;\n}\n\nPerson[] public people; // dynamic Array, we can keep adding to it\n```\n\n\n\n> 公共数组支持其它的合约读取数据（但不能写入数据），所以这在合约中是一个有用的保存公共数据的模式。（有点像全局变量，所有合约共享同一个“内存空间“，厉害了！）\n\n\n\n### 函数\n\n\n\nSolidity 中，函数定义如下：\n\n```javascript\nfunction eatHamburgers(string _name, uint _amount) {\n\n}\n```\n\n\n\n> `Solidity`  习惯上函数里的变量都是以(**_**)开头 (但不是硬性规定) 以区别全局变量。\n\n\n\n这是一个名为 `eatHamburgers` 的函数，它接受两个参数：一个 `string`类型的 和 一个 `uint`类型的。现在函数内部还是空的。\n\n函数调用如下：\n\n\n\n```go\neatHamburgers(\"vitalik\", 100);\n```\n\n\n\n#### 私有/公共函数\n\n\n\nSolidity 函数分为私有函数和共有函数。\n\n> Solidity 定义的函数的属性默认为`公共`。 这就意味着任何一方 (或其它合约) 都可以调用你合约里的函数。\n\n\n\n显然，不是什么时候都需要这样，而且这样的合约易于受到攻击。所以将自己的函数定义为`私有`是一个好的编程习惯，只有当你需要外部世界调用它时才将它设置为`公共`。\n>\n> 可以把所有的函数都显式的声明 `public`和`private`来规避这个问题。\n\n\n\n定义私有函数比较简单，只需要在函数参数后添加 `private`关键字即可。示例如下：\n\n\n\n```go\nuint[] numbers;\n\nfunction _addToArray(uint _number) private {\n  numbers.push(_number);\n}\n```\n\n\n\n这意味着只有我们合约中的其它函数才能够调用这个函数，给 `numbers`数组添加新成员。\n\n> 和函数的参数类似，私有函数的名字用(`_`)起始。\n\n\n\n> `注意：`在智能合约中你所用的一切都是公开可见的，即便是局部变量和被标记成 `private` 的状态变量也是如此。\n\n\n\n#### 返回值\n\n和其它语言一样，Solidity 函数也有返回值，示例如下：\n\n\n\n```go\nstring greeting = \"What's up dog\";\n\nfunction sayHello() public returns (string) {\n  return greeting;\n}\n```\n\n\n\n返回值使用 `returns`关键字标注。（已经是非常奇怪的写法了。。）\n\n\n\n#### 修饰符\n\n\n\n##### view\n\n> `constant` 是 `view` 的别名\n\n\n\n```go\nstring greeting = \"What's up dog\";\n\nfunction sayHello() public returns (string) {\n  return greeting;\n}\n```\n\n\n\n像 `sayHello` 函数这种实际上没有改变合约中数据内容的情况，可以把函数定义为`view`，这意味着此函数只读不修改数据。可以使用以下声明方式：\n\n\n\n```javascript\nfunction sayHello() public view returns (string) {}\n```\n\n可以将函数声明为 `view` 类型，这种情况下要保证不修改状态。\n\n下面的语句被认为是修改状态：\n\n1. 修改状态变量。\n2. [产生事件](https://solidity-cn.readthedocs.io/zh/develop/contracts.html#events)。\n3. [创建其它合约](https://solidity-cn.readthedocs.io/zh/develop/control-structures.html#creating-contracts)。\n4. 使用 `selfdestruct`。\n5. 通过调用发送以太币。\n6. 调用任何没有标记为 `view` 或者 `pure` 的函数。\n7. 使用低级调用。\n8. 使用包含特定操作码的内联汇编。\n\n\n\n##### pure\n\npure 比 view 更轻量，使用这个修饰符修饰的函数甚至都不会读取合约中的数据，例如：\n\n```javascript\nfunction _multiply(uint a, uint b) private pure returns (uint) { return a * b; }\n```\n\n这个函数没有读取应用里的状态，它的返回值只和它输入的参数相关。\n\n\n\n>  Solidity 编辑器会给出提示，提醒你使用 pure/view修饰符。\n\n\n\n函数可以声明为 `pure` ，在这种情况下，承诺不读取或修改状态。\n\n除了上面解释的状态修改语句列表之外，以下被认为是从状态中读取：\n\n1. 读取状态变量。\n2. 访问 `this.balance` 或者 `<address>.balance`。\n3. 访问 `block`，`tx`， `msg` 中任意成员 （除 `msg.sig` 和 `msg.data` 之外）。\n4. 调用任何未标记为 `pure` 的函数。\n5. 使用包含某些操作码的内联汇编。\n\n\n\n##### payable\n\n\n\npayable 关键字用来说明，这个函数可以接受以太币，如果没有这个关键字，函数会自动拒绝所有发送给它的以太币。   \n\n\n\n### 事件\n\n**事件** 是合约和区块链通讯的一种机制。你的前端应用“监听”某些事件，并做出反应。例如：\n\n\n\n```javascript\n// 这里建立事件\nevent IntegersAdded(uint x, uint y, uint result);\n\nfunction add(uint _x, uint _y) public {\n  uint result = _x + _y;\n  //触发事件，通知app\n  IntegersAdded(_x, _y, result);\n  return result;\n}\n```\n\n\n\n用户界面（当然也包括服务器应用程序）可以监听区块链上正在发送的事件，而不会花费太多成本。一旦它被发出，监听该事件的listener都将收到通知。而所有的事件都包含了 `from` ， `to` 和 `amount` 三个参数，可方便追踪事务。 为了监听这个事件，你可以使用如下代码（javascript 实现）：\n\n\n\n```javascript\nvar abi = /* abi 由编译器产生 */;\nvar ClientReceipt = web3.eth.contract(abi);\nvar clientReceipt = ClientReceipt.at(\"0x1234...ab67\" /* 地址 */);\n\nvar event = clientReceipt.IntegersAdded();\n\n// 监视变化\nevent.watch(function(error, result){\n    // 结果包括对 `Deposit` 的调用参数在内的各种信息。\n    if (!error)\n        console.log(result);\n});\n\n// 或者通过回调立即开始观察\nvar event = clientReceipt.IntegersAdded(function(error, result) {\n    if (!error)\n        console.log(result);\n});\n```\n\n\n\n\n\n### 代码示例\n\n下面是一个完整的代码示例：\n\n\n```javascript\npragma solidity ^0.4.19;\n\ncontract ZombieFactory {\n\n    // 建立事件\n    event NewZombie(uint zombieId, string name, uint dna);\n\n    uint dnaDigits = 16;  // 定义状态变量\n    uint dnaModulus = 10 ** dnaDigits;\n\n    struct Zombie {  // 定义结构体\n        string name;\n        uint dna;\n    }\n\n    Zombie[] public zombies;  // 定义动态数组\n\n    // 创建私有函数，私有函数命名使用 _ 前缀\n    function _createZombie(string _name, uint _dna) private {\n        // 函数参数命名 使用 _ 作为前缀\n        // arrays.push() 将元素加入到数组尾部，并且返回数组的长度\n        uint id = zombies.push(Zombie(_name, _dna)) - 1;\n        // 触发事件\n        NewZombie(id, _name, _dna);\n    }\n\n    // view 为函数修饰符，表示此函数不需要更新或创建状态变量\n    // pure 表示函数不需要使用状态变量\n    function _generateRandomDna(string _str) private view returns (uint) {\n        // 使用 keccak256 创建一个伪随机数\n        uint rand = uint(keccak256(_str));\n        return rand % dnaModulus;\n    }\n\n    function createRandomZombie(string _name) public {\n        uint randDna = _generateRandomDna(_name);\n        _createZombie(_name, randDna);\n    }\n\n}\n\n```\n\n> Ethereum 内部有一个散列函数keccak256，它用了SHA3版本。一个散列函数基本上就是把一个字符串转换为一个256位的16进制数字。\n> 在智能合约中使用随机数很难保证节点不作弊， 这是因为智能合约中的随机数一般要依赖计算节点的本地时间得到， 而本地时间是可以被恶意节点伪造的，因此这种方法并不安全。 通行的做法是采用 链外off-chain 的第三方服务，比如 Oraclize 来获取随机数）。\n\n\n### 参考链接\n\n- [Solidity 文档: https://solidity-cn.readthedocs.io/zh/develop/index.html](https://solidity-cn.readthedocs.io/zh/develop/index.html)\n- [cryptozombie-lessons: https://cryptozombies.io/zh/](https://cryptozombies.io/zh/)\n\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![](http://media.gusibi.mobi/ah0mqMXMtdJb9Yj03suu-NGEyVRxyEuOIT5bXSv7ip5aqtHkiRjTTl8SMRMv3Qp5?)\n",
      "data": {
        "title": "Solidity 简易教程",
        "date": "2018-09-04 13:36:53",
        "tags": [
          "区块链",
          "以太坊",
          "tutorial"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "solidity-simple-guide"
    },
    {
      "content": "\n最近有文字转图片的需求，但是不太想下载 APP，就使用 Python **Pillow** 实现了一个，效果如下：\n\n![文字转图片步骤](http://note.gusibi.mobi/oRWAws7M4TDPnm7I8nt6Rp9dbAO8_1531017842.png)\n\n\n\nPIL 提供了 `PIL.ImageDraw.ImageDraw.text` 方法，可以方便的把文字写到图片上，简单示例如下：\n\n\n\n```python\nfrom PIL import Image, ImageDraw, ImageFont\n# get an image\nbase = Image.open('Pillow/Tests/images/hopper.png').convert('RGBA')\n\n# make a blank image for the text, initialized to transparent text color\ntxt = Image.new('RGBA', base.size, (255,255,255,0))\n\n# get a font\nfnt = ImageFont.truetype('Pillow/Tests/fonts/FreeMono.ttf', 40)\n# get a drawing context\nd = ImageDraw.Draw(txt)\n\n# draw text, half opacity\nd.text((10,10), \"Hello\", font=fnt, fill=(255,255,255,128))\n# draw text, full opacity\nd.text((10,60), \"World\", font=fnt, fill=(255,255,255,255))\n\nout = Image.alpha_composite(base, txt)\n\nout.show()\n```\n\n\n\n> 为什么要计算文字的宽高呢？把文字直接写到背景图不可以么？\n\n\n\n**Pillow** `PIL.ImageDraw.ImageDraw.text`写文字是按换行符`\\n`换行的，如果个字符串特别长，文字部分就会超出背景图的宽度，所以第一步我们需要先把文本按固定的宽度计算出高度。\n\n\n\n像图上写的这样，文字转图片分三步：\n\n1. 计算文字宽高\n2. 生成响应尺寸背景图\n3. 把文字写到图片上\n\n\n\n### 计算文字宽高\n\n\n\n这里背景图宽度是固定的，所以文字的宽可以不用计算。`PIL.ImageDraw.ImageDraw.text` 是通过`\\n`来换行的，那我们只需要在文字合适的位置加上`\\n`就可以了。\n\n第一个想到的是 `textwrap` 方法，textwrap 可以实现通过调整换行符的位置来格式化文本。但 textwrap 还有一个问题就是它是根据字符长度来分隔的，但文本中的字符并不是等宽的，通过`textwrap`格式化后的文字写到图片上效果可能是这样的：\n\n![使用 textwrap 格式化后文字效果](http://media.gusibi.mobi/5eyQdzV0RMDigRT1sqQIsxJ6MdhEgaEUEM05yThoGXQmVQAaYiildNJ0N2dDAYep)\n\n\n\n> 使用这种方式，如果我们要调整字体大小，每一行的长度都还需要再重新调整。\n\n\n\n为了保证每一行宽度尽可能的一致，这里使用 `PIL.ImageDraw.ImageDraw.textsize` 获取字符宽高，然后按约定宽度把长文本分隔成文本列表，然后把列表每行文字写到图片上。\n\n\n\n```python\ndef get_paragraph(text, note_width):\n    # 把每段文字按约定宽度分隔成几行\n    txt = Image.new('RGBA', (100, 100), (255, 255, 255, 0))\n    # get a drawing context\n    draw = ImageDraw.Draw(txt)\n    paragraph, sum_width = '', 0\n    line_numbers, line_height = 1, 0\n    for char in text:\n        w, h = draw.textsize(char, font)\n        sum_width += w\n        if sum_width > note_width:\n            line_numbers += 1\n            sum_width = 0\n            paragraph += '\\n'\n        paragraph += char\n        line_height = max(h, line_height)\n    if not paragraph.endswith('\\n'):\n        paragraph += '\\n'\n    return paragraph, line_height, line_numbers\n\n\ndef split_text(text):\n    # 将文本按规定宽度分组\n    max_line_height, total_lines = 0, 0\n    paragraphs = []\n    for t in text.split('\\n'):\n        # 先按 \\n 把文本分段\n        paragraph, line_height, line_numbers = get_paragraph(t)\n        max_line_height = max(line_height, max_line_height)\n        total_lines += line_numbers\n        paragraphs.append((paragraph, line_numbers))\n    line_height = max_line_height\n    total_height = total_lines * line_height\n    # 这里返回分好的段，文本总高度以及行高\n    return paragraphs, total_height, line_height\n```\n\n\n\n这是按字符宽度分隔文本写到图片的效果：\n\n\n\n![计算字符宽度后格式化效果](http://media.gusibi.mobi/c6HsAdeihOmRnO5WtppOXWOmiiyB3rh5AW82fmUDEg35EjKzt-o5yGWQcJWQaSCq)\n\n\n\n> 由于文本长度不固定，生成得到的文本高度也不固定，背景图我们也需要动态生成\n\n\n\n### 根据文本高度生成背景图\n\n\n\n![便签图片](http://media.gusibi.mobi/OjG3S1KAtlLVG7NYgnaabCQzCLwzSGlVaeSinqc0tzXZNQuzZHAD9ZLRBb8zsL0v)\n\n\n\n通过图片我们可以看到，头部和尾部是固定的，变化的是文字部分，那么背景图片的高度计算公式为\n\n\n\n> 背景图片高度=头部高度+尾部高度+文本高度\n\n实现代码如下：\n\n```python\nNOTE_HEADER_IMG = path.normpath(path.join(\n    path.dirname(__file__), 'note_header_660.png'))\nNOTE_BODY_IMG = path.normpath(path.join(\n    path.dirname(__file__), 'note_body_660.png'))\nNOTE_FOOTER_IMG = path.normpath(path.join(\n    path.dirname(__file__), 'note_footer_660.png'))\nNOTE_WIDTH = 660\nNOTE_TEXT_WIDTH = 460\nbody_height = NOTE_BODY_HEIGHT = 206\nheader_height = NOTE_HEADER_HEIGHT = 89\nfooter_height = NOTE_FOOTER_HEIGHT = 145\nfont = ImageFont.truetype(NOTE_OTF, 24)\n\n\n\ndef get_images(note_height):\n    numbers = note_height // body_height + 1\n    images = [(NOTE_HEADER_IMG, header_height)]\n    images.extend([(NOTE_BODY_IMG, body_height)] * numbers)\n    images.append((NOTE_FOOTER_IMG, footer_height))\n    return images\n\n\ndef make_backgroud():\n    # 将图片拼接到一起\n    images = get_images()\n    total_height = sum([height for _, height in images])\n    # 最终拼接完成后的图片\n    backgroud = Image.new('RGB', (body_width, total_height))\n    left, right = 0, 0\n    background_img = '/tmp/%s_backgroud.png' % total_height\n    # 判断背景图是否存在\n    if path.exists(background_img):\n        return background_img\n    for image_file, height in images:\n        image = Image.open(image_file)\n        # (0, left, self.body_width, right+height)\n        # 分别为 左上角坐标 0, left\n        # 右下角坐标 self.body_width, right+height\n        backgroud.paste(image, (0, left, body_width, right+height))\n        left += height  # 从上往下拼接，左上角的纵坐标递增\n        right += height  # 左下角的纵坐标也递增\n    backgroud.save(background_img, quality=85)\n    return background_img\n```\n\n\n\n### 将文字写到图片\n\n\n\n现在我们得到了背景图以及分隔好的文本，就可以直接将文本写到图片上了\n\n\n\n```python\ndef draw_text(paragraphs, height):\n    background_img = make_backgroud()\n    note_img = Image.open(background_img).convert(\"RGBA\")\n    draw = ImageDraw.Draw(note_img)\n    # 文字开始位置坐标，需要根据背景图的大小做调整\n    x, y = 80, 100\n    for paragraph, line_numbers in paragraphs:\n        for line in paragraph.split('\\n')[:-1]:\n            draw.text((x, y), line, fill=(110, 99, 87), font=font)\n            y += line_height\n        # draw.text((x, y), paragraph, fill=(110, 99, 87), font=font)\n        # y += self.line_height * line_numbers\n    note_img.save(filename, \"png\", quality=1, optimize=True)\n    return filename\n```\n\n\n\n完整版代码请查看 [https://github.com/gusibi/momo/blob/master/momo/note.py][https://github.com/gusibi/momo/blob/master/momo/note.py]\n\n\n\n执行后效果如图：\n\n\n\n![](http://note.gusibi.mobi/oRWAws7M4TDPnm7I8nt6Rp9dbAO8_1531033396.png)\n\n\n\n### 遇到的问题\n\n\n\n为了能方便使用，我把这个做成了公号的一个功能，然后遇到了一个严重问题，**太慢了！**\n\n\n\n使用 `line_profiler` 分析可以发现，大部分时间都消耗在了图片保存这一步，\n\n```python\nnote_img.save(filename, \"png\", quality=1, optimize=True)\n```\n\n\n\n> 性能分析工具也会占用时间，测试完成后需要关闭分析\n\n\n\n解决这个问题可能的方法：\n\n1. 减小背景图片大小\n2. 减小字体大小\n\n\n\n通过测试，发现把背景图宽度从990减到660，字体大小从40px 调整到24px，生成的图片大小体积缩小了接近1倍，生成速度也比原来快了2/5。\n\n\n\n> 相同代码，相同文本，使用 python3 只用了2.3s，而 Python2 用时却是5.3 s，还从来没在其它功能上遇到过 Python2 和 Python3 有这么大的差别。\n>\n> > 具体差异可以使用源码测试一下\n\n\n\n#### 还是有问题\n\n优化完图片生成速度后，发现在长文本状态下，公号还是会超时报错。经过检查发现是图片上传到公众平台太慢了（服务器只有1M 带宽，没有办法.）。\n\n\n\n> 解决方法，把图片上传到腾讯云（文件上传使用的是内网带宽，不受限制），返回图片 url。\n\n\n\n![](http://media.gusibi.mobi/QoT4slWjqm_MtC910mPpJqhzlRmEpz75vGh1T4Oip_Zj3FrHIeQtZxi2imzLE1ex)\n\n## 参考链接\n\n\n------\n\n\n***最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "Python 生成便签图片",
        "date": "2018-07-08 07:04:52",
        "tags": [
          "python",
          "tutorial",
          "weixin",
          "公众号"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python_text_to_image"
    },
    {
      "content": "\n## UNIX 进程\n\n### 系统调用\n\nUnix 系统是由用户空间（userland）和内核组成。Unix 内核位于计算机硬件之上，是与硬件交互的中介。这些交互包括通过问卷系统进程读/写、在网络上发送数据、分配内存，以及通过扬声器播放音频。这些都是用户应用程序所不能涉及的，只能通过系统调用来完成。\n\n> `系统调用`为内核和用户空间搭建了桥梁。规定了程序和计算机硬件直接所允许发生的一切交互。\n\n进程是 Unix 系统的基石，所有的代码都是在进程中运行。\n\nunix 中的进程创建是通过内核系统调用 fork() 实现的。当一个进程产生一个 fork 请求时，操作系统执行以下功能：\n\n1. 为新进程在进程表中分配一个空项\n2. 为子进程赋一个唯一的进程标识符\n3. 为一个父进程上下文的逻辑副本，不包括共享内存区\n4. 增加父进程拥有的所有文件的计数器，以表示有一个另外的进程现在也用户这些文件。\n5. 把子进程置为就绪态\n6. 向父进程返回子进程的进程号；对子进程返回0。\n\n所有这些操作都在父进程的内核态下完成。\n\n### 进程皆有标识\n\n在系统中运行的所有进程都有一个唯一的进程标识符，称为 pid。\n\n> pid 并不传达关于进程本身的任何信息，仅仅是一个数字标识\n\n在 python 中查看当前进程 pid 可以使用 `getpid()` 方法。\n\n```python\n>>> import os\n\n>>> print os.getpid()\n26164\n```\n\n> 在实际应用中，pid 可以加入都日志信息中，这样当多个进程向同一个文件写入日志的时候，就可以知道哪一行是由哪个进程写入的。\n\n### 进程皆有父\n\n系统中运行的每一个进程都有对应的父进程。每个进程都知道它父进程的标识符（ppid）。\n\n在 python 中查看当前进程 pid 可以使用 `getppid()` 方法。\n\n```python\n>>> import os\n\n>>> print os.getpid()\n26164\n>>> print os.getppid()\n26125\n```\n\n### 进程皆有文件描述符\n\n在 Unix 中，一切都是文件。\n\n![一切皆文件](<http://media.gusibi.mobi/7_BEou-9LxGREQm2CyB18Oeb93T8Pp_shyshaDgE5teiRCA48OatdxhJWq8J07wF>)\n\n无论何时在进程中打开一个资源，你都会获得一个文件描述符编号（file description number）。文件描述符并不会在无关进程之间共享，它只存在于其所属的进程之中。\n\n```python\n#! -*- coding: utf-8 -*-\n\nimport os\n\np = open('test.txt', 'wb')\nprint(p.name, p.fileno())\n\np1 = open('test1.txt', 'wb')\nprint(p1.name, p1.fileno())\n\np.close()\n\np2 = open('test2.txt', 'wb')\nprint(p2.name, p2.fileno())\n\nprint(p.name, p.fileno())\n```\n\n\n输出：\n\n```shell\ntest.txt 3\ntest1.txt 4\ntest2.txt 3\nTraceback (most recent call last):\n  File \"/Users/gs/Desktop/fdn.py\", line 16, in <module>\n    print(p.name, p.fileno())\nValueError: I/O operation on closed file\n```\n\n\n> 进程打开所有资源都会获得一个用于标识的唯一数字。\n>\n> 打开多个资源所分配的文件描述符编号是尚未使用的最小的数值。\n>\n> 资源一旦关闭，对应的文件描述符编号就会释放又能继续使用了。\n>\n> 文件描述符只是用来跟踪打开的资源，已经关闭的资源是没有文件描述符的。\n\n标准流\n\n每个 Unix 进程都有三个打开的资源，它们是标准输入（STDIN）、标准输出（STDOUT）和标准错误（STDERR）。\n\n* STDIN 提供了一种从键盘或管道中读取输入的通用方法\n* STDOUT 和 STDERR 提供了一种向显示器、文件或打印机等输出写入内容的通用方法。\n* STDIN、STDOUT、STDERR 也是文件\n\n```python\nimport sys\n\nprint(sys.stdin.fileno())\nprint(sys.stdout.fileno())\nprint(sys.stderr.fileno())\n```\n\n输出：\n\n```shell\n0\n1\n2\n```\n\n### 进程皆有资源限制\n\n> 文件描述符代表已打开的资源，当资源没有被关闭的时候，文件描述符编号会一直递增，那一个进程可以拥有多少个文件描述符呢？\n\n可以使用`getrlimit`找出限制：\n\n```python\nimport resource\n\nprint(resource.getrlimit(resource.RLIMIT_NOFILE))\n```\n\n输出：\n\n```shell\n(10496, 9223372036854775807)\n```\n\n\n\n可以看到输出的结果是一个元组，里边有两个元素，第一个元素是文件描述符的软限制，第二个是文件描述符的硬限制。\n\n> `软限制`：软限制其实不算限制，因为每个进程都可以修改这个值。超出这个值后会抛出一个异常。\n>\n> `硬限制`: 硬限制只有超级用户才能修改，但是硬限制其实是一个无限大的数字，可以认为是没有限制。\n\n`getrlimit`还可以查询其它限制，比如：\n\n* `RLIMIT_NPROC`  用户可拥有的最大进程数\n* `RLIMIT_FSIZE` 进程可创建的最大文件。如果进程试图超出这一限制时，核心会给其发送SIGXFSZ信号，默认情况下将终止进程的执行。\n\n详细信息可以查看 [Recource 文档](https://docs.python.org/2/library/resource.html)\n\n可以使用 `setrlimit`来修改软限制：\n\n```python\nimport resource\n\nprint(resource.getrlimit(resource.RLIMIT_NOFILE))\nresource.setrlimit(resource.RLIMIT_NOFILE, (2048, resource.RLIM_INFINITY))\nprint(resource.getrlimit(resource.RLIMIT_NOFILE))\n```\n\n输出：\n\n```shell\n(10496, 9223372036854775807)\n(2048, 9223372036854775807)\n```\n\n> `硬限制`的大小不建议修改，因为它是不可逆的。\n\npython 中如果超出了软限制，会抛出 OSError：\n\n```python\nimport resource\n\nresource.setrlimit(resource.RLIMIT_NOFILE, (3, resource.RLIM_INFINITY))\nprint(resource.getrlimit(resource.RLIMIT_NOFILE))\n\np = open('test.txt', 'wb')\nprint(p.name, p.fileno())\n```\n\n输出：\n\n```python\n(3, 9223372036854775807)\nTraceback (most recent call last):\n  File \"/Users/gs/Desktop/fdn.py\", line 30, in <module>\nOSError: [Errno 24] Too many open files: 'test.txt'\n```\n\n> 多数程序是不需要修改系统资源限制的，但对一些特殊工具，这是必须的步骤。\n>\n> 比如压测工具 httperf：如果我们使用命令 httperf —hog —server www —num-conn 5000 这样的命令，就需要 httperf 创建5000个并发连接，如果这里超出了软限制，就会抛出异常。\n>\n> 所以在压测之前httperf需要先调高软限制。\n\n### 进程皆有退出码\n\n当进程结束时，都会留下数字（0-255）退出码，操作系统根据退出码可以知道进程是否运行正常。\n\n>  退出码0被认为是顺利结束，其他退出码表示出现了错误\n\npython 使用 os.exit() 来退出进程\n\n\n```python\n#! -*- coding: utf-8 -*-\n\nimport sys\n\nsys.exit() # 这将使进程携带状态码0退出\n\ntry:\n    sys.exit(2)\nexcept SystemExit as e:\n    print('error', e)  # 这里将打印 exit 中的参数 2\n```\n\n\n\n> `sys.exit()` 会引发一个异常，如果异常没有被捕获，那么 python 解释器将会退出。如果有捕获此异常代码，那么代码继续执行。\n\n\n\n```python\n#! -*- coding: utf-8 -*-\nimport sys\nimport atexit\n\ndef test():\n    print(\"hello exit\")\n\natexit.register(test)\n\nsys.exit() # 也可以是 raise\n```\n\n\n\n> 当 exit 被调用时，在进程结束之前，python 会调用 atexit 所定义的语句。\n\n\n\n### 进程皆可衍生\n\n衍生是 Unix 编程中最强大的概念之一。fork 系统调用允许允许中的进程以编程的形式创建新的进程。这个新进程和原始进程一模一样。\n\n> 进行衍生时，调用 fork 的进程被称为`父进程`，新创建的进程被称为`子进程`。\n>\n> 子进程从父进程处继承了其所占用内存中的所有内容，以及所有属于父进程的已打开的文件描述符。\n\n* 子进程拥有自己唯一的 pid\n* 子进程的ppid 就是调用 fork 的进程的 pid\n* fork 调用时，子进程从父进程处继承了所有的文件描述符，也获得了父进程所有的文件描述符编号。这样，两个进程就可以共享打开的文件、套接字等。\n* 子进程继承了父进程内存中所有的数据\n* 子进程可以随意更改其内存内容的副本，而不会对父进程造成影响。\n\n\n\n```python\n#! -*- coding: utf-8 -*-\n\nimport os, sys\n\nprint('current pid:', os.getpid())\npid = os.fork()\n\nprint('pid', pid)\n\nif pid == 0:\n    print('I am child process (%s) and my parent is %s.' % (os.getpid(), os.getppid())) \nelse:\n    print('I (%s) just created a child process (%s).' % (os.getpid(), pid))\n```\n\n输出：\n\n```python\ncurrent pid: 9316\npid 9317\nI (9316) just created a child process (9317).\npid 0\nI am child process (9317) and my parent is 9316.\n```\n\n> `fork()`函数是 python 的内建函数，子进程拥有返回0，而父进程返回子进程的 ID。\n>\n> 所以这段代码中，if 语句由子进程执行，而 else 语句由父进程执行。\n\n\n考虑一个问题：\n\n由于 fork 的时候创建了一个和父进程一模一样的子进程，它包含了父进程在内存中的一切内容。如果，父进程占用内存特别大怎么办呢？\n\n\n> Unix 采用的是写时复制（copy-on-write，CoW）的方法，所以 fork 的时候父进程和子进程是共享内存中数据的，直到它们中的一个需要对数据进程修改，才会进行内存复制，使得两个进程保持适当的隔离。\n\n\n\n### 孤儿进程\n\n> 当通过终端启动单个进程时，通常只有这个进程向 STDOUT 写入，从键盘获取输入或者侦听 Ctrl+C 已待退出。\n>\n> 但是，如果进程衍生出了子进程，当你按下 Ctrl+C 的时候，哪一个进程应该退出呢？是全部退出还是只有父进程退出？\n\n\n\n```python\n#! -*- coding: utf-8 -*-\nimport time\nimport os, sys\n\nprint('current pid:', os.getpid())\npid = os.fork()\nprint('pid', pid)\n\nif pid == 0:\n    for i in range(5):\n        time.sleep(1)\n        print(\"I'm an orphan!\")\nelse:\n    sys.exit('Parent process died...')\n```\n\n执行代码，打印结果如下：\n\n![](<http://media.gusibi.mobi/kiV8luPm0vIwOTZRnYTlUyVD4zjBKHa03kBjjFeBJHGSUmIVt8ZXZ70JzvpILfhm>)\n\n\n\n通过打印结果会发现，运行程序父进程结束后，立刻放回到终端命令提示符下，此时终端被子进程输出到 STDOUT 的内容重写了。\n\n> 父进程结束后，子进程并不好退出，还是会继续运行。\n>\n> 这种操作适用于希望子进程异步的处理其他事务，而父进程按原计划运行的场景。\n\n### 进程皆可待\n\n如果想监控子进程的动向，应该怎么操作呢？\n\nPython 提供了 `os.wait()` 方法。\n\n```python\n#! -*- coding: utf-8 -*-\nimport time\nimport os, sys\nfrom subprocess import Popen\n\nprint('current pid:', os.getpid())\npid = os.fork()\nprint('pid', pid)\n\nif pid == 0:\n    for i in range(5):\n        time.sleep(1)\n        print(\"I'm an orphan!\")\nelse:\n    os.wait()\n    sys.exit('Parent process died...')\n```\n\n输出如下：\n\n![](<http://media.gusibi.mobi/W8LmJ8a_SIDIQlOHElCueUTd5v8T8eu6yQTd8x9uHCxcLHyh29mvwJZqk98VkFE0>)\n\n这一次，所有输出都打印出来之后，控制才返回给终端。\n\n那么，os.wait() 做了什么呢❓\n\n> os.wait() 是一个阻塞调用，该调用使得父进程一直等到它的子进程退出之后才继续执行。\n>\n> 这个方法会返回一个元组，包含 pid 和退出码。\n\n\n### 僵尸进程\n\n### 进程皆可获得信号\n\n### 进程皆可通信\n\n### 守护进程\n\n## 参考链接\n\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n想了解以下内容可以在公号输入相应关键字获取历史文章： `公号&小程序` | `设计模式` | `并发&协程`\n\n| 关注 |赞赏 |\n|---|---|\n|![](http://media.gusibi.mobi/kel2L88yf9YXZYecLIn0LPZPSXc7zJfHyGUz5biWsZrGh7xF2JONZT93dgClGdMn)|![](http://media.gusibi.mobi/VFjjmZ7cgkIkpieAFHYXcLVBB8f9snm2vAzc0GyLjSmCzok8mL3vqLNMzYVvrDha)|\n",
      "data": {
        "title": "《理解 unix 进程》笔记-1",
        "date": "2018-03-25 15:25:53",
        "tags": [
          "进程",
          "并发",
          "读书笔记",
          "后端"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "understand-unix-process-1"
    },
    {
      "content": "\n> 这是`操作系统进程`系列文章第三篇-操作系统线程描述\n> 文章是《操作系统-精髓与设计原理》学习笔记\n\n## 线程（thread）\n\n### 什么是线程\n\n**线程**是操作系统能够进行运算调度的最小单位。它被包含在[进程](http://mp.weixin.qq.com/s/s_um6t-mORit4SDHvEYgpQ)之中，是[进程](http://mp.weixin.qq.com/s/s_um6t-mORit4SDHvEYgpQ)中的实际运作单位。一条线程指的是[进程](http://mp.weixin.qq.com/s/s_um6t-mORit4SDHvEYgpQ)中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。\n\n关于进程的两个概念：\n\n* 资源所有权：一个进程包括一个存放进程映像的虚拟地址空间（进程映像是程序、数据、栈和进程控制块中定义的属性的集合）。一个进程总是拥有对资源的控制或所有权，这些资源包括内存、I/O 通道，I/O 设备和文件。\n* 调度/执行：一个进程沿着通过一个或多个程序的一条执行路径执行，其执行过程可能与其他进程的执行过程交替执行。一个进程具有一个执行状态和一个分片的优先级，并且是一个可被操作系统调度和分配的实体。\n\n这两个概念是独立的，操作系统可以独立的处理。\n\n> 现代操作系统通常把分派单位称为线程（或轻量级进程），拥有资源所有权的单位称为进程。\n\n\n### 多线程\n\n多线程是指操作系统在单个进程内支持多个并发执行路径的能力。每个进程中只有一个线程在执行的方法称为单线程方法。进程支持多个线程的情况被称作多线程。\n\n在多线程环境中，进程被定义成资源分配的单位和一个被保护的单位，与进程相关联的有：\n\n* 存放进程映像的虚拟地址空间\n* 受保护的对处理器、其他进程、文件和 I/O 资源的访问\n\n在一个进程中，可能有一个或多个线程，每个线程有：\n\n* 线程的执行状态（运行，就绪）\n* 在未运行时保存的线程上下文\n* 一个执行栈\n* 用于每个线程局部变量的静态存储空间\n* 与进程内的其他线程共享的对进程的内存和资源的访问\n\n\n### 进程 VS 线程\n\n\n下图说明了进程和线程的区别：\n\n![线程和进程的区别](<http://media.gusibi.mobi/0KDXx7b4LkTyhJrxat45HK22Hsoz4OQrb_MKZCdsZH9DvqiPlajrDtLd1S_QtHMn>)\n\n在单线程模型中，进程的标出包括他的进程控制块和用户地址空间，以及在进程执行中管理调用/返回 行为的用户栈和内核栈。当进程被控制时，处理器寄存器被该进程锁控制；当进程不运行时，这些处理器寄存器的内容被保存。\n\n在多线程环境中，进程仍然只有一个与之关联的进程控制块和用户地址空间。但是每个线程都有一个独立的栈，还有独立的控制块用于包含寄存器值、优先级和其他与线程相关的状态信息。\n\n> 进程中的所有线程共享该进程的状态和资源，它们驻留在同一块地址空间中，并且可以访问到相同的数据。当一个线程改变了内存中的一个数据项时，其他线程在访问这一数据项时能够看到变化后的结果。\n\n### 线程的优点\n\n1. 在一个已有的进程中创建一个新的线程比创建一个全新的进程所需时间要少的多。\n2. 终止一个线程比终止一个进程花费的时间少\n3. 同一个进程内线程间切换比进程间切换花费的时间要少。\n4. 线程提高了不同的执行程序间通信的效率。（大多数操作系统中，独立进程间的通信需要内核的介入，由于同一进程中的线程共享内存和文件，它们间的通信无需调用内核）\n\n### 线程状态\n\n和进程一样，线程的关键状态有运行态、就绪态和阻塞态。挂起是进程级别的概念，一个进程被换出，它的所有线程都被换出。\n\n有4个与线程状态改变相关的操作：\n\n* 派生：当派生一个新进程时，同时也为改进程派生出一个线程。进程中的线程也可以在同一个进程中派生另一个线程，新的线程拥有自己的寄存器上下文和栈空间，且被放置在就绪队列中。\n* 阻塞：当线程需要等待一个事件时，将被阻塞，此时处理器转而执行另一个就绪线程（可能是同一进程，也可能是不同进程）\n* 解除阻塞：当阻塞一个线程的事件发生时，该线程被转移到就绪队列中\n* 结束：当一个线程完成时，其寄存器上下文和栈都被释放。\n\n### 用户级线程和内核级线程\n\n线程的实现可以分为两大类：`用户级线程（User-Level Thread ULT）`和`内核级线程（Kernel-Level Thread KLT）`。\n\n![用户级线程和内核级线程](<http://media.gusibi.mobi/gaApT9BLo5q0kZG1iOaC5yllVRMtR74cnYNxvAKy-jBDVm122aizcvSB2-ZyxCIp>)\n\n\n在用户级线程和内核级线程使用时，通常有以下三种模式：\n\n![用户级线程和内核级线程](<http://media.gusibi.mobi/gx5Ssn4Taoq-BDMJ0Dty58lVtdWhc5AHnF-3yssLGRzJl2k7HZa-sgq9PP3xAKGA>)\n\n**在一个纯粹的用户级线程程序中，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。**\n\n使用用户级线程的优点：\n\n1. 线程切换不需要内核态特权，因此，进程不需要为了线程管理而切换到内核态，这节省了两次状态转换（从用户态到内核态，再从内核态返回用户态）的开销。\n2. 调度可以是用户程序相关的。（可以为特定的应用使用特定的调度算法）\n3. 用户级线程可以在任何操作系统中运行，不需要对底层内核进行修改以支持用户级线程。\n\n使用用户级线程的缺点：\n\n1. 许多系统调用会被阻塞。因此当用户级线程执行一个系统调用时，不仅这个线程会被阻塞，进程中所有线程都会被阻塞。\n2. 不能使用多个处理器。内核一次只把一个进程分配给一个处理器，因此一个进程中只有一个线程可以执行。\n\n> 解决这两个问题有两种方式：\n>\n> 1. 使用多进程代替多线程，但这样消除了多线程的优势\n> 2. 使用 jacketing 技术。把一个产生阻塞的系统调用转换成一个非阻塞的系统调用。\n\n\n\n在一个纯粹的内合辑线程程序中，有关线程管理的所有工作都由内核完成。内核为进程及其内部的每个线程维护上下文信息。调度由内核基于线程完成。\n\n> 使用内核级线程客服了用户级线程的两个基本缺陷。首先内核可以把同一个进程的多个线程调度到多个处理器；其次一个进程中的线程被阻塞，内核可以调度同一个进程的另一个线程。\n>\n> 主要缺点是：把控制从一个线程传送到同一个进程内的另一个线程是，需要内核的状态切换。\n\n\n![线程和进程的执行时间](<http://media.gusibi.mobi/iD4lEh-rtxW0iN5EzdzLYtyQr4LZlcFDiMOo06JLNuhC69DKDMjXgGRldy6ELJvV>)\n\n某些操作系统提供了一种组合的用户级/内核级线程设施。在组合的系统中，线程创建完全在用户空间中完成，线程的调度和同步也是在应用程序中进行。一个应用程序中的多个用户级线程被映射到一些（小于或等于用户级线程的数目）内核级线程上。开发者可以为特定的应用程序和处理器调节内核级线程的数目，以达到最佳结果。\n\n### Linux 的进程和线程管理\n\nLinux中的进程或任务由一个 `task_struct`数据结构表示，这个数据结构包含了以下信息：\n\n*  状态：进程的执行状态\n* 调度信息：Linux 调度进程所需的信息\n* 标识符\n* 进程间通信：Linux 支持 UNIX SVR4中的 IPC 机制。\n* 时间和计时器：包括进程创建的时刻和进程所消耗的处理器时间总量\n* 文件系统：包括指向被该进程打开的任何文件的指针和指向该进程当前和根目录的指针。\n* 地址空间：定义分配给该进程的虚拟空间\n* 处理器专用上下文：构成改进程上下文的寄存器和栈信息\n* 停止：进程被终止，并且只能由来自另一个进程的主动动作恢复\n* 僵死：进程已被终止，但由于某些原因，在进程表中仍然有它的任务结构\n\nLinux 提供一种不区分进程和线程的解决方案，用户级线程被映射到内核级进程上。组成一个用户级进程的多个用户级线程被映射到共享同一组 ID 的多个 Linux 内核级进程上。这使得这些进程可以共享文件和内存等资源，使得同一组中的进程调度切换是不需要切换上下文。\n\n在 Linux 中通过复制当前进程的属性可创建一个新进程。新进程被克隆出来，使得它可以共享资源。当两个进程共享相同虚拟内存时，它们可以被当做是一个进程中的线程。因此 Linux 中进程和线程没有区别。\n\n\n## 参考链接\n\n* 《操作系统-精髓与设计原理》\n* [Threads and Concurrency](https://applied-programming.github.io/Operating-Systems-Notes/3-Threads-and-Concurrency/)\n\n------\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n想了解以下内容可以在公号输入相应关键字获取历史文章： `公号&小程序` | `设计模式` | `并发&协程`\n\n| 关注 |赞赏 |\n|---|---|\n|![](http://media.gusibi.mobi/kel2L88yf9YXZYecLIn0LPZPSXc7zJfHyGUz5biWsZrGh7xF2JONZT93dgClGdMn)|![](http://media.gusibi.mobi/VFjjmZ7cgkIkpieAFHYXcLVBB8f9snm2vAzc0GyLjSmCzok8mL3vqLNMzYVvrDha)|\n",
      "data": {
        "title": "操作系统线程描述",
        "date": "2018-03-24 04:25:53",
        "tags": [
          "进程",
          "并发",
          "读书笔记",
          "后端"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "system-process-3"
    },
    {
      "content": "\n> 这是`操作系统进程`系列文章第二篇-操作系统进程描述\n\n## 进程\n\n### 什么是进程\n\n在给进程下定义前，先考虑以下几个概念：\n\n1. 一个计算机平台包括一组硬件资源：比如处理器、内存、I/O 模块、定时器和磁盘驱动器等。\n2. 计算机程序是为执行某些任务而开发的。典型情况下，它们接受外来的输入，做一些处理后，输出结果。\n3. 直接根据给定的硬件平台写应用程序效率是低下的\n4. 开发操作系统是为了给应用程序提供一个方便、安全和一直的接口。操作系统是计算机硬件和应用程序直接的一层软件，对应用程序和工具提供了支持。\n5. 可以把操作系统想象为资源的统一抽象表示，可以被应用程序请求和访问。资源包括内存、网络接口和文件系统等。\n\n有了上述概念，现在就可以讨论操作系统怎样以一个有序的方式管理应用程序的执行，以达到以下目的：\n\n* 资源对多个应用程序是可用的\n* 物理处理器在多个应用程序间切换以保证所有程序都在执行中\n* 处理器和 I/O 设备能得到充分的利用\n\n现代操作系统采用的方法都是`依据对应于一个或多个进程存在的应用程序执行的一种模型`。\n\n关于进程有很多定义：\n\n- 一个正在执行的程序\n- 计算机中正在运行的程序的一个实例\n- 可以分配给处理器并由处理器执行的一个实体\n- 由单一的顺序的执行线程、一个当前状态和一组相关的系统资源所描述的活动单元\n\n### 进程状态\n\n一个被执行的程序，操作系统会为该程序创建一个进程或任务，并且控制进程的执行。\n\n简单来说，程序只有两种状态：`运行态`、`未运行态`。\n\n![两状态进程模型](<http://media.gusibi.mobi/OskbbEAvy2Pml-DAIPGNsq73iTnGmEoG61GC1jFK2S7grZpYiIZxN5rYXw1NvA_3>)\n\n* 当操作系统创建一个新进程时，它将该进程以未运行态加入到系统中，操作系统知道进程的存在，并等待执行机会。\n* 当前运行的进程不时中断，操作系统的分派器将选择一个新进程运行。\n* 前一个进程从运行态转换到未运行态，另一个从未运行态转换到运行态。\n\n同时，未运行的进程需保持在某种类型的队列中，并等待它们的执行时机。\n\n上图中的排队图可以描述分派器的行为：被中断的进程转移到等待进程队列中，或者，如果进程以及结束或取消，则被销毁。在任何一种情况下，分派器均从队列中选择一个进程来执行。\n\n通过这个模型，可以看出操作系统需要用某种方式来表示每个进程，使得操作系统能够跟踪它，也就是说需要有一些与进程相关的信息，包括进程在内存中的状态和位置，即`进程控制块`。\n\n### 进程控制块\n\n进程在任意时间都可以唯一地被表征为以下元素：\n\n![简化的进程控制块](<http://media.gusibi.mobi/Nra2ykMZsSS2HqGQjASJUXZ7krpqAhCZPSVKc7_G6CUH_kusdOcZpLL2BddET7oJ>)\n\n* 标识符：存储在进程控制块中的数字标识符，包括（次进程的标识符-进程 ID，父进程标识符，用户标识符-用户 ID）\n* 状态：进程状态（如运行态，就绪态，等待态等）\n* 优先级：用于描述进程调度优先级的一个或多个域。\n* 程序计数器：程序中即将被执行的下一条指令的地址\n* 内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享内存块的指针\n* 上下文数据：进程执行时处理器的寄存器的数据\n* I/O 状态信息：包括显示的 I/O 请求、分配给进程的 I/O 设备和被进程使用的文件列表等\n* 记账信息：可能包括处理器时间总和、使用的时钟数总和、时间限制、记账号等。\n\n这些信息被存放在一个叫`进程控制块`的数据结构中，它由操作系统创建和管理。进程控制块是进程存在的唯一标志，也就是说任何一个进程只要进程创建了它就一定有一个跟它相对应的进程控制块，进程结束了进程控制块就会被操作系统回收，进程在执行的过程对进程的所有操作都是通过进程控制块来实现的。\n\n#### 进程创建和终止\n\n进程除运行和未运行外，在进程的生命周期中，创建和终止都是不可避免的。\n\n##### 进程创建\n\n通常有4个事件会导致创建一个进程：\n\n1. 新的批量作业\n2. 交互登录。终端用户登录到系统\n3. 操作系统因为提供一项服务而创建。操作系统可以创建一个进程，代表用户程序执行一个功能，使用户无需等待。\n4. 由现有进程派生。基于模块化的考虑，或者为了开发并行性，用户程序可以指示创建多个进程。\n\n>  当一个进程派生另一个进程时，前一个称为父进程，被派生的被称为子进程。\n\n一旦操作系统决定创建一个新进程，它就会按以下步骤进行：\n\n1. 给新进程分配一个唯一的进程标识符。\n2. 给进程分配空间。\n3. 初始化进程控制块。\n4. 设置正确的连接。（例如，如果操作系统把每个调度队列都保存成链表，则新进程必须放置在就绪或就绪/挂起链表中）。\n5. 创建或扩充其他数据结构。\n\n##### 进程终止\n\n有很多事件可以导致进程终止，比如：\n\n1. 进程完成\n2. 进程超时。进程运行时间超过规定的时限\n3. 无可用内存\n4. I/O 失败\n5. 算术错误\n6. 无效指令\n7. 父进程终止\n8. 父进程请求\n   。。。\n\n#### 五状态模型\n\n系统中还存在着一些处于非运行状态但已经就绪等待执行的进程，而且还存在另一些处于阻塞状态等待 I/O 操作结束的进程。\n\n这时，`就绪态(ready)`和`阻塞态(blocked)`出现了，两状态模型升级为了5状态模型，5个状态如下：\n\n![五状态进程模型](<http://media.gusibi.mobi/TaAMUjZ0MfiJF65CMJc6Z-q5vVlGvMYOAz5UBsfIOTF_HplbJuYKEc2pyfZj9wwJ>)\n\n\n* 运行态：该进程正在执行\n* 就绪态：进程做好了准备，等待处理器调度\n* 阻塞/等待态：进程在某些事件发生前不能执行，比如 I/O 操作完成\n* 新建态：刚刚创建的进程，操作系统还没有把它加入到可执行进程组中。通常是进程控制块已经创建但还没有被加载到内存中。\n* 退出态：操作系统从可执行进程组中释放出的进程，或者是因为它自身停止了，或者是因为某种原因被取消。\n\n\n> `新建-就绪`: 操作系统准备好再接纳一个进程时，把一个进程从新建态转换到就绪态。大多数系统基于心有的进程数或分配给现有进程的虚拟内存数量设置一些限制，以确保不会因为活跃进程数量过多而导致系统的性能下降。\n>\n> `就绪-退出`: 在某些系统中，父进程可以在任何时候终止一个子进程。如果一个父进程终止，与该父进程相关的所有子进程都将被终止。\n\n#### 挂起\n\n> `就绪态、运行态和阻塞态`提供了一种为进程行为建立模型的系统方法，但有个问题需要考虑：每个被执行的进程必须完全载入内存，当一个进程在等待 I/O 操作时，处理器可以转移到另一个进程，但 I/O 活动比CPU 计算速度慢很多，因此大多数情况下处理器在多数时候都是空闲的。但是如果内存中都是阻塞态的进程怎么办呢？\n\n* 一种办法就是扩充内存已适应更多的进程\n* 另一种方案是把进程中的某个内存的一部分或者全部移到磁盘中。当内存中没有处于就绪态的进程时，操作系统就把被阻塞的进程换出到磁盘中的`挂起队列`，这是暂时保存从内存中被驱逐出的进程队列，或者说是被挂起的进程队列。操作系统在此之后取出挂起队列中的另一个进程，或者接受一个新进程的请求，将其纳入内存运行。\n\n\n![有挂起态的进程状态转换图](<http://media.gusibi.mobi/RERwAhivDCla0-LTO6wylcXfaA0WFJTFS1oDvMIh9EkzsNrTbRVqu9rWuS9fUmMf>)\n\n\n> 这里有两个独立的概念：进程是否在等待一个事件（阻塞与否）以及进程是否已经被换出内存（挂起与否）。这里需要4个状态：\n\n* `就绪态`：进程在内存中并可以执行\n* `阻塞态`：进程在内存中并等待一个事件\n* `阻塞/挂起态`：进程在外存中并等待一个事件\n* `就绪/挂起态`：进程在外存中，但是只要被载入内存就可以执行\n\n现在状态转换如下：\n\n> `阻塞`-`阻塞/挂起`：如果没有就绪进程，则至少一个阻塞进程被换出，为另一个没有阻塞的进程让出空间\n\n> `阻塞/挂起`-`就绪/挂起`：如果等待事件发生了，比如 I/O 不再阻塞，则处于阻塞/挂起 状态的进程可以转换到 就绪/挂起状态。\n\n> `阻塞/挂起`-`阻塞`：比如一个进程终止了，释放了一些内存空间，阻塞/挂起队列中有一个进程比 就绪/挂起队列中的任何任何进程的优先级都要高，并且操作系统有理由相信阻塞进程的时间很快就会发生，这时，把阻塞进程而不是就绪进程调入内存是合理的。\n\n### 进程控制\n\n大多数处理器至少支持两种执行模式，某些指令只能在特权态下运行，包括读取或改变诸如程序状态之类控制寄存器的指令，原始 I/O 指令和与内存管理相关的指令。另外有部分内存区域仅在特权态下可以被访问到。\n\n> `特权态`：特权态可称做系统态、控制态或内核态，内核态指的是操作系统的内核。\n> `用户态`：用户程序常在该模式下运行\n\n两种模式可以保护操作系统和重要的操作系统表不受用户程序的干涉。\n\n操作系统内核的典型功能：\n\n![操作系统内核的典型功能](http://media.gusibi.mobi/icSKmpD5WmGdRg1YaqotICAvgAbhxbK7fAzcXE1nhVSzua6LhvbeZJGpQdXiKqX-)\n\n#### 进程切换\n\n从表面看，进程切换非常简单。在某一时刻，操作系统中断正在运行的进程，然后指定另一个进程为运行态，并把控制权交给这个进程。但是现在会有几个问题：\n\n* 什么事件触发进程切换\n* 模式切换和进程切换的区别\n* 进程切换时，操作系统要做哪些工作\n\n`何时切换进程`？\n\n进程切换可以在操作系统从当前正在运行的进程中获得控制权的任何时刻发生。以下是可能把控制权交给操作系统的事件：\n\n![进程执行的中断机制](http://media.gusibi.mobi/Jb4HJnGGvdlYgSmF1goSBFTo2sHE8atDcPaO3yw54AHs39xw8PxXiKrpnKZ7frtn)\n\n 系统中断通常分为两种，一种是`中断`，另一种是`陷阱`。\n`中断`与当前正在运行的进程无关的某种类型的外部事件相关，比如 I/O 操作；`陷阱`与当前正在运行的进程锁产生的错误或异常条件相关，比如非法的文件访问。\n\n以下是一些常见的中断事件：\n\n> * `时钟中断`：操作系统确认当前正在运行的进程的执行时间已经超过了最大允许时间段（时间片：即进程在被中断前可以执行的最大时间段），进程必须切换到就绪态，调入另一个进程。\n> * `I/O 中断`：进程等待 I/O 活动。\n> * `内存失效`：处理器访问一个虚拟内存地址，且次地址单元不在内存中，操作系统必须从外存中把包含这个引用的内存块调入内存中。在发出调入内存块的 I/O 请求之后，操作系统可能会执行一个进程切换，以恢复另一个进程的执行，发生内存失效的进程被置为阻塞态，当前的块调入内存中时，该进程被置为就绪态。\n\n对于`陷阱`,操作系统首先确认错误或者异常是否是致命的。如果是，当前进程被转换到退出态；如果不是，操作系统的动作取决于错误的种类和操作系统的设计（有可能是视图恢复或通知用户）。\n操作系统也可能被来自正在执行的程序的`系统调用`激活，比如打开文件，通常，使用系统调用会导致把当前进程置为阻塞态\n\n##### 系统调用\n\nUnix 系统是由用户空间（userland）和内核组成。Unix 内核位于计算机硬件之上，是与摇篮吗交互的中介。这些交互包括通过问卷系统进程读/写、在网络上发送数据、分配内存，以及通过扬声器播放音频。这些都是用户应用程序所不能涉及的，只能通过系统调用来完成。\n\n> `系统调用`为内核和用户空间搭建了桥梁。规定了程序和计算机硬件直接所允许发生的一切交互。\n\n模式切换和进程切换是不同的。发生模式切换可以不改变正处于运行态的进程的状态，而进程被转换到另一个状态操作系统必须使其环境产生实质性的变化。\n\n进程切换步骤如下：\n1. 保存处理器上下文环境，包括程序计数器和其他寄存器\n2. 更新当前处于运行态进程的进程控制块\n3. 将进程的进程控制块移到相应的队列（就绪、挂起等）\n4. 选择另一个进程执行\n5. 更新所选择进程的进程控制块，包括将进程的状态变为运行态\n6. 更新内存管理的数据结构\n7. 恢复处理器在被选择的进程最近一次切换出运行态时的上下文环境。\n\n下一篇将介绍 Unix 进程\n\n## 参考\n\n《操作系统-精髓与设计原理》\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n想了解以下内容可以在公号输入相应关键字获取历史文章： `公号&小程序` | `设计模式` | `并发&协程`\n\n| 关注 |赞赏 |\n|---|---|\n|![](http://media.gusibi.mobi/kel2L88yf9YXZYecLIn0LPZPSXc7zJfHyGUz5biWsZrGh7xF2JONZT93dgClGdMn)|![](http://media.gusibi.mobi/VFjjmZ7cgkIkpieAFHYXcLVBB8f9snm2vAzc0GyLjSmCzok8mL3vqLNMzYVvrDha)|\n",
      "data": {
        "title": "操作系统进程描述",
        "date": "2018-03-20 15:25:53",
        "tags": [
          "进程",
          "并发",
          "读书笔记",
          "后端"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "system-process-2"
    },
    {
      "content": "\n> 这是`操作系统进程`系列文章第一篇-操作系统发展和进程简介\n\n### 操作系统的发展\n\n#### 串行处理\n\n对于早期计算机（20世纪40年代后期到20世纪50年代中期），因为没有操作系统，程序员都是直接与计算机硬件打交道。这些机器都在一个控制台上运行，控制台包括显示灯、触发器、某种类型的输入设备和打印机。用机器代码编写的程序通过输入设备载入计算机。如果程序因错误停止，错误原因由指示灯只是。如果程序运行结束，结果将出现在打印机中。\n\n*早期系统主要有两个问题*：\n\n- 调度： 大多数设备使用一个硬拷贝的登记表预定时间。如果用户预定了一个小时，半小时就运行结束，计算机将闲置30分钟，而如果没有在一个小时内运行结束，程序也会被强制停止。\n- 准备时间：一个程序称为一个作业，运行一个程序可能需要往内存中加载编译器和程序语言，保存编译程序，加载目标程序和公用函数变链接在一起。每一步都可能需要安装拆卸硬件，如果这些步骤出现错误，只能重新开始，会占用太多时间。\n\n这种模式称为串行处理，用户必须顺序访问计算机。\n\n#### 简单批处理系统\n\n早期计算机非常贵，调度和准备又非常浪费时间和资源，为了最大限度的利用处理器，当时的研究人员开发了批处理操作系统。\n\n第一个批处理操作系统（也是第一个操作系统）是20世纪50年代中期由 General Motors 开发的，用在 IBM 701上。\n\n简单批处理方案的中心思想是使用一个称作`监控程序`的软件。通过使用这类操作系统，用户不再直接访问机器，相反，用户把卡片或磁带中的作业提交给计算机管理员，由他把这些作业按顺序组织成一批，并将整个批作业放在输入设备上，供监控程序使用。每个程序完成批处理后返回到监控程序，同事监控程序自动加载下一个程序。\n\n我们可以从两个角度分析这个方案是如何工作的：\n\n`监控程序角度：` 监控程序为了能一直控制事件的顺序，需要总是处于内存中并且可以执行。监控程序每次从输入设备中读取一个作业，读入后，当前作业被放置在用户程序区域，并把控制权交给这个作业。作业完成后，控制权交还给监控程序，监控程序再读入下一个作业。\n\n`处理器角度:` 从这个角度看，处理器执行内存中存储的监控程序的指令，这些指令读入下一个作业并存储到内存中的另一个部分。一旦已经读入一个作业，处理器将会遇到监控程序的分支指令，分支指令指导处理器在用户程序开始处继续执行。处理器继而执行用户程序直到执行结束或者遇到错误。无论哪种情况，处理器都将从监控程序读入下一个指令。\n\n> `控制权交给作业`仅仅意味着处理器当前取和执行的都是用户程序中的指令，而`控制权交给监控程序`的意思是处理器当前从监控程序中取指令并且执行指令。\n\n监控程序或者批处理操作系统，只是一个简单的计算机程序。它依赖于处理器可以从内存的不同部分取指令的能力，以交替的获取或释放控制权。此外，还要考虑其他硬件功能：\n\n* 内存保护：当用户程序在运行时，不能改变包含监控程序的内存区域\n* 定时器：用户防止一个作业独占系统。作业开始时，设置定时器，时间到，用户程序将被停止\n* 特权指定：某些指令设计成特权指令，只能由监控程序执行。\n* 中断：早期的计算机模型没有中断能力。这个特征使得操作系统在让用户程序放弃控制权或从用户程序获得控制权时具有更大的灵活性。\n\n#### 多道程序设计批处理（多任务处理）系统\n\n虽然简单的批处理系统可以提供自动作业序列，但由于 I/O 设备处理速度相对于处理器速度太慢，处理器仍然经常空闲。这个时候多道程序设计/多任务处理方案就被提了出来。\n\n它的工作原理是：基于内存空间可以保存操作系统和一个用户程序，假设内存空间容得下操作系统和两个用户程序，那么当一个作业需要等待 I/O 时，处理器可以切换到另一个可能并不在等待 I/O 的作业。进一步还可以扩展存储器以保存三个、四个或更多的程序，并在它们之间进行切换。\n\n![多道程序设计实例](<http://media.gusibi.mobi/knNY5bDB-SP5Vn1eOwq1QOBnC6F8SfwZD1ZIw94D_Gs4JXBKidmXYsgnHNpvjUOu>)\n\n多道程序操作系统比单个程序或单道程序系统相对要复杂一些。对准备运行的多个作业，它们必须保存在内存中，这就需要内存管理。此外，如果多个作业都准备运行，处理器还必须决定运行哪一个，这需要某种调度算法。\n\n多道程序设计是为了让处理器和 I/O 设备同时保持忙状态，以实现最大效率。其关键机制是：在响应表示 I/O 事务结束的信号时，操作系统对内存中驻留的不同程序进行处理器切换。\n\n#### 分时系统\n\n通过使用多道程序设计，可以使批处理更加有效，但是对许多作业来说，需要提供一个交互模式，以使用户可以和计算机交互。\n\n因为当时的计算机特别昂贵且巨大，普通用户也买不起，分时操作系统应运而生。\n\n和多道程序设计允许处理器同时处理多个批作业一样，它还可以用于处理多个交互作业。\n\n> 多个用户分享处理器的时间，因而该技术成为分时。\n\n分时系统中，多个用户可以通过终端同时访问系统，由操作系统控制每个用户程序以很短的时间为单位交替执行。\n\n> 如果有 n 个用户同时请求服务，若不计算操作系统的开销，每个用户平均只能得到1/n 计算机的有效速度，但由于人的反应时间相对计算机比较慢，所以一个设计良好的操作系统，其响应时间可以接近于计算机的时间。\n\n批处理多道程序设计和分时的比较\n\n| 项目           | 批处理多道程序设计         | 分时             |\n| -------------- | -------------------------- | ---------------- |\n| 主要目标       | 充分使用处理器             | 减小响应时间     |\n| 操作系统指令源 | 作业提供的作业控制语言命令 | 从终端键入的命令 |\n\n> 第一个分时操作系统是由麻省理工学院开发的兼容分时系统（CTSS）。系统运行在一台内存为32000个36位字的机器上，常驻程序占用了5000个。当控制权被分配给一个交互用户时，改用户的程序和数据被载入到内存剩余的27000个字的空间中。程序通常在第5000个字单元处开始被载入，系统时钟以大约没0.2秒一个的速度产生中断，在每个中断处，操作系统恢复控制权，并将处理器分配给下一个用户。因此，在固定的时间间隔内，当前用户被剥夺，另一个用户被载入。这项技术称为`时间片`技术。\n\n操作系统是最复杂的软件之一，操作系统开发中有5个重要的理论进展：`进程`、`内存管理`、`信息保护和安全`、调度和资源管理、系统结构。\n\n### 进程\n\n进程的概念是操作系统结构的基础，这个属于最早在20世纪60年代被提出。\n\n关于进程有很多定义：\n\n* 一个正在执行的程序\n* 计算机中正在运行的程序的一个实例\n* 可以分配给处理器并由处理器执行的一个实体\n* 由单一的顺序的执行线程、一个当前状态和一组相关的系统资源所描述的活动单元\n\n系统程序员在开发早期的多道程序（多任务）和多用户交互系统时（分时）使用的主要工具是中断。一个已定义事件的发生可以暂停任何作业的活动。处理器保留某些上下文（如程序计数器和其他寄存器），然后跳转到中断处理程序中，处理中断，然后恢复用户被中断作业或其他作业的处理。\n\n设计出一个能够协调各种不同活动的系统软件非常困难，也容易出错，一般而言，产生这类错误又4个主要原因：\n\n1. 不正确的同步：常常会出现这样的情况，一个例程必须挂起，等待系统中其他地方的某一事件。\n2. 失败的互斥：常常出现多个用户或程序试图同时使用一个共享资源的情况。（例如两个用户同时试图编辑文件）\n3. 不正确的程序操作：一个特定的程序结果只依赖与该程序的输入，而并不依赖于共享系统中其他程序的活动。但当程序共享内存并且处理器控制它们交错执行时，它们可能会因为重写相同的内存区域而发生不可预测的相互干扰\n4. 死锁：很可能两个或多个程序相互挂起等待。（单进程 web 应用中相互调用）\n\n解决这些问题需要一种系统级的方法监控处理器中不同程序的执行。进程的概念为此提供了基础。进程可以看做是由3部分组成的：\n\n* 一段可执行的程序\n* 程序所需的相关数据（变量、工作空间、缓冲区）\n* 程序的执行上下文\n\n最后一部分是根本。执行上下文（execution context）又称做进程状态，是操作系统用来管理和控制进程所需的内部数据。\n\n> 这种内部信息和进程是分开的，因为操作系统信息不允许被进程之间访问。\n\n上下文包括操作系统管理进程以及处理器正确执行进程所需的所有信息。包括了各种处理器寄存器的内容，汝程序计数器和数据寄存器。它还包括操作系统使用的信息，如进程优先级以及进程是否在等待特定 I/O 事件的完成。\n\n操作系统会给每个进程（包含程序、数据和上下文信息）分配一块存储器区域，并在由操作系统建立和维护的进程表中进行记录。进程表包含记录每个进程的表项，表项内容包括指向包含进程的存储块地址的指针，还包括该进程的部分或全部执行上下文。\n\n* 进程索引寄存器包含当前正在控制处理器的进程在进程表中的索引。\n* 程序计数器指向该进程中下一条待执行的指令。\n* 基址寄存器和界限寄存器定义了该进程所占的存储器区域：基址寄存器中保存了该存储区域的开始地址，界限寄存器中保存了该区域的大小。\n\n> 程序计数器和所有的数据引用相对于基址寄存器被解释，并且不能超过界限寄存器中的值，这就可以保护内部进程间不会相互干涉。\n\n下图是一种进程管理的方法：\n\n![典型的进程实现方法](<http://media.gusibi.mobi/v4Sj3T22rYA1gqBWodb7F0cYZf2tf4tt7ISgv4sNnSjEw_j2vw1D6l01uvE-TKOG>)\n\n在上图中，进程索引寄存器表明进程 B 正在执行。以前执行的进程被临时中断，在 A 中断的同时，所有寄存器的内容被记录在它的执行上下文环境中，以后操作系统就可以执行进程切换，恢复进程 A 的执行。进程切换过程包括保存 B 的上下文和恢复 A 的上下文。当在程序计数器中载入指向 A 的程序区域的值时，进程 A 自动恢复执行。\n\n> 进程是被当做数据结构来实现的，一个进程可以是正在执行，也可以是等待执行。任何时候整个进程状态都包含在它的上下文环境中。\n\n这一篇主要介绍了操作系统的发展，下篇主要介绍进程的概念以及工作原理。\n\n------\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n想了解以下内容可以在公号输入相应关键字获取历史文章： `公号&小程序` | `设计模式` | `并发&协程`\n\n| 关注 |赞赏 |\n|---|---|\n|![](http://media.gusibi.mobi/kel2L88yf9YXZYecLIn0LPZPSXc7zJfHyGUz5biWsZrGh7xF2JONZT93dgClGdMn)|![](http://media.gusibi.mobi/VFjjmZ7cgkIkpieAFHYXcLVBB8f9snm2vAzc0GyLjSmCzok8mL3vqLNMzYVvrDha)|\n\n",
      "data": {
        "title": "操作系统发展和进程简介",
        "date": "2018-03-07 15:25:53",
        "tags": [
          "进程",
          "并发",
          "读书笔记",
          "后端"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "system-process-1"
    },
    {
      "content": "\n\n### 命令模式\n\n\n> `题目：` 现在要做一个智能家居控制遥控器，功能如下图所示。\n\n![智能家居遥控器](<http://media.gusibi.mobi/UPqlqNDZ-vRoQN65O3JhR8egeJyz2zIVfbPRV7V47ZhMsWp0aT6awTJoplv_XQbw>)\n\n\n> 下图是家电厂商提供的类，接口各有差异，并且以后这种类可能会越来越多。\n\n![家电厂商类](<http://media.gusibi.mobi/vcUsidbuki8NvnE6GIQ4V-UtyVMw5I3B1C3GkIceIETTGiMuYdTYnD2NSFaJOzTn>)\n\n\n\n观察厂商提供的类，你会发现，好多类提供了 on()、off() 方法，除此之外，还有一些方法像 dim()、setTemperature()、setVolumn()、setDirection()。由此我们可以想象，之后还会有更多的厂商类，每个类还会有各式各样的方法。\n\n如果我们把这些类都用到遥控器代码中，代码就会多一大堆的 if 语句，例如 \n\n```python\nif slot1 == Light:\n    light.on()\nelif slot1 == Hottub:\n    hottob.jetsOn()\n```\n\n并且更严重的是，每次有新的厂商类加进来，遥控器的代码都要做相应的改动。\n\n这个时候我们就要把`动作的请求者（遥控器）`从`动作的执行者（厂商类）`对象中解耦。\n\n\n\n>  如何实现解耦呢？\n\n我们可以使用`命令对象`。利用命令对象，把请求（比如打开电灯）封装成一个特定对象。所以，如果对每个按钮都存储一个命令对象，那么当按钮按下的时候，就可以请求命令对象做相关的工作。此时，遥控器并不需要知道工作的内容是什么，只要有个命令对象能和正确的对象沟通，把事情做好就可以了。\n\n\n\n下面我们拿餐厅点餐的操作来介绍下命令模式。\n\n\n\n餐厅通常是这样工作的：\n\n1. 顾客点餐，把订单交给服务员\n2. 服务员拿了订单，把订单交给厨师。\n3. 厨师拿到订单后根据订单准备餐点。\n\n![](<http://media.gusibi.mobi/yzFfIqvBPf9WmHIashy3smiDYBsJbsr-pT5d7I9JnFVoLLron_ZVyXhot3-VufIT>)\n\n这里我们把订单想象成一个用来请求准备餐点的对象，\n\n* 和一般对象一样，订单对象可以被传递：从服务员传递到订单柜台，订单的接口只包含一个方法 orderUp()。这个方法封装了准备餐点所需的动作。\n* 服务员的工作就是接受订单，然后调用订单的 orderUp() 方法，她不需要知道订单内容是什么。\n* 厨师是一个对象，他知道如何准备准备餐点，是任务真正的执行者。\n\n\n\n> 如果我们把餐厅想象成OO 设计模式的一种模型，这个模型允许将”发出请求的对象“和”接受与执行这些请求的对象“分隔开来。比如对于遥控器 API，我们要分隔开”发出请求的按钮代码“和”执行请求的厂商特定对象”。\n\n\n\n`回到命令模式`我们把餐厅的工作流程图转换为命令模式的流程图：这里 client 对应上一张图的顾客，command 对应订单，Invoker 对应服务员，Receiver 对应的是厨师。\n\n\n\n![](http://media.gusibi.mobi/xnRDNC6NqVbMnXzD66vzgCAICcb3tKcXDGyBDxZuERwAwI0TnUQACv6MhFEezDAO)\n\n\n\n\n\n## 命令模式\n\n\n\n先来看下命令模式的定义：\n\n> `命令模式`将”请求“封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。\n\n通过上边的定义我们知道，一个命令对象通过在特定接收者上绑定一组动作来封装一个请求。要达到这一点，命令对象将动作和接收者包进对象中。这个对象只暴露一个 execute() 方法，当此方法被调用时，接收者就会进行这些动作。\n\n命令模式类图如下：\n\n![命令模式类图](<http://media.gusibi.mobi/BehmMRbLQ_w7RbvRD7q0DIu78jUvQ07v9zSVqFp79D8COVe6VL2UxtZjgw_C10fr>)\n\n\n\n> 回到遥控器的设计：我们打算将遥控器的每个插槽，对应到一个命令，这样就让遥控器变成了`调用者`。当按下按钮，相应命令对象的 execute() 方法就会被调用，其结果就是接收者(例如：电灯、风扇、音响)的动作被调用。\n\n\n\n![](<http://media.gusibi.mobi/ddLNmiEJXUuiKe7rChshd-mPX-ycVAJGYFw3MLv8M24D_A0pOSGfDwBWPxK5ZMgT>)\n\n\n\n命令模式还支持撤销，该命令提供和 execute() 方法相反的 undo() 方法。不管 execute() 做了什么，undo() 都会倒转过来。\n\n\n\n## 代码实现\n\n\n\n### 遥控器的实现\n\n\n\n```python\nclass RemoteControl(object):\n\n    def __init__(self):\n        # 遥控器要处理7个开与关的命令\n        self.on_commands = [NoCommand() for i in range(7)] \n        self.off_commands = [NoCommand() for i in range(7)]\n        self.undo_command = None  # 将前一个命令记录在这里\n\n    def set_command(self, slot, on_command, off_command):\n        # 预先给每个插槽设置一个空命令的命令\n        # set_command 命令必须要有三个参数(插槽的位置、开的命令、关的命令)\n        self.on_commands[slot] = on_command\n        self.off_commands[slot] = off_command\n\n    def on_button_was_pressed(self, slot):\n        command = self.on_commands[slot]\n        command.execute()\n        self.undo_command = command\n        \n    # 当按下开或关的按钮，硬件就会负责调用对应的方法\n    def off_button_was_pressed(self, slot):\n        command = self.off_commands[slot]\n        command.execute()\n        self.undo_command = command\n\n    def undo_button_was_pressed(self):\n        self.undo_command.undo()\n\n    def __str__(self):\n        # 这里负责打印每个插槽和它对应的命令\n        for i in range(7):\n            print('[slot %d] %s %s' % (i,\n                                       self.on_commands[i].__class__.__name__,\n                                       self.off_commands[i].__class__.__name__))\n        return ''\n\n```\n\n\n\n### 命令的实现\n\n\n\n这里实现一个基类，这个基类有两个方法，execute 和 undo，命令封装了某个特定厂商类的一组动作，遥控器可以通过调用 execute() 方法，执行这些动作，也可以使用 undo() 方法撤销这些动作：\n\n```python\nclass Command(object):\n\n    def execute(self):\n        # 每个需要子类实现的方法都会抛出NotImplementedError\n        # 这样的话，这个类就是真正的抽象基类\n        raise NotImplementedError()\n\n    def undo(self):\n        raise NotImplementedError()\n\n\n# 在遥控器中，我们不想每次都检查是否某个插槽都加载了命令，\n# 所以我们给每个插槽预先设定一个NoCommand 对象\n# 所以没有被明确指定命令的插槽，其命令将是默认的 NoCommand 对象\nclass NoCommand(Command):\n\n    def execute(self):\n        print('Command Not Found')\n\n    def undo(self):\n        print('Command Not Found')\n```\n\n\n\n以下是电灯类，利用 Command 基类，每个动作都被实现成一个简单的命令对象。命令对象持有对一个厂商类的实例的引用，并实现了一个 execute()。这个方法会调用厂商类实现的一个或多个方法，完成特定的行为，在这个例子中，有两个类，分别打开电灯与关闭电灯。\n\n```python\nclass Light(object):\n\n    def __init__(self, name):\n        # 因为电灯包括 living room light 和 kitchen light\n        self.name = name\n\n    def on(self):\n        print('%s Light is On' % self.name)\n\n    def off(self):\n        print('%s Light is Off' % self.name)\n\n\n# 电灯打开的开关类\nclass LightOnCommand(Command):\n\n    def __init__(self, light):\n        self.light = light\n\n    def execute(self):\n        self.light.on()\n\n    def undo(self):\n        # undo 是关闭电灯\n        self.light.off()\n\n        \nclass LightOffCommand(Command):\n\n    def __init__(self, light):\n        self.light = light\n\n    def execute(self):\n        self.light.off()\n\n    def undo(self):\n        self.light.on()\n```\n\n\n\n执行代码，这里创建多个命令对象，然后将其加载到遥控器的插槽中。每个命令对象都封装了某个家电自动化的一项请求：\n\n```python\ndef remote_control_test():\n    remote = RemoteControl()\n\n    living_room_light = Light('Living Room')\n    kitchen_light = Light('Kitchen')\n\n    living_room_light_on = LightOnCommand(living_room_light)\n    living_room_light_off = LightOffCommand(living_room_light)\n    kitchen_light_on = LightOnCommand(kitchen_light)\n    kitchen_light_off = LightOffCommand(kitchen_light)\n\n    remote.set_command(0, living_room_light_on, living_room_light_off)\n    remote.set_command(1, kitchen_light_on, kitchen_light_off)\n\n    print(remote)\n\n    remote.on_button_was_pressed(0)\n    remote.off_button_was_pressed(0)\n    remote.undo_button_was_pressed()\n    remote.on_button_was_pressed(1)\n    remote.off_button_was_pressed(1)\n    remote.undo_button_was_pressed()\n```\n\n执行后输出为：\n\n```bash\n[slot 0] LightOnCommand LightOffCommand\n[slot 1] LightOnCommand LightOffCommand\n[slot 2] NoCommand NoCommand\n[slot 3] NoCommand NoCommand\n[slot 4] NoCommand NoCommand\n[slot 5] NoCommand NoCommand\n[slot 6] NoCommand NoCommand\n\nLiving Room Light is On\nLiving Room Light is Off\nLiving Room Light is On\nKitchen Light is On\nKitchen Light is Off\nKitchen Light is On\n```\n\n\n\n## 集合多个命令\n\n\n\n通常，我们还希望能有一个开关一键打开所有的灯，然后也可以一键关闭所有的灯，这里我们使用 `MacroCommand`:\n\n\n\n```python\nclass MacroCommand(Command):\n\n    def __init__(self, commands):\n        # 首先创建一个 commands 的 list，这里可以存放多个命令\n        self.commands = commands\n\n    def execute(self):\n        # 执行时，依次执行多个开关\n        for command in self.commands:\n            command.execute()\n\n    def undo(self):\n        # 撤销时，给所有命令执行 undo 操作\n        for command in self.commands:\n            command.undo()\n```\n\n\n\n测试开关集合：\n\n\n\n```python\ndef remote_control_test():\n    remote = RemoteControl()\n    \n    living_room_light = Light('Living Room')\n    kitchen_light = Light('Kitchen')\n    garage_door = GarageDoor()\n\n    living_room_light_on = LightOnCommand(living_room_light)\n    living_room_light_off = LightOffCommand(living_room_light)\n    kitchen_light_on = LightOnCommand(kitchen_light)\n    kitchen_light_off = LightOffCommand(kitchen_light)\n\n    garage_door_open = GarageDoorOpenCommand(garage_door)\n    garage_door_close = GarageDoorCloseCommand(garage_door)\n    \n    # 测试开关集合\n    party_on_macro = MacroCommand([living_room_light_on, kitchen_light_on])\n    party_off_macro = MacroCommand([living_room_light_off, kitchen_light_off])\n    remote.set_command(3, party_on_macro, party_off_macro)\n    print('--pushing macro on--')\n    remote.on_button_was_pressed(3)\n    print('--pushing macro off--')\n    remote.off_button_was_pressed(3)\n    print('--push macro undo--')\n    remote.undo_button_was_pressed()\n```\n\n\n\n当然，我们也可以使用一个列表来记录命令的记录，实现多层次的撤销操作。\n\n\n\n## 命令模式的用途\n\n\n\n### 1. 队列请求\n\n命令可以将运算块打包（一个接收者和一组动作），然后将它传来传去，就像是一般的对象一样。即使在命令对象被创建许久以后，运算依然可以被调用。我们可以利用这些特性衍生一些应用，例如：日程安排、线程池、工作队列等。\n\n> `想象一个工作队列:`你在某一端添加命令，然后在另一端则是线程。线程进行下面的动作：从队列中取出一个命令，调用它的 execute() 方法，等待这个调用完成，然后将次命令对象丢弃，再取下一个命令\n\n此时的工作队列和计算的对象之间是完全解耦的，此刻线程可能进行的是音频转码，下一个命令可能就变成了用户评分计算。\n\n\n\n### 2.  日志请求\n\n\n\n某些应用需要我们将所有的动作都记录在日志中，并能在系统死机之后，重新调用这些动作恢复到之前的状态。通过新增两个方法（store()、load()），命令模式能够支持这一点。这些数据最好是持久化到硬盘。\n\n\n\n> `要怎么做呢?` 当我们执行命令时，将历史记录存储到磁盘，一旦系统死机，我们就将命令对象重新加载，并成批的依次调用这些对象的 execute() 方法。\n\n\n\n比如对于excel，我们可能想要实现的错误恢复方式是将电子表格的操作记录在日志中，而不是每次电子表格一有变化就记录整个电子表格。数据库的事务（transaction）也是使用这个技巧，也就是说，一整群操作必须全部进行完成，或者没有任何操作。\n\n\n\n## 参考链接\n\n[命令模式完整代码-https://gist.github.com/gusibi/e66134218fdecff59e5690298d657c26](https://gist.github.com/gusibi/e66134218fdecff59e5690298d657c26)\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "python设计模式-命令模式",
        "date": "2018-01-09 15:16:56",
        "tags": [
          "python",
          "读书笔记",
          "设计模式"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-design-pattern-command"
    },
    {
      "content": "\n>  这一篇是`《流畅的 python》`读书笔记。主要介绍：\n> * 常见的字典方法\n> * 如何处理查不到的键\n> * 标准库中 dict 类型的变种\n> * 散列表的工作原理\n\n## 泛映射类型\n\ncollections.abc 模块中有 Mapping 和 MutableMapping 这两个抽象基类，它们的作用是为 dict 和其他类似的类型定义形式接口。\n\n![](http://media.gusibi.mobi/VP8Xn1-MImX7FFIVi1kyiBms-WIPy5ccIXinstWWn0bL8knd7vbCOK-9RpPwNaQN)\n\n标准库里所有映射类型都是利用 dict 来实现的，它们有个共同的限制，即只有可散列的数据类型才能用做这些映射里的键。\n\n> `问题：` 什么是可散列的数据类型？\n\n在 python 词汇表（[https://docs.python.org/3/glossary.html#term-hashable](https://docs.python.org/3/glossary.html#term-hashable)）中，关于可散列类型的定义是这样的：\n> 如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是不变的，而且这个对象需要实现 `__hash__()` 方法。另外可散列对象还要有 `__eq__()` 方法，这样才能跟其他键做比较。如果两个可散列对象是相等的，那么它们的散列只一定是一样的\n\n根据这个定义，原子不可变类型（str，bytes和数值类型）都是可散列类型，frozenset 也是可散列的（因为根据其定义，frozenset 里只能容纳可散列类型），如果元组内都是可散列类型的话，元组也是可散列的（元组虽然是不可变类型，但如果它里面的元素是可变类型，这种元组也不能被认为是不可变的）。\n\n> 一般来讲，用户自定义的类型的对象都是可散列的，散列值就是它们的 id() 函数的返回值，所以这些对象在比较的时候都是不相等的。（如果一个对象实现了 __eq__ 方法，并且在方法中用到了这个对象的内部状态的话，那么只有当所有这些内部状态都是不可变的情况下，这个对象才是可散列的。）\n\n根据这些定义，字典提供了很多种构造方法，[https://docs.python.org/3/library/stdtypes.html#mapping-types-dict](https://docs.python.org/3/library/stdtypes.html#mapping-types-dict) 这个页面有个例子来说明创建字典的不同方式。\n\n```python\n>>> a = dict(one=1, two=2, three=3)\n>>> b = {'one': 1, 'two': 2, 'three': 3}\n>>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))\n>>> d = dict([('two', 2), ('one', 1), ('three', 3)])\n>>> e = dict({'three': 3, 'one': 1, 'two': 2})\n>>> a == b == c == d == e\nTrue\n```\n\n除了这些方法以外，还可以用字典推导的方式来建造新 dict。\n\n### 字典推导\n\n自 Python2.7 以来，列表推导和生成器表达式的概念就移植到了字典上，从而有了字典推导。字典推导（dictcomp）可以从任何以键值对作为元素的可迭代对象中构建出字典。\n\n比如：\n\n```python\n>>> data = [(1, 'a'), (2, 'b'), (3, 'c')]\n>>> data_dict = {num: letter for num, letter in data}\n>>> data_dict\n{1: 'a', 2: 'b', 3: 'c'}\n```\n\n### 常见的映射方法\n\n下表为我们展示了 dict、defaultdict 和 OrderedDict 的常见方法（后两种是 dict 的变种，位于 collections模块内）。\n\n![](http://media.gusibi.mobi/Ofx-MtfIphm8ceCJlP3tMi5IwYMuLT8DUem1ANIjR2n2NwYFZ6JFTIJJntdaZFNF)\n\n* default_factory 并不是一个方法，而是一个可调用对象，它的值 defaultdict 初始化的时候由用户设定。\n* OrderedDict.popitem() 会移除字典最先插入的元素（先进先出）；可选参数 last 如果值为真，则会移除最后插入的元素（后进先出）。\n\n* 用 setdefault 处理找不到的键\n当字典 d[k] 不能找到正确的键的时候，Python 会抛出异常，平时我们都使用`d.get(k, default)` 来代替 d[k]，给找不到的键一个默认值，还可以使用效率更高的 `setdefault` \n\n```python\nmy_dict.setdefault(key, []).append(new_value)\n# 等同于\nif key not in my_dict:\n    my_dict[key] = []\nmy_dict[key].append(new_value)\n```\n这两段代码的效果一样，只不过，后者至少要进行两次键查询，如果不存在，就是三次，而用 `setdefault` 只需一次就可以完成整个操作。\n\n那么，我们取值的时候，该如何处理找不到的键呢？\n\n### 映射的弹性查询\n\n> 有时候，就算某个键在映射里不存在，我们也希望在通过这个键读取值的时候能得到一个默认值。有两个途径能帮我们达到这个目的，`一个是通过 defaultdict` 这个类型而不是普通的 dict，`另一个是给自己定义一个 dict` 的子类，然后在子类中实现 `__missing__` 方法。\n\n#### defaultdict：处理找不到的键的一个选择\n\n首先我们看下如何使用 defaultdict ：\n\n```python\nimport collections\n\nindex = collections.defaultdict(list)\nindex[new_key].append(new_value)\n```\n\n这里我们新建了一个字典 index，如果键 `new_key` 在 index 中不存在，表达式 `index[new_key]` 会按以下步骤来操作：\n\n1. 调用 list() 来建立一个新的列表\n2. 把这个新列表作为值，'new_key' 作为它的键，放入 index 中\n3. 返回这个列表的引用。\n\n而这个用来生成默认值的可调用对象存放在名为 `default_factory` 的实例属性中。\n\n> defaultdict 中的 default_factory 只会在 __getitem__ 里调用，在其他方法中不会发生作用。比如 index[k] 这个表达式会调用 default_factory 创造的某个默认值，而 index.get(k) 则会返回 None。（这是因为特殊方法 __missing__ 会在 defaultdict 遇到找不到的键的时候调用 default_factory，实际上，这个特性所有映射方法都可以支持）。\n\n#### 特殊方法 __missing__\n\n所有映射在处理找不到的键的时候，都会牵扯到 __missing__ 方法。但基类 dict 并没有提供 这个方法。不过，如果有一个类继承了 dict ，然后这个继承类提供了 __missing__ 方法，那么在 __getitem__ 碰到找不到键的时候，Python 会自动调用它，而不是抛出一个 KeyError 异常。\n\n> `__missing__` 方法只会被 `__getitem__` 调用。提供 __missing__ 方法对 get 或者 __contains__(in 运算符会用到这个方法)这些方法的是有没有影响。\n\n下面这段代码实现了 StrKeyDict0 类，StrKeyDict0 类在查询的时候把非字符串的键转化为字符串。\n\n```python\nclass StrKeyDict0(dict): # 继承 dict\n    def __missing__(self, key):\n        if isinstance(key, str):\n            # 如果找不到的键本身就是字符串，抛出 KeyError    \n            raise KeyError(key)\n        # 如果找不到的键不是字符串，转化为字符串再找一次\n        return self[str(key)]\n    def get(self, key, default=None):\n        # get 方法把查找工作用 self[key] 的形式委托给 __getitem__，这样在宣布查找失败钱，还能通过 __missing__ 再给键一个机会\n        try:\n            return self[key]\n        except KeyError:\n            # 如果抛出 KeyError  说明 __missing__ 也失败了，于是返回 default    \n            return default\n    def __contains__(self, key):\n        # 先按传入的键查找，如果没有再把键转为字符串再找一次\n        return key in self.keys() or str(key) in self.keys()\n```\n\n__contains__ 方法存在是为了保持一致性，因为 k in d 这个操作会调用它，但我们从 dict 继承到的 __contains__ 方法不会在找不到键的时候用 __missing__ 方法。\n\n> my_dict.keys() 在 Python3 中返回值是一个 \"视图\",\"视图\"就像是一个集合，而且和字典一样速度很快。但在 Python2中，my_dict.keys() 返回的是一个列表。 所以 k in my_dict.keys() 操作在 python3中速度很快，但在 python2 中，处理效率并不高。\n\n>如果要自定义一个映射类型，合适的策略是继承 `collections.UserDict` 类。这个类就是把标准 dict 用 python 又实现了一遍，UserDict 是让用户继承写子类的，改进后的代码如下：\n\n```python\nimport collections\n\nclass StrKeyDict(collections.UserDict):\n    \n    def __missing__(self, key):\n        if isinstance(key, str):\n            raise KeyError(key)\n        return self[str(key)]\n        \n    def __contains__(self, key):\n        # 这里可以放心假设所有已经存储的键都是字符串。因此只要在 self.data 上查询就好了\n        return str(key) in self.data\n        \n    def __setitem__(self, key, item):\n        # 这个方法会把所有的键都转化成字符串。\n        self.data[str(key)] = item\n```\n\n因为 UserDict 继承的是 MutableMapping，所以 StrKeyDict 里剩下的那些映射类型都是从 UserDict、MutableMapping 和 Mapping 这些超类继承而来的。\n\nMapping 中提供了 get 方法，和我们在 StrKeyDict0 中定义的一样，所以我们在这里不需要定义 get 方法。\n\n## 字典的变种\n\n在 collections 模块中，除了 defaultdict 之外还有其他的映射类型。\n\n* collections.OrderedDict\n* collections.ChainMap\n* collections.Counter\n\n## 不可变的映射类型\n\n> `问题：`标准库中所有的映射类型都是可变的，如果我们想给用户提供一个不可变的映射类型该如何处理呢？\n\n从 Python3.3 开始 types 模块中引入了一个封装类名叫 `MappingProxyType`。如果给这个类一个映射，它会返回一个只读的映射视图（如果原映射做了改动，这个视图的结果页会相应的改变）。例如\n\n```python\n>>> from types import MappingProxy Type\n>>> d = {1: 'A'}\n>>> d_proxy = MappingProxyType(d)\n>>> d_proxy\nmappingproxy({1: 'A'})\n>>> d_proxy[1]\n'A'\n>>> d_proxy[2] = 'x'\nTraceback(most recent call last):\n    File \"<stdin\", line 1, in <module>\nTypeError: 'MappingProxy' object does not support item assignment\n>>> d[2] = 'B'\n>>> d_proxy[2]  # d_proxy 是动态的，d 的改动会反馈到它上边\n'B'\n```\n\n## 字典中的散列表\n\n散列表其实是一个稀疏数组（总有空白元素的数组叫稀疏数组），在 dict 的散列表中，每个键值都占用一个表元，每个表元都有两个部分，`一个是对键的引用，另一个是对值的引用`。因为所有表元的大小一致，所以可以通过`偏移量来读取某个表元`。\npython 会设法保证大概有1/3 的表元是空的，所以在快要达到这个阈值的时候，原有的散列表会被复制到一个更大的空间。\n\n 如果要把一个对象放入散列表，那么首先要计算这个元素的散列值。\nPython内置的 hash() 方法可以用于计算所有的内置类型对象。\n\n> 如果两个对象在比较的时候是相等的，那么它们的散列值也必须相等。例如 1==1.0 那么，hash(1) == hash(1.0)\n\n### 散列表算法\n\n为了获取 my_dict[search_key] 的值，Python 会首先调用 hash(search_key) 来计算 search_key 的散列值，把这个值的最低几位当做偏移量在散列表中查找元。`若表元为空，抛出 KeyError 异常。若不为空，则表元会有一对 found_key:found_value`。\n这时需要校验 search_key == found_key，如果相等，返回 found_value。\n如果不匹配（散列冲突），再在散列表中再取几位，然后处理一下，用处理后的结果当做索引再找表元。 然后重复上面的步骤。\n\n取值流程图如下：\n\n![字典取值流程图](http://media.gusibi.mobi/oppfxsnS5Fx_KOpd054J2yer_K_wee7WphoUzDN6z8H_R5rtONXr6x3Bb2J3tcBd)\n\n添加新值和上述的流程基本一致，只不过对于前者，在发现空表元的时候会放入一个新元素，而对于后者，在找到相应表元后，原表里的值对象会被替换成新值。\n\n> 另外，在插入新值是，Python 可能会按照散列表的拥挤程度来决定是否重新分配内存为它扩容，`如果增加了散列表的大小，那散列值所占的位数和用作索引的位数都会随之增加`\n\n### 字典的优势和限制\n\n#### 1、键必须是可散列的\n\n可散列对象要求如下：\n\n* 支持 hash 函数，并且通过__hash__() 方法所得的散列值不变\n* 支持通过 __eq__() 方法检测相等性\n* 若 a == b 为真， 则 hash(a) == hash(b) 也为真\n\n#### 2、字典开销巨大\n\n因为字典使用了散列表，而散列表又必须是稀疏的，这导致它在空间上效率低下。\n\n#### 3、键查询很快\n\ndict 的实现是典型的空间换时间：字典类型由着巨大的内存开销，但提供了无视数据量大小的快速访问。\n\n#### 4、键的次序决定于添加顺序\n\n当往 dict 里添加新键而又发生散列冲突时，新建可能会被安排存放在另一个位置。\n\n#### 5、往字典里添加新键可能会改变已有键的顺序\n\n无论何时向字典中添加新的键，Python 解释器都可能做出为字典扩容的决定。扩容导致的结果就是要新建一个更大的散列表，并把原有的键添加到新的散列表中，这个过程中可能会发生新的散列冲突，导致新散列表中次序发生变化。\n因此，不要对字典同时进行迭代和修改。\n\n## 总结\n\n这一篇主要介绍了：\n* 常见的字典方法\n* 如何处理查不到的键\n* 标准库中 dict 类型的变种\n* 散列表的工作原理\n* 散列表带来的潜在影响\n\n## 参考链接\n\n* [https://docs.python.org/3/glossary.html#term-hashable](https://docs.python.org/3/glossary.html#term-hashable)\n* [https://docs.python.org/3/library/stdtypes.html#mapping-types-dict](https://docs.python.org/3/library/stdtypes.html#mapping-types-dict)\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "Python 字典",
        "date": "2017-12-03 15:05:27",
        "tags": [
          "python",
          "tutorial",
          "读书笔记"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-data-structures-dict"
    },
    {
      "content": "\n##\n\n### \n\n## 参考链接\n\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)\n",
      "data": {
        "categories": [
          "xxx",
          "xxxx"
        ],
        "date": "2017-12-03 03:15:38",
        "description": "description",
        "author": "goodspeed",
        "permalink": "/post/url-path",
        "tags": [
          "xx",
          "xxxx"
        ],
        "title": "title",
        "published": false,
        "hideInList": false,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-data-structures-set"
    },
    {
      "content": "\n> `问题：`现代化的巧克力工厂具备计算机控制的巧克力锅炉。锅炉做的事情就是把巧克力和牛奶融在一起，然后送到下一个阶段，以制成巧克力棒。下边是一个巧克力公司锅炉控制器的代码，仔细观察一下，这段代码有什么问题？\n\n```python\nclass ChocolateBoiler(object):\n\n    def __init__(self):\n        self.empty = True\n        self.boiled = False\n\n    def fill(self):\n        # 向锅炉填充巧克力和牛奶混合物\n        # 在锅炉内填充原料时，锅炉必须是空的。\n        # 一旦填入原料，就要把empty 和 boiled 标志设置好\n        if self.empty:\n            self.empty = False\n            self.boiled = False\n\n    def drain(self):\n        # 排出煮沸的巧克力和牛奶\n        # 锅炉排出时，必须是满的且煮沸的。\n        # 排出完毕empty 设置为 true\n        if not self.empty and self.boiled:\n            self.empty = True\n\n    def boil(self):\n        # 将颅内物煮沸\n        # 煮混合物时，锅炉内必须是满的且没有煮沸过\n        # 一旦煮沸，就把 boiled 设置为 true\n        if not self.empty and not self.boiled:\n            self.boiled = True\n```\n\n从代码可以看出，他们加入了多种判断，以防止不好的事情发生。如果同时存在两个`ChocolateBoiler`实例，那这么多判断岂不是失去作用了。那我们改如何实现这个需求呢？这个问题的核心是，我们要先判断实例是不是已经存在，如果存在就不再创建。\n\n```python\n_chocolate_boiler_instance = None  # 声明实例\n\ndef chocolate_boiler():\n    global _chocolate_boiler_instance  # 使用全局变量\n\n    if _chocolate_boiler_instance is not None: # 判断是否存在，如果存在，直接返回\n        return _chocolate_boiler_instance\n    else:\n        # 如果不存在，创建一个新的\n        _chocolate_boiler_instance = ChocolateBoiler()\n        return _chocolate_boiler_instance\n```\n\n现在我们需要获取 `ChocolateBoiler` 实例的时候只需要调用 chocolate_boiler 方法获取实例即可保证同时只有一个 `ChocolateBoiler`实例。\n\n这种保证 `ChocolateBoiler`类只有一个实例，并提供一个全局访问点的模式，就是`单例模式`。\n\n## 单例模式\n### 定义\n\n> `单例模式：`确保一个类只有一个实例，并提供一个全局访问点。\n\n* 也就是说，我们使用单例模式要把某个类设计成自己管理的一个单独实例，同时也避免其他类再自行产生实例。并且只允许通过单例类获取单例的实例。\n* 我们也提供对这个实例的全局访问点：当你需要实例时，像类查询，它会返回单个实例。\n\n### 实现\n\npython 实现单例模式有多种方案：\n#### 使用 metaclass\n\n《python cookbook》提供了非常易用的 `Singleton` 类，只要继承它，就会成为单例。\n\n```python\n# python 3 代码实现\nclass Singleton(type):\n\n    def __init__(self, *args, **kwargs):\n        self.__instance = None\n        super().__init__(*args, **kwargs)\n\n    def __call__(self, *args, **kwargs):\n        if self.__instance is None:\n            # 如果 __instance 不存在，创建新的实例\n            self.__instance = super().__call__(*args, **kwargs)\n            return self.__instance\n        else:\n            # 如果存在，直接返回\n            return self.__instance\n\n\nclass Spam(metaclass=Singleton):\n\n    def __init__(self):\n        print('Creating Spam')\n\na = Spam()\nb = Spam()\n\nprint(a is b)  # 这里输出为 True\n```\n\n元类（metaclass）可以控制类的创建过程，它主要做三件事：\n\n* 拦截类的创建\n* 修改类的定义\n* 返回修改后的类\n\n例子中我们构造了一个Singleton元类，并使用__call__方法使其能够模拟函数的行为。构造类 Spam 时，将其元类设为Singleton，那么创建类对象 Spam 时，行为发生如下：\n\nSpam = Singleton(name,bases,class_dict)，Spam 其实为Singleton类的一个实例。\n\n创建 Spam 的实例时，Spam()=Singleton(name,bases,class_dict)()=Singleton(name,bases,class_dict).__call__()，这样就将 Spam 的所有实例都指向了 Spam 的属性 __instance上。\n\n#### 使用 __new__\n\n我们可以使用 __new__ 来控制实例的创建过程，代码如下:\n\n```python\nclass Singleton(object):\n\n    __instance = None\n\n    def __new__(cls, *args, **kw):\n        if not cls.__instance:\n            cls.__instance = super().__new__(cls, *args, **kw)\n        return cls.__instance\n\nclass Foo(Singleton):\n    a = 1\n\none = Foo()\ntwo = Foo()\nassert one == two\nassert one is two\nassert id(one) == id(two)\n```\n\n通过 __new__ 方法，将类的实例在创建的时候绑定到类属性 __instance 上。如果cls.__instance 为None，说明类还未实例化，实例化并将实例绑定到cls.__instance 以后每次实例化的时候都返回第一次实例化创建的实例。注意从Singleton派生子类的时候，不要重载__new__。\n\n#### 使用装饰器\n\n```python\nimport functools\n\ndef singleton(cls):\n    ''' Use class as singleton. '''\n    # 首先将 __new__ 方法赋值给 __new_original__\n    cls.__new_original__ = cls.__new__\n\n    @functools.wraps(cls.__new__)\n    def singleton_new(cls, *args, **kw):\n        # 尝试从 __dict__ 取 __it__\n        it =  cls.__dict__.get('__it__')\n        if it is not None: # 如果有值，说明实例已经创建，返回实例\n            return it\n        # 如果实例不存在，使用 __new_original__ 创建实例，并将实例赋值给 __it__\n        cls.__it__ = it = cls.__new_original__(cls, *args, **kw)\n        it.__init_original__(*args, **kw)\n        return it\n    # class 将原有__new__ 方法用 singleton_new 替换\n    cls.__new__ = singleton_new\n    cls.__init_original__ = cls.__init__\n    cls.__init__ = object.__init__\n\n    return cls\n\n#\n# 使用示例\n#\n@singleton\nclass Foo:\n    def __new__(cls):\n        cls.x = 10\n        return object.__new__(cls)\n\n    def __init__(self):\n        assert self.x == 10\n        self.x = 15\n\n\nassert Foo().x == 15\nFoo().x = 20\nassert Foo().x == 20\n```\n\n这种方法的内部实现和使用 `__new__` 类似：\n\n* 首先，将 __new__ 方法赋值给 __new_original__，原有 __new__ 方法用 singleton_new 替换，定义  __init_original__ 并将 cls.__init__ 赋值给 __init_original__\n* 在 singleton_new 方法内部，尝试从 __dict__ 取 __it__（实例）\n* 如果实例不存在，使用 __new_original__ 创建实例，并将实例赋值给 __it__，然后返回实例\n\n#### 最简单的方式\n\n将名字singleton绑定到实例上，singleton就是它自己类的唯一对象了。\n\n```python\nclass singleton(object):\n    pass\nsingleton = singleton()\n```\n\n[https://github.com/gusibi/Metis/blob/master/apis/v1/schemas.py#L107](https://github.com/gusibi/Metis/blob/master/apis/v1/schemas.py#L107) 使用的就是这种方式，用来获取全局的 request\n\n> Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。\n\n## 参考链接\n\n* [Creating a singleton in Python](https://stackoverflow.com/questions/6760685/creating-a-singleton-in-python#)\n* [Python单例模式](https://www.cnblogs.com/linxiyue/p/3902256.html)\n* [Why is __init__() always called after __new__()?](https://stackoverflow.com/questions/674304/why-is-init-always-called-after-new)\n------\n\n\n最后，感谢女朋友支持。\n\n欢迎关注(April_Louisa) | 请我喝芬达\n------- | -------\n![欢迎关注](http://media.gusibi.mobi/Hy8XHexmzppNKuekLuGxWy8LjdGrQAzZA3mH_e9xltoiYgTFWdvlpZwGWxZESrbK)| ![请我喝芬达](http://media.gusibi.mobi/CO9DwU6ZHnXHD5xuG3GqTsY_IYPl-JdpQrDaOo6tl6PiAGEBDeYFHO7sGQi_VVFc)\n",
      "data": {
        "title": "python设计模式-单例模式",
        "date": "2017-11-26 04:59:39",
        "tags": [
          "python",
          "读书笔记",
          "设计模式"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-design-pattern-singleton"
    },
    {
      "content": "\n> `问题：`在上一篇[python设计模式：抽象工厂模式](https://mp.weixin.qq.com/s/mdulFWnTUiNvitNb2A5ZOQ)中，我们尝试用抽象工厂模式规范化了 Pizza 原材料的供应以及 Pizza 的创建。但是我们忽略了一个问题，那就是每种 Pizza 的烘焙时间依赖于生面团的厚度和使用的配料，它们所需的时间是不一样的。那这时我们改如何处理呢？\n\nPizza 的制作流程包括：准备（擀面皮、加佐料），然后烘烤、切片、装盒。这些有特定的顺序，不能错乱。\n\n为了保证 生产 Pizza 的步骤不会出错，我们打算指派一个创建者，创建者用于控制 Pizza 的制作流程。\n\n\n## 创建 Pizza 创建者\n\n首先我们定义一个 Pizza\n\n```python\nclass Pizza:\n\n    def __init__(self, name):\n        self.name = name\n        self.dough = None\n        self.sauce = None\n        self.toppings = []\n\n    def prepare_dough(self, dough):\n        self.dough = dough\n        print(self.dough)\n        print('preparing the {} dough of your {}...'.format(self.dough, self))\n        time.sleep(STEP_DELAY)\n        print('Done with the {} dough'.format(self.dough))\n\n    def __str__(self):\n        return self.name\n```\n\n然后我们抽象出一个创建者：\n\n```python\nclass PizzaBuilder(object):\n\n    name = None\n\n    def __init__(self):\n        self.progress = PIZZA_PROGRESS\n        self.baking_time = 5\n\n    def prepare_dough(self):\n        raise NotImplementedError()\n\n    def add_sauce(self):\n        raise NotImplementedError()\n\n    def add_topping(self):\n        raise NotImplementedError()\n\n    def bake(self):\n        raise NotImplementedError()\n\n    def cut(self):\n        raise NotImplementedError()\n\n    def box(self):\n        raise NotImplementedError()\n\n    @property\n    def pizza(self):\n        return Pizza(self.name)\n\n```\n\n### 创建具体建造者\n\n\n```python\nclass NYStyleCheeseBuilder(PizzaBuilder):\n\n    name = 'NY Style Sauce and Cheese Pizza'\n\n    def prepare_dough(self):\n        self.progress = PIZZA_PROGRESS[0]\n        self.pizza.prepare_dough('thin')\n\n    def add_sauce(self):\n        print('adding the tomato sauce to your pizza..')\n        self.pizza.sauce = 'tomato'\n        time.sleep(STEP_DELAY)\n        print('done with the tomato sauce')\n\n    def add_topping(self):\n        print('adding the topping (grated reggiano cheese) to your pizza')\n        self.pizza.toppings.append([\"Grated\", \"Reggiano\", \"Cheese\"])\n        time.sleep(STEP_DELAY)\n        print('done with the topping (grated reggiano cheese)')\n\n    def bake(self):\n        self.progress = PIZZA_PROGRESS[1]\n        print('baking your pizza for {} seconds'.format(self.baking_time))\n        time.sleep(self.baking_time)\n\n    def cut(self):\n        self.progress = PIZZA_PROGRESS[2]\n        print(\"Cutting the pizza into diagonal slices\")\n\n    def box(self):\n        self.progress = PIZZA_PROGRESS[3]\n        print(\"Place pizza in official PizzaStore box\")\n```\n\n\n### 创建指挥者\n\n```python\nclass Waiter:\n    # 指挥者\n\n    def __init__(self):\n        self.builder = None\n\n    def construct_pizza(self, builder):\n        self.builder = builder\n        #  一旦我们有了一个 pizza，需要做一些准备（擀面皮、加佐料），然后烘烤、切片、装盒\n        [step() for step in (builder.prepare_dough, builder.add_sauce,\n                             builder.add_topping, builder.bake,\n                             builder.cut, builder.box)]\n\n    @property\n    def pizza(self):\n        return self.builder.pizza\n```\n\n完整代码参考：[python-design-patter-builder](https://gist.github.com/gusibi/8f84ec29e6b9d42ad2de224dc731a6bf)\n\n从这个例子我可以看出，建造者模式包含如下角色：\n\n* Builder：抽象建造者(Builder)（引入抽象建造者的目的，是为了将建造的具体过程交与它的子类来实现。这样更容易扩展。一般至少会有两个抽象方法，一个用来建造产品，一个是用来返回产品。）\n* ConcreteBuilder：具体建造者(CommonBuilder、SuperBuilder)（实现抽象类的所有未实现的方法，具体来说一般是两项任务：组建产品；返回组建好的产品。）\n* Director：指挥者(Director)（负责调用适当的建造者来组建产品，指挥者类一般不与产品类发生依赖关系，与指挥者类直接交互的是建造者类。一般来说，指挥者类被用来封装程序中易变的部分。）\n* Product：产品角色(Role)\n\n## 建造者模式\n\n造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。也可以说，每个产品的建造会遵循同样的流程，不过流程内的每一个步骤都不尽相同。\n\n> 建造者模式又可以称为生成器模式。\n\n![建造者模式类图](http://media.gusibi.mobi/XYQwmOYBhmsCsm3_Tg9UDoZD50j-X6CS9_ywASYrKXUKBhx5Qokk9Y7w3B9EDWbc)\n\n\n### 建造者模式在软件中的应用\n\n* django-widgy是一个 Django的第三方树编辑器扩展，可用作内容管理系统(Content Management System，CMS)。它包含一个网页构建器，用来创建具有不同布局的HTML页面。\n\n* django-query-builder是另一个基于建造者模式的Django第三方扩展库，该扩展库可用于动态 地构建SQL查询。使用它，我们能够控制一个查询的方方面面，并能创建不同种类的查询，从简 单的到非常复杂的都可以\n\n\n## 建造者模式和工厂模式的区别\n\n看上边这个例子，你可能会疑惑，为什么明明可以使用工厂方法模式可以解决的问题，要换成建造者模式呢？\n\n通过代码可以看出，建造者模式和工厂方法模式最大的区别是，建造者模式多了一个指挥者的角色。`建造者负责创建复杂对象的各个组成部分。而指挥者使用一个建造者实例控制建造的过程`。\n\n`与工厂模式相比，建造者模式一般用来创建更为复杂的对象`，因为对象的创建过程更为复杂，因此将对象的创建过程独立出来组成一个新的类——指挥者类。\n\n建造者模式通常用于补充工厂模式的不足，尤其是在如下场景中：\n\n* 要求一个对象有不同的表现，并且希望将对象的构造与表现解耦\n* 要求在某个时间点创建对象，但在稍后的时间点再访问\n\n\n## 参考链接\n\n\n* [讲故事，学（Java）设计模式—建造者模式](http://www.importnew.com/6841.html)\n* [设计模式（九）——建造者模式](http://www.hollischuang.com/archives/1477)\n* [23种设计模式（4）：建造者模式](http://blog.csdn.net/zhengzhb/article/details/7375966)\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "python设计模式-建造者模式",
        "date": "2017-11-12 13:16:56",
        "tags": [
          "python",
          "读书笔记",
          "设计模式"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-design-pattern-builder"
    },
    {
      "content": "\n> `问题：`在上一篇 [python设计模式：工厂方法模式](https://mp.weixin.qq.com/s/3HtKVCzPOmuk5uFpfoBsqA)我们尝试使用工厂方法创建了披萨店，现在为了保证披萨加盟店也能有良好的声誉，我们需要`统一原材料`，这个该如何做呢？\n\n为了确保每家加盟店都是用高质量的原材料，我们打算建造一加原材料工厂，并将原材料运送到各个加盟店。`每个加盟店会对原材料有不同的需求`，这里我们就可以用上上一篇介绍的工厂方法模式了。\n\n1. 首先，建造原料工厂\n2. 然后建造区域的原料工厂（继承自原料工厂）\n3. 在区域的原料工厂中实现原料的创建方法。\n4. 将原料工厂组合起来，加入到 PizzaStore（上一篇中由工厂方法实现）代码中。\n\n按照这个思路，我们先创建原料工厂\n\n## 创建原料工厂\n\n创建原料工厂的实现代码如下：\n\n```python\n# 原料\nclass FreshClams:\n\n    def __str__(self):\n        return 'Fresh Clams'\n\nclass MarinaraSauce:\n\n    def __str__(self):\n        return \"Marinara Sauce\"\n\nclass ThickCrustDough:\n\n    def __str__(self):\n        return \"Thick Crust Dough\"\n\nclass ReggianoCheese:\n\n    def __str__(self):\n        return \"Reggiano Cheese\"\n\nclass SlicedPepperoni:\n\n    def __str__(self):\n        return \"Sliced Pepperoni\"\n\nclass Garlic:\n\n    def __str__(self):\n        return \"Garlic\"\n\nclass Onion:\n\n    def __str__(self):\n        return \"Onion\"\n\nclass RedPepper:\n\n    def __str__(self):\n        return \"Red Pepper\"\n\n# 披萨店原料工厂\nclass PizzaIngredientFactory:\n\n    '''\n    定义原料工厂\n    '''\n\n    def create_dough(self):\n        raise NotImplementedError()\n\n    def create_sauce(self):\n        raise NotImplementedError()\n\n    def create_cheese(self):\n        raise NotImplementedError()\n\n    def create_pepperoni(self):\n        raise NotImplementedError()\n\n    def create_clam(self):\n        raise NotImplementedError()\n\n    def create_veggies(self):\n        raise NotImplementedError()\n```\n\n在这个工厂中，每个原料都是一个方法，原料的实现需要在具体的原料工厂中实现。\n这里每个原料方法没有做任何工作，只是抛出了`NotImplementedError` 这样做是为了强制子类重新实现相应的方法，如果不重新实现用到时就会抛出 NotImplementedError。\n\n> 当然也可以把 PizzaIngredientFactory 的 metaclass 设置成 abc.ABCMeta 这样的话，这个类就是真正的抽象基类。\n\n### 创建纽约原料工厂\n\n```python\nclass NYPizzaIngredientFactory(PizzaIngredientFactory):\n    def create_dough(self):\n        print(\"Tossing %s\" % ThickCrustDough())\n        return ThickCrustDough()\n\n    def create_sauce(self):\n        print(\"Adding %s...\" % MarinaraSauce())\n        return MarinaraSauce()\n\n    def create_cheese(self):\n        print(\"Adding %s...\" % ReggianoCheese())\n        return ReggianoCheese()\n\n    def create_pepperoni(self):\n        print(\"Adding %s...\" % SlicedPepperoni())\n        return SlicedPepperoni()\n\n    def create_clam(self):\n        print(\"Adding %s...\" % FreshClams())\n        return FreshClams()\n\n    def create_veggies(self):\n        # 蔬菜可能有多种，这里使用列表\n        veggies = [Garlic(), Onion(), RedPepper()]\n        for veggie in veggies:\n            print(\"  %s\" % veggie)\n        return veggies\n```\n\n对于原料家族的每一种原料，我们都提供了原料的纽约版本。\n\n### 重做 Pizza 类\n\n```python\nclass Pizza:\n    \n    name = None\n    dough = None\n    sauce = None\n    cheese = None\n    veggies = []\n    pepperoni = None\n    clam = None\n\n    def prepare(self):\n        raise NotImplementedError()\n\n    def bake(self):\n        print(\"Bake for 25 minutes at 350\")\n\n    def cut(self):\n        print(\"Cutting the pizza into diagonal slices\")\n\n    def box(self):\n        print(\"Place pizza in official PizzaStore box\")\n\n    def __str__(self):\n        return self.name\n```\n\n上述代码和工厂方法的代码相比，只是把 `prepare()` 方法抽象出来，需要相应的 具体的 pizza 类来实现 `prepare()`。\n\n### 实现 芝加哥芝士披萨\n\n```python\nclass NYStyleCheesePizza(Pizza):\n\n    def prepare(self):\n        dough = self.ingredient_factory.create_dough()\n        sauce = self.ingredient_factory.create_sauce()\n        cheese = self.ingredient_factory.create_cheese()\n        clam = self.ingredient_factory.create_clam()\n        veggies = self.ingredient_factory.create_veggies()\n```\n\n从上述代码可以发现，Pizza 的原料也是从原料工厂直接获取，现在我们控制了原料。\n\n> 现在，Pizza 类不需要关心原料，只需要负责制作 pizza 就好。Pizza 和原料被解耦。\n\n### 重新实现 PizzaStore\n\n```python\nclass PizzaStore:\n    \n    # 需要声明原料工厂\n    ingredient_factory = None\n\n    def create_pizza(self, pizza_type):\n        # 每个需要子类实现的方法都会抛出NotImplementedError\n        # 我们也可以把 PizzaStore 的 metaclass 设置成 abc.ABCMeta\n        # 这样的话，这个类就是真正的抽象基类\n        raise NotImplementedError()\n\n    def order_pizza(self, pizza_type):  # 现在把 pizza 的类型传入 order_pizza()\n\n        pizza = self.create_pizza(pizza_type)\n\n        #  一旦我们有了一个 pizza，需要做一些准备（擀面皮、加佐料），然后烘烤、切片、装盒\n        pizza.prepare()\n        pizza.bake()\n        pizza.cut()\n        pizza.box()\n        return pizza\n\nclass NYStylePizzStore(PizzaStore):\n    \n    # 将需要用到的原料工厂赋值给变量 ingredient_factory\n    ingredient_factory = NYPizzaIngredientFactory()\n\n    def create_pizza(self, pizza_type):\n        # 根据 pizza 类型，我们实例化正确的具体类，然后将其赋值给 pizza 实例变量\n        if pizza_type == 'cheese':\n            pizza = NYStyleCheesePizza('NY Style Sauce and Cheese Pizza',\n                                       self.ingredient_factory)\n        elif pizza_type == 'clam':\n            pizza = NYStyleClamPizza('NY Style Clam Pizza',\n                                     self.ingredient_factory)\n        return pizza\n```\n\n通过上述代码可以看到我们做了以下工作：\n1. 引入了新类型的工厂（抽象工厂）来创建原料家族\n2. 通过抽象工厂提供的接口，我们创建了原料家族。\n3. 我们的原料代码从实际的 Pizza 工厂中成功解耦，可以应用到不同地方，响应的，我们可以方便的替换原料工厂来生产不同的 pizza。\n\n### 来看下下单的代码\n\n```python\ndef main():\n    nystore = NYStylePizzStore()\n    pizza = nystore.order_pizza('cheese')\n    print('*' * 10)\n    print(\"goodspeed ordered a %s\" % pizza)\n    print('*' * 10)\n```\n和工厂方法的代码相比，没有任何改变。\n\n`[源码参考python-design-patter-abstract-factory.py](https://gist.github.com/gusibi/5e0797f5458678322486f999ca87a180)`\n\n## 抽象工厂模式\n\n> `抽象工厂模式`提供一个接口，用于创建相关或依赖对象的家族，而不需要指定具体类。\n\n也就是说，抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道实际产出的具体产品是什么，这样依赖，客户就从具体产品中被解耦。\n\n概括来说就是，抽象工厂是逻辑上的一组工厂方法，每个工厂方法各司其职，负责生产不同种类的对象。\n\n我们来看下 抽象工厂模式 的类图：\n\n![抽象工厂模式类图](http://media.gusibi.mobi/WXTX-aCeU8DaFhBXBHy1D8pqiLDUJggw-XqCGgYTmigQOdi8dly0Z-ujsJVgq7T5)\n\n抽象工厂在 django_factory 中应用比较多，有兴趣的可以看下源码。\n\n## 抽象工厂模式 和 工厂方法模式 的比较\n\n抽象工厂模式 和 工厂方法模式 都是负责创建对象，但 \n\n* `工厂方法模式使用的是继承`\n* `抽象工厂模式使用的是对象的组合`\n\n这也就意味着利用`工厂方法`创建对象需要扩展一个类，并覆盖它的工厂方法（负责将客户从具体类中解耦）。\n`抽象工厂`提供一个用来创建产品家族的抽象类型，这个类型的子类定义了产品被产生的方法。要想使用这个工厂（`NYPizzaIngredientFactory`），必须先实例化它（`ingredient_factory = NYPizzaIngredientFactory()`），然后将它传入一些针对抽象类型所写的代码中（也做到了将客户从具体产品中解耦），同时还把一群相关的产品集合起来。\n\n#### 工厂方法模式和抽象工厂模式如何选择\n\n开始的时候，可以选择工厂方法模式，因为他很简单（只需要继承，并实现工厂方法即可）。如果后来发现应用需要用到多个工厂方法，那么是时候使用`抽象工厂模式`了，它可以把相关的工厂方法组合起来。\n\n### 抽象工厂模式优点和缺点\n\n#### 优点\n\n* 可以将客户从具体产品中解耦\n* 抽象工厂可以让对象创建更容易被追踪\n* 同时将对象创建与使用解耦\n* 也可以优化内存占用提升应用性能\n\n#### 缺点\n\n因为抽象工厂是将一组相关的产品集合起来，如果需要扩展这组产品，就需要`改变接口`，而改变接口则意味着需要改变`每个子类的接口`\n\n\n## 参考链接\n\n* [python设计模式：工厂方法模式](https://mp.weixin.qq.com/s/3HtKVCzPOmuk5uFpfoBsqA)\n* [python-design-patter-abstract-factory.py https://gist.github.com/gusibi/5e0797f5458678322486f999ca87a180](https://gist.github.com/gusibi/5e0797f5458678322486f999ca87a180)\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "python设计模式-抽象工厂模式",
        "date": "2017-10-28 13:23:56",
        "tags": [
          "python",
          "读书笔记",
          "设计模式"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-design-pattern-abstract-factory"
    },
    {
      "content": "\n最近做小程序服务器的配置，这一篇是服务器配置的记录，方便以后安装配置。\n\n## 购买服务器\n\n之所以选腾讯云的原因很简单，那就是便宜，`选用成都区`，最低配置每月只需29￥。\n在 [腾讯云](https://cloud.tencent.com) 官网注册登录就可以直接购买服务器了。\n服务器系统我选择的是 ubuntu。\n\n## 服务器配置\n\n启动服务后使用新用户（此步骤不是必须）。\n\n### 新建用户\n\n首先确认使用的是 root 用户登录如果不是使用以下命令切换\n\n```bash\nsudo su\n```\n使用 `adduser` 命令创建用户\n```bash\nadduser username # username替换为你自己的用户名\n```\n\n接下来的步骤会让你输入密码和个人信息，自己设置就好。\n\n使用`usermod` 命令将新建的用户添加到 `sudo` 组。\n\n```go\nusermod -aG sudo username\n```\n\n### 关闭ssh密码登录使用密钥登录\n\n#### 安装openssh\n\n因为是新系统，先执行一下 apt-get update\n\n```bash\nsudo apt-get update\nsudo apt-get install openssh-server\n```\n\n#### 启动ssh服务\n\n可以通过sudo su命令来临时切换到root权限(不是所有的账号都可以切换到root权限,只有在/etc/sudoers文件中符合规则的用户能切换root身份)\n\n```bash\nsudo su\n/etc/init.d/ssh start\n```\n\n#### 使用密钥登录\n\n* 服务器端生成密钥对：\n\n```bash\ncd /home/gs # 打开新建的用户目录\nmkdir .ssh\ncd .ssh\nssh-keygen -b 2048 -t rsa\n```\n\n> ssh-keygen的基本用法：\n-b后面是指定加密后的字符串长度\n-t后面是指定加密算法，常用的加密算法有rsa,dsa等\n\n默认生成的文件如下：\n\n``` bash\nid_rsa.pub  # 公钥文件\nid_rsa      # 私钥文件\n```\n\n* 新建 authorized_keys 文件\n\n将本地机器的 id_rsa.pub 文件内容复制到 authorized_keys 文件\n\n* 测试使用公钥是否可以登录\n\n```bash\nssh name@host  # name 是机器的用户名 host 是机器的地址\n```\n\n#### 关闭ssh密码登录\n\n确认可以通过私钥进行登录后，关闭ssh密码登录。\n\n```bash\nsudo su\nvim /etc/ssh/sshd_config\n```\n\n将 PasswordAuthentication yes修改成PasswordAuthentication no\n\n重启系统\n\n```bash\nsudo su\nreboot\n```\n\n## 搭建开发环境\n\n### 安装 zsh\n\n在终端中输入下面命令进行安装：\n\n```bash\nsudo apt-get install zsh\n```\n\n输入下面命令进行替换zsh替换为你的默认shell：\n\n```bash\nchsh -s /bin/zsh\n```\n\n重启终端使用 zsh\n\n### 安装oh-my-zsh\n\n* 通过curl安装\n\n```bash\ncurl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh\n```\n\n* 通过wget安装\n\n```bash\nwget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O - | sh\n```\n\n### 安装 pip\n\n```bash\nsudo apt-get install python-pip  # 安装 pip\npip install --upgrade pip\nsudo apt-get install python3-pip  # 安装 pip3\npip3 install --upgrade pip\n```\n\n### 安装 virtualenv\n\n因为我使用 python3 作为开发环境，所以这里使用 `pip3`\n```bash\nsudo pip3 install virtualenv\nsudo pip3 install virtualenvwrapper\n```\n\n在 .zshrc 添加以下内容\n```bash\nexport VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3\nexport WORKON_HOME=$HOME/.virtualenvs\nsource /usr/local/bin/virtualenvwrapper.sh\n```\n然后执行命令：\n\n```bash\nsource .zshrc\n```\n\n现在可以输入 `workon` 测试 virtualenvwrapper 是否已经安装成功。\n\n#### 创建虚拟环境\n\n```bash\nmkvirtualenv py3 -p python3  # -p 参数指定 python 版本\n```\n\n测试虚拟环境\n\n```bash\nworkon py3\n```\n\n### 安装 ipython\n\n首先进入 py3 虚拟环境\n\n```bash\nworkon py3\n```\n使用 pip 安装 ipython\n\n```bash\npip install ipython # 安装 ipython \n```\n### 配置 vim\n\n python vim 配置使用的是 [py-vim](https://github.com/gusibi/py-vim)\n\n需要先安装 ctags和 cmake\n\n```bash\nsudo apt-get install ctags\nsudo apt-get install cmake\n```\n\n然后将 py-vim clone 到服务器\n\n```bash\ngit clone https://github.com/gusibi/py-vim\ncd py-vim\nsh setup.sh \n```\n\n## 使用 Caddy 配置 https\n\n> Caddy是一种新的Web服务器，由 go 编写，默认使用 https 协议。caddy 配置简单，容易上手。\n\n### 安装 caddy 二进制文件\n\nCaddy项目提供了一个安装脚本，可以检索和安装Caddy服务器的二进制文件。 可以执行以下命令直接安装：\n\n```bash\ncurl -s https://getcaddy.com | bash\n```\n\n在安装过程中，脚本将使用sudo获取管理权限，以便将Caddy文件放在系统范围的目录中，因此可能会提示您输入密码。\n\n### 配置 caddy 必要的目录\n\nCaddy的自动TLS支持和unit文件需要特定的目录和文件权限。 我们将在这一步中创建它们。\n\n首先，创建一个目录，该目录将容纳主要的配置文件Caddyfile 。\n\n```bash\n# 创建一个目录，该目录将容纳主要的配置文件Caddyfile\nsudo mkdir /etc/caddy\n# 将此目录的所有者更改为root用户及其组到www-data ，以便Caddy可以读取它\nsudo chown -R root:www-data /etc/caddy\n# 创建一个空的Caddyfile\nsudo touch /etc/caddy/Caddyfile\n# 在/etc/ssl创建另一个目录用来存储自动获得的SSL私钥和证书\nsudo mkdir /etc/ssl/caddy\n# 将此目录的所有者更改为root用户及其组到www-data\nsudo chown -R www-data:root /etc/ssl/caddy\n# 确保没有人可以通过删除其他人的所有访问权限来读取这些文件。\nsudo chmod 0770 /etc/ssl/caddy\n# 创建的最终目录是网站的发布目录\nsudo mkdir /var/www\n# 该目录应由www-data完全拥有。\nsudo chown www-data:www-data /var/www\n# 创建日志目录\nsudo mkdir /var/log/caddy\n# 将此目录的所有者更改为root用户及其组到www-data\nsudo chown -R www-data:root /var/log/caddy\n```\n\n### 将 caddy 配置为系统服务\n\n从官方的Caddy存储库下载文件。 curl命令的附加-o参数会将该文件保存在/etc/systemd/system/目录中，并使其对systemd可见。\n\n```bash\nsudo curl -s https://raw.githubusercontent.com/mholt/caddy/master/dist/init/linux-systemd/caddy.service -o /etc/systemd/system/caddy.service\n```\n\nreload 系统服务\n\n```bash\nsudo systemctl daemon-reload\n```\n将caddy 设置为开机启动\n```bash\nsudo systemctl enable caddy.service\n```\n检查 caddy 服务是否已正式加载\n```bash\nsudo systemctl status caddy.service\n```\n\n### 允许HTTP和HTTPS连接\n\nCaddy使用HTTP和HTTPS协议提供网站，因此我们需要允许访问相应的端口，以便使网路可以从网路获取\n\n```bash\nsudo ufw allow http\nsudo ufw allow https\n```\n\n现在修改caddy 配置 /etc/caddy/Caddyfile\n\n```bash\nhttps://your.domain {  # 启用 https\n    gzip\n    log /var/log/caddy/access.log  # 指定日志目录\n    proxy / http://127.0.0.1:8888 {\n        header_upstream Host {host}\n        header_upstream X-Real-IP {remote}\n        header_upstream X-Forwarded-For {remote}\n        header_upstream X-Forwarded-Proto {scheme}\n    }\n}\n```\n\n保存文件，启动 caddy\n\n```bash\nsudo systemctl start caddy    # 启动 caddy\nsudo systemctl restart caddy  # 重启 caddy\nsudo systemctl stop caddy     # 关闭 caddy\n```\n\n现在启动服务，访问 `https://your.domain` 应该就能看到数据。\n日志文件在 `/var/log/caddy/` 目录下。\n\n## 总结\n\n小程序开发需要 https，这里我们使用了 caddy 作为 web 服务器。服务器配置好后可以直接存储为镜像，以后可以直接从镜像开启服务，就不再需要配置环境。\n\n## 参考链接\n\n* [How To Create a Sudo User on Ubuntu ](https://www.digitalocean.com/community/tutorials/how-to-create-a-sudo-user-on-ubuntu-quickstart)\n* [zsh安装和配置](http://blog.csdn.net/ii1245712564/article/details/45843657)\n* [virtualenvwrapper](https://virtualenvwrapper.readthedocs.io/en/latest/)\n* [py-vim](https://github.com/gusibi/py-vim)\n* [Install MongoDB Community Edition on Ubuntu](https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/)\n* [使用 Caddy 替代 Nginx，全站升级 https，配置更加简单](https://zhuanlan.zhihu.com/p/26839519)\n* [how-to-host-a-website-with-caddy-on-ubuntu-16-04](https://www.digitalocean.com/community/tutorials/how-to-host-a-website-with-caddy-on-ubuntu-16-04)\n------\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "使用腾讯云配置小程序Python开发环境",
        "date": "2017-10-21 14:11:35",
        "tags": [
          "development",
          "小程序",
          "后端",
          "tutorial"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "wxapp-server-config"
    },
    {
      "content": "\n> `题目`：假设你有一个 pizza 店，功能包括`下订单`、`做 pizza`，你的代码会如何写呢？\n\n```python\ndef order_pizza():\n    pizza = Pizza()\n    pizza.prepare()\n    pizza.bake()\n    pizza.cut()\n    pizza.box()\n    return pizza\n```\n\n但是现在你遇到了一个问题，你的 pizza 店需要更多的 pizza，所以现在你需要增加一些代码，来决定适合的 pizza 类型，然后再制造这个 pizza：\n\n```python\ndef order_pizza(pizza_type):  # 现在把 pizza 的类型传入 order_pizza()\n\n    # 根据 pizza 类型，我们实例化正确的具体类，然后将其赋值给 pizza 实例变量\n    if pizza_type == 'cheese':\n        pizza = CheesePizza()\n    elif pizza_type == 'greek':\n        pizza = GreekPizza()\n    elif pizza_type == 'pepperoni':\n        pizza = PepperoniPizza()\n    # 一旦我们有了一个 pizza，需要做一些准备（擀面皮、加佐料），然后烘烤、切片、装盒\n    pizza.prepare()\n    pizza.bake()\n    pizza.cut()\n    pizza.box()\n    return pizza\n```\n\n但是经过几天的实践，你发现顾客喜欢点的 ClamPizza、Veggie Pizza 而 Greek pizza 并没有什么人喜欢，这个时候需要修改代码：\n\n```python\ndef order_pizza(pizza_type):  # 现在把 pizza 的类型传入 order_pizza()\n\n    # 根据 pizza 类型，我们实例化正确的具体类，然后将其赋值给 pizza 实例变量\n    if pizza_type == 'cheese':\n        pizza = CheesePizza()\n    # elif pizza_type == 'greek':  # greek pizza 不再出现在菜单\n    #     pizza = GreekPizza()\n    elif pizza_type == 'pepperoni':\n        pizza = PepperoniPizza()\n    # 新加了 clam pizza 和 veggie pizza\n    elif pizza_type == 'clam':\n        pizza = ClamPizza()\n    elif pizza_type == 'veggie':\n        pizza = VeggiePizza()\n\n    #  一旦我们有了一个 pizza，需要做一些准备（擀面皮、加佐料），然后烘烤、切片、装盒\n    pizza.prepare()\n    pizza.bake()\n    pizza.cut()\n    pizza.box()\n    return pizza\n```\n\n现在你发现了一个问题， order_pizza() 是在内部实例化了具体的 `Pizza 类`，并且，order_pizza() 也没有对修改关闭，以至于每次有了新的 pizza 加入都要修改 order_pizza() 的代码。这时一个比较好的办法是把创建 Pizza 对象是抽象出来，修改后的代码如下：\n\n```python\n# 把创建对象的代码从 order_pizza 方法中抽离\ndef create_pizza(pizza_type):\n    # 根据 pizza 类型，我们实例化正确的具体类，然后将其赋值给 pizza 实例变量\n    if pizza_type == 'cheese':\n        pizza = CheesePizza()\n    elif pizza_type == 'pepperoni':\n        pizza = PepperoniPizza()\n    elif pizza_type == 'clam':\n        pizza = ClamPizza()\n    elif pizza_type == 'veggie':\n        pizza = VeggiePizza()\n    return pizza\n\ndef order_pizza(pizza_type):  # 现在把 pizza 的类型传入 order_pizza()\n    # 这里使用 create_pizza() 方法创建 pizza 类\n    pizza = create_pizza(pizza_type)\n\n    #  一旦我们有了一个 pizza，需要做一些准备（擀面皮、加佐料），然后烘烤、切片、装盒\n    pizza.prepare()\n    pizza.bake()\n    pizza.cut()\n    pizza.box()\n    return pizza\n```\n\n## 简单工厂模式\n\n我们把创建 pizza 对象的代码提取到一个新的方法中，我们称这个新的方法叫做`工厂`。\n\n> `工厂`处理创建对象的细节，一旦有了`create_pizza`，`order_pizza()` 就成了此对象的客户。当需要 pizza 时，只需要告诉工厂需要什么类型的 pizza，让它做一个即可。\n\n现在 order_pizza() 方法只关心从工厂得到一个 pizza，这个 pizza 实现了 Pizza 的接口，所以它可以调用 `prepare()（准备）`、`bake()（烘烤）`、`cut()（切片）`、`box()（装盒）`\n\n> `问：`现在你可能会问，这段代码看上去更复杂了，有什么好处了呢？看上去只是把问题搬到另一个对象了。\n`答：` 现在看来，order_pizza 只是`create_pizza` 的一个客户，其它客户（比如pizza 店菜单 PizzaShopMenu）也可以使用这个工厂来取得 pizza。把创建 pizza 的代码包装进一个类，当以后实现修改时，只需要修改这个部分代码即可。\n\n这里我们的工厂`create_order()` 是一个简单的方法，利用方法定义一个简单工厂的方法通常被称为`简单工厂模式`（`简单工厂`更像是一中编程习惯而不是设计模式）。\n\n### 重做 PizzaStore 类\n\n上边的代码中，`order_pizza` 是客户代码，但是为了让我们的 pizza 店有更好的扩展性，这里我们需要把客户代码做一下修改：\n\n```python\nclass SimplePizzaFactory:\n\n    def create_pizza(self, pizza_type):\n        ...\n        return pizza\n\nclass PizzaStore:\n    def order_pizza(self, pizza_type):  # 现在把 pizza 的类型传入 order_pizza()\n        factory = SimplePizzaFactory()\n        pizza = factory.create_pizza(pizza_type)\n        ...\n        return pizza\n    \n    # 下边是其他可能用到的方法\n```\n\n这段代码中，我们把一个方法（create_pizza）使用类（SimplePizzaFactory）封装了起来，目的是使工厂可以`通过继承来改变创建方法的行为`，并且这样做，也可以提高工厂方法的扩展性。\n\n现在来看一下我们 pizza 店的类图：\n\n![pizza店类图](http://media.gusibi.mobi/6DtG1bIO_WXNiv0cdjgTA6UP7rze9-4XY7jKkrrwA43Gtx5eHEwkKNGqvQtWs8NM)\n\n### 简单工厂模式的局限\n\n#### 缺点\n\n* 由于工厂类集中了所有产品创建逻辑，违反了高内聚责任分配原则，一旦不能正常工作，整个系统都要受到影响。\n* 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。\n\n#### 使用场景\n\n* 工厂类负责创建的对象较少\n* 客户只知道传入工厂类的参数，对于如何创建对象（逻辑）不关心；客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。\n\n为了突破这些局限，我们接着看一下`工厂方法模式`\n\n## 工厂方法模式\n\n> 现在我们有了一个新的问题，我们创建 pizza 店后，现在有人想要加盟，但我们还想要控制一下 pizza 的制作流程，该如何实现呢？\n\n首先，要给 pizza 店使用框架，我们所要做的就是把`create_pizza()`方法放回到`PizzaStore`类中，不过这个方法需要在每个子类中倒要实现一次。现在 `PizzaStore`代码为：\n\n```python\nclass PizzaStore:\n\n    def create_pizza(self, pizza_type):\n        # 每个需要子类实现的方法都会抛出NotImplementedError\n        # 我们也可以把 PizzaStore 的 metaclass 设置成 abc.ABCMeta\n        # 这样的话，这个类就是真正的抽象基类\n        raise NotImplementedError()\n\n    def order_pizza(self, pizza_type):  # 现在把 pizza 的类型传入 order_pizza()\n\n        pizza = self.create_pizza(pizza_type)\n\n        #  一旦我们有了一个 pizza，需要做一些准备（擀面皮、加佐料），然后烘烤、切片、装盒\n        pizza.prepare()\n        pizza.bake()\n        pizza.cut()\n        pizza.box()\n        return pizza\n```\n这样我们就声明了一个工厂方法。这个工厂方法用来处理对象的创建，并将这个创建行为封装在子类中，这样客户程序中关于父类的代码就和子类的对象创建代码解耦成功。\n\n我们将 create_pizza 放回 PizzaStore 的目的是让继承此方法的子类负责定义自己的`create_pizza()` 方法。现在我们看一下PizzaStore 的子类示意图：\n\n![](http://media.gusibi.mobi/tca7Q3e78ijKMLm2vfUvrvR5FiVLM7rBvv6DZ402NsxAkgcUc8xEPsjCvnZALnxK)\n\n这里 `NYStlyePizzaStore` 和 `ChicagoStylePizzaStore` 需要分别定义自己的 `create_pizza` 方法。\n\n现在来看下完整代码：\n\n```python\n#! -*- coding: utf-8 -*-\n\nclass Pizza:\n\n    name = None\n    dough = None\n    sauce = None\n    toppings = []\n\n    def prepare(self):\n        print(\"Preparing %s\" % self.name)\n        print(\"Tossing dough...\")\n        print(\"Adding sauce...\")\n        print(\"Adding toppings: \")\n        for topping in self.toppings:\n            print(\"  %s\" % topping)\n\n    def bake(self):\n        print(\"Bake for 25 minutes at 350\")\n\n    def cut(self):\n        print(\"Cutting the pizza into diagonal slices\")\n\n    def box(self):\n        print(\"Place pizza in official PizzaStore box\")\n\n    def __str__(self):\n        return self.name\n\n\nclass NYStyleCheesePizza(Pizza):\n\n    name = \"NY Style Sauce and Cheese Pizza\"\n    dough = \"Thin Crust Dough\"\n    sauce = \"Marinara Sauce\"\n    toppings = [\"Grated\", \"Reggiano\", \"Cheese\"]\n\n\nclass ChicagoStyleCheesePizza(Pizza):\n\n    name = \"Chicago Style Deep Dish Cheese Pizza\"\n    dough = \"Extra Thick Crust Dough\"\n    sauce = \"Plum Tomato Sauce\"\n    toppings = [\"Shredded\", \"Mozzarella\", \"Cheese\"]\n\n    def cut(self):\n        print(\"Cutting the pizza into square slices\")\n\n\nclass PizzaStore:\n    def create_pizza(self, pizza_type):\n        # 每个需要子类实现的方法都会抛出NotImplementedError\n        # 我们也可以把 PizzaStore 的 metaclass 设置成 abc.ABCMeta\n        # 这样的话，这个类就是真正的抽象基类\n        raise NotImplementedError()\n\n    def order_pizza(self, pizza_type):  # 现在把 pizza 的类型传入 order_pizza()\n\n        pizza = self.create_pizza(pizza_type)\n\n        #  一旦我们有了一个 pizza，需要做一些准备（擀面皮、加佐料），然后烘烤、切片、装盒\n        pizza.prepare()\n        pizza.bake()\n        pizza.cut()\n        pizza.box()\n        return pizza\n\nclass NYStylePizzStore(PizzaStore):\n    def create_pizza(self, pizza_type):\n        # 根据 pizza 类型，我们实例化正确的具体类，然后将其赋值给 pizza 实例变量\n        if pizza_type == 'cheese':\n            pizza = NYStyleCheesePizza()\n        return pizza\n\n\nclass ChicagoStylePizzaStore(PizzaStore):\n    def create_pizza(self, pizza_type):\n        # 根据 pizza 类型，我们实例化正确的具体类，然后将其赋值给 pizza 实例变量\n        if pizza_type == 'cheese':\n            pizza = ChicagoStyleCheesePizza()\n        return pizza\n\n\ndef main():\n    nystore = NYStylePizzStore()\n    pizza = nystore.order_pizza('cheese')\n    print(\"goodspeed ordered a %s\" % pizza)\n\n    print(\"*\" * 100)\n    chicago_store = ChicagoStylePizzaStore()\n    pizza = chicago_store.order_pizza('cheese')\n    print(\"goodspeed ordered a %s\" % pizza)\n\n\nif __name__ == '__main__':\n    main()\n```\n这里工厂方法 create_pizza() 直接抛出了`NotImplementedError`，这样做事为了强制子类重新实现 create_pizza() 方法，如果不重新实现就会抛出`NotImplementedError`。\n当然也可以把 PizzaStore 的 `metaclass` 设置成 `abc.ABCMeta` 这样的话，这个类就是真正的抽象基类。\n\n现在我们看一下工厂方法模式的类图：\n\n![工厂方法模式类图](http://media.gusibi.mobi/X2xyI6pQ3sXdU_Y3Z_CH-qN6zP62jnvQDstKTz8AJL50FS8xhOazvO2RmRhsHH6X)\n\n产品类和创建者类其实是平行的类的层级它们的关系如下图：\n\n![](http://media.gusibi.mobi/LYoRbaaHRx4HhBho1wzNWB9LKxiVfCBJd-WxEkhfKo-9JJUjnFdIJxyEVuJKnhwP)\n\n### 工厂方法模式定义\n\n通过上文的介绍，我们可以得到工厂方法模式大概的定义：\n\n> 在`工厂方法模式`中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。\n\n工厂方法模式能够封装具体类型的实例化，抽象的 Creator 提供了一个创建对象的`工厂方法`。在抽象的 Creator 中，任何其他实现的方法，都可能使用到这个方法锁制造出来的产品，但只有子类真正实现这个工厂方法并创建产品。\n\n下图是工厂方法模式原理类图：\n\n![工厂方法模式类图](http://media.gusibi.mobi/jRO23-NdrmQi6ffAX-rpa2rzVSrlIIgzqQbKcSNa96Nshk8bCXFR2_jozUgCoHNa)\n\n\n### 工厂方法模式优点\n\n* 工厂方法集中的在一个地方创建对象，使对象的跟踪变得更容易。\n* 工厂方法模式可以帮助我们将产品的实现从`使用`中`解耦`。如果增加产品或者改变产品的实现，Creator 并不会收到影响。\n* 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。\n\n> 工厂方法可以在必要时创建新的对象，从而提高性能和内存使用率。若直接实例化类来创建对象，那么每次创建新对象就需要分配额外的内存。\n\n## `简单工厂`和`工厂方法`之间的差异\n\n> 简单工厂把全部的事情在一个地方处理完了（create_pizza），而工厂方法是创建了一个框架，让子类去决定如何实现。比如在工厂方法中，order_pizza() 方法提供了一般的框架用来创建 pizza，order_pizza() 方法依赖工厂方法创建具体类，并制造出实际的 pizza。而制造什么样的 pizza 是通过继承 PizzaStore来实现的。  但 `简单工厂` 只是把对象封装起来，并不具备工厂方法的弹性。\n\n\n## python 应用中使用工厂模式的例子\n\nDjango 的 forms 模块使用工厂方法模式来创建表单字段。WTForm 也使用到了工厂方法模式。sqlalchemy 中不同数据库连接部分也用到了工厂方法模式。\n\n## 总结\n\n工厂方法模式的核心思想是定义一个用来创建对象的公共接口，由工厂而不是客户来决定需要被实例化的类，它通常在构造系统整体框架时被用到。工厂方法模式看上去似乎比较简单，但是内涵却极其深刻，抽象、封装、继承、委托、多态等面向对象设计中的理论都得到了很好的体现，应用范围非常广泛。\n\n## 参考\n\n* 《Head First 设计模式》\n* 《精通 python 设计模式》\n* 《Python 编程实战》\n* [Python设计模式系列之三: 创建型Factory Method模式](https://www.ibm.com/developerworks/cn/linux/l-pypt/part3/index.html)\n\n------\n\n最后，感谢女朋友支持。\n\n欢迎关注(April_Louisa) | 请我喝芬达\n------- | -------\n![欢迎关注](http://media.gusibi.mobi/Hy8XHexmzppNKuekLuGxWy8LjdGrQAzZA3mH_e9xltoiYgTFWdvlpZwGWxZESrbK)| ![请我喝芬达](http://media.gusibi.mobi/CO9DwU6ZHnXHD5xuG3GqTsY_IYPl-JdpQrDaOo6tl6PiAGEBDeYFHO7sGQi_VVFc)\n",
      "data": {
        "title": "python设计模式-工厂方法模式",
        "date": "2017-10-15 05:23:56",
        "tags": [
          "python",
          "读书笔记",
          "设计模式"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-design-pattern-factory-method"
    },
    {
      "content": "\n> `题目`：现在你有一个数字，默认格式化程序是以十进制格式展示此数值，但需要提供一个功能，这个程序要支持添加/注册更多的格式化程序（比如：添加一个十六进制格式化程序和一个二进制格式化程序）。每次数值更新时，已注册的程序就会收到通知，并显示更新后的值。\n\n我们看下需求：\n\n1. NumberFormatter 有一个 number 属性\n2. 当 number 值修改时，相关的格式化方式展示结果要改变\n3. 此系统必须可扩展已适应其他格式化方式的使用。\n\n一个错误的实现可能是这样的：\n\n```python\nclass NumberFormatter(object):\n    def __init__(self, number):\n        self.number = number\n        \n    def show_data(self):\n        self.default_formatter()\n        self.hex_formatter()\n        self.binary_formatter()\n        \n    def default_formatter(self):\n        pass\n        \n    def hex_formatter(self):\n        pass\n        \n    def binary_formatter(self):\n        pass\n```\n\n我们可以这么使用：\n\n```python\nnumber = NumberFormatter(10)\nnumber.show_data()\n```\n\n但是这样会有一个问题：`这种针对实现的编程会导致我们在增加或者删除需要格式化方式时必须修改代码。`比如我们现在不再需要十六进制数字格式的显示，就需要把 `hex_formatter` 相关的代码删除或者注释掉。\n\n要解决这个问题，就可以用到我们这次要介绍的`观察者模式`了。\n\n## 什么是观察者模式\n\n### 认识观察者模式\n\n我们先看看报纸和杂志的订阅是怎么回事：\n\n1. 报社的业务就是出版报纸\n2. 向某家报社订阅报纸，只要他们有新报纸，就会给你送来，只要你是他们的订户，你就会一直受到新报纸。\n3. 当你不再想看的时候，取消订阅，他们就不会在送新报纸给你\n4. 只要报社还在运营，就会一直有人向他们订阅报纸或取消订阅。\n\n我们用图表示一下，这里`出版者` 改称为`主题(Subject)`，`订阅者`改称为`观察者(Observer)`：\n\n`1.` 开始的时候，鸭子对象不是观察者\n![](http://media.gusibi.mobi/FfEgRxfZ2c7lzOINxR1JJ9uarNvN0AjO15HBfKxEBoVdr4GANZIFjFmAwq6L9fM-)\n`2.` 鸭子对象过来告诉主题，它想当一个观察者（鸭子其实想说的是：我对你的数据改变感兴趣，一有变化请通知我）\n![](http://media.gusibi.mobi/2KE6cyN1-K24iLlk-l_WWxjAC894wqhqDWMrfk780kRArv1QQMD7AU66WabDnHZ4)\n`3.` 鸭子对象已经是观察者了（鸭子静候通知，一旦接到通知，就会得到一个整数）。\n![](http://media.gusibi.mobi/si9qkWv1-wgocRkh8v1gXPbZJlfqpJCsYqXZaQX-8WnY-DbTHGqv_eVLGyy3yfab)\n`4.` 主题有了新的数据（现在鸭子和其他所有观察者都会受到通知：`主题已经改变`）\n![](http://media.gusibi.mobi/9HhHmLzCUctRb46Te5j1A3OUosE-1f_qp37gC7pLJfQI-OFdxpFgosEfIjV9K8I4)\n`5.` 老鼠对象要求从观察者中把自己除名（老鼠已经观察次主题太久，决定不再当观察者了）。\n![](http://media.gusibi.mobi/3crIE4jTaaDE3bUWrp3tHL0jb2cKI0pQhaZeJPKh0HTYl_lY7D30uTeaybry0bRZ)\n`6.` 老鼠离开了（主题知道老鼠的请求后，把它从观察者中移除了）。\n![](http://media.gusibi.mobi/lnPq4IXxYH1fZURcPK2SiLXXbndcgA3f31F9UZ6BSi9QyWO5ZrkswwZ-cxI9_xL5)\n`7.` 主题有了一个新的整数（除了老鼠之外，每个观察者都会收到通知，如果老鼠又想当观察者了，它还可以再回来）\n![](http://media.gusibi.mobi/_PeyLBIegB7aBqh7oLad5fUs8l1ANeqEEd1zEBkcrY02cN768EIDD33rL75YopbU)\n\n### 定义观察者模式\n\n当你试图勾勒观察者模式时，可以利用报纸订阅服务，以及出版这和订阅者比你这一切。在程序设计中，观察者模式通常被定义为：\n\n>`观察者模式`定义了对象之间的一对多依赖，这样一来，当一个对象改变状态是，它的所有依赖者都会收到通知并自动更新。\n\n我们和之前的例子做个对比：\n\n![](http://media.gusibi.mobi/5ictzh2edjji9GITg0JJXtR9bLqEmPN6XDytKrevXzKKdhtpLbZLRFElxRR3GOo3)\n\n主题和观察者定义了一对多的关系。观察者依赖于此主题，只要主题状态一有变化，观察者就会被通知。根据通知的风格，观察者可能因此新值而更新。\n\n`现在你可能有疑问，这和一对多的关系有何关联？`\n\n> 利用观察者模式，主题是具有状态的对象，并且可以控制这些状态。也就是说，有`一个`具有状态的主题。另一方面，观察者使用这些状态，虽然这些状态不属于他们。有许多观察者，依赖主题告诉他们状态何时改变了。这就产生了一个关系：`一个主题对多个观察者的关系`。\n\n`观察者和主题之间的依赖关系是如何产生的？`\n\n> 主题是真正拥有数据的人，观察者是主题的依赖者，在数据变化时更新，这样比起让许多对象控制同一份数据来，可以得到更干净的 OO 设计。\n\n### 观察者模式的应用案例\n\n观察者模式在实际应用中有许多的案例，比如信息的聚合。无论格式为 RSS、Atom 还是其它，思想多事一样的：你追随某个信息源，当它每次更新时，你都会收到关于更新的通知。\n事件驱动系统是一个可以使用观察者模式的例子。在这种系统中，监听者被用于监听特定的事件。监听者的事件被创建出来时就会触发它们。这个事件可以使键入某个特定的键、移动鼠标或者其他。事件扮演发布者的角色，监听者则扮演观察者的角色。\n\n## Python 实现\n\n现在，让我们回到文章开始的那个问题。\n\n这里我们可以实现一个基类 Publisher，包括添加、删除及通知观察者这些公用功能。DefaultFormatter 类继承自 Publisher，并添加格式化程序特定的功能。\n\n![文章开头问题的类图](http://media.gusibi.mobi/pRyxskK89xODXjfsCdPVnnPiJhyP2iyYmYHryZb3taKTnpZxtZZ8TINFsCroP0Y_)\n\nPublisher 的代码如下：\n\n```python\nimport itertools\n\n'''\n观察者模式实现\n'''\n\nclass Publisher:\n\n    def __init__(self):\n        self.observers = set()\n\n    def add(self, observer, *observers):\n        for observer in itertools.chain((observer, ), observers):\n            self.observers.add(observer)\n            observer.update(self)\n        else:\n            print('Failed to add: {}'.format(observer))\n\n    def remove(self, observer):\n        try:\n            self.observers.discard(observer)\n        except ValueError:\n            print('Failed to remove: {}'.format(observer))\n\n    def notify(self):\n        [observer.update(self) for observer in self.observers]\n```\n\n现在，打算使用观察者模式的模型或类都应该继承 Publisher 类。该类用 set 来保存观察者对象。当用户向 Publisher 注册新的观察者对象时，观察者的 update() 方法会执行，这使得它能够用模型当前的状态初始化自己。模型状态发生变化时，应该调用继承而来的 notify() 方法，这样的话，就会执行每个观察者对象的 update() 方法，以确保他们都能反映出模型的最新状态。\n\n> `add()` 方法的写法值得注意，这里是为了支持可以接受一个或多个观察者对象。这里我们采用了`itertools.chain()` 方法，它可以接受任意数量的  `iterable`，并返回单个`iterable`。遍历这个 iterable，也就相当于依次遍历参数里的那些 iterable。\n\n接下来是 `DefaultFomatter` 类。`__init__()` 做的第一件事就是调用基类的`__init__()` 方法，因为这在 Python 中没法自动完成。`DefaultFormatter` 实例有自己的名字，这样便于我们跟踪其状态。对于`_data` 变量，我们使用了名称改编来声明不能直接访问该变量。`DefaultFormatter` 把`_data` 变量用作一个整数，默认值为0。\n\n```python\nclass DefaultFormatter(Publisher):\n\n    def __init__(self, name):\n        Publisher.__init__(self)\n        self.name = name\n        self._data = 0\n\n    def __str__(self):\n        return \"{}: '{}' has data = {}\".format(type(self).__name__, self.name, self._data)\n\n    @property\n    def data(self):\n        return self._data\n\n    @data.setter\n    def data(self, new_value):\n        try:\n            self._data = int(new_value)\n        except ValueError as e:\n            print('Error: {}'.format(e))\n        else:\n            self.notify()\n```\n\n* `__str__()` 方法返回关于发布者名称和 `_data` 值的信息。type(self).__name 是一种获取类名的方便技巧，避免硬编码类名。（不过这会降低代码的可读性）\n\n* `data()` 方法有两个，第一个使用了 `@property` 装饰器来提供_data 变量的读访问方式。这样，我们就能使用 `object.data` 来代替 `object._data`。第二个 data() 方法使用了`@setter` 装饰器，改装饰器会在每次使用赋值操作符(=)为`_data` 变量赋值时被调用。该方法也会尝试把新值强制转换为一个整数，并在转换失败时处理异常。\n\n接下来是添加观察者。`HexFormatter` 和 `BinaryFormatter` 功能基本相似。唯一的不同在于如何格式化从发布者那获取到的数据值，即十六进制和二进制格式化。\n\n```python\nclass HexFormatter:\n\n    def update(self, publisher):\n        print(\"{}: '{}' has now hex data= {}\".format(type(self).__name__,\n                                                     publisher.name, hex(publisher.data)))\n\nclass BinaryFormatter:\n\n    def update(self, publisher):\n        print(\"{}: '{}' has now bin data= {}\".format(type(self).__name__,\n                                                     publisher.name, bin(publisher.data)))\n```\n\n接下来我们添加一下测试数据，运行代码观察一下结果：\n\n```python\ndef main():\n    df = DefaultFormatter('test1')\n    print(df)\n\n    print()\n    hf = HexFormatter()\n    df.add(hf)\n    df.data = 3\n    print(df)\n\n    print()\n    bf = BinaryFormatter()\n    df.add(bf)\n    df.data = 21\n    print(df)\n\n    print()\n    df.remove(hf)\n    df.data = 40\n    print(df)\n\n    print()\n    df.remove(hf)\n    df.add(bf)\n\n    df.data = 'hello'\n    print(df)\n\n    print()\n    df.data = 4.2\n    print(df)\n\n\nif __name__ == '__main__':\n    main()\n\n```\n\n完整代码参考：[https://gist.github.com/gusibi/93a000c79f3d943dd58dcd39c4b547f1](https://gist.github.com/gusibi/93a000c79f3d943dd58dcd39c4b547f1)\n\n运行代码：\n\n```shell\npython observer.py    \n## output\nDefaultFormatter: 'test1' has data = 0\n\nHexFormatter: 'test1' has now hex data= 0x0\nFailed to add: <__main__.HexFormatter object at 0x10277da20>\nHexFormatter: 'test1' has now hex data= 0x3\nDefaultFormatter: 'test1' has data = 3\n\nBinaryFormatter: 'test1' has now bin data= 0b11\nFailed to add: <__main__.BinaryFormatter object at 0x10277da90>\nBinaryFormatter: 'test1' has now bin data= 0b10101\nHexFormatter: 'test1' has now hex data= 0x15\nDefaultFormatter: 'test1' has data = 21\n\nBinaryFormatter: 'test1' has now bin data= 0b101000\nDefaultFormatter: 'test1' has data = 40\n\nBinaryFormatter: 'test1' has now bin data= 0b101000\nFailed to add: <__main__.BinaryFormatter object at 0x10277da90>\nError: invalid literal for int() with base 10: 'hello'\nDefaultFormatter: 'test1' has data = 40\n\nBinaryFormatter: 'test1' has now bin data= 0b100\nDefaultFormatter: 'test1' has data = 4\n\n```\n\n在输出中我们看到，添加额外的观察者，就会出现更多的输出；一个观察者被删除后就不再被通知到。\n\n## 总结\n\n这一篇我们介绍了观察者模式的原理以及 Python 代码的实现。在实际的项目开发中，观察者模式广泛的运用于 GUI 编程，而且在仿真及服务器等其他时间处理架构中也能用到，比如：`数据库触发器`、`Django 的信号系统`、`Qt GUI 应用程序框架的信号（signal）与槽（slot）机智`以及`WebSocket`的许多用例。\n\n## 参考链接\n\n* [The 10 Minute Guide to the Observer Pattern in Python：http://www.giantflyingsaucer.com/blog/?p=5117](http://www.giantflyingsaucer.com/blog/?p=5117)\n* [Observer：http://python-3-patterns-idioms-test.readthedocs.io/en/latest/Observer.html](http://python-3-patterns-idioms-test.readthedocs.io/en/latest/Observer.html)\n\n\n------\n\n\n最后，感谢女朋友支持。\n\n欢迎关注(April_Louisa) | 请我喝芬达\n------- | -------\n![欢迎关注](http://media.gusibi.mobi/Hy8XHexmzppNKuekLuGxWy8LjdGrQAzZA3mH_e9xltoiYgTFWdvlpZwGWxZESrbK)| ![请我喝芬达](http://media.gusibi.mobi/CO9DwU6ZHnXHD5xuG3GqTsY_IYPl-JdpQrDaOo6tl6PiAGEBDeYFHO7sGQi_VVFc)\n",
      "data": {
        "date": "2017-09-24 14:29:39",
        "description": "python 观察者模式",
        "author": "goodspeed",
        "permalink": "/post/python-design-pattern-observer",
        "categories": [
          "development",
          "python",
          "设计模式"
        ],
        "tags": [
          "python",
          "读书笔记",
          "设计模式"
        ],
        "title": "python设计模式-观察者模式",
        "published": false,
        "hideInList": false,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-design-pattern-observer"
    },
    {
      "content": "\n> 这篇 redis 学习笔记主要介绍 redis 的数据结构和数据类型，并讨论数据结构的选择以及应用场景的优化。\n\n### redis 是什么\n\n> Redis是一种面向“键/值”对类型数据的分布式NoSQL数据库系统，特点是高性能，持久存储，适应高并发的应用场景。\n\n### Redis 数据结构\n\n* 动态字符串 (Sds)\n* 双端列表   (LINKEDLIST)\n* 字典      \n* 跳跃表    (SKIPLIST)\n* 整数集合  (INTSET)\n* 压缩列表  (ZIPLIST)\n\nHUGOMORE42\n\n#### [动态字符串](http://origin.redisbook.com/internal-datastruct/sds.html)\n\nSds (Simple Dynamic String,简单动态字符串)是 Redis 底层所使用的字符串表示,它被用 在几乎所有的 Redis 模块中\n\nRedis 是一个键值对数据库(key-value DB),数据库的值可以是字符串、集合、列表等多种类 型的对象,而数据库的键则总是字符串对象\n\n在 Redis 中, 一个字符串对象除了可以保存字符串值之外,还可以保存 long 类型的值当字符串对象保存的是字符串时,它包含的才是 sds 值,否则的话,它就 是一个 long 类型的值\n\n##### 动态字符串主要有两个作用:\n\n1. 实现字符串对象(StringObject)\n2. 在 Redis 程序内部用作 char * 类型的替代品\n\n\n#### [双端列表] (http://origin.redisbook.com/internal-datastruct/adlist.html)\n\n双端链表还是 Redis 列表类型的底层实现之一，当对列表类型的键进行操作——比如执行 RPUSH 、LPOP 或 LLEN 等命令时,程序在底层操作的可能就是双端链表\n\n##### 双端链表主要有两个作用:\n\n* 作为 Redis 列表类型的底层实现之一;\n* 作为通用数据结构,被其他功能模块所使用;\n\n#### [字典](http://origin.redisbook.com/internal-datastruct/dict.html)\n\n字典(dictionary),又名映射(map)或关联数组(associative array), 它是一种抽象数据结 构,由一集键值对(key-value pairs)组成,各个键值对的键各不相同,程序可以将新的键值对 添加到字典中,或者基于键进行查找、更新或删除等操作\n\n##### 字典的应用\n\n1. 实现数据库键空间(key space);\n2. 用作 Hash 类型键的其中一种底层实现;\n\n> Redis 是一个键值对数据库,数据库中的键值对就由字典保存:每个数据库都有一个与之相对应的字典,这个字典被称之为键空间(key space)。\n\nRedis 的 Hash 类型键使用**字典和压缩列表**两种数据结构作为底层实现\n\n#### [跳跃表](http://origin.redisbook.com/internal-datastruct/skiplist.html)\n\n跳跃表(skiplist)是一种随机化的数据,由 William Pugh 在论文《Skip lists: a probabilistic alternative to balanced trees》中提出,这种数据结构以有序的方式在层次化的链表中保存元素,它的效率可以和平衡树媲美——查找、删除、添加等操作都可以在对数期望时间下完成, 并且比起平衡树来说,跳跃表的实现要简单直观得多\n\n和字典、链表或者字符串这几种在 Redis 中大量使用的数据结构不同,跳跃表在 Redis 的唯一作用,就是实现有序集数据类型\n跳跃表将指向有序集的 score 值和 member 域的指针作为元素,并以 score 值为索引,对有序集元素进行排序。\n\n\n#### [整数集合](http://origin.redisbook.com/compress-datastruct/intset.html)\n\n整数集合(intset)用于有序、无重复地保存多个整数值,它会根据元素的值,自动选择该用什么长度的整数类型来保存元素\n\nIntset 是集合键的底层实现之一,如果一个集合:\n1. 只保存着整数元素;\n2. 元素的数量不多;\n那么 Redis 就会使用 intset 来保存集合元素。\n\n#### [压缩列表](http://origin.redisbook.com/compress-datastruct/ziplist.html)\n\nZiplist 是由一系列特殊编码的内存块构成的列表,一个 ziplist 可以包含多个节点(entry),每个节点可以保存一个长度受限的字符数组(不以 \\0 结尾的 char 数组)或者整数\n\n### Redis 数据类型\n\n#### [RedisObject](http://origin.redisbook.com/datatype/object.html#redisobject-redis)\n\nredisObject 是 Redis 类型系统的核心,数据库中的每个键、值,以及 Redis 本身处理的参数,都表示为这种数据类型\n\nredisObject 的定义位于 redis.h :\n\n```c\n/*\n* Redis 对象\n*/\ntypedef struct redisObject {\n    // 类型\n    unsigned type:4;\n    // 对齐位\n    unsigned notused:2;\n    // 编码方式\n    unsigned encoding:4;\n    // LRU 时间(相对于 server.lruclock)\n    unsigned lru:22;\n    // 引用计数\n    int refcount;\n    // 指向对象的值\n    void *ptr;\n} robj;\n```\n\ntype 、encoding 和 ptr 是最重要的三个属性。\n\ntype 记录了对象所保存的值的类型,它的值可能是以下常量的其中一个\n\n```c\n/*\n* 对象类型\n*/\n#define REDIS_STRING 0 // 字符串\n#define REDIS_LIST 1   // 列表\n#define REDIS_SET 2    // 集合\n#define REDIS_ZSET 3   // 有序集\n#define REDIS_HASH 4   // 哈希表\n```\n\nencoding 记录了对象所保存的值的编码,它的值可能是以下常量的其中一个\n\n```c\n/*\n* 对象编码\n*/\n#define REDIS_ENCODING_RAW 0    // 编码为字符串\n#define REDIS_ENCODING_INT 1    // 编码为整数\n#define REDIS_ENCODING_HT 2     // 编码为哈希表\n#define REDIS_ENCODING_ZIPMAP 3 // 编码为 zipmap(2.6 后不再使用)\n#define REDIS_ENCODING_LINKEDLIST 4 // 编码为双端链表\n#define REDIS_ENCODING_ZIPLIST 5    // 编码为压缩列表\n#define REDIS_ENCODING_INTSET 6     // 编码为整数集合\n#define REDIS_ENCODING_SKIPLIST 7    // 编码为跳跃表\n```\n\nptr 是一个指针,指向实际保存值的数据结构,这个数据结构由 type 属性和 encoding 属性决定。\n\n当执行一个处理数据类型的命令时,Redis 执行以下步骤:\n\n1. 根据给定key,在数据库字典中查找和它像对应的redisObject,如果没找到,就返回 NULL 。\n2. 检查redisObject的type属性和执行命令所需的类型是否相符,如果不相符,返回类 型错误。\n3. 根据redisObject的encoding属性所指定的编码,选择合适的操作函数来处理底层的 数据结构。\n4. 返回数据结构的操作结果作为命令的返回值。\n\n\n#### [字符串](http://redisdoc.com/string/index.html)\n\nREDIS_STRING (字符串)是 Redis 使用得最为广泛的数据类型,它除了是 SET 、GET 等命令 的操作对象之外,数据库中的所有键,以及执行命令时提供给 Redis 的参数,都是用这种类型 保存的。\n\n字符串类型分别使用 REDIS_ENCODING_INT 和 REDIS_ENCODING_RAW 两种编码\n\n> 只有能表示为 long 类型的值,才会以整数的形式保存,其他类型 的整数、小数和字符串,都是用 sdshdr 结构来保存\n\n#### [哈希表](http://redisdoc.com/hash/index.html)\n\nREDIS_HASH (哈希表)是HSET 、HLEN 等命令的操作对象\n\n它使用 REDIS_ENCODING_ZIPLIST和REDIS_ENCODING_HT 两种编码方式\n\nRedis 中每个hash可以存储232-1键值对（40多亿）\n\n#### [列表](http://redisdoc.com/list/index.html)\n\nREDIS_LIST(列表)是LPUSH 、LRANGE等命令的操作对象\n\n它使用 REDIS_ENCODING_ZIPLIST和REDIS_ENCODING_LINKEDLIST 这两种方式编码\n\n一个列表最多可以包含232-1 个元素(4294967295, 每个列表超过40亿个元素)。\n\n#### [集合](http://redisdoc.com/set/index.html)\n\nREDIS_SET (集合) 是 SADD 、 SRANDMEMBER 等命令的操作对象\n\n它使用 REDIS_ENCODING_INTSET 和 REDIS_ENCODING_HT 两种方式编码\n\nRedis 中集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。\n\n集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)\n\n#### [有序集](http://redisdoc.com/sorted_set/index.html)\n\nREDIS_ZSET (有序集)是ZADD 、ZCOUNT 等命令的操作对象\n\n它使用 REDIS_ENCODING_ZIPLIST和REDIS_ENCODING_SKIPLIST 两种方式编码\n\n不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。\n\n有序集合的成员是唯一的,但分数(score)却可以重复。\n\n集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)\n\n#### Redis各种数据类型_以及它们的编码方式\n\n![Redis各种数据类型_以及它们的编码方式](http://hangjia.qiniudn.com/Fj2h6yEVRaDHEshO9OC5mVzm9Sht)\n\n### 过期时间\n\n在数据库中,所有键的过期时间都被保存在 redisDb 结构的 expires 字典里:\n\n```c\ntypedef struct redisDb {\n\t// ...\n\tdict *expires;\n\t// ...\n} redisDb;\n```\n\nexpires 字典的键是一个指向 dict 字典(键空间)里某个键的指针,而字典的值则是键所指 向的数据库键的到期时间,这个值以 long long 类型表示\n\n#### 过期时间设置\n\nRedis 有四个命令可以设置键的生存时间(可以存活多久)和过期时间(什么时候到期):\n\n* EXPIRE 以秒为单位设置键的生存时间;\n* PEXPIRE 以毫秒为单位设置键的生存时间;\n* EXPIREAT 以秒为单位,设置键的过期 UNIX 时间戳;\n* PEXPIREAT 以毫秒为单位,设置键的过期 UNIX 时间戳。\n\n> 虽然有那么多种不同单位和不同形式的设置方式,但是 expires 字典的值只保存“以毫秒为单位的过期 UNIX 时间戳” ,这就是说,通过进行转换,所有命令的效果最后都和 PEXPIREAT 命令的效果一样。\n\n**如果一个键是过期的,那它什么时候会被删除?**\n\n下边是参考答案\n\n1. 定时删除:在设置键的过期时间时,创建一个定时事件,当过期时间到达时,由事件处理 器自动执行键的删除操作。\n2. 惰性删除:放任键过期不管,但是在每次从 dict 字典中取出键值时,要检查键是否过 期,如果过期的话,就删除它,并返回空;如果没过期,就返回键值。\n3. 定期删除:每隔一段时间,对expires字典进行检查,删除里面的过期键\n\nRedis 使用的过期键删除策略是惰性删除加上定期删除\n\n### 应用场景\n\n* 缓存\n* 队列\n* 需要精准设定过期时间的应用\n\n> 比如你可以把上面说到的sorted set的score值设置成过期时间的时间戳，那么就可以简单地通过过期时间排序，定时清除过期数据了，不仅是清除Redis中的过期数据，你完全可以把Redis里这个过期时间当成是对数据库中数据的索引，用Redis来找出哪些数据需要过期删除，然后再精准地从数据库中删除相应的记录\n\n* 排行榜应用，取TOP N操作\n> 这个需求与上面需求的不同之处在于，前面操作以时间为权重，这个是以某个条件为权重，比如按顶的次数排序，这时候就需要我们的sorted set出马了，将你要排序的值设置成sorted set的score，将具体的数据设置成相应的value，每次只需要执行一条ZADD命令即可\n\n* 统计页面访问次数\n\n> 使用 incr 命令 定时使用 getset 命令 读取数据 并设置新的值 0\n\n* 使用set 设置标签\n\n例如假设我们的话题D 1000被加了三个标签tag 1,2,5和77，就可以设置下面两个集合：\n\n```shell\n$ redis-cli sadd topics:1000:tags 1\n(integer) 1\n$ redis-cli sadd topics:1000:tags 2\n(integer) 1\n$ redis-cli sadd topics:1000:tags 5\n(integer) 1\n$ redis-cli sadd topics:1000:tags 77\n(integer) 1\n$ redis-cli sadd tag:1:objects 1000\n(integer) 1\n$ redis-cli sadd tag:2:objects 1000\n(integer) 1\n$ redis-cli sadd tag:5:objects 1000\n(integer) 1\n$ redis-cli sadd tag:77:objects 1000\n(integer) 1\n```\n\n要获取一个对象的所有标签：\n\n```bash\n$ redis-cli smembers topics:1000:tags\n1. 5\n2. 1\n3. 77\n4. 2\n```\n\n获得一份同时拥有标签1, 2,10和27的对象列表。\n这可以用SINTER命令来做，他可以在不同集合之间取出交集\n\n\n### 内存优化\n\n`问题`:  Instagram的照片数量已经达到3亿，而在Instagram里，我们需要知道每一张照片的作者是谁，下面就是Instagram团队如何使用Redis来解决这个问题并进行内存优化的。\n\n具体方法，参考下边这篇文章：[节约内存：Instagram的Redis实践](http://blog.nosqlfan.com/html/3379.html)。\n\n\n#### 参考链接\n\n* [Redis 文档：http://redisdoc.com/index.html](http://redisdoc.com/index.html)\n* [Redis 设计与实践：http://origin.redisbook.com/](http://origin.redisbook.com/)\n* [Redis 数据结构使用场景：http://get.jobdeer.com/523.get](http://get.jobdeer.com/523.get)\n* [Redis作者谈Redis应用场景：http://blog.nosqlfan.com/html/2235.html](http://blog.nosqlfan.com/html/2235.html)\n* [一次使用 Redis 优化查询性能的实践：http://www.restran.net/2015/02/17/redis-practice/](http://www.restran.net/2015/02/17/redis-practice/)\n* [节约内存：Instagram的Redis实践：http://blog.nosqlfan.com/html/3379.html](http://blog.nosqlfan.com/html/3379.html)\n\n最后，感谢女朋友支持。\n\n欢迎关注(April_Louisa) | 请我喝芬达\n------- | -------\n![欢迎关注](http://media.gusibi.mobi/Hy8XHexmzppNKuekLuGxWy8LjdGrQAzZA3mH_e9xltoiYgTFWdvlpZwGWxZESrbK)| ![请我喝芬达](http://media.gusibi.mobi/CO9DwU6ZHnXHD5xuG3GqTsY_IYPl-JdpQrDaOo6tl6PiAGEBDeYFHO7sGQi_VVFc)",
      "data": {
        "title": "Redis 学习笔记",
        "date": "2017-09-17 14:41:51",
        "tags": [
          "redis",
          "nosql",
          "database"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "redis-note"
    },
    {
      "content": "\n> 这一篇是`《流畅的 python》`读书笔记。主要介绍元组、分片、序列赋值以及引用了大师 Edsger W.Dijkstra`为什么序列从0开始计数`的解释。\n\n## 元组\n\n在有些python 的介绍中，元组被称为`不可变列表`，这其实是不准确的，没有完全概括元组的特点。元组除了用作不可变列表，还可以用于`没有字段名的记录`。\n\n### 元组和记录\n\n元组其实是对数据的记录：元组中的每个元素都存放了记录中一个字段的数据，外加这个数据的位置。\n\n如果把元组当作一些字段的集合，数量和位置信息会变得非常重要。比如以下几条用元组表示的记录：\n\n```python\n >>> lax_coordinates = (33.9425, -118.408056) # 洛杉矶国际机场的经纬度\n # 东京的一些信息：市名、年份、人口、人口变化和面积\n >>> city, year, pop, chg, area = ('Tokyo', 2003, 32450, 0.66, 8014)\n```\n\n以上这两个元组每个位置都对应一个数据记录。\n\n### 元组拆包\n\n```python\n>>> city, year, pop, chg, area = ('Tokyo', 2003, 32450, 0.66, 8014)\n```\n\n这个例子中，我们把元组的数据用一条语句分别赋值给 city, year, pop, chg, area，这就是元组拆包的一个具体应用。\n\n> 元组拆包可以应用到任何可迭代对象上，但是被迭代的对象窄的元素的数量必须跟接受这些元素的元组的空档数一致。\n\n比如：\n\n```python\n>>> lax_coordinates = (33.9425, -118.408056)\n>>> latitude, longitude = lax_coordinates\n>>> latitude\n33.9425\n>>> longitude\n-118.408056\n```\n\n还可以用 `*` 运算符把一个可迭代对象拆开作为函数的参数：\n\n```python\n>>> divmod(20, 8)\n(2, 4)\n>>> t = (20, 8)\n>>> divmode(*t)\n(2, 4)\n>>> quotient, remainder = divmode(*t)\n>>> quotient, remainder\n(2, 4)\n```\n\n在进行拆包是，我们可能对元组的某些值并不感兴趣，这时可以用 `_` 占位符处理。比如：\n\n```python\n>>> divmode(20, 8)\n(2, 4)\n>>> _, remainder = divmode(20, 8)  # 这里我们只关心第二个值\n>>> remainder\n4\n```\n\n在处理函数参数时，我们经常用`*args` 来表示不确定数量的参数。在`python3`中，这个概念被扩展到了平行赋值中：\n\n```python\n# python 3 代码示例\n>>> a, b, *rest = range(5)\n>> a, b, rest\n(0, 1, [2, 3, 4])\n# * 前缀只能用在一个变量名前，这个变量可以在其他位置\n>>> a, *rest, c, d = range(5) \n>> a, rest, c, d\n(0, [1, 2], 3, 4)\n>>> a, b, *rest = range(2)\n>> a, b, rest\n(0, 1, [])\n```\n元组也支持嵌套拆包，比如：\n\n```python\n>>> l = (1, 2, 3, (4, 5))\n>>> a, b, c, (d, e) = l\n>>> d\n4\n>>> 5\n4\n```\n\n### 具名元组\n\n元组作为记录除了位置以外还少一个功能，那就是无法给字段命名，`namedtuple`解决了这个问题。\n\nnamedtuple 使用方式实例：\n\n```python\n>>> from collecitons import namedtuple\n>>> city = namedtuple('City', 'name country population coordinates')\n>>> tokyo = City('Tokyo', 'JP', 36.933, (35.689722, 139.691667))\n>>> tokyo.population  # 可以使用字段名获取字段信息\n36.933\n>>> tokyo[1] # 也可以使用位置获取字段信息\n'JP'\n>>> City._fields # _fields 属性是一个包含这个类所有字段名的元组 \n('name', 'country', 'population', 'coordinates')\n>>> tokyo_data = ('Tokyo', 'JP', 36.933, (35.689722, 139.691667))\n>>> tokyo = City._make(tokyo_data) # _make() 方法接受一个可迭代对象生成这个类的实例，和 City(*tokyo_data) 作用一致\n>>>  tokyo._asdict() # _asdict() 把具名元组以 collections.OrderedDict 的形式呈现\nOrderedDict([('name', 'Tokyo'), ('country', 'JP'), ('population', 36.933), ('coordinates', (35.689722, 139.691667))])\n```\n> `collections.namedtuple` 是一个工厂函数，它可以用来构建一个带字段名的元组和一个有名字的类。\n> `namedtuple` 构建的类的实例锁消耗的内存和元组是一样的，因为字段名都被存放在对应的类里。这个实例和普通的对象实例相比也更小一些，因为 在这个实例中，Python 不需要用 `__dict__` 来存放这些实例的属性\n\n## 切片\n\nPython 中列表、元组、字符串都支持切片操作。\n\n在切片和区间操作里不包含区间范围的最后一个元素是 Python 的风格。这样做的好处如下：\n* 当只有最后一个位置信息时，我们可以快速看出切片和区间里有几个元素：range(3) 和 mylist[:3] 都只返回三个元素\n* 当气质位置可见时，可以快速计算出切片和区间的长度，用后一个数减去第一个下标（stop-start）即可。\n* 这样还可以让我们利用任意一个下标来把序列分割成不重复的两部分，只要写成 mylist[:x] 和 mylist[x:] 就可以。\n\n切片除了开始和结束的下标之外还可以有第三个参数，比如：`s[a:b:c]`，这里 c 表示取值的间隔，c 还可以为负值，负值意味着反向取值。\n\n```python\n>>> s = 'bicycle'\n>>> s[::3]\n'bye'\n>>> s[::-1]\n'elcycib'\n>>> s[::2]\n'eccb'\n```\n\na:b:c 这种用法只能作为索引或者下标在[] 中返回一个切片对象：slice(a, b, c)。对 seq[start:stop:step] 进行求值的时候，Python 会调用 seq.__getitem__(slice(start:stop:step)]。\n\n### 给切片赋值\n\n如果把切片放在赋值语句的左边，或者把它作为 del 操作的对象，我们就可以对序列进行嫁接、切除或修改操作，比如：\n\n```python\n>>> l = list(range(10))\n>>> l\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> l[2:5] = [20, 30]\n>>> l\n[0, 1, 20, 30, 5, 6, 7, 8, 9]\n>>> del l[5:7]\n[0, 1, 20, 30, 5, 8, 9]\n>>> l[3::2] = [11, 22]\n>>> l\n[0, 1, 20, 11, 5, 22, 9]\n>>> l[2:5] = 100\nTraceback (most recent call last):\n      file \"<stdin>\", line 1 in <moduld>\nTypeError: can only assign an iterable\n```\n\n> 如果赋值的对象是一个切片，那么赋值语句的右侧必须是一个可迭代对象。\n\n### 给切片命名\n\n如果代码中已经出现了大量的无法直视的硬编码切片下标，可以使用给切片命名的方式清理代码。比如你有一段代码要从一个记录字符串中几个固定位置提取出特定的数据字段  比如文件或类似格式 :\n\n```python\n### 01234567890123456789012345678901234567890123456789012345678901234\nrecord = '............100....513.25........'\ncost = int(record[20:23]) * float(record[31:37])\n# 这时，可以先给切片命名,以避免大量无法理解的硬编码下标，使代码可读性更强\nSHARES= slice(20, 23)\nPRICE = slice(31, 37)\ncost = int(record[SHARES]) * float(record[PRICE])\n```\n\nslice() 函数创建了一个`切片对象`，可以被用在任何切片允许使用的地方，比如：\n\n```python\n>>> items = [0, 1, 2, 3, 4, 5, 6]\n>>> a = slice(2, 4)\n>>> items[2:4]\n[2, 3]\n>>> items[a]\n[2, 3]\n>>> items[a] = [10, 11]\n>>> items\n[0, 1, 10, 11, 4, 5, 6]\n```\n如果你有一个切片对象 a，还可以调用 a.start, a.stop, a.step 来获取更多信息，比如：\n\n```python\n>>> a = slice(5, 50, 2)\n>>> a.start\n5\n>>> a.step\n2\n```\n\n## 扩展阅读 为什么下标要从0开始\n\nPython 里的范围（range）和切片都不会反悔第二个下标所指的元素，计算机科学领域的大师 Edsger W.Dijkstra 在一个很短的备忘录 [Why numbering should start at zero](http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html) 里对这一惯例做了说明。以下是部分关键说明：\n\n为了表示出自然数的子序列，2, 3, ... , 12，不使用省略记号那三个点号，我们可以选择4种约定方式：\n\n* a) 2 ≤ i < 13\n* b) 1 < i ≤ 12\n* c) 2 ≤ i ≤ 12\n* d) 1 < i < 13\n\n是否有什么理由，使选择其中一种约定比其它约定要好呢？是的，确实有理由。可以观察到，a) 和 b)有个优点，`上下边界的相减得到的差，正好等于子序列的长度`。另外，作为推论，下面观察也成立：在 a)，b)中，`假如两个子序列相邻的话，其中一个序列的上界，就等于另一个序列的下界`。但上面观察，并不能让我们从a), b)两者中选出更好的一个。让我们重新开始分析。\n\n一定存在最小的自然数。假如像b)和d)那样，子序列并不包括下界，那么当子序列从最小的自然数开始算起的时候，会使得下界进入非自然数的区域。这就比较丑陋了。所以对于下界来说，我们更应该采用≤，正如a)或c)那样。\n现在考虑，假如子序列包括上界，那么当子序列从最小的自然数开始算起，并且序列为空的时候，上界也会进入非自然数的区域。这也是丑陋的。所以，对于上界，我们更应该采用 <, 正如a)或b)那样。因此我们得出结论，约定a)是更好的选择。\n\n> * 比如要表示 `0, 1, 2, 3` 如果用 b) d) 的方式，下界就要表示成 `-1 < i`\n> * 如果一个空序列用 c) 其实是无法表示的,用 a) 则可以表示成 0 ≤ i < 0\n\n\n## 总结\n\n这一篇主要介绍元组、分片、序列赋值以及对`为什么序列从0开始计数`做了摘录。\n\n## 参考链接\n\n* [Why numbering should start at zero](http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html)\n* [Why numbering should start at zero: http://www.cs.utexas.edu/users/EWD/ewd08xx/EWD831.PDF](http://www.cs.utexas.edu/users/EWD/ewd08xx/EWD831.PDF)\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)\n",
      "data": {
        "title": "Python 元组和分片",
        "date": "2017-09-10 06:05:27",
        "tags": [
          "python",
          "tutorial",
          "读书笔记"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-data-structures-tuple-and-slice"
    },
    {
      "content": "\n> 这一篇是`《流畅的 python》`读书笔记。主要介绍列表、列表推导有关的话题，最后演示如何用列表实现一个优先级队列。\n\n## Python 内置序列类型\n\nPython 标准库用 C 实现了丰富的序列类型：\n\n#### 容器序列：\n\nlist、tuple 和 collections.deque 这些序列能存放不同类型的数据。\n\n#### 扁平序列：\n\nstr、bytes、bytearray、memoryview 和 array.array，这类序列只能容纳一种类型。\n\n> 容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是引用（也可以说扁平序列其实存放的是一段连续的内存空间）。\n\n如果按序列是否可被修改来分类，序列分为`可变序列` 和 `不可变序列`:\n\n#### 可变序列\n\nlist、bytearray、array.array、collections.deque 和 memoryview。\n\n#### 不可变序列\n\ntuple、str和 bytes。\n\n下图显示了可变序列（MutableSequence）和不可变序列（sequence）的差异：\n\n![可变序列(MutableSequence)和不可变序列（sequence）的差异](http://media.gusibi.mobi/Wlrr9jXCMsTupf03pVmVSkCb4ObKTI8g7QWycfjJS80UJ7tHptjZsHLLCz3evCZM)\n\n从这个图可以看出，可变序列从不可变序列那里继承了一些方法。\n\n## 列表推导和生成器表达式\n\n列表（list）是 Python 中最基础的序列类型。list 是一个可变序列，并且能同时存放不同类型的元素。\n列表的基础用法这里就不再介绍了，这里主要介绍一下列表推导。\n\n### 列表推导和可读性\n\n列表推导是构建列表的快捷方式，并且有更好的可读性。\n先看下面两段代码：\n\n`#1. 把一个字符串变成 unicode 码位的列表`\n\n```python\n>>> symbols = '$&@#%^&*'\n>>> codes = []\n>>> for symbol in symbols:\n        codes.append(ord(symbol))\n\n>>> codes\n[36, 38, 64, 35, 37, 94, 38, 42]\n```\n\n`#2. 把一个字符串变成 unicode 码位的列表 使用列表推导`\n\n```python\n>>> symbols = '$&@#%^&*'\n>>> codes = [ord(s) for s in symbols]\n>>> codes\n[36, 38, 64, 35, 37, 94, 38, 42]\n```\n\n对比发现，如果理解列表推导的话，第二段代码比第一段更简洁可读性也更好。\n当然，列表推导也不应该被滥用，通常的原则是`只用列表推导来创建新的列表，并且尽量保持简短。`\n如果列表推导超过两行，就应该考虑要不要使用 `for` 循环重写了。\n\n#### NOTE \n\n> 在 Python2 中列表推导有变量泄露的问题\n\n`#Python2 的例子`\n```python\n>>> x = 'my precious'\n>>> dummy = [x for x in 'ABC']\n>>> x\n'C'\n```\n\n这里 x 原来的值被取代了，变成了列表推导中的最后一个值，需要避免这个问题。好消息是 Python3解决了这个问题。\n\n`#Python3 的例子`\n```python\n>>> x = 'ABC'\n>>> dummy = [ord(x) for x in x]\n>>> x \n'ABC'\n>>> dummy\n[65, 66, 67]\n```\n\n可以看到，这里 x 原有的值被保留了，列表推导也创建了正确的列表。\n\n### 笛卡尔积\n\n列表推导还可以生成两个或以上的可迭代类型的笛卡尔积。\n\n> 笛卡尔积是一个列表，列表里的元素是由输入的可迭代类型的元素对构成的元组，因此笛卡尔积列表的长度等于输入变量的长度的成绩，如图所示：\n\n![笛卡尔积](http://media.gusibi.mobi/Ug5fo3x6f2sM4pGOavCxHcmMpLbEnw6sCyZ6_9HMMHSbbrKQXahYQDsZC1bhxpp2)\n\n`# 使用列表推导计算笛卡尔积代码如下`\n```python\n>>> suits = ['spades', 'diamonds', 'clubs', 'hearts']\n>>> nums = ['A', 'K', 'Q']\n>>> cards = [(num, suit) for num in nums for suit in suits]\n>>> cards\n[('A', 'spades'),\n ('A', 'diamonds'),\n ('A', 'clubs'),\n ('A', 'hearts'),\n ('K', 'spades'),\n ('K', 'diamonds'),\n ('K', 'clubs'),\n ('K', 'hearts'),\n ('Q', 'spades'),\n ('Q', 'diamonds'),\n ('Q', 'clubs'),\n ('Q', 'hearts')]\n```\n这里得到的结果是先按数字排列，再按图案排列。如果想先按图案排列再按数字排列，只需要调整 for 从句的先后顺序。\n\n### 过滤序列元素\n\n> `问题`：你有一个数据序列，想利用一些规则从中提取出需要的值或者是缩短序列\n\n最简单的过滤序列元素的方法是使用列表推导。比如：\n\n```python\n>>> mylist = [1, 4, -5, 10, -7, 2, 3, -1]\n>>> [n for n in mylist if n >0]\n[1, 4, 10, 2, 3]\n```\n\n使用列表推导的一个潜在缺陷就是若干输入非常大的时候会产生一个非常大的结果集，占用大量内存。这个时候，使用生成器表达式迭代产生过滤元素是一个好的选择。\n\n### 生成器表达式\n\n生成器表达式遵守了迭代器协议，可以逐个产出元素，而不是先建立一个完整的列表，然后再把这个列表传递到某个构造函数里。\n\n> 生成器表达式的语法跟列表推导差不多，只需要把方括号换成圆括号。\n\n`# 使用生成器表达式创建列表`\n```python\n>>> pos = (n for n in mylist if n > 0)\n>>> pos\n<generator object <genexpr> at 0x1006a0eb0>\n>>> for x in pos:\n... print(x) \n...\n1\n4\n10 \n2 \n3\n```\n\n*如果生成器表达式是一个函数调用过程中唯一的参数，那么不需要额外再用括号把它围起来。例如：*\n\n```python\ntuple(n for n in mylist)\n```\n\n*如果生成器表达式是一个函数调用过程中其中一个参数，此时括号是必须的。比如：*\n\n```python\n>>> import array\n>>> array.array('list', (n for n in mylist))\narray('list', [1, 4, 10, 2, 3])\n```\n\n## 实现一个优先级队列\n\n### 问题\n\n怎么实现一个按优先级排序的队列？并在这个队列上每次 pop 操作总是返回优先级最高的那个元素\n\n### 解决方法\n\n> 利用 `heapq` 模块\n\n`heapq` 是 python 的内置模块，源码位于 Lib/heapq.py ，该模块提供了基于堆的优先排序算法。\n\n> 堆的逻辑结构就是完全二叉树，并且二叉树中父节点的值小于等于该节点的所有子节点的值。这种实现可以使用 heap[k] <= heap[2k+1] 并且 heap[k] <= heap[2k+2] （其中 k 为索引，从 0 开始计数）的形式体现，对于堆来说，最小元素即为根元素 heap[0]。\n\n可以通过 list 对 heap 进行初始化，或者通过 api 中的 heapify 将已知的 list 转化为 heap 对象。\n\nheapq 提供的一些方法如下：\n\n* heap = [] #创建了一个空堆 \n* heapq.heappush(heap, item)：向 heap 中插入一个元素\n* heapq.heappop(heap)：返回 root 节点，即 heap 中最小的元素\n* heapq.heappushpop(heap, item)：向 heap 中加入 item 元素，并返回 heap 中最小元素\n* heapq.heapify(x)\n* heapq.nlargest(n, iterable, key=None)：返回可枚举对象中的 n 个最大值，并返回一个结果集 list，key 为对该结果集的操作\n* heapq.nsmallest(n, iterable, key=None)：同上相反\n\n实现如下：\n```python\nimport heapq\nclass PriorityQueue: \n    def __init__(self):\n        self._queue = []\n        self._index = 0\n        \n    def push(self, item, priority):\n        heapq.heappush(self._queue, (-priority, self._index, item)) \n        self._index += 1\n        \n    def pop(self):\n        return heapq.heappop(self._queue)[-1]\n```\n\n下面是它的使用方法：\n\n```python\n>>> class Item:\n        def __init__(self, name):\n            self.name = name\n        def __repr__(self):\n            return 'Item({!r})'.format(self.name)\n            \n>>> q = PriorityQueue()\n>>> q.push(Item('foo'), 1)\n>>> q.push(Item('bar'), 5)\n>>> q.push(Item('spam'), 4)\n>>> q.push(Item('grok'), 1)\n>>> q.pop()\nItem('bar') \n>>> q.pop() \nItem('spam') \n>>> q.pop() \nItem('foo') \n>>> q.pop() \nItem('grok')\n```\n\n通过执行结果我们可以发现，第一个 pop() 操作返回优先级最高的元素。两个优先级相同的元素（foo 和 grok），pop 操作按照它们被插入到队列的顺序返回。\n\n函数 heapq.heappush() 和 heapq.heappop() 分别在队列 queue 上插入和删除第一个元素，并且队列 queue 保证 第一个元素拥有最小优先级。 heappop() 函数总是返回 *`最小的`* 的元素，这就是保证队列 pop 操作返回正确元素的关键。另外，由于 push 和 pop 操作`时间复杂度为 O(log N)，其中 N 是堆的大小`，因此就算是 N 很大的时候它们 运行速度也依旧很快。\n*`在上面代码中，队列包含了一个 (-priority, index, item) 的元组。优先级为负 数的目的是使得元素按照优先级从高到低排序。这个跟普通的按优先级从低到高排序的堆排序恰巧相反。`*\nindex 变量的作用是保证同等优先级元素的正确排序。通过保存一个不断增加的 index 下标变量，可以确保元素按照它们插入的顺序排序。而且， index 变量也在相 同优先级元素比较的时候起到重要作用。\n\n实现上边排序的关键是 元组是支持比较的：\n\n```python\n>>> a = (1, Item('foo')) \n>>> b = (5, Item('bar')) \n>>> a < b\nTrue\n>>> c = (1, Item('grok'))\n>>> a < c\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module> \nTypeError: unorderable types: Item() < Item()\n```\n\n当第一个值大小相等时，由于`Item` 并不支持比较会抛出 `TypeError`。为了避免上述错误，我们引入了`index`（不可能用两个元素有相同的 index 值）， 变量组成了(priority, index, item) 三元组。现在再比较就不会出现上述问题了：\n\n```python\n>>> a = (1, 0, Item('foo')) \n>>> b = (5, 1, Item('bar')) \n>>> c = (1, 2, Item('grok')) \n>>> a < b\nTrue\n>>> a < c \nTrue\n```\n\n> 主要介绍列表、列表推导有关的话题，最后演示如何用`heapq`和`列表`实现一个优先级队列。下一篇介绍`元组`\n\n## 参考链接\n\n* [Heap queue algorithm](https://docs.python.org/2/library/heapq.html)\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)\n",
      "data": {
        "title": "Python 列表推导及优先级队列的实现",
        "date": "2017-09-03 06:05:27",
        "tags": [
          "python",
          "tutorial",
          "读书笔记"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-data-structures-an-array-of-sequences"
    },
    {
      "content": "\n> 装饰器是可调用的对象，其参数是另一个函数（被装饰的函数）。\n\n## 装饰器基础知识\n\n首先看一下这段代码\n\n```python\ndef deco(fn):\n    print \"I am %s!\" % fn.__name__\n\n@deco\ndef func():\n    pass\n\n# output\nI am func!\n\n# 没有执行func 函数 但是 deco 被执行了\n```\n\nHUGOMORE42\n\n在用某个@decorator来修饰某个函数func时\n\n```python\n@decorator\ndef func():\n    pass\n\n```\n其解释器会解释成下面这样的语句：\n\n`func = decorator(func)`\n\n> 其实就是把一个函数当参数传到另一个函数中，然后再回调，但是值得注意的是装饰器必须返回一个函数给func\n\n装饰器的一大特性是，能把被装饰的函数替换成其他函数。第二大特性是，装饰器在加载模块时立即执行。\n\n### 装饰器何时执行\n\n装饰器的一个关键特性是，它们在被装饰的函数定义后立即运行。这通常在导入是（python 加载模块时）。\n\n看下下面的示例：\n\n```python\nregistry = []  # registry 保存被@register 装饰的函数的引用\n\ndef register(func):  # register 的参数是一个函数\n    print('running register(%s)' % func)  # 打印被装饰的函数\n    registry.append(func)  # 把 func 存入 `registery`\n    return func  # 返回 func：必须返回函数，这里返回的函数与通过参数传入的一样\n\n@register  # `f1` 和 `f2`被 `@register` 装饰\ndef f1():\n    print('running f1()')\n\n@register\ndef f2():\n    print('running f2()')\n\ndef f3():  # <7>\n    print('running f3()')\n\ndef main():  # main 打印 `registry`，然后调用 f1()、f2()和 f3()\n    print('running main()')\n    print('registry ->', registry)\n    f1()\n    f2()\n    f3()\n\nif __name__=='__main__':\n    main()  # <9>\n```\n\n运行代码结果如下：\n\n```python\nrunning register(<function f1 at 0x1023fb378>)\nrunning register(<function f2 at 0x1023fb400>)\nrunning main()\nregistry -> [<function f1 at 0x1023fb378>, <function f2 at 0x1023fb400>]\nrunning f1()\nrunning f2()\nrunning f3()\n```\n\n从结果可以发现`register` 在模块中其他函数之前运行了两次。调用 register 时，传给它的参数是被装饰的函数（例如<function f1 at 0x1023fb378>）。\n\n看完上边的示例我们知道，函数被装饰器装饰后会变成装饰器函数的一个参数，那这时就不得不说变量的作用域了。\n\n## 变量作用域\n\n\n先看下下边这段代码：\n\n```python\ndef f1(a):\n    print(locals())\n    print(a)\n    print(b)\n    \n    \nf1(3)\n# output\n{'a': 3}\n3\nTraceback(most recent call last):\n    File \"<stdin>\", line 1, in <module>\n    File \"<stdin>\", line 3, in f1\nNameError: global name 'b' is not defined\n```\n\n这里的错误是因为全局变量 `b` 没有定义，如果我们先在函数外部给 b 赋值，再调用这个方法就不会报错了。\n\n> 函数运行时会创建一个新的作用域（命名空间）。函数的命名空间随着函数调用开始而开始，结束而销毁。\n> 这个例子中 f1 的命名空间中只有 {'a': 3}，所以 `b` 会被认为是全局变量。\n\n再看一个例子：\n\n```python\nb = 6\ndef f2(a):\n    print(a)\n    print(globals())\n    print(locals())\n    print(b)\n    b = 9\n    \nf2(3)\n# output\n3\n{\n    '__name__': '__main__',\n    '__doc__': None, \n    '__package__': None, \n    '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x10c7f2dd8>, \n    '__spec__': None, \n    '__annotations__': {}, \n    '__builtins__': <module 'builtins' (built-in)>, \n    '__file__': '~/var_local.py', \n    '__cached__': None, \n    'b': 6, \n    'f2': <function f2 at 0x10c7e7598>\n}\n{'a': 3}\n3\nTraceback(most recent call last):\n    File \"<stdin>\", line 1, in <module>\n    File \"<stdin>\", line 3, in f1\nUnboundLocalError: local variable 'b' referenced before assignment\n```\n\n这个例子和上一个例子不同是，我现在函数外部定义了全局变量`b`，但是执行`f2` 这个方法并没有打印6，这是为什么呢？\n这是因为执行函数时 Python 会尝试从局部变量中获取 `b`，函数对于已经引用但未赋值的变量并不会自动声明为局部变量，所以解释器发现后边的赋值之前有引用就会抛出 `UnboundLocalError` 错误。\n\n> Python 不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量。\n\n如果要让解释器把`b`当做全局变量，要使用`global`声明：\n\n```python\nb = 6\ndef f3(a):\n    global b\n    print(a)\n    print(b)\n    b = 9\n    \nf2(3)\n# output\n3\n6\n```\n\n## 闭包\n\n> `闭包`是一种函数，它会保留定义函数时存在的自由变量的绑定，这样调用函数时，虽然定义作用域不可用，但仍能使用那些绑定。\n\n介绍闭包前先要说明一下 Python 的函数参数\n\n### 函数的两种参数\n\n函数有两种参数\n\n1. 位置参数\n2. 命名参数\n\n```python\ndef foo(x, y=0):\n\treturn x - y\n```\n\n### python 中一切都是对象\n\n函数和python中其他一样都是对象\n\n```python\nIn [7]: class A(object):\n   ...:     pass\n\n\nIn [8]: A\nOut[8]: __main__.A\nIn [9]: type(A)\nOut[9]: type\nIn [10]: def foo():\n   ....:     pass\n\n\nIn [11]: type(foo)\nOut[11]: function\n\nIn [12]: A.__class__\nOut[12]: type\n\nIn [13]: foo.__class__\nOut[13]: function\n\nIn [14]: a = 1\nIn [15]: a.__class__\nOut[15]: int\n\n# 类 是对象\nIn [16]: issubclass(A.__class__, object)\nOut[16]: True\n\n# 变量 是对象\nIn [17]: issubclass(a.__class__, object)\nOut[17]: True\n\n# 函数 是对象\nIn [18]: issubclass(foo.__class__, object)\nOut[18]: True\n```\n\n所以函数也可以作为参数传递给其它函数，也可以被当做返回值返回\n\n```python\ndef add(x, y):\n\treturn x + y\n\ndef apply(func):\n\treturn func\n\n>> a = apply(add)\n>> type(a)\n<type 'function'>\n\n>> a(1, 2)\n>> 3\n```\n\n### 闭包的使用\n\n先来看一个示例：假设有个名为 avg 的函数，它的作用是计算不断增加的系列值的均值；\n它是这么使用的：\n\n```python\n>>> avg(10)\n10\n>>> avg(11)\n10.5\n>>> avg(12)\n11\n```\n\n那么我们考虑下，avg 从何而来，它又在哪里保存历史值呢，这个用闭包如何实现呢？\n下边的代码是闭包的实现：\n\n```python\ndef make_averager():\n    series = []\n\n    def averager(new_value):\n        series.append(new_value)\n        total = sum(series)\n        return total/len(series)\n\n    return averager\n```\n\n调用  `make_averager` 时，返回一个 averager 函数对象。每次调用 averager 时，它都会把参数添加到系列值中，然后计算当前平均值。\n\n```python\navg = make_averager()\n\n>>> avg(10)\n10\n>>> avg(11)\n10.5\n>>> avg(12)\n11\n```\n\n> `series` 是`make_averager` 函数的局部变量，因为那个函数的定义体中初始化了`series: series=[]`。但在`averager` 函数中，`series` 是自由变量（指未在本地作用域中绑定的变量）。\n\n![变量示意图](http://media.gusibi.mobi/wNM0i84JsmsgldhxUjV1TP1M43awUXzWTWU8YY7goHgKOjrZCW8l5qxeo6bYSY46)\n> `averager` 的闭包延伸到那个函数的作用域之外，包含自由变量`series`的绑定。\n\n* avg 就是一个闭包\n* 也可以说 make_averager 指向一个闭包\n* 或者说 make_averager 是闭包的工厂函数\n\n> 闭包可以认为是一个内层函数(averager)，由一个变量指代，而这个变量相对于外层包含它的函数而言，是本地变量\n> 嵌套定义在非全局作用域里面的函数能够记住它在被定义的时候它所处的封闭命名空间\n\n> `闭包` 只是在形式和表现上像函数，但实际上不是函数。函数是一些可执行的代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。\n\n## 装饰器\n\n### 实现一个简单的装饰器\n\n对一个已有的模块做一些“修饰工作”，所谓修饰工作就是想给现有的模块加上一些小装饰（一些小功能，这些小功能可能好多模块都会用到），但又不让这个小装饰（小功能）侵入到原有的模块中的代码里去\n\n```python\ndef my_decorator(func):\n    def wrapper():\n        print \"Before the function runs\"\n        func() # 这行代码可用，是因为 wrapper 的闭包中包含自由变量 func\n        print \"After the function runs\"\n    return wrapper\n\ndef my_func():\n    print \"I am a stand alone function\"\n\n\n>> my_func()\n\n# output\nI am a stand alone function\n\n# 然后，我们在这里装饰这个函数\n# 将函数传递给装饰器，装饰器将动态地将其包装在任何想执行的代码中，然后返回一个新的函数\n\n>> my_func = my_decorator(my_func)\n>> my_func()\n#output\nBefore the function runs\nI am a stand alone function\nAfter the function runs\n\n# 也可以这么写\n\n@ my_decorator\ndef my_func():\n    print \"I am a stand alone function\"\n\n>> my_func()\n#output\nBefore the function runs\nI am a stand alone function\nAfter the function runs\n```\n\n装饰器是设计模式中[装饰器模式](https://zh.wikipedia.org/wiki/%E4%BF%AE%E9%A5%B0%E6%A8%A1%E5%BC%8F)（[英文版](https://en.wikipedia.org/wiki/Decorator_pattern)）的python实现。\n\n### 多个装饰器\n\n**装饰器可以嵌套使用**\n\n```python\ndef bread(func):\n    def wrapper():\n        print \"</''''''\\>\"\n        func()\n        print \"<\\______/>\"\n    return wrapper\n\ndef ingredients(func):\n    def wrapper():\n        print \"#tomatoes#\"\n        func()\n        print \"~salad~\"\n    return wrapper\n\ndef sandwich(food=\"--ham--\"):\n    print food\n\n#### outputs:\n```\n\n### 嵌套两个装饰器\n\n```python\n>> sandwich = bread(ingredients(sandwich))\n>> sandwich()\n\n#### outputs\n</''''''\\>\n #tomatoes#\n --ham--\n ~salad~\n<\\______/>\n```\n\n更简单的写法\n\n```python\n@bread\n@ingredients\ndef sandwich(food=\"--ham--\"):\n    print food\n\n```\n\n**装饰器的顺序是很重要的**\n\n如果我们换下顺序就会发现，三明治变成了披萨。。\n\n```python\n@ingredients\n@bread\ndef sandwich(food=\"--ham--\"):\n    print food\n\n# outputs:\n    \n #tomatoes#\n </' ' ' ' ' '\\>\n   --ham--\n <\\______/>\n ~salad~\n```\n\n\n### Decorator 的工作原理\n\n首先看一下这段代码\n\n```python\ndef deco(fn):\n    print \"I am %s!\" % fn.__name__\n\n@deco\ndef func():\n    pass\n\n# output\nI am func!\n\n# 没有执行func 函数 但是 deco 被执行了\n```\n\n在用某个@decorator来修饰某个函数func时\n\n```python\n@decorator\ndef func():\n    pass\n\n```\n其解释器会解释成下面这样的语句：\n\n`func = decorator(func)`\n\n> 其实就是把一个函数当参数传到另一个函数中，然后再回调\n> 但是值得注意的是装饰器必须返回一个函数给func\n\n回到刚才的例子\n\n```python\n\ndef my_decorator(func):\n    def wrapper():\n        print \"Before the function runs\"\n        func()\n        print \"After the function runs\"\n    return wrapper\n\ndef my_func():\n    print \"I am a stand alone function\"\n\n>> my_func = my_decorator(my_func)\n>> my_func()\n#output\nBefore the function runs\nI am a stand alone function\nAfter the function runs\n\n```\n\nmy_decorator(my_func)返回了wrapper()函数，所以，my_func其实变成了wrapper的一个变量，而后面的my_func()执行其实变成了wrapper()\n\n\n比如：多个decorator\n```python\n@decorator_one\n@decorator_two\ndef func():\n    pass\n```\n相当于：\n\n```python\nfunc = decorator_one(decorator_two(func))\n```\n比如：带参数的decorator：\n\n```python\n@decorator(arg1, arg2)\ndef func():\n    pass\n# 相当于：\n\nfunc = decorator(arg1,arg2)(func)\n```\n\n\n### 带参数的装饰器\n\n首先看一下， 如果被装饰的方法有参数\n\n```python\ndef a_decorator(method_to_decorate):\n    def wrapper(self, x):\n        x -= 3\n        print 'x is %s' % x\n        method_to_decorate(self, x)\n    return wrapper\n\n\nclass A(object):\n\n    def __init__(self):\n        self.b = 42\n\n    @a_decorator\n    def number(self, x):\n        print \"b is %s\" % (self.b + x)\n\n\na = A()\na.number(-3)\n\n# output\nx is -6\nb is 36\n```\n\n通常我们都使用更加通用的装饰器，可以作用在任何函数或对象方法上，而不必关心其参数使用\n\n```python\ndef a_decorator(method_to_decorate):\n    def wrapper(*args, **kwargs):\n        print '****** args ******'\n        print args\n        print kwargs\n        method_to_decorate(*args, **kwargs)\n    return wrapper\n\n@a_decorator\ndef func():\n    pass\n\nfunc()\n#output\n****** args ******\n()\n{}\n\n@a_decorator\ndef func_with_args(a, b=0):\n    pass\n    return a + b\n\nfunc_with_args(1, b=2)\n\n#output\n****** args ******\n(1,)\n{'b': 2}\n\n```\n\n上边的示例是带参数的被装饰函数\n\n现在我们看一下向装饰器本身传递参数\n\n\n### 向装饰器本身传递参数\n\n**装饰器必须使用函数作为参数**，你不能直接传递参数给装饰器本身\n如果想传递参数给装饰器，可以 **声明一个用于创建装饰器的函数**\n\n```python\n# 我是一个创建装饰器的函数\ndef decorator_maker():\n    print \"I make decorators!\"\n\n    def my_decorator(func):\n        print \"I am a decorator!\"\n\n        def wrapped():\n            print \"I am the wrapper around the decorated function. \"\n            return func()\n\n        print \"As the decorator, I return the wrapped function.\"\n        return wrapped\n\n    print \"As a decorator maker, I return a decorator\"\n    return my_decorator\n\n# decorator_maker()返回的是一个装饰器\nnew_deco = decorator_maker()\n\n#outputs\nI make decorators!\nAs a decorator maker, I return a decorator\n\n# 使用装饰器\ndef decorated_function():\n    print \"I am the decorated function\"\n\ndecorated_function = new_deco(decorated_function)   \ndecorated_function()\n\n# outputs\nI make decorators!\nAs a decorator maker, I return a decorator\nI am a decorator!\nAs the decorator, I return the wrapped function.\nI am the wrapper around the decorated function.\nI am the decorated  function\n\n```\n**使用@修饰**\n\n```python\ndecorated_function = new_deco(decorated_function)\n\n# 等价于下面的方法\n\n@new_deco\ndef func():\n    print \"I am the decorated function\"\n\n\n@decorator_maker()\ndef func():\n    print \"I am the decorated function\"\n\n```\n\n> my_decorator（装饰器函数）是decorator_maker（装饰器生成函数）的内部函数\n所以可以使用把参数加在decorator_maker（装饰器生成函数）的方法像装饰器传递参数\n\n```python\n# 我是一个创建带参数装饰器的函数\ndef decorator_maker_with_arguments(darg1, darg2):\n    print \"I make decorators! And I accept arguments:\", darg1, darg2\n\n    def my_decorator(func):\n        print \"I am a decorator! Somehow you passed me arguments:\", darg1, darg2\n\n        def wrapped(farg1, farg2):\n            print \"I am the wrapper around the decorated function.\"\n            print \"I can access all the variables\", darg1, darg2, farg1, farg2\n            return func(farg1, farg2)\n\n        print \"As the decorator, I return the wrapped function.\"\n        return wrapped\n\n    print \"As a decorator maker, I return a decorator\"\n    return my_decorator\n\n@decorator_maker_with_arguments(\"deco_arg1\", \"deco_arg2\")\ndef decorated_function_with_arguments(function_arg1, function_arg2):\n    print (\"I am the decorated function and only knows about my arguments: {0}\"\n           \" {1}\".format(function_arg1, function_arg2))\n\n\ndecorated_function_with_arguments('farg1', 'farg2')\n\n# outputs\n\nI make decorators! And I accept arguments: deco_arg1 deco_arg2\nAs a decorator maker, I return a decorator\nI am a decorator! Somehow you passed me arguments: deco_arg1 deco_arg2\nAs the decorator, I return the wrapped function.\nI am the wrapper around the decorated function.\nI can access all the variables deco_arg1 deco_arg2 farg1 farg2\nI am the decorated function and only knows about my arguments: farg1 farg2    \n\n```\n\n这里装饰器生成函数内部传递参数是闭包的特性\n\n### 使用装饰器需要注意\n\n* 装饰器是Python2.4的新特性\n* 装饰器会降低代码的性能\n* 装饰器仅在Python代码导入时被调用一次,之后你不能动态地改变参数.当你使用\"import x\",函数已经被装饰\n\n#### 使用 `functools.wraps`\n\n最后Python2.5解决了最后一个问题，它提供`functools`模块，包含`functools.wraps`，这个函数会将被装饰函数的名称、模块、文档字符串拷贝给封装函数\n\n\n```python\ndef foo():\n    print \"foo\"\n\nprint foo.__name__\n#outputs: foo\n\n# 但当你使用装饰器\ndef bar(func):\n    def wrapper():\n        print \"bar\"\n        return func()\n    return wrapper\n\n@bar\ndef foo():\n    print \"foo\"\n\nprint foo.__name__\n#outputs: wrapper\n\n```\n**\"functools\" 可以修正这个错误**\n\n```python\n\nimport functools\n\ndef bar(func):\n    # 我们所说的 \"wrapper\", 封装 \"func\"\n    @functools.wraps(func)\n    def wrapper():\n        print \"bar\"\n        return func()\n    return wrapper\n\n@bar\ndef foo():\n    print \"foo\"\n\n# 得到的是原始的名称, 而不是封装器的名称\nprint foo.__name__\n#outputs: foo\n```\n\n### 类装饰器\n\n```python\nclass myDecorator(object):\n\n    def __init__(self, func):\n        print \"inside myDecorator.__init__()\"\n        self.func = func\n\n    def __call__(self):\n        self.func()\n        print \"inside myDecorator.__call__()\"\n\n@myDecorator\ndef aFunction():\n    print \"inside aFunction()\"\n\nprint \"Finished decorating aFunction()\"\n\naFunction()\n\n# output：\n# inside myDecorator.__init__()\n# Finished decorating aFunction()\n# inside aFunction()\n# inside myDecorator.__call__()\n```\n\n我们可以看到这个类中有两个成员：\n\n1. 一个是__init__()，这个方法是在我们给某个函数decorator时被调用，所以，需要有一个func的参数，也就是被decorator的函数。\n2. 一个是__call__()，这个方法是在我们调用被decorator函数时被调用的\n\n**如果decorator有参数的话，__init__() 就不能传入func了，而fn是在__call__的时候传入**\n\n```python\nclass myDecorator(object):\n\n    def __init__(self, arg1, arg2):\n        self.arg1 = arg2\n\n    def __call__(self, func):\n        def wrapped(*args, **kwargs):\n            return self.func(*args, **kwargs)\n        return wrapped\n```\n\n## 装饰器示例\n\nPython 内置了三个用于装饰方法的函数：property、classmethod和 staticmethod。\n另一个常见的装饰器是 functools.wraps，它的作用是协助构建行为良好的装饰器。\n\n#### functools.lru_cache \n\n`functools.lru_cache` 实现了内存缓存功能，它可以把耗时长的函数结果保存起来，避免传入相同参数时重复计算。\n\n我们自己的实现代码如下：\n\n```python\n\nfrom functools import wraps\ndef memo(fn):\n    cache = {}\n    miss = object()\n\n    @wraps(fn)\n    def wrapper(*args):\n        result = cache.get(args, miss)\n        if result is miss:\n            result = fn(*args)\n            print \"{0} has been used: {1}x\".format(fn.__name__, wrapper.count)\n            cache[args] = result\n        return result\n\n    return wrapper\n\n@memo\ndef fib(n):\n    if n < 2:\n        return n\n    return fib(n - 1) + fib(n - 2)\n```\n\n#### 统计函数执行次数的装饰器\n\n```python\ndef counter(func):\n    \"\"\"\n    记录并打印一个函数的执行次数\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        wrapper.count = wrapper.count + 1\n        res = func(*args, **kwargs)\n        print \"{0} has been used: {1}x\".format(func.__name__, wrapper.count)\n        return res\n    wrapper.count = 0\n    return wrapper\n```\n\n* 装饰器做缓存\n\n\n#### 带有过期时间的内存缓存\n\n```python\ndef cache_for(duration):\n    def deco(func):\n        @wraps(func)\n        def fn(*args, **kwargs):\n            key = pickle.dumps((args, kwargs))\n            value, expire = func.func_dict.get(key, (None, None))\n            now = int(time.time())\n            if value is not None and expire > now:\n                return value\n            value = func(*args, **kwargs)\n            func.func_dict[key] = (value, int(time.time()) + duration)\n            return value\n        return fn\n    return deco\n```\n\n#### 统计代码运行时间\n\n```python\ndef timeit(fn):\n\n    @wraps(fn)\n    def real_fn(*args, **kwargs):\n        if config.common['ENVIRON'] == 'PRODUCTION':\n            return fn(*args, **kwargs)\n\n        _start = time.time()\n        #app.logger.debug('Start timeit for %s' % fn.__name__)\n        result = fn(*args, **kwargs)\n        _end = time.time()\n        _last = _end - _start\n        app.logger.debug('End timeit for %s in %s seconds.' %\n                         (fn.__name__, _last))\n        return result\n\n    return real_fn\n```\n\n\n### 参考链接\n\n1. [How can I make a chain of function decorators in Python?](http://stackoverflow.com/questions/739654/how-can-i-make-a-chain-of-function-decorators-in-python/1594484#1594484)\n2. [理解PYTHON中的装饰器](http://www.wklken.me/posts/2013/07/19/python-translate-decorator.html#_1)\n3. [Python修饰器的函数式编程](http://coolshell.cn/articles/11265.html)\n4. [Understanding Python Decorators in 12 Easy Steps!](http://simeonfranklin.com/blog/2012/jul/1/python-decorators-in-12-steps/)\n5. [PEP 0318 -- Decorators for Functions and Methods](https://www.python.org/dev/peps/pep-0318/)\n6. [PEP 3129 -- Class Decorators](https://www.python.org/dev/peps/pep-3129/)\n7. [*args and **kwargs? [duplicate]](http://stackoverflow.com/questions/3394835/args-and-kwargs)\n8. [why-cant-i-set-a-global-variable-in-python](http://stackoverflow.com/questions/1281184/why-cant-i-set-a-global-variable-in-python)\n9. [【flask route】](https://github.com/mitsuhiko/flask/blob/master/flask/app.py#L1040)\n10. [PythonDecoratorLibrary](https://wiki.python.org/moin/PythonDecoratorLibrary)\n11. [关于Python Decroator的各种提案](https://wiki.python.org/moin/PythonDecoratorProposals)\n\n------\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)\n\n\n",
      "data": {
        "title": "Python 装饰器使用指南",
        "date": "2017-08-15 14:41:51",
        "tags": [
          "python",
          "tutorial",
          "读书笔记"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-decorator"
    },
    {
      "content": "\n> `Sanic` 是一个和类Flask 的基于Python3.5+的web框架，它使用了 Python3 异步特性，有远超 flask 的性能。\n\n编写 RESTful API 的时候，我们会定义特定的异常错误类型，比如我定义的错误返回值格式为：\n\n```json\n{\n  \"error_code\": 0,\n  \"message\": \"string\",\n  \"text\": \"string\"\n}\n```\n\n不同的错误信息指定不同的 http 状态码。\n\nsanic 提供了几种常用的 exception：\n\n* NotFound(404)\n* Forbidden(403)\n* ServerError(500)\n* InvalidUsage(400)\n* Unauthorized(401)\n* RequestTimeout(408)\n* PayloadTooLarge(413)\n\n这些 exception 继承自 SanicException 类：\n\n```python\nclass SanicException(Exception):\n\n    def __init__(self, message, status_code=None):\n        super().__init__(message)\n\n        if status_code is not None:\n            self.status_code = status_code\n```\n\n从上述代码可以看出，这些异常只能指定 message 和 status_code 参数，那我们可不可以自定义 exception 然后在自定义的 exception 中增加参数呢？下面的代码是按照这个思路修改后的代码：\n\n```python\nclass ApiException(SanicException):\n\n    def __init__(self, code, message=None, text=None, status_code=None):\n        super().__init__(message)\n        self.error_code = code\n        self.message = message\n        self.text = text\n\n        if status_code is not None:\n            self.status_code = status_code\n```\n使用后我得到一个结果如下：\n\n![错误结果示例](http://media.gusibi.mobi/2VpVk8OPGxBl7oZ4qzyU7pBroeXXUslZ5vWiHRPnq0cZ1fFUsGDd23o5Gk7knIUa)\n\n从结果可以发现，除了 http 状态码使我想要的其它全错，连 `content-type` 都是 `text/plain; charset=utf-8`，为什么会这样呢，我们定义的参数code 和 text 去了哪里？\n\n翻开 sanic handler 的代码[https://github.com/channelcat/sanic/blob/master/sanic/handlers.py](https://github.com/channelcat/sanic/blob/master/sanic/handlers.py)我找到了答案：\n\n```python\ndef default(self, request, exception):\n        self.log(format_exc())\n        if issubclass(type(exception), SanicException):\n            # 如果是 SanicException 类，返回格式是定义好的，\n            # response 处理方法用的是 text\n            return text(\n                'Error: {}'.format(exception),\n                status=getattr(exception, 'status_code', 500),\n                headers=getattr(exception, 'headers', dict())\n            )\n        elif self.debug:\n            html_output = self._render_traceback_html(exception, request)\n\n            response_message = (\n                'Exception occurred while handling uri: \"{}\"\\n{}'.format(\n                    request.url, format_exc()))\n            log.error(response_message)\n            return html(html_output, status=500)\n        else:\n            return html(INTERNAL_SERVER_ERROR_HTML, status=500)\n```\n\n> 从源码可以看出，如果response 结果是 SanicException 类，response 处理方法会改用text，响应内容格式为 `Error: status_code`。\n\n看来直接使用自定义异常类的方法不能满足我们上边定义的 json 格式（需要有 error_code、message 和 text）数据的要求。那我们能不能自定义 异常处理方法呢？`答案当然是可以。`\n\n下面介绍两种自定义异常处理的方法：\n\n## 使用 response.json \n\n这种方法比较简单，既然 sanic 异常处理是把错误信息使用 response.text() 方法返回，那我们改成 response.json() 不就可以了么。sanic response 提供了 json 的响应对象。可以使用 response.json 定义一个错误处理方法：\n\n```python\ndef json_error(error_code, message, text, status_code):\n    return json(\n        {\n            'error_code': error_code,\n            'message': message,\n            'text': text\n        },\n        status=status_code)\n```\n\n这样我们只需要在需要抛出异常的地方 `return json_error(code, msg, text, status_code)`。\n \n使用这种方法有一点需要注意：\n\n```python\n\ndef get_account():\n    ...\n    if account:\n        return account\n    else:\n        # 如果用户没找到 返回错误信息\n        return json_error(code, msg, text, status_code)\n    \n@app.route(\"/\")\nasync def test(request):\n    account = get_account()\n    return text('Hello world!')\n```\n这段代码中，如果我们没有找到用户信息，json_error 的返回结果会赋值给 account，并不会抛出异常，如果需要抛出异常，我们需要在 test 方法中检查 account 的结果，如果包含 account 是 response.json 对象， 直接 return， 更正后的代码如下：\n\n```python\n@app.route(\"/\")\nasync def test(request):\n    account = get_account()\n    if isinstance(account, response.json):\n        return account\n    return text('Hello world!')\n```\n\n这样虽然简单，但是会增加很多不必要的判断，那有没有方法可以直接抛出异常呢？这时就可以使用 sanic 提供的 `@app.exception` 装饰器了。\n\n## 使用 Handling exceptions\n\nsanic 提供了一个 `@app.exception`装饰器，使用它可以覆盖默认的异常处理方法。它的使用方法也很简单：\n\n```python\nfrom sanic.response import text\nfrom sanic.exceptions import NotFound\n\n@app.exception(NotFound)\ndef ignore_404s(request, exception):\n    return text(\"Yep, I totally found the page: {}\".format(request.url))\n```\n\n这个装饰器允许我们传入一个需要捕获的异常的列表，然后，就可以在自定义方法中返回任意的响应数据了。\n\n以下自定义的异常处理类：\n\n```python\nerror_codes = {\n    'invalid_token': ('Invalid token', '无效的token'),\n}\n\ndef add_status_code(code):\n    \"\"\"\n    Decorator used for adding exceptions to _sanic_exceptions.\n    \"\"\"\n    def class_decorator(cls):\n        cls.status_code = code\n        return cls\n    return class_decorator\n\n\nclass MetisException(SanicException):\n\n    def __init__(self, code, message=None, text=None, status_code=None):\n        super().__init__(message)\n        self.error_code = code\n        _message, _text = error_codes.get(code, (None, None))\n        self.message = message or _message\n        self.text = text or _text\n\n        if status_code is not None:\n            self.status_code = status_code\n\n@add_status_code(404)\nclass NotFound(MetisException):\n    pass\n\n@add_status_code(400)\nclass BadRequest(MetisException):\n    pass\n\n# 使用 app.exception 捕获异常，返回自定义响应数据\n@app.exception(Unauthorized, NotFound, BadRequest)\ndef json_error(request, exception):\n    return json(\n        {\n            'error_code': exception.error_code,\n            'message': exception.message,\n            'text': exception.text\n        },\n        status=exception.status_code)\n``` \n\n## 参考链接\n\n* [Sanic Exceptions：http://sanic.readthedocs.io/en/latest/sanic/exceptions.html](http://sanic.readthedocs.io/en/latest/sanic/exceptions.html)\n* [Metis：https://github.com/gusibi/Metis](https://github.com/gusibi/Metis)\n\n------\n\n最后，感谢女朋友支持。\n\n欢迎关注(April_Louisa) | 请我喝芬达\n------- | -------\n![欢迎关注](http://media.gusibi.mobi/Hy8XHexmzppNKuekLuGxWy8LjdGrQAzZA3mH_e9xltoiYgTFWdvlpZwGWxZESrbK)| ![请我喝芬达](http://media.gusibi.mobi/CO9DwU6ZHnXHD5xuG3GqTsY_IYPl-JdpQrDaOo6tl6PiAGEBDeYFHO7sGQi_VVFc)\n",
      "data": {
        "title": "自定义 Sanic Exception",
        "date": "2017-08-05 02:23:35",
        "tags": [
          "python",
          "tutorial",
          "sanic"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "sanic-custom-exception"
    },
    {
      "content": "\n## 数据库基础\n\n### 数据库\n\n数据库是保存有组织的数据的容器（通常是一个文件或一组文件）。\n\n一个 excel 文件。\n\n**这里是一个 excel 文件图片**\n\n![这里是一个 excel 文件图片](http://media.gusibi.mobi/WzFaDj_ugK7JLrtKzU-L9oTWY5qSXEHa0FszhV8gQicJWSZtHsXFss34r-TkRUJQ)\n\n**这里是一个数据库图片**\n\n![这里是一个数据库图片](http://media.gusibi.mobi/GtovdBEGv1VzGyeGImgE45jrJuakyx9-Bmkltwm5kNgKpKrgBB00sk_1yPC_IgnC)\n\n> 通常人们用数据库代表他们使用的数据库软件。不过确切的说，数据库软件应称作数据库管理系统。\n\n### 表\n\n表是某种特定数据的结构化清单。\n\nexcel 中的 sheet。\n\n数据库中每个表都有一个自己的名字来标识自己，这个名字是唯一的，即数据库中没有其他表具有相同的名字。（不同的数据库可以有不同的名字）\n\n**这里是一个 sheet结构**\n\n![这里是一个 sheet结构](http://media.gusibi.mobi/NCnjCS_QjOinK0X1e1p5uTvx7iYjTfFGZE_rn8CRk-m_mNZbrsqzq2kaUYqpTSCT)\n\n**这里是一个表结构**\n\n![这里是一个表结构](http://media.gusibi.mobi/AOjmnriLW8FxYAQqBUcZJSw-9NrzJ3rZPrqjfJf0MGBLQjTfhp1urWCRc9PRxIF5)\n\n> 表具有一些特性，这些特性定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。描述表的这组信息就是所谓的模式，模式可以用来描述数据库中特定的表，也可以描述整个数据库。\n\n### 列和数据类型\n\n表由列组成。列存储表中某部分的信息。\n\n> 列是表中的一个字段。所有表都是由一个或多个列组成。\n\n**这是表结构**\n\n![这是表结构，指出哪些是列](http://media.gusibi.mobi/iUwFYgJyLqZoJ88D0AWfHHKS3aOtPrK7q_l98-PUyeMQ2DJrHAkUjOdrYhcagOe2)\n\n每一列存储着某种特定的信息。例如在顾客表中，一列存储顾客编号，另一列存储顾客姓名，而地址、城市、州以及邮编全都存储在各自的列中。\n\n数据库中每个列都有相应的数据类型。数据类型(datatype)定义了列可以存储哪些数据种类。例如，如果列中存储的是数字(或许是订单中的物品数)，则相应的数据类型应该为数值类型。如果列中存储的是日期、文本、注释、金额等，则应该规定好恰当的数据类型。\n\n> 数据类型是每列所允许的类型。每个列都有相应的数据类型，它限制该列中存储的数据。\n> 数据类型限定了可存储在列中的数据种类(例如，防止在数值字段中录入字符值)。数据类型还帮助正确地分类数据。因此，在创建表时必须特别关注所用的数据类型。\n\n### 行\n\n> 行是表中的一个记录。\n\n表中的数据是按行存储的，所保存的每个记录存储在自己的行内。\n\n### 主键\n\n一列(或一组列)，其值能够唯一标识表中每一行。（用户表的用户 ID，问题表的问题 ID）\n\n> 表可以不创建主键，正常情况下，我们都会给每个表创建一个主键，以便以后的数据操作和管理。\n\n每个列都可以做主键，需要的条件：\n\n* 任意两行都不具有相同的主键值;\n* 每一行都必须具有一个主键值(主键列不允许NULL值); \n* 主键列中的值不允许修改或更新; \n* 主键值不能重用(如果某行从表中删除，它的主键不能赋给以后的新行)\n\n## 操作表\n\n### 创建表\n\n创建表用到的命令是 `CREATE TABLE`，需要注意的点为：\n\n1. 给表起一个独特（不能和其它表重名）的名字\n2. 然后在括号内来定义每一列的列表，在表中是什么样的数据类型以及要加的限制（比如，不能重复，最长多少字符..)\n\n```sql\nCREATE TABLE account(\n user_id integer PRIMARY KEY, \n username VARCHAR (50) UNIQUE NOT NULL,\n password VARCHAR (50) NOT NULL,\n created_on TIMESTAMP NOT NULL DEFAULT now(),\n last_login TIMESTAMP\n);\n```\n\n表名： account\n列名： user_id, username, password, created_on, last_login\nPRIMARY KEY: 表明这是主键。\nUNIQUE: 表明这个字段值不能重复。\nNOT NULL: 表明该列不能为空。\nDEFAULT: 用来指定默认值。\n\n### 删除表\n\n```sql\nDROP TABLE account;\n```\n\n### 更新表\n\n> 更新操作\n\n## 插入数据\n\n### 数据插入\n\n语法格式：\n\n```sql\nINSERT INTO TABLE_NAME (column1, column2, column3,...columnN)  \nVALUES (value1, value2, value3,...valueN);\n```\n\n> `column1`, `column2`, `column3`,...`columnN` 是要插入数据的表中的列的名称。\n\n#### 插入完整的行\n\n```sql\nINSERT INTO account (user_id, username, password, created_on, last_login)  \nVALUES (1, 'fenda', 'fenda123', now(), now());\n```\n\n> 重复执行会报错，因为 user_id 和 username 不能重复。\n\n#### 插入部分行\n\n可为空的，设置了默认值的字段可以不设定值。\n\n```sql\nINSERT INTO account (user_id, username, password)  \nVALUES (2, 'zaihang', 'fenda123');\n```\n\n这里，created_on 和 last_login 并没有指定值。\n\n## 检索数据\n\nSQL语句是由简单的英语单词构成的。这些单词称为关键字，每个SQL语句都是由一个或多个关键字构成的。最经常使用的SQL语句大概就是SELECT语句了SELECT语句了。它的用途是从一个或多个表中检索信息。\n\n> 为了使用SELECT检索表数据，必须至少给出两条信息——想选择什么，以及从什么地方选择\n\n### 检索单个列\n\n```sql\nselect user_id from account;\n```\n\n> 上述语句利用SELECT语句从 account 表中检索一个名为 user_id 的列。所需的列名写在SELECT关键字之后，FROM关键字指出从哪个表中检索。\n\n这条SELECT语句将返回表中的所有行。数据没有过滤(过滤将得出结果集的一个子集)，也没有排序。\n\n**注意**\n\n* 多条SQL语句必须以分号(;)分隔。多数DBMS不需要在单条SQL语句后加分号，但Postgresql必须在单条SQL语句后加上分号。当然，如果愿意可以总是加上分号。事实上，即使不一定需要，加上分号也肯定没有坏处。\n* `SQL语句不区分大小写`，因此SELECT与select是相同的。\n* 在处理SQL语句时，其中所有空格都被忽略。SQL语句可以写成长长的一行，也可以分写在多行。下面这三种写法的作用是一样的。\n\n```sql\n-- 1\nselect user_id from account;\n\n-- 2\nselect user_id\nfrom account;\n\n-- 3\nselect\nuser_id\nfrom\naccount;\n```\n\n> SQL 使用 `双横线（--）` 注释\n\n### 什么时候需要注释\n\n* SQL语句变长，复杂性增加时，你就会想添加一些描述性的注释，这便于你自己今后参考，或者供项目后续参与人员参考；\n* 在SQL文件开始处添加程序员的联系方式、程序描述以及一些说明的内容。\n* 暂时停止要执行的SQL代码。如果你碰到一个长SQL语句，而只想测试它的一部分，那么应该注释掉一些代码， 以便数据库将其视为注释而加以忽略。\n\n```sql\nselect user_id  -- 这是注释（可是试试把 -- 去掉看会发生什么）\nfrom account;\n\n/* SELECT user_id,  FROM account; */\nSELECT username\nFROM account;\n```\n\n### 检索多个列\n\n```sql\nselect user_id, username from account;\n```\n\n### 检索所有列\n\n```sql\nselect * from account;\n```\n\n### 限制结果\n\n```sql\nselect * from account limit 1;\n\nselect * from account where user_id> 1 limit 1;\n```\n\n## 排序检索数据\n\n`ORDER BY` 对产生的输出排序。\n\n### 排序数据\n\n```sql\nselect * from trade where operate_type='recharge' order by operate_fee; -- 按充值金额从小到大\n\nselect * from trade where operate_type='recharge' order by operate_fee desc; -- 按充值金额从大到小\n```\n\n### 按多个列排序\n\n```sql\n-- 按充值金额从小到大 金额相同的按充值时间从大到小\nselect * from trade where operate_type='recharge' order by operate_fee, date_created desc; \n\n-- 按充值金额从大到小 金额相同的按充值金额从小到大\nselect * from trade where operate_type='recharge' order by operate_fee desc, date_created; \n```\n\n## 过滤数据\n\n### 使用 where 子句\n\n```sql\nselect * from trade where where operate_type='recharge' and operate_fee > 1000 limit 1;\n```\n\n### where 子句操作符\n\n```sql\nselect * from trade where operate_fee = 1000;\n\nselect * from trade where operate_fee > 1000;\n\nselect * from trade where operate_fee >= 1000;\n\nselect * from trade where operate_fee < 1000;\n\nselect * from trade where operate_fee <= 1000;\n```\n\n### 组合 where 子句\n\n```sql\nselect * from trade where operate_fee <= 1000 and date_created > '2017-04-05';\n\nselect * from trade where date_created < '2017-08-05' and date_created > '2017-04-05';\n\nselect * from trade where date_created > '2017-07-05' or date_created < '2017-04-05';\n```\n\n#### 求值顺序\n\n```sql\n-- 先组合 date_created < '2017-04-05' and operate_fee > 1000 \n-- 再判断 date_created > '2017-07-05'\n-- 意思是 查询创建时间大于 2017-07-05 和 创建于 2017-04-05 之前的\n-- 金额大于1000的充值数据。\nselect * from trade \n    where date_created > '2017-07-05' \n    or date_created < '2017-04-05' \n    and operate_fee > 1000 \n    and operate_type='recharge';\n\n-- 查询 创建时间在 2017-04-05 之前 \n-- 或者 2017-07-05之后的 充值金额大于1000的订单\nselect * from trade \n    where (date_created > '2017-07-05' \n        or date_created < '2017-04-05') \n    and operate_fee > 1000\n    and operate_type='recharge';\n```\n\n### in 操作\n\n**查询充值金额为1000 或者 600 的订单**\n\n```sql\nselect * from trade where operate_fee in (600, 1000) and operate_type='recharge';\n\n-- 等同于 \n\nselect * from trade where (operate_fee = 600 or operate_fee = 1000) and operate_type='recharge';\n```\n\n为什么要使用IN操作符?其优点为:\n\n* 在有很多合法选项时，IN操作符的语法更清楚，更直观。 \n* 在与其他AND和OR操作符组合使用IN时，求值顺序更容易管理。 \n* IN操作符一般比一组OR操作符执行得更快(在上面这个合法选项很少的例子中，你看不出性能差异)。 \n* IN的最大优点是可以包含其他SELECT语句，能够更动态地建立WHERE子句。\n\n### not 操作符\nWHERE子句中的NOT操作符有且只有一个功能，那就是否定其后所跟的任何条件。因为NOT从不单独使用(它总是与其他操作符一起使用)，\n所以它的语法与其他操作符有所不同。NOT关键字可以用在要过滤的列前，而不仅是在其后。\n\n> `NOT`\nWHERE子句中用来否定其后条件的关键字。\n\n```sql\nselect * from trade where not operate_fee in (600, 1000) and operate_type='recharge' LIMIT 10;\n\nSELECT * FROM trade WHERE operate_fee NOT IN (600, 1000) AND operate_type='recharge' LIMIT 10;\n\nSELECT * FROM trade WHERE NOT (operate_fee IN (600, 1000) AND operate_type='recharge') LIMIT 10;\n```\n\n## like 操作符\n\n前面介绍的所有操作符都是针对已知值进行过滤的。不管是匹配一个值还是多个值，检验大于还是小于已知值，或者检查某个范围的值，其共\n同点是过滤中使用的值都是已知的。\n\n但是，这种过滤方法并不是任何时候都好用。例如，我们想找出 `account` 表中 username 以 `fenda` 开头的数据。\n\n这时，就必须使用通配符了。\n\n> `通配符(wildcard)` 用来匹配值的一部分的特殊字符。\n> `搜索模式(search pattern)` 由字面值、通配符或两者组合构成的搜索条件。\n\nSQL支持几种通配符。为在搜索子句中使用通配符，必须使用LIKE操作符。LIKE指示数据库，后跟的搜索模式利用通配符匹配而不是简单的相等匹配进行比较。\n\n> `注意：`通配符搜索只能用于文本字段(串)，非文本数据类型字段不能使用通配符搜索。\n\n### 百分号(%)通配符\n\n最常使用的通配符是百分号(%)。在搜索串中，%表示任何字符出现任意次数。\n\n```sql\nselect * from account where username like 'fenda%';\n```\n\n此例子使用了搜索模式'fenda%'。在执行这条子句时，将检索任意以 `fenda` 起头的词。`%``告诉数据库接受 `fenda` 之后的任意字符，不管它有多少字符。\n\n> 搜索模式区分大小写。 `'Fenda%'` 和 `'fenda%'` 是不同的。\n\n`%` 不仅可以放在最后，也可以放在其他位置，比如\n\n```sql\nselect * from account where username like '%enda%';\n```\n\n### 下划线(_)通配符\n\n下划线的用途与%一样，但它只匹配单个字符，而不是多个字符。\n\n```sql\nselect * from account where username like 'fenda-_bc-9';\n```\n\n### 方括号([ ])通配符\n\n方括号([])通配符用来指定一个字符集，它必须匹配指定位置(通配符的位置)的一个字符。\n\n```sql\n-- bc 前边的字符只能是 a 或 b\nselect * from account where username like 'fenda-[ab]bc-9';\n\n-- bc 前边的字符不能是 a 或 b\nselect * from account where username like 'fenda-[^ab]bc-9';\n```\n\n### 通配符转义\n\n```sql\n-- abc 前只能是 下划线(_)\nselect * from account where username like 'fenda[_]abc-9';\n\n-- 使用转义字符声明下划线是一个字符而不是通配符\nselect * from account where username like 'fenda\\_abc-9';\n```\n\n### 使用通配符的技巧\n\n通配符搜索一般比前面讨论的其他搜索要耗费更长的处理时间。这里给出一些使用通配符时要记住的技巧。\n\n* 不要过度使用通配符。如果其他操作符能达到相同的目的，应该使用其他操作符。\n* 在确实需要使用通配符时，也尽量不要把它们用在搜索模式的开始处。把通配符置于开始处，搜索起来是最慢的。\n* 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。\n\n\n## 汇总数据\n\n我们经常需要汇总数据而不用把它们实际检索出来，为此SQL提供了专门的函数。使用这些函数，SQL查询可用于检索数据，以便分析和报表生成。这种类型的检索例子有:\n\n* 确定表中行数(或者满足某个条件或包含某个特定值的行数);\n* 获得表中某些行的和;\n* 找出表列(或所有行或某些特定的行)的最大值、最小值、平均值。\n\nSQL 提供的常用的聚集函数：\n\n函数 | 说明\n-----|----\nCOUNT()| 返回某列的行数\nAVG()| 返回某列的平均值\nMAX()| 返回某列的最大值\nMIN()| 返回某列的最小值\nSUM()| 返回某列的和\n\n### AVG() 函数\n\nAVG()通过对表中行数计数并计算其列值之和，求得该列的平均值。AVG()可用来返回所有列的平均值，也可以用来返回特定列或行的平均值。 \n\n下面的例子使用AVG()返回 trade 表中所有充值数据的均值:\n\n```sql\n-- 充值金额的均值\nselect avg(operate_fee) from trade \n    where operate_type='recharge';\n```\n\n> AVG()函数忽略列值为NULL的行。\n\n### COUNT() 函数\n\nCOUNT()函数进行计数。可利用COUNT()确定表中行的数目或符合特定条件的行的数目。\n\nCOUNT()函数有两种使用方式: \n* 使用COUNT(*)对表中行的数目进行计数，不管表列中包含的是空值(NULL)还是非空值。\n* 使用COUNT(column)对特定列中具有值的行进行计数，忽略NULL值。\n\n比如：\n\n```sql\nselect count(*) from account;  -- 用户数\n\nselect count(last_login) from account; -- 登录过的用户数\n```\n\n> 如果指定列名，则COUNT()函数会忽略指定列的值为空的行，但如果COUNT()函数中用的是星号(*)，则不忽略。\n\n### MAX() 函数\n\nMAX()返回指定列中的最大值。MAX()要求指定列名，如下所示:\n\n```sql\n-- 充值数据中的最高金额\nselect max(operate_fee) from trade where operate_type='recharge'; \n\nselect operate_fee from trade \n    where operate_type='recharge' \n    order by operate_fee desc limit 1;\n```\n\n> MAX()函数忽略列值为NULL的行。\n\n### MIN() 函数\n\nMIN()的功能正好与MAX()功能相反，它返回指定列的最小值。与MAX()一样，MIN()要求指定列名，如下所示:\n\n```sql\n-- 充值数据中的最少金额\nselect min(operate_fee) from trade where operate_type='recharge'; \n\nselect operate_fee from trade \n    where operate_type='recharge' \n    order by operate_fee limit 1;\n```\n\n> MIN()函数忽略列值为NULL的行。\n\n### SUM() 函数\n\n```sql\n-- 最大的充值金额\nSELECT max(operate_fee) FROM trade WHERE operate_type='recharge';\n\n-- 以最大充值金额充值的条数\nSELECT count(*) FROM trade \n    WHERE operate_type='recharge' \n    AND operate_fee = (SELECT max(operate_fee) FROM trade \n                       WHERE operate_type='recharge');\n\nSELECT operate_fee * (SELECT count(*) FROM trade \n                          WHERE operate_type='recharge' \n                          AND operate_fee = (SELECT max(operate_fee) FROM trade \n                              WHERE operate_type='recharge')) AS 最大充值金额总和 FROM trade \n    WHERE operate_type='recharge' \n    AND operate_fee=(SELECT max(operate_fee) FROM trade \n                     WHERE operate_type='recharge');\n\nSELECT sum(operate_fee) AS 最大充值金额总和 FROM trade \n    WHERE operate_type='recharge' \n    AND operate_fee = (SELECT max(operate_fee) FROM trade \n                       WHERE operate_type='recharge');\n```\n\nSUM()用来返回指定列值的和(总计)。比如:\n\n```sql\n-- 充值金额的总和\nselect sum(operate_fee) from trade where operate_type='recharge'; \n\n-- 充值金额的总和\nselect sum(operate_fee) from trade where operate_type='recharge';\n```\n\n### 组合聚集函数\n\nSELECT语句可根据需要包含多个聚集函数。请看下面的例子:\n\n```sql\nSELECT count(*) AS 总充值条数,\n    min(operate_fee) AS 最小充值金额,\n    max(operate_fee) AS 最大充值金额,\n    avg(operate_fee) AS fee_avg,\n    sum(operate_fee) AS fee_sum\nFROM trade WHERE operate_type='recharge';\n```\n\n#### 练习： 计算最大的充值金额，并统计最大金额的充值次数\n```sql\nSELECT count(*) FROM trade \n    WHERE operate_type='recharge' \n    AND operate_fee=(\n        SELECT max(operate_fee) FROM trade \n            WHERE operate_type='recharge');\n```\n#### 练习：计算最大的充值金额，并统计以这个金额充值的总金额\n```sql\nSELECT sum(operate_fee) FROM trade \n    WHERE operate_type='recharge' \n    AND operate_fee = (\n        SELECT max(operate_fee) FROM trade \n            WHERE operate_type='recharge');\n```\n\n这条 select 语句执行了5个聚合函数，返回5个值（总充值次数，最小值，最大值，平均值，总充值金额）。\n\n> `取别名` 使用聚合函数时，建议使用别名指定计算后的结果。在指定别名时，不应该使用表中实际的列名。\n\n\n## 分组数据\n\n使用SQL聚集函数可以汇总数据。这样，我们就能够对行进行计数，计算和与平均数，不检索所有数据就获得最大值和最小值。\n目前为止的所有计算都是在表的所有数据或匹配特定的WHERE子句的数据上进行的。比如下面的例子返回供应商DLL01提供的产品数目:\n\n```sql\nSELECT COUNT(*) AS num_prods FROM Products\nWHERE vend_id = 'DLL01';\n```\n\n如果要返回每个供应商提供的产品数目，该怎么办?或者返回只提供一项产品的供应商的产品，或者返回提供10个以上产品的供应商的产品，怎么办?\n这就是分组大显身手的时候了。使用分组可以将数据分为多个逻辑组，对每个组进行聚集计算。\n\n### 创建分组\n\n分组是使用SELECT语句的`GROUP BY`子句建立的。理解分组的最好办法是看一个例子:\n\n```sql\n-- 查询每个用户充值的次数\nselect account_id, count(*) AS 充值次数 from trade \n    where operate_type='recharge' \n    group by account_id;\n```\n\n上面的`SELECT`语句指定了两个列: account_id 包含用户的ID，`充值次数`为计算字段(用COUNT(*)函数建立)。`GROUP BY`子句指示 数据库按 `account_id`排序并分组数据。这就会对每个`account_id`而不是整个表计算充值次数一次。\n因为使用了`GROUP BY`，就不必指定要计算和估值的每个组了。系统会自动完成。`GROUP BY`子句指示数据库分组数据，然后对每个组而不是整个结果集进行聚集。\n\n* GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。\n* 除聚集计算语句外，SELECT语句中的每一列都必须在GROUP BY子句中给出。\n* 如果分组列中包含具有NULL值的行，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组。\n\n### 过滤分组\n\n除了能用GROUP BY分组数据外，SQL还允许过滤分组，规定包括哪些分组，排除哪些分组。例如，你可能想要列出至少充值两次的用户。为此，必须基于完整的分组而不是个别的行进行过滤。\n\nSQL为此提供了另一个子句，就是`HAVING`子句。HAVING非常类似于WHERE。WHERE过滤行，而 `HAVING` 过滤分组。\n\n```sql\n-- 查询充值的次数大于10的用户\nselect account_id, count(*) AS 充值次数 from trade \n    where operate_type='recharge' \n    group by account_id\n    having count(*) > 10;\n```\n\n> WHERE在数据分组前进行过滤，HAVING在数据分组后进行过滤。这是一个重要的区别，WHERE排除的行不包括在分组中。这可能会改变计算值，从而影响HAVING子句中基于这些值过滤掉的分组\n\n### 分组和排序\n\n使用 `GROUP BY` 分组的结果是无序的，我们可以使用 `ORDER BY` 对结果进行排序。\n\n```sql\n-- 查询充值的次数大于10的用户 按充值次数排序\nSELECT account_id, count(*) AS 充值次数 FROM trade \n    WHERE operate_type='recharge' \n    GROUP BY account_id\n    HAVING count(*) > 10\n    ORDER BY count(*) desc;\n```\n\n## 参考链接\n\n------\n\n\n最后，感谢女朋友支持。\n\n欢迎关注(April_Louisa) | 请我喝芬达\n------- | -------\n![欢迎关注](http://media.gusibi.mobi/Hy8XHexmzppNKuekLuGxWy8LjdGrQAzZA3mH_e9xltoiYgTFWdvlpZwGWxZESrbK)| ![请我喝芬达](http://media.gusibi.mobi/CO9DwU6ZHnXHD5xuG3GqTsY_IYPl-JdpQrDaOo6tl6PiAGEBDeYFHO7sGQi_VVFc)\n",
      "data": {
        "title": "数据库基础：创建表",
        "date": "2017-07-30 00:02:22",
        "tags": [
          "database"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "sql-start-1-how-to-create-table"
    },
    {
      "content": "\n前两篇 `微信公号DIY` 系列:\n* [微信公号DIY：一小时搭建微信聊天机器人](https://mp.weixin.qq.com/s?__biz=MzAwNjI5MjAzNw==&mid=2655752007&idx=1&sn=46cf89695e8147fb30acb162ec895290&chksm=80b0b86db7c7317bca8612498cb7b01bc541d5b03399496fd5ce06291b844c0af9920d09f8fc#rd) \n* [微信公号DIY：训练聊天机器人&公号变身图片上传工具](https://mp.weixin.qq.com/s?__biz=MzAwNjI5MjAzNw==&mid=2655752009&idx=1&sn=b6d533c6bf408daec7229e2ddb6843a0&chksm=80b0b863b7c73175ff3d6300ad1a2f9e013c5614397a7115a73eba38af715e9a905e28aaa49e#rd)  \n\n介绍了如何使用搭建&训练聊天机器人以及让公号支持图片上传到七牛，把公号变成一个七牛图片上传客户端。这一篇将继续开发公号，让公号变成一个更加实用的工具`账本`（理财从记账开始）。\n\n> `代码：` 项目代码已上传至github，地址为[gusibi/momo：https://github.com/gusibi/momo](https://github.com/gusibi/momo)\n\nHUGOMORE42\n\n## 账本功能\n\n账本是一个功能比较简单应用，公号内只需要支持：\n1. 记账（记账，修改金额，取消记账）\n2. 账单统计（提供数据和图片形式的统计功能）\n\n当然后台管理功能就比较多了，这个以后再介绍。\n\n对于数据存储，我选择的是MongoDB（选MongoDB的原因是，之前没用过，想试一下），我们先看下MongoDB和关系型数据库的不同。\n\n## MongoDB\n\n### 什么是MongoDB ?\n\nMongoDB 是由C++语言编写的，是一个开放源代码的面向文档的数据库,易于开发和缩放。\n\n> mongo和传统关系数据库的最本质的区别在那里呢？MongoDB 是文档模型。\n\n关系模型和文档模型的区别在哪里？\n\n* 关系模型需要你把一个数据对象，拆分成零部件，然后存到各个相应的表里，需要的是最后把它拼起来。举例子来说，假设我们要做一个CRM应用，那么要管理客户的基本信息，包括客户名字、地址、电话等。由于每个客户可能有多个电话，那么按照第三范式，我们会把电话号码用单独的一个表来存储，并在显示客户信息的时候通过关联把需要的信息取回来。\n* 而MongoDB的文档模式，与这个模式大不相同。由于我们的存储单位是一个文档，可以支持数组和嵌套文档，所以很多时候你直接用一个这样的文档就可以涵盖这个客户相关的所有个人信息。关系型数据库的关联功能不一定就是它的优势，而是它能够工作的必要条件。 而在MongoDB里面，利用富文档的性质，很多时候，关联是个伪需求，可以通过合理建模来避免做关联。\n![关系模型和文档模型区别图例](http://www.mongoing.com/wp-content/uploads/2016/01/MongoDB-%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E8%BF%9B%E9%98%B6%E6%A1%88%E4%BE%8B_%E9%A1%B5%E9%9D%A2_04-1024x791.png)\n\n### MongoDB 概念解析\n\n在mongodb中基本的概念是文档、集合、数据库，下表是MongoDB和关系型数据库概念对比：\n\n|SQL术语/概念\t|MongoDB术语/概念\t|解释/说明|\n|------|------|------|\n|database\t   |database\t|数据库\n|table\t       |collection\t|数据库表/集合\n|row\t       |document\t|数据记录行/文档\n|column\t       |field\t    |数据字段/域\n|index\t       |index\t    |索引\n|table         |joins\t    |表连接,MongoDB不支持\n|primary key\t|primary key\t|主键,MongoDB自动将_id字段设置为主键\n\n通过下图实例，我们也可以更直观的的了解Mongo中的一些概念：\n\n![Mongo中的一些概念](http://www.runoob.com/wp-content/uploads/2013/10/Figure-1-Mapping-Table-to-Collection-1.png)\n\n接下来，我从使用的角度来介绍下如何使用 python 如何使用MongoDB，在这个过程中，我会实现一个简单的MongoDB的ORM，同时也会解释一下涉及到的概念。\n\n## 简易 Python MongoDB ORM\n### python 使用 mongodb\n\n首先，需要确认已经安装了 PyMongo，如果没有安装，使用以下命令安装：\n\n```sh\npip install pymongo\n# 或者\neasy_install pymongo\n```\n详细安装步骤参考: [PyMongo Installing / Upgrading](http://api.mongodb.com/python/current/installation.html)\n\n#### 连接 MongoClient：\n\n```python\n>>> from pymongo import MongoClient\n>>> client = MongoClient()\n```\n上述命令会使用Mongo的默认host和端口号，和以下命令作用相同：\n```python\nclient = MongoClient('localhost', 27017) # mongo 默认端口号\n为27017\n# 也可以这样写\nclient = MongoClient('mongodb://localhost:27017/')\n```\n\n#### 选择一个数据库\n\n获取 MongoClient 后我们接下来要做的是选择要执行的数据库，命令如下：\n\n```python\n>>> db = client.test_database # test_database 是选择的数据库名称\n# 也可以使用下述方式\n>>> db = client['test-database']\n```\n\n> `数据库（Database）` \n> 一个mongodb中可以建立多个数据库。\nMongoDB的默认数据库为\"db\"，该数据库存储在data目录中。\nMongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中。\n\"show dbs\" 命令可以显示所有数据的列表。\n> 执行 \"db\" 命令可以显示当前数据库对象或集合。\n> 运行\"use\"命令，可以连接到一个指定的数据库。\n\n#### 获取集合\n\n选择数据库后，接下来就是选择一个集合（Collection），获取一个集合和选择一个数据库的方式基本一致：\n\n```python\n>>> collection = db.test_collection  # test_collection 是集合名称\n# 也可以使用字典的形式\n>>> collection = db['test-collection']\n```\n\n> `集合（collection）`\n> 集合就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System)中的表。\n集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。\n> `当第一个文档插入时，集合就会被创建。`\n> 集合名`不能是空字符串\"\"`。\n> 集合名`不能含有\\0字符（空字符)`，这个字符表示集合名的结尾。\n> 集合名`不能以\"system.\"开头`，这是为系统集合保留的前缀。\n> 用户创建的集合名字`不能含有保留字符`。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。　\n\n了解这几个操作后我们把这几个封装一下：\n\n```python\nfrom six import with_metaclass\nfrom pymongo import MongoClient\nfrom momo.settings import Config\n\npyclient = MongoClient(Config.MONGO_MASTER_URL)\n\nclass ModelMetaclass(type):\n    \"\"\"\n    Metaclass of the Model.\n    \"\"\"\n    __collection__ = None\n\n    def __init__(cls, name, bases, attrs):\n        super(ModelMetaclass, cls).__init__(name, bases, attrs)\n        cls.db = pyclient['momo_bill']  # 数据库名称，也可以作为参数传递 通常情况下一个应用只是用一个数据库就能实现需求\n        if cls.__collection__:\n            cls.collection = cls.db[cls.__collection__]\n\n\nclass Model(with_metaclass(ModelMetaclass, object)):\n\n    __collection__ = 'model_base'\n```\n\n现在我们可以这样定义一个集合（Collection）：\n```python\nclass Account(Model):\n\n    '''\n    暂时在这里声明文档结构，用不用做校验，只是方便自己查阅\n    以后也不会变成类似 SQLAlchemy 那种强校验的形式\n    :param _id: '用户ID',\n    :param nickname: '用户昵称 用户显示',\n    :param username: '用户名 用于登录',\n    :param avatar: '头像',\n    :param password: '密码',\n    :param created_time: '创建时间',\n    '''\n    __collection__ = 'account'  # 集合名\n```\n\n使用方式：\n\n```python\naccount = Account()\n```\n现在就已经指定了数据库和集合，可以自由做 CURD 操作了（虽然还不支持）。\n\n#### 创建文档（insert document）\n\n使用PyMongo 创建文档非常方便：\n\n```python\n>>> import datetime\n>>> account = {\"nickname\": \"Mike\",\n...         \"username\": \"mike\",\n...         \"avatar\": \"http://media.gusibi.mobi/Hy8XHexmzppNKuekLuGxWy8LjdGrQAzZA3mH_e9xltoiYgTFWdvlpZwGWxZESrbK\",\n...         \"password\": \"password\",\n...         \"created_time\": datetime.datetime.utcnow()}\n\n>>> accounts = db.account\n>>> account_id = accounts.insert_one(account).inserted_id\n>>> account_id\nObjectId('...')\n```\n\n创建一个文档时，你可以指定 `_id`，如果不指定，系统会自动添加上`_id` 字段，这个字段必须是唯一不可重复的字段。\n\n也可是使用 `collection_names` 命令显示所有的集合：\n```python\n>>> db.collection_names(include_system_collections=False)\n[u'account']\n```\n> `文档（Document）` 文档是一组键值(key-value)对(即BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。\n\n现在我们给这个简易ORM添加创建文档的功能：\n```python\nclass Model(with_metaclass(ModelMetaclass, object)):\n\n    __collection__ = 'model_base'\n\n    @classmethod\n    def insert(cls, **kwargs):\n        # insert one document\n        doc = cls.collection.insert_one(kwargs)\n        return doc\n        \n    @classmethod\n    def bulk_inserts(cls, *params):\n        '''\n        :param params: document list\n        :return: \n        '''\n        results = cls.collection.insert_many(params)\n        return results        \n```\n\n创建一个文档方法为：\n\n```python\naccount = Account.insert(\"nickname\": \"Mike\",\n        \"username\": \"mike\",\n        \"avatar\": \"http://media.gusibi.mobi/Hy8XHexmzppNKuekLuGxWy8LjdGrQAzZA3mH_e9xltoiYgTFWdvlpZwGWxZESrbK\",\n        \"password\": \"password\",\n        \"created_time\": datetime.datetime.utcnow())\n```\n\n#### 查询文档\n\n使用 `find_one` 获取单个文档：\n\n```python\naccounts.find_one()\n```\n\n> 如果没有任何筛选条件，find_one 命令会取集合中的第一个文档\n> 如果有筛选条件，会取符合条件的第一个文档\n\n```python\naccounts.find_one({\"nickname\": \"mike\"})\n```\n\n使用 `ObjectId` 查询单个文档：\n\n```python\naccounts.find_one({\"_id\": account_id})\n```\n\n将这个添加到ORM中：\n\n```python\nclass Model(with_metaclass(ModelMetaclass, object)):\n\n    __collection__ = 'model_base'\n\n    @classmethod\n    def get(cls, _id=None, **kwargs):\n        if _id: # 如果有_id\n            doc = cls.collection.find_one({'_id': _id})\n        else: # 如果没有id\n            doc = cls.collection.find_one(kwargs)\n        return doc\n```\n如果你想获取多个文档可以使用`find`命令。\n\n使用`find`命令获取多个文档\n\n```python\naccounts.find()\n# 当然支持筛选条件\naccounts.find({\"nickname\": \"mike\"})\n```\n\n将这个功能添加到ORM：\n\n```python\nclass Model(with_metaclass(ModelMetaclass, object)):\n\n    __collection__ = 'model_base'\n    \n    @classmethod\n    def find(cls, filter=None, projection=None, skip=0, limit=20, **kwargs):\n        docs = cls.collection.find(filter=filter,\n                                   projection=projection,\n                                   skip=skip, \n                                   limit=limit,\n                                   **kwargs)\n        return docs\n```\n\n现在我们可以这样做查询操作：\n\n```python\naccount = Account.get(_id='account_id')\naccounts = Account.find({'name': \"mike\"})\n```\n\n#### 修改（update）\n\n更新操作[文档地址：http://api.mongodb.com/python/current/api/pymongo/collection.html#pymongo.collection.Collection.update_one](http://api.mongodb.com/python/current/api/pymongo/collection.html?highlight=update_one#pymongo.collection.Collection.update_one)：\n\n> `update_one`(filter, update, upsert=False, bypass_document_validation=False, collation=None)\n\n更新一个符合筛选条件的文档 upsert 如果为True 则会在没有匹配到文档的时候创建一个\n> `update_many`(filter, update, upsert=False, bypass_document_validation=False, collation=None)\n\n更新全部符合筛选条件的文档 upsert 如果为True 则会在没有匹配到文档的时候创建一个\n\n添加到ORM中：\n\n```python\nclass Model(with_metaclass(ModelMetaclass, object)):\n\n    __collection__ = 'model_base'\n    \n    @classmethod\n    def update_one(cls, filter, **kwargs):\n        result = cls.collection.update_one(filter, **kwargs)\n        return result\n\n    @classmethod\n    def update_many(cls, filter, **kwargs):\n        results = cls.collection.update_many(filter, **kwargs)\n        return results\n```\n\n可以看到，我这里并没有做多余的操作，只是直接调用了PyMongo的方法。\n\n#### 删除\n\n删除操作和update类似但是比较简单：\n\n> delete_one(filter, collation=None):\n\n删除一个匹配到的文档\n\n> delete_many(filter, collation=None):\n\n删除全部匹配到的文档\n\n添加到ORM中：\n\n```python\nclass Model(with_metaclass(ModelMetaclass, object)):\n\n    __collection__ = 'model_base'\n\n    @classmethod\n    def delete_one(cls, **filter):\n        cls.collection.delete_one(filter)\n\n    @classmethod\n    def delete_many(cls, **filter):\n        cls.collection.delete_many(filter)\n\n```\n\n到这里，简易的ORM就实现了（这只能算是个功能简单的框，可以再自由添加其它更多的功能）。\n\n接下来是账本文档结构的设计\n\n## 账本数据结构设计\n\n账本需要包含的数据有：\n\n* 账户所有人\n* 账单记录\n* 账单分类\n\n那么我们至少需要三个集合：\n\n```python\n{\n    'account': {  # 用户集合\n        '_id': '用户ID',\n        'nickname': '用户昵称',\n        'username': '用户名 用于登录',\n        'avatar': '头像',\n        'password': '密码',\n        'created_time': '创建时间',\n    },\n    'bill': { # 账单集合\n        '_id': '账单ID',\n        'uid': '用户ID',\n        'money': '金额 精确到分',\n        'tag': '标签',\n        'remark': '备注',\n        'created_time': '创建时间',\n    },\n    'tag': {  # 账单标签\n        '_id': '标签ID',\n        'name': '标签名',\n        'icon': '标签图标',\n        'uid': '创建者ID（默认是管理员）',\n        'created_time': '创建时间',\n    }\n}\n```\n\n这里账单和用户使用 uid 作为引用的关联，account 和 bill 是一对多关系。\n\n> 当然你也可以再加一个账本的集合，用户和账本对应，这时，账单可以作为账本中的一个list数据结构（单个文档有16M的限制，如果存储超过这个大小不能使用这种形式，数据量大的时候，查询操作会比较缓慢）。\n\n作为公号中的账本，我们暂时不加账本功能，因为这会让我们的操作变得复杂。\n\n因为公号里的每次操作都是独立请求，并没有上下文。所以我们要记录记账这个操作走到了哪一步，接下来改干嘛。\n\n记账逻辑如图：\n\n![公号记账流程图](http://media.gusibi.mobi/5hzgvdbSsM37XRm-A8mRkPe6d2sHmvvT6w3RgNAKzoHxZwpxcE3f_tRBsFxRgA-p)\n\n所以我们这里要有数据来记录当前的操作步骤以及接下来改有的操作步骤：\n\n```python\n{\n    'account_workflow': {  # 用户当前工作流\n        '_id': 'id', \n        'next': '下一步的操作',\n        'uid': '用户ID',\n        'workflow': '使用的工作流',\n        'created_time': '开始时间'\n    }\n}\n```\n\n这个集合记录了我们当前所在的工作流，下一步该走向哪一步。\n\n> 这个集合需要设置文档的过期时间，比如输入 “记账” 激活记账工作流后，如果10分钟没有操作完成，那么需要重新开始。以免输入记账后不完成不能继续其它的操作。\n\n下面的这个集合记录了哪些关键字可以激活工作流，对应的工作流是什么以及开始哪个动作。\n\n```python\n{\n    'keyword': {  # 特殊关键字\n        '_id': '关键字ID',\n        'word': '关键字',\n        'data': {\n            'workflow': '工作流',\n            'action': '工作流动作',\n            'value': '返回值',\n            'type': '返回值类型 url|pic|text',\n        },\n        'created_time': '创建时间'\n    },\n}\n```\n\n到这里账本的数据库设计就结束了。\n\n## 总结\n\n这一篇主要介绍了MongoDB，PyMongo 的使用以及如何编写一个简易的MongoDB ORM。\n然后又介绍了基于 MongoDB 的公号账本应用的数据库设计。\n\n### 预告\n\n下一篇我们将介绍，如何实现记账功能。\n\n以下是操作截图。\n\n![记账](http://media.gusibi.mobi/SDTcm0mQp-0ugO8R9bz9NxA-HrhsKBXCdEK85exrLYmU7EiI2X07FhsVRFhQqj3K)\n![修改金额](http://media.gusibi.mobi/Ya4Ip_QWn_XR2CnG5yipx9ZeG7s6wJZy8_SFYIKYPLOFk75KPq54e42x27v6kjD4)\n![取消记账](http://media.gusibi.mobi/JdJvDNlb4SyvozhE-1YSPdkTWkrk8A1BSO6pxmLUzHpF-7QyqEQYACAeetdkhbFo)\n\n欢迎关注公号`四月（April_Louisa）`试用。\n\n## 参考链接\n\n* [MongoDB数据库设计中6条重要的经验法则：http://www.cnblogs.com/WeiGe/p/4903850.html](http://www.cnblogs.com/WeiGe/p/4903850.html)\n* [MongoDB 进阶模式设计：http://www.mongoing.com/mongodb-advanced-pattern-design](http://www.mongoing.com/mongodb-advanced-pattern-design)\n* [MongoDB 概念解析：http://www.runoob.com/mongodb/mongodb-databases-documents-collections.html](http://www.runoob.com/mongodb/mongodb-databases-documents-collections.html)\n* [PyMongo 3.4.0 Documentation：http://api.mongodb.com/python/current/index.html](http://api.mongodb.com/python/current/index.html)\n\n-------\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "微信公号DIY：MongoDB 简易ORM & 公号记账数据库设计",
        "date": "2017-07-16 13:14:10",
        "tags": [
          "python",
          "tutorial",
          "weixin",
          "公众号"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "weixin_mp_diy_setp_by_setp_1_db_desgin"
    },
    {
      "content": "\n## 什么是 RESTful\n \n### 什么是REST\n\nREST（英文：Representational State Transfer，又称具象状态传输）是Roy Thomas Fielding博士于2000年在他的博士论文[1] 中提出来的一种万维网软件架构风格，目的是便于不同软件/程序在网络（例如互联网）中互相传递信息。\n\nREST 的核心是可编辑的资源及其集合，用符合 Atom 文档标准的 Feed 和 Entry 表示。每个资源或者集合有一个惟一的 URI。系统以资源为中心，构建并提供一系列的 Web 服务。\n\n在 REST 中，开发人员显式地使用 HTTP 方法，对系统资源进行创建、读取、更新和删除的操作：\n\n* 使用 POST 方法在服务器上创建资源\n* 使用 GET 方法从服务器检索某个资源或者资源集合\n* 使用 PUT 方法对服务器的现有资源进行更新\n* 使用 DELETE 方法删除服务器的某个资源\n\n如果一个架构符合REST原则，就可以称它为`RESTful架构`。\n\n#### RESTful API 设计定义\n\n以下是几个RESTful API的几个概念。\n\n* 资源（Resource）：系统上的所有事物都被抽象为资源（一篇文章，一张照片，一段语音）\n* 集合（Collection）：一组资源的合辑称为集合（几篇文章，几张照片）\n* 路径（Endpoint）：路径又称”终点“，表示API的具体网址（每个网址代表一种资源）\n\n那么一个设计良好的RESTful API应该遵循哪些原则呢？\n\n##### 协议\n\nAPI与用户的通信协议总是使用HTTPs协议。\n\n##### 域名\n\n应该尽量将API部署在专用域名，例如：\n\n```sh\nhttps://apis.gusibi.com\n```\n#####  API地址和版本\n\n在url中指定API版本。比如：\n\n```sh\nhttps://apis.gusibi.com/v1\n```\n\n##### 以资源为中心设计URL\n\n资源是RESTful API的核心元素，所有的操作都是针对特定资源进化的。而资源就是URL表示的，所以简洁、清晰、结构化的URL设计是至关重要的。 \n在RESTful 架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。我们来看一下 Github 的例子：\n\n```sh\n/users/:username/repos\n/users/:org/repos\n/repos/:owner/:repo\n/repos/:owner/:repo/tags\n/repos/:owner/:repo/branches/:branch\n```\n\n##### 使用正确的Method\n\n对于资源的具体操作类型，使用HTTP method 表示。\n以下是常用的HTTP方法。\n\n* GET：从服务器取出资源\n* POST：在服务器新建一个资源\n* PUT：在服务器更新资源（客户端提供改变后的完整资源\n* PATCH：在服务器更新资源（客户端只提供改变了属性）\n* DELETE：从服务器删除资源\n\n还是使用 github 的例子：\n\n```sh\nGET /repos/:owner/:repo/issues\nGET /repos/:owner/:repo/issues/:number\nPOST /repos/:owner/:repo/issues\nPATCH /repos/:owner/:repo/issues/:number\nDELETE /repos/:owner/:repo\n```\n\n##### 正确的过滤信息（filtering）\n\n如果记录数量很多，服务器不能都将他们返回给用户。API应该提供参数，过滤返回结果。\n\n下边是一些是、常见的参数。\n\n* ?limit=10: 指定返回记录的数量\n* ?offset=10：指定返回记录的开始位置\n* ?page=2&per_page=100：：指定第几页，以及每页的记录数。\n* ?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。\n* ?animal_type_id=1：指定筛选条件\n\n##### 选择合适的状态码\n\nHTTP 应答中，需要带一个很重要的字段：status code。它说明了请求的大致情况，是否正常完成、需要进一步处理、出现了什么错误，对于客户端非常重要。状态码都是三位的整数，大概分成了几个区间：\n\n2XX：请求正常处理并返回\n3XX：重定向，请求的资源位置发生变化\n4XX：客户端发送的请求有错误\n5XX：服务器端错误\n\n常见的状态码有以下几种：\n\n> 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。\n201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。\n204 NO CONTENT - [DELETE]：用户删除数据成功。\n400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。\n401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。\n403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。\n404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。\n406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。\n410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。\n422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。\n500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。\n\n##### 返回结果\n\n针对不同操作，服务器向用户返回的结果应该符合以下规范。\n\n> GET /collection：返回资源对象的列表（数组）\nGET /collection/resource：返回单个资源对象\nPOST /collection：返回新生成的资源对象\nPUT /collection/resource：返回完整的资源对象\nPATCH /collection/resource：返回完整的资源对象\nDELETE /collection/resource：返回一个空文档\n\n##### 错误处理（Error handling）\n\n如果出错的话，在response body 中通过 message 给出明确的信息。如果状态码是4xx，就应该向用户返回出错信息。\n\n##### 良好的文档\n\n文档应该是规范的API的重要的组成部分，没有文档的API是难以给他人使用的，也是不利于维护的。\n\n##### 其它\n\n* 使用 OAuth2.0 鉴权\n* 尽量使用JSON作为返回的数据格式\n* 限流\n\n对应上述规则，我们并不能保证其它的API提供者也会遵守，特别是文档，有很大一部分API提供者给出的文档是pdf或者word文档，这是因为在API的迭代开发过程中，文档更新会比较麻烦。\n\nswagger帮API使用者和开发者纠正了这个问题。\n\n## 什么是swagger\n\nSwagger是一个简单但功能强大的API表达工具。改框架为创建JSON或YAML格式的RESTful API 文档提供了OpenAPI规范。swagger文档可由各种编程语言处理，可以在软件开发周期中嵌入源代码控制系统中，以便进行版本管理。使用Swagger生成API，我们可以得到交互式文档，自动生成代码的SDK以及API的发现特性等。\n\n### 如何编写API文档\n\n我们可以选择使用JSON或者YAML来编写API文档。文档示例如下：\n\njson 格式文档：\n\n```json\n{\n    \"swagger\": \"2.0\",\n    \"info\": {\n        \"version\": \"1.0.0\",\n        \"title\": \"Simple API\",\n        \"description\": \"A simple API to learn how to write OpenAPI Specification\"\n    },\n    \"schemes\": [\n        \"https\"\n    ],\n    \"host\": \"simple.api\",\n    \"basePath\": \"/openapi101\",\n    \"paths\": {\n        \"/persons\": {\n            \"get\": {\n                \"summary\": \"Gets some persons\",\n                \"description\": \"Returns a list containing all persons.\",\n                \"responses\": {\n                    \"200\": {\n                        \"description\": \"A list of Person\",\n                        \"schema\": {\n                            \"type\": \"array\",\n                            \"items\": {\n                                \"properties\": {\n                                    \"firstName\": {\n                                        \"type\": \"string\"\n                                    },\n                                    \"lastName\": {\n                                        \"type\": \"string\"\n                                    },\n                                    \"username\": {\n                                        \"type\": \"string\"\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\nyaml 格式文档：\n```yml\nswagger: \"2.0\"\n\ninfo:\n  version: 1.0.0\n  title: Simple API\n  description: A simple API to learn how to write OpenAPI Specification\n\nschemes:\n  - https\nhost: simple.api\nbasePath: /openapi101\n\npaths:\n  /persons:\n    get:\n      summary: Gets some persons\n      description: Returns a list containing all persons.\n      responses:\n        200:\n          description: A list of Person\n          schema:\n            type: array\n            items:\n              required:\n                - username\n              properties:\n                firstName:\n                  type: string\n                lastName:\n                  type: string\n                username:\n                  type: string\n```\n\n可以发现，yaml格式的文档比json格式的更清晰，可读性更高，推荐使用yaml格式书写文档。\n\nswagger 官网提供了 [swagger editor: http://editor.swagger.io/#/](http://editor.swagger.io/#/)，你可以在这个编辑器中创建或导入文档，并在交互式环境中浏览它。\n\n以下是您导入 leads.yaml 定义后的 Swagger Editor UI 外观：\n\n![Swagger Editor UI 外观](http://media.gusibi.mobi/5f3vEHQSGzv7HLePBpb-fIZBRCw5wnuCkBe4gPFLMtQTuz4LsZCOMHq5gWv-dlal)\n\n右侧的显示窗格显示了格式化的文档，反映了在左侧窗格中的代码编辑器中执行的更改。代码编辑器会指出了所有格式错误。你可以展开和折叠每个窗格。\n\n### API文档的基本结构\n\n我用一个例子来介绍下swagger文档的基本结构，这里我用yaml格式来编写文档：\n\n```yml\nswagger: \"2.0\"\ninfo:\n  title: Sample API\n  description: API description in Markdown.\n  version: 1.0.0\n\nhost: api.example.com\nbasePath: /v1\nschemes:\n  - https\n\npaths:\n  /users:\n    get:\n      summary: Returns a list of users.\n      description: Optional extended description in Markdown.\n      produces:\n        - application/json\n      responses:\n        200:\n          description: OK\n```\n\n上述文档包括元数据（Metadata）、Base URL、API路径（paths）三部分：\n\n#### Metadata\n\n这部分信息包括swagger 使用的版本：\n\n```yml\nswagger: \"2.0\"\n```\nAPI相关的描述信息（比如API介绍、版本等）：\n\n```yml\ninfo:\n  title: Sample API\n  description: API description in Markdown.\n  version: 1.0.0\n```\n\n#### Base URL\n\n作为web API，一个很重要的信息就是用来给用户使用的 根URL，可用协议（http/https）、host地址：\n\n```yml\nhost: api.example.com\nbasePath: /v1\nschemes:\n  - https\n```\n\n所有的API都是base URL 的相对路径 例如 /users 的API地址是 `https://api.example.com/v1/users`。\n\n#### 路径（Paths）\n\npaths 部分定义API的路径（endpoint）、支持的HTTP 请求方法\n\n```yml\npaths:  # 声明路径\n  /users:  # 定义API路径\n    get:   # 定义请求方式\n      summary: Returns a list of users.  # 简介\n      description: Optional extended description in Markdown.  # 描述\n      produces:\n        - application/json    # 定义 服务端response MIME types \n      responses:\n        200:    # response 状态码\n          description: OK\n```\n\n当然这只是个最简单的例子，swagger可定义的内容要比我提到的多的多。\n具体详细信息可以看下 [swagger 文档：https://swagger.io/docs/specification/what-is-swagger/](https://swagger.io/docs/specification/what-is-swagger/)。\n\n当然，写完文档并不代表我们的代码就可以直接使用这份文档以及文档中的约束，swagger 还提供了 [swagger-codegen：https://github.com/swagger-api/swagger-codegen](https://github.com/swagger-api/swagger-codegen)。\n\n### swagger_codegen\n\nswagger-codegen 是一个开源的代码生成工具，它包含一个模板驱动引擎，可以直接从我们定义的 swagger 文档中生成可视化的文档查看界面和API客户端。\n\n这是一个开源的项目，地址是[swagger-codegens： https://github.com/swagger-api/swagger-codegen](https://github.com/swagger-api/swagger-codegen)。可以自己安装使用一下。\n\n因为我最常用的语言是Python，所以给大家介绍一个第三方的 python 的代码生成器[swagger-py-codegen：https://github.com/guokr/swagger-py-codegen](https://github.com/guokr/swagger-py-codegen)\n\n## swagger_py_codegen\n\nswagger-py-codegen的亮点是它是一个Python web framework 代码生成器，可以根据swagger 文档自动生成相应web framework 的代码，现在支持 Flask, Tornado，falcon，最新版将支持sanic。\n\n### 安装\n\n可以使用 pip 安装：\n\n```sh\npip install swagger-py-codegen\n```\n### 使用\n\n安装后使用命令如下：\n\n```sh\nswagger_py_codegen --swagger-doc api.yml example-app\n```\n\n可选参数有：\n\n```\n-s, --swagger, --swagger-doc    Swagger doc file.  [required]\n-f, --force                     Force overwrite.\n-p, --package                   Package name / application name.\n-t, --template-dir              Path of your custom templates directory.\n--spec, --specification         Generate online specification json response.\n--ui                            Generate swagger ui.\n-j, --jobs INTEGER              Parallel jobs for processing.\n-tlp, --templates               gen flask/tornado/falcon templates, default flask.\n--version                       Show current version.\n--help                          Show this message and exit.\n```\n\n如果不指定 -tlp 参数，默认使用 flask 作为模板。\n如果指定 --ui --spec 参数则会在 由-p 参数指定的目录下生成swagger UI 目录 static。\n\n#### 举个例子\n\n我们这里使用 swagger-py-codegen 提供的测试文档 执行：\n\n```sh\nswagger_py_codegen --swagger-doc api.yml example-app --ui --spec\n```\n生成的代码目录结构如下\n\n```\n$tree\n.\n|__ api.yml\n\n$ swagger_py_codegen -s api.yml example-app -p demo\n$ tree (flask-demo)\n.\n|__ api.yml\n|__ example-app\n   |__ demo\n   |  |__ __init__.py\n   |  |__ v1\n   |     |__ api\n   |     |  |__ __init__.py\n   |     |  |__ oauth_auth_approach_approach.py\n   |     |  |__ oauth_auth_approach.py\n   |     |  |__ users_token.py\n   |     |  |__ users_current.py\n   |     |  |__ users.py\n   |     |__ __init__.py\n   |     |__ routes.py\n   |     |__ schemas.py\n   |     |__ validators.py\n   |__ requirements.txt\n```\n\n可以看到，这时一个简单的app框架已经生成了，其中 routes.py 是自动生成的路由，validators.py 是response和request的校验代码，schemas.py 是由文档生成的校验规则，api 目录下的各个文件是你定义的endpoint。\n\n这时运行demo 目录下的 `__init__.py` 文件:\n\n```python\npython __init__.py \n```\n会发现 server 已经启动：\n\n![server 启动示例](http://media.gusibi.mobi/pRyxskK89xODXjfsCdPVns9DJfMA2TF7tDLszenOAvhdB8gf5aBSwkCHCX9rSfQO)\n\n如果生成命令带上 --ui --spec，生成代码的同时也会生成swagger UI：\n\n```sh\nswagger_py_codegen --swagger-doc api.yml example-app --ui --spec\n```\n启动server后在浏览器输入地址 `http://0.0.0.0:8000/static/swagger-ui/index.html#!/default/get_users_uid`\n\n可以看到直接使用的 swagger UI。\n\n![swagger ui 截图](http://media.gusibi.mobi/SGfBUnb6jxikwbr0IxOYROmwpqmScGJBWUHu88v5sIy806XNbk6KWDGGggDIeJH3)\n\n> swagger-py-codegen 认证默认使用 OAuth2 认证方式，认证部分代码需要自己实现。\n\n现在代码结构已经生成，可以安心的写逻辑代码了。\n\n## 总结\n\n这一篇主要介绍了RESTful API以及如何使用swagger编写规范的RESTful API。\n最后介绍了如何使用 swagger-py-codegen 生成 web framework 的结构代码。\n参考链接中的文章都非常值得一看，建议都看一下。\n\n## 参考链接\n\n* [REST： https://zh.wikipedia.org/wiki/REST](https://zh.wikipedia.org/wiki/REST)\n* [RESTful API 设计指南： http://www.ruanyifeng.com/blog/2014/05/restful_api.html](http://www.ruanyifeng.com/blog/2014/05/restful_api.html)\n* [Principles of good RESTful API Design： https://codeplanet.io/principles-good-restful-api-design/](https://codeplanet.io/principles-good-restful-api-design/)\n* [跟着 Github 学习 Restful HTTP API 设计： http://cizixs.com/2016/12/12/restful-api-design-guide](http://cizixs.com/2016/12/12/restful-api-design-guide)\n* [最佳实践：更好的设计你的 REST API： https://www.ibm.com/developerworks/cn/web/1103_chenyan_restapi/](https://www.ibm.com/developerworks/cn/web/1103_chenyan_restapi/)\n* [swagger： https://swagger.io/](https://swagger.io/)\n* [如何编写基于OpenAPI规范的API文档：https://www.gitbook.com/book/huangwenchao/swagger/details](https://www.gitbook.com/book/huangwenchao/swagger/details)\n* [使用 Swagger 文档化和定义 RESTful API：https://www.ibm.com/developerworks/cn/web/wa-use-swagger-to-document-and-define-restful-apis/index.html](https://www.ibm.com/developerworks/cn/web/wa-use-swagger-to-document-and-define-restful-apis/index.html)\n* [swagger 文档：https://swagger.io/docs/specification/what-is-swagger/](https://swagger.io/docs/specification/what-is-swagger/)\n* [swagger-py-codegen：https://github.com/guokr/swagger-py-codegen](https://github.com/guokr/swagger-py-codegen)\n\n------\n\n最后，感谢女朋友支持。\n\n欢迎关注(April_Louisa) | 请我喝芬达\n------- | -------\n![欢迎关注](http://media.gusibi.mobi/Hy8XHexmzppNKuekLuGxWy8LjdGrQAzZA3mH_e9xltoiYgTFWdvlpZwGWxZESrbK)| ![请我喝芬达](http://media.gusibi.mobi/CO9DwU6ZHnXHD5xuG3GqTsY_IYPl-JdpQrDaOo6tl6PiAGEBDeYFHO7sGQi_VVFc)\n\n这里是分割线\n\n--------------\n\n公号现在已经开通了留言功能，如果你觉得文章有不对的地方，欢迎指出。\n",
      "data": {
        "title": "使用swagger 生成 Flask RESTful API",
        "date": "2017-07-11 13:29:15",
        "tags": [
          "python",
          "swagger",
          "restful"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "restful_api_by_swagger_py_codegen"
    },
    {
      "content": "\n上一篇 [一小时搭建微信聊天机器人](http://blog.gusibi.site/post/wechat-chatbot-step-by-step/) 介绍了如何搭建一个可用的聊天机器人，但是和机器人聊完你会发现，聊天机器人实在是太傻了，来回就那么几句。这是因为我们给聊天机器人的数据太少，他只能在我们给的训练集中找它认为最合适的。那么，如何导入更多的训练数据呢？\n我能想到最简单的方法是找对话的数据，然后把这些数据作为训练数据训练机器人。\n\n感谢 candlewill 已经收集好了大量的训练数据，[dialog_corpus https://github.com/candlewill/Dialog_Corpus](https://github.com/candlewill/Dialog_Corpus) 。\n\nHUGOMORE42\n\n这个库中包含电影台词、中英文短信息、自然语言处理相关的数据集、小黄鸡语料等。这里我选择电影台词语料。\n\n> 语料地址为：[dgk_lost_conv：https://github.com/rustch3n/dgk_lost_conv](https://github.com/rustch3n/dgk_lost_conv)\n\n## chatterbot 训练逻辑处理模块\n\n这个模块提供训练机器人的方法，chatterbot自带了通过输入list来训练（[\"你好\", \"你好啊\"] 后者是前者的回答）以及通过导入Corpus格式文件来训练的方式。\n\n这里我们选择使用第一种，通过输入list来训练机器人。\n\n### 处理训练数据\n\n首先下载数据集：\n\n```sh\nwget https://codeload.github.com/rustch3n/dgk_lost_conv/zip/master\n# 解压\n$ unzip dgk_lost_conv-master.zip\n```\n\n我们先打开一个文件看下数据结构：\n\n```sh\nE\nM 你得想想办法 我弟弟是无辜的\nM 他可是美国公民啊\nM 对此我也无能为力\nM 你当然能\nM 再去犯罪现场看看 定能证实清白\nM 你看 我不过是个夜间办事员而已\nM 你若真想解决问题\nM 最好等领事来\nM 他早上才上班\nM 我很抱歉\nE\nM 那我自己来搞定\nM 你兄弟\nM 关在哪个监狱?\nM 索纳监狱\nE\nM 怎么了?\nM 那里关的都是最穷凶极恶的罪犯\nM 别的监狱都不收\n```\n\n.conv 语料文件中：E 是分隔符 M 表示会话。因为我是使用输入list 的方式训练数据，这时我可以以分隔符E为分隔，将一段对话放入一个list中，那么上述例子中的训练数据应该被格式化为：\n\n```python\nconvs = [\n    [\n       '你得想想办法 我弟弟是无辜的',\n       '他可是美国公民啊',\n       '对此我也无能为力',\n       '你当然能',\n       '再去犯罪现场看看 定能证实清白',\n       '你看 我不过是个夜间办事员而已',\n       '你若真想解决问题',\n       '最好等领事来',\n       '他早上才上班',\n       '我很抱歉'\n    ],\n    [\n       '那我自己来搞定',\n       '你兄弟',\n       '关在哪个监狱?',\n       '索纳监狱',\n    ],\n    [\n       '怎么了?',\n       '那里关的都是最穷凶极恶的罪犯',\n       '别的监狱都不收',\n    ]\n]\n```\n\n导入训练数据的脚本如下：\n```python\nfrom chatterbot import ChatBot\nfrom chatterbot.trainers import ListTrainer\n\n# 初始化聊天机器人\nmomo = ChatBot(\n    'Momo',\n    storage_adapter='chatterbot.storage.MongoDatabaseAdapter', # 使用mongo存储数据\n    logic_adapters=[ # 指定逻辑处理模块\n            \"chatterbot.logic.BestMatch\",\n            \"chatterbot.logic.MathematicalEvaluation\",\n            \"chatterbot.logic.TimeLogicAdapter\",\n        ],\n    input_adapter='chatterbot.input.VariableInputTypeAdapter',\n    output_adapter='chatterbot.output.OutputAdapter',\n    database='chatterbot', # 指定数据库\n    read_only=True\n)\n\n# 读取.conv 数据文件，因为我服务器配置较低，所以选择了一个内容较少的文件\n# 这个函数是一个生成器\ndef read_conv(filename='prisonb.conv'):\n    with open(filename, 'rt') as f:\n        conv = []\n        # 逐行读取\n        for line in f:\n            _line = line.replace('\\n', '').strip()  # 预处理字符串 去掉首位空格\n            if _line == 'E':  # 如果是分隔符 表示对话结束 返回对话列表\n                yield conv\n                conv = []  # 重置对话列表\n            else:  # 不是分隔符则将内容加入对话列表\n                c = _line.split()[-1]  # 其实这里如果对话中包含空格 对话数据会不完整，应该只去掉M和开头的空格\n                conv.append(c)\n\n\ndef traine_momo():\n    for conv in read_conv():\n        print(conv)\n        momo.set_trainer(ListTrainer) # 指定训练方式\n        momo.train(conv) # 训练数据\n\n\ndef main():\n    traine_momo()\n\n\nif __name__ == '__main__':\n    main()\n\n```\n\n这个脚本比较简单，只是简单的将数据从对话文件中读取出来，然后拼接为对话列表输入聊天机器人。\n\n> 由于这里对话大部分都是多行数据，聊天机器人匹配结果时运算量会大幅提升，我单核cpu的服务器在导入一个700k 的语料文件后每次聊天都会让cpu飚到100%！🤦‍ 无奈之下只能删掉大半数据。\n\n对话示例如图:\n\n![使用电影台词训练后的聊天截图](http://media.gusibi.mobi/kF27RcGVBL3xDf4kKhJQCbXAB3qgc_HXpYy28ykdfudK0B52Z5nvm63m0wbiKlCA)\n\n导入电影台词后，虽然训练数据大幅提升，但是你会发现聊天机器人开始答非所问了，这是因为聊天数据噪音太大，对白也有点问题。\n\n### 使用图灵机器人训练\n\n之前在对比聊天机器人实现方案的时候，我试用过 [图灵机器人](http://www.tuling123.com)，他们号称中文语境下智能渡最高的机器人大脑。他们的对话比我自己的搭建的靠谱很多，那么我们是不是可以利用一下他的数据呢？\n\n我的方案是这样的，在图灵机器人新建两个机器人教练A 和 教练B，让两个机器人互相对话，然后把训练数据导入chatterbot。\n\n1. 打开 [http://www.tuling123.com](http://www.tuling123.com)，注册账号\n2. 新建两个机器人（免费用户最多可以创建5个，每个机器人每天最多请求5000次）\n3. 调用对话API，让两个机器人互相聊天\n\n建好机器人后的界面：\n\n![机器人示例🤖](http://media.gusibi.mobi/3WZasRFKofxaVIV55WJy2TNRYeUlf7qcD5ijEpYZqwJctWzuAqu3HRBi8VRZSFYz)\n\n训练示例代码如下：\n\n```python\n# tuling_trainer.py\nimport sys\nfrom time import sleep\n\nfrom chatterbot import ChatBot\nfrom chatterbot.trainers import ListTrainer\n\nimport requests\n\nAPI_URL = \"http://www.tuling123.com/openapi/api\"\nAPI_KEY0 = \"\"  # 机器人1 的key\nAPI_KEY1 = \"\"  # 机器人2 的key\n\n# 初始化chatterbot\nmomo = ChatBot(\n    'Momo',\n    storage_adapter='chatterbot.storage.MongoDatabaseAdapter',\n    logic_adapters=[\n            \"chatterbot.logic.BestMatch\",\n            \"chatterbot.logic.MathematicalEvaluation\",\n            \"chatterbot.logic.TimeLogicAdapter\",\n        ],\n    input_adapter='chatterbot.input.VariableInputTypeAdapter',\n    output_adapter='chatterbot.output.OutputAdapter',\n    database='chatterbot',\n    read_only=True\n)\n\n# 请求图灵机器人接口\ndef ask(question, key, name):\n    params = {\n        \"key\": key,\n        \"userid\": name,\n        \"info\": question,\n    }\n    res = requests.post(API_URL, json=params)\n    result = res.json()\n    answer = result.get('text')\n    return answer\n\n\ndef A(bsay):\n    # 打印 A 和 B 的对话内容\n    print('B:', bsay)\n    answer = ask(bsay, API_KEY0, 'momo123')\n    print('A:', answer)\n    return answer\n\n\ndef B(asay):\n    print('A:', asay)\n    answer = ask(asay, API_KEY1, 'momo456')\n    print('B', answer)\n    return answer\n\n\ndef tariner(asay):\n    momo.set_trainer(ListTrainer)  # 设置处理方式\n    while True:  # 两个机器人训练的主循环\n        conv = []\n        conv.append(asay) # 先把 A 说的第一句加入到对话列表\n        bsay = B(asay)  # A 先问 B\n        conv.append(bsay) # 将B 的回答加入到对话列表\n        momo.train(conv) # 将对话用于训练\n        print(conv)\n        conv = []\n        conv.append(bsay) # 用B的对话 去问 A 步骤和上述方式一致\n        asay = A(bsay)\n        conv.append(asay)\n        momo.train(conv)\n        print(conv)\n        sleep(5)  # 控制频率\n\n\ndef main(asay):\n    tariner(asay)\n\n\nif __name__ == '__main__':\n    main(*sys.argv[1:])  # 接收参数作为开始的第一句话\n    \n# 执行脚本\n# python tuling_trainer.py 你好？\n\n```\n\n使用图灵聊天机器人训练的时候是需要监测的，因为如果两个机器人说的内容一样的时候，机器人可能会一直重复同一句话，直到调用次数耗尽，你需要看一下两个机器人的对话是否陷入了僵局。\n\n当然也可以在程序中加入判断，先多设定几个开始打招呼的句子，如果一句话连续出现多次的时候，换下一个句子纠正他们。\n\n以下是我训练了两天之后的结果：\n\n![对话示例](http://media.gusibi.mobi/wNM0i84JsmsgldhxUjV1TMHr_YwwM726brHr0tmSYS_cxAYWWIHQEvG-eTmBIRjJ)\n\n虽然还是答非所问，但是已经比之前像样了。\n\n> 图灵聊天机器人免费版每天可调用5000 次，如果觉得次数太少可以多新建几个轮流使用\n\n聊天机器人的配置及训练方式就到这里了，接下来介绍个更实用的功能，如何让微信公号变成图床。\n\n## 如何让微信公号化身图片上传助手\n\n在使用 `markdown` 格式来写文章的过程中，发现图片地址是一个比较麻烦的事情，每次贴图获取图片URL都是一个比较麻烦的过程。\n以我使用的七牛为例，获取图片地址的步骤如下：\n\n1. 登录七牛网站，打开存储空间>内容管理\n2. 上传文件\n3. 返回内容管理找到刚才上传的文件，获取外链\n\n按照这个步骤上传一张图片至少耗时半分钟。\n\n那能不能简化这个步骤呢？\n\n答案是`可以！`\n\n微信公号是可以发送图片消息的，我的做法是\n\n1. 将图片发送到公号\n2. 服务器获取触发图片消息的处理逻辑> 将图片使用七牛提供的`第三方资源抓取`API`另存到`，七牛存储空间\n3. 将设定好的图片地址返回给微信，发送到公号消息对话中\n\n示例如下图所示：\n\n![上传图片到七牛](http://media.gusibi.mobi/Eg5Idjmp3nLyufBVU2hzp6jNMdNoSWEYgKTqNG9BbqD6VrM4U5oN-gmJw3PaN-Yh)\n\n### 实现步骤\n\n* 注册个七牛账号\n* 新建存储空间\n* 在个人中心秘钥管理获取 AccessKey 和 SecreKey \n* pip install qiniu\n\n代码实现如下：\n\n```python\n# media.py\n# 图片抓取逻辑处理\nfrom qiniu import Auth, BucketManager\n\nfrom momo.settings import Config\n\ndef qiniu_auth():\n    access_key = str(Config.QINIU_ACCESS_TOKEN)\n    secret_key = str(Config.QINIU_SECRET_TOKEN)\n    auth = Auth(access_key, secret_key)\n    return auth\n    \ndef media_fetch(media_url, media_id):\n    '''抓取url的资源存储在库'''\n    auth = qiniu_auth()\n    bucket = BucketManager(auth)\n    bucket_name = Config.QINIU_BUCKET  # 存储空间名称\n    ret, info = bucket.fetch(media_url, bucket_name, media_id) # 参数依次是第三方图片地址，空间名称，目标文件名\n    if info.status_code == 200:\n        return True, media_id # 如果上传成功，返回文件名\n    return False, None\n```\n\n抓取第三方图片文档地址为：[第三方资源抓取 https://developer.qiniu.com/kodo/api/1263/fetch](https://developer.qiniu.com/kodo/api/1263/fetch)。\n\n微信图片消息处理逻辑代码：\n\n```python\nclass WXResponse(_WXResponse):\n\n    def _image_msg_handler(self):\n        media_id = self.data['MediaId']\n        picurl = None\n        if not picurl:\n            picurl = self.data['PicUrl']  # 从消息中获取图片地址\n        is_succeed, media_key = media_fetch(picurl, media_id) # 使用图片抓取接口将图片存储到七牛并获取图片文件名\n        if is_succeed:\n            qiniu_url = '{host}/{key}'.format(host=Config.QINIU_HOST, key=media_key) # 拼接图片地址\n        else:\n            qiniu_url = '图片上传失败，请重新上传'\n        self.reply_params['content'] = qiniu_url # 返回图片地址\n        self.reply = TextReply(**self.reply_params).render()\n```\n\n代码已开源道github，详细代码逻辑参考 [gusibi/momo: https://github.com/gusibi/momo/tree/chatterbot](https://github.com/gusibi/momo/blob/chatterbot/momo/views/mweixin.py)\n\n欢迎试用体验：\n\n* 请不要上传高清图片，微信会压缩损坏图片质量\n* 也不要上传太个人的图片，毕竟内容我能看到\n\n## 总结\n\n这一篇主要提供了两个训练 chatterbot 的思路，以及使用公号作为图片上传客户端提高上传图片的效率的解决方法。\n接下来公号还是继续开发，准备给公号加一个记账功能，促使自己养成记账的习惯。\n\n### 预告\n\n下一篇的公号DIY 将介绍 `记账的功能设计以及实现思路`。\n\n------\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "微信公号DIY：训练聊天机器人&公号变身图片上传工具",
        "date": "2017-07-08 15:34:53",
        "tags": [
          "python",
          "tutorial",
          "weixin",
          "公众号"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "weixin_mp_diy_image_upload"
    },
    {
      "content": "\n> 最近借用了女朋友的公号，感觉如果只是用来发文章，太浪费微信给提供的这些功能了。想了想，先从最简单的开始，做一个聊天机器人吧。\n\n使用Python实现聊天机器人的方案有多种：AIML、chatterBot以及图灵聊天机器人和微软小冰等。\n\n考虑到以后可能会做一些定制化的需求，这里我选择了`chatterBot`（[github 项目地址：https://github.com/gunthercox/ChatterBot](https://github.com/gunthercox/ChatterBot))。\n\nchatterbot是一款python接口的，基于一系列规则和机器学习算法完成的聊天机器人。具有结构清晰，可扩展性好，简单实用的特点。\n\n\n\nchatterBot 的工作流程如图：\n\n![chatterBot 工作流程](http://media.gusibi.mobi/l-OywTEmN9B6u_RevUWyUpAD9yeHyChmh55q7fIObhC82Wf9X-DTxCF6oGI4tqG7)\n\n1. 输入模块（input adapter）从终端或者API等输入源获取数据\n2. 输入源会被指定的逻辑处理模块（logic Adapter）分别处理，逻辑处理模块会匹配训练集中已知的最接近输入数据句子A，然后根据句子A去找到相关度最高的结果B，如果有多个逻辑处理模块返回了不同的结果，会返回一个相关度最高的结果。\n3. 输出模块（output adapter）将匹配到的结果返回给终端或者API。\n\n\n值得一说的是chatterBot 是一个模块化的项目，分为 input Adapter、logic Adapter、storage Adapter、output Adapter以及Trainer 模块。\n\nlogic Adapter是一个插件式设计，主进程在启动时会将用户定义的所有逻辑处理插件添加到logic context中，然后交MultiLogicAdapter 进行处理，MultiLogicAdapter 依次调用每个 logic Adapter，logic Adapter 被调用时先执行can_process 方式判断输入是否可以命中这个逻辑处理插件。比如”今天天气怎么样“这样的问题显然需要命中天气逻辑处理插件，这时时间逻辑处理插件的can_process 则会返回False。在命中后logic Adapter 负责计算出对应的回答（Statement对象）以及可信度（confidence），MultiLogicAdapter会取可信度最高的回答，并进入下一步。\n\n下面我们来看下 chatterBot 如何使用\n\n## chatterBot 安装&使用\n\n### 安装\n\nchatterBot 是使用Python编写的，可以使用 pip 安装：\n\n```bash\npip install chatterbot\n```\n\n> chatterBot 的中文对话要求Python3 以上版本，建议在Python3.x 环境下开发\n\n### 测试\n\n打开iPython，输入测试一下\n\n```bash\nIn [1]: from chatterbot import ChatBot  # import ChatBot\n\nIn [2]: momo = ChatBot('Momo', trainer='chatterbot.trainers.ChatterBotCorpusTrainer')\n/Users/gs/.virtualenvs/py3/lib/python3.6/site-packages/chatterbot/storage/jsonfile.py:26: UnsuitableForProductionWarning: The JsonFileStorageAdapter is not recommended for production environments.\n  self.UnsuitableForProductionWarning  # 这里storage adapter 默认使用的是 json 格式存储数据的，如果想在服务端部署，应该避免使用这种格式，因为实在是太慢了\n\nIn [3]: momo.train(\"chatterbot.corpus.chinese\")  # 指定训练集，这里我们使用中文\n\n# 下边是对话结果\nIn [4]: momo.get_response('你好')\nOut[4]: <Statement text:你好>\n\nIn [5]: momo.get_response('怎么了')\nOut[5]: <Statement text:没什么.>\n\nIn [6]: momo.get_response('你知道它的所有内容吗?')\nOut[6]: <Statement text:优美胜于丑陋.>\n\nIn [7]: momo.get_response('你是一个程序员吗?')\nOut[7]: <Statement text:我是个程序员>\n\nIn [8]: momo.get_response('你使用什么语言呢？')\nOut[8]: <Statement text:我经常使用 Python, Java 和 C++ .>\n```\n\n这时你已经可以和机器人对话了，不过现在由于训练数据太少，机器人只能返回简单的对话。\n> 这里是默认的中文对话训练数据 [中文训练数据地址：https://github.com/gunthercox/chatterbot-corpus/tree/master/chatterbot_corpus/data/chinese](https://github.com/gunthercox/chatterbot-corpus/tree/master/chatterbot_corpus/data/chinese)。\n\n那么我们怎么添加训练数据呢？\n\n### 训练机器人\n\nchatterBot 内置了training class，自带的方法有两种，一种是使用通过输入list 来训练，比如 [\"你好\", \"我不好\"]，后者是前者的回答，另一种是通过导入Corpus 格式的文件来训练。也支持自定义的训练模块，不过最终都是转为上述两种类型。\n\nchatterBot 通过调用 train() 函数训练，不过在这之前要先用 set_trainer() 来进行设置。例如：\n\n```bash\nIn [12]: from chatterbot.trainers import ListTrainer  # 导入训练模块的 ListTrainer 类\n\nIn [13]: momo.get_response('你叫什么?')  # 现在是答非所问，因为在这之前我们并没有训练过\nOut[13]: <Statement text:我在烤蛋糕.>\n\nIn [14]: momo.set_trainer(ListTrainer)  # 指定训练方式\n\nIn [15]: momo.train(['你叫什么?', '我叫魔魔！'])  # 训练\n\nIn [16]: momo.get_response('你叫什么?')  # 现在机器人已经可以回答了\nOut[16]: <Statement text:我叫魔魔！>\n```\n\n训练好的数据默认存在 ./database.db，这里使用的是 jsondb。\n\n对 chatterBot 的介绍先到这里，具体用法可以参考文档：[ChatterBot Tutorial：http://chatterbot.readthedocs.io/en/stable/tutorial.html](http://chatterbot.readthedocs.io/en/stable/tutorial.html)\n\n接下来，介绍如何在项目中使用 chatterBot。\n\n## 使用 Sanic 创建项目\n\nSanic 是一个和类Flask 的基于Python3.5+的web框架，它编写的代码速度特别快。\n\n除了像Flask 以外，Sanic 还支持以异步请求的方式处理请求。这意味着你可以使用新的 async/await 语法，编写非阻塞的快速的代码。\n\n对 Sanic 不了解的可以参考我之前的一篇文章： [python web 框架 Sanci 快速入门](https://mp.weixin.qq.com/s?__biz=MzAwNjI5MjAzNw==&mid=2655752001&idx=1&sn=2c2e84f5f493514fdbff482a28dd7551&chksm=80b0b86bb7c7317df9d1c7b13411a231b91bb107de5e99c5379a3d9d072d5d3fb8117f364188#rd)，可以在公号输入 【sanic】获取文章地址。\n\n这里之所以使用 Sanic 是因为他和Flask 非常像，之前我一直使用Flask，并且它也是专门为Python3.5 写的，使用到了协程。\n\n首先建个项目，这里项目我已经建好了，项目结构如下：\n\n```sh\n.\n├── LICENSE\n├── README.md\n├── manage.py   # 运行文件 启动项目 使用 python manage.py 命令\n├── momo\n│   ├── __init__.py\n│   ├── app.py          # 创建app 模块\n│   ├── helper.py  \n│   ├── settings.py     # 应用配置\n│   └── views\n│       ├── __init__.py\n│       ├── hello.py    # 测试模块\n│       └── mweixin.py  # 微信消息处理模块\n├── requirements.txt\n└── supervisord.conf\n```\n源码我已经上传到github，有兴趣的可以看一下，也可以直接拉下来测试。\n[项目代码地址](https://github.com/gusibi/momo/tree/chatterbot)\n\n我们先重点看下 `hello.py` 文件 和 `helper.py `。\n\n```python\n# hello.py\n# -*- coding: utf-8 -*-\n\nfrom sanic import Sanic, Blueprint\nfrom sanic.views import HTTPMethodView\nfrom sanic.response import text\n\nfrom momo.helper import get_momo_answer  # 导入获取机器人回答获取函数\n\n\nblueprint = Blueprint('index', url_prefix='/')\n\n\nclass ChatBot(HTTPMethodView):\n    # 聊天机器人 http 请求处理逻辑\n    async def get(self, request):\n        ask = request.args.get('ask')\n        # 先获取url 参数值 如果没有值，返回 '你说啥'\n        if ask:\n            answer = get_momo_answer(ask)\n            return text(answer)\n        return text('你说啥?')\n\n\nblueprint.add_route(ChatBot.as_view(), '/momo')\n```\n\n```python\n# helper.py\nfrom chatterbot import ChatBot\n\nmomo_chat = ChatBot(\n    'Momo',\n    # 指定存储方式 使用mongodb 存储数据\n    storage_adapter='chatterbot.storage.MongoDatabaseAdapter',\n    # 指定 logic adpater 这里我们指定三个\n    logic_adapters=[\n        \"chatterbot.logic.BestMatch\", \n        \"chatterbot.logic.MathematicalEvaluation\",  # 数学模块\n        \"chatterbot.logic.TimeLogicAdapter\",   # 时间模块\n    ],\n    input_adapter='chatterbot.input.VariableInputTypeAdapter',\n    output_adapter='chatterbot.output.OutputAdapter',\n    database='chatterbot',\n    read_only=True\n)\n\n\ndef get_momo_answer(content):\n    # 获取机器人返回结果函数\n    response = momo_chat.get_response(content)\n    if isinstance(response, str):\n        return response\n    return response.text\n\n```\n运行命令 `python manage.py` 启动项目。\n\n在浏览器访问url： [http://0.0.0.0:8000/momo?ask=你是程序员吗](http://0.0.0.0:8000/momo?ask=你是程序员吗)\n\n![运行结果](http://media.gusibi.mobi/3l0HV4l5N473KqwM6C35IW78zP5j0qybSymjK4HHzeFj3KbMkH3jS7W_kpsF-EtX)\n\n到这里，我们已经启动了一个web 项目，可以通过访问url 的方式和机器人对话，是时候接入微信公号了！\n\n## 接入微信公众号\n\n### 前提\n\n1. 拥有一个可以使用的微信公众号（订阅号服务号都可以，如果没有，可以使用微信提供的测试账号）\n2. 拥有一个外网可以访问的服务器（vps 或公有云都可以 aws 新用户免费使用一年，可以试试）\n3. 服务器配置了python3 环境，（建议使用 virtualenvwrapper 配置虚拟环境）\n\n### 微信设置\n\n登录微信公众号： [https://mp.weixin.qq.com](https://mp.weixin.qq.com)\n\n#### 打开：开发>基本配置\n查看公号开发信息：\n\n![公号基本信息](http://media.gusibi.mobi/JZqW6bMs4_qRB-XnMoPZNMHWUh3uI3l482UTg6EbkrN0KZSisiloqhV4uCBuLPYP)\n\n#### 开启服务器配置：\n**设置请求url，这里是你配置的url（需要外网可访问，只能是80或443端口）**\n\n![开启服务器配置](http://media.gusibi.mobi/gx5Ssn4Taoq-BDMJ0Dty56ks7IkWR9ruCn5oMYuXEUMDeNj8YgCSM8caxI3AVzcu)\n填写token和EncodingAESKey，这里我选择的是兼容模式，既有明文方便调试，又有信息加密。\n\n![配置服务器](http://media.gusibi.mobi/CghRlbwDFA2-U2I9mOZZZitRiT-gRnj433UPHuRMh9jEEbUMuzE8PfrmCc9lZqNk)\n\n详细配置可以参考官方文档：[接入指南](https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1445241432)\n\n如果你的 `服务器地址` 已经配置完成，现在点击提交应该就成功了。如果没有成功我们接下来看怎么配置服务器地址。\n\n### 代码示例\n\n先看下 微信请求的视图代码：\n\n```python\n# -*- coding: utf-8 -*-\nfrom __future__ import unicode_literals\n\nfrom six import StringIO\n\nimport re\nimport xmltodict\nfrom chatterbot.trainers import ListTrainer\n\nfrom sanic import Blueprint\nfrom sanic.views import HTTPMethodView\nfrom sanic.response import text\nfrom sanic.exceptions import ServerError\n\nfrom weixin import WeixinMpAPI\nfrom weixin.lib.WXBizMsgCrypt import WXBizMsgCrypt\n\nfrom momo.settings import Config\n\nblueprint = Blueprint('weixin', url_prefix='/weixin')\n\n\nclass WXRequestView(HTTPMethodView):\n\n    def _get_args(self, request):\n        # 获取微信请求参数，加上token  拼接为完整的请求参数\n        params = request.raw_args\n        if not params:\n            raise ServerError(\"invalid params\", status_code=400)\n        args = {\n            'mp_token': Config.WEIXINMP_TOKEN,\n            'signature': params.get('signature'),\n            'timestamp': params.get('timestamp'),\n            'echostr': params.get('echostr'),\n            'nonce': params.get('nonce'),\n        }\n        return args\n\n    def get(self, request):\n        # 微信验证服务器这一步是get  请求，参数可以使用 request.raw_args 获取\n        args = self._get_args(request)\n        weixin = WeixinMpAPI(**args) # 这里我使用了 第三方包 python-weixin 可以直接实例化一个WeixinMpAPI对象\n        if weixin.validate_signature(): # 验证参数合法性\n            # 如果参数争取，我们将微信发过来的echostr参数再返回给微信，否则返回 fail\n            return text(args.get('echostr') or 'fail')\n        return text('fail')\n        \nblueprint.add_route(WXRequestView.as_view(), '/request')\n```\n这里处理微信请求我使用的是 我用python 写的 微信SDK [python-weixin](https://github.com/gusibi/python-weixin)，可以使用 pip 安装：\n\n```bash\npip install python-weixin\n```\n\n这个包最新版本对Python3 加密解密有点问题，可以直接从github 安装:\n\n```bash\npip install git+https://github.com/zongxiao/python-weixin.git@py3\n```\n\n然后更新 app.py 文件：\n\n```python\n# -*- coding: utf-8 -*-\nfrom sanic import Sanic\nfrom momo.settings import Config\n\n\ndef create_app(register_bp=True, test=False):\n    # 创建app    \n    app = Sanic(__name__)\n    if test:\n        app.config['TESTING'] = True\n    # 从object 导入配置\n    app.config.from_object(Config)\n    register_blueprints(app)\n    return app\n\n\ndef register_blueprints(app):\n    from momo.views.hello import blueprint as hello_bp\n    from momo.views.mweixin import blueprint as wx_bp\n    app.register_blueprint(hello_bp)\n    # 注册 wx_bp \n    app.register_blueprint(wx_bp)\n```\n\n详细代码参考github: [微信聊天机器人 momo](https://github.com/gusibi/momo/tree/chatterbot)\n\n## 接入聊天机器人\n\n现在我们公号已经接入了自己的服务，是时候接入微信聊天机器人。\n\n微信聊天机器人的工作流程如下：\n\n![微信聊天机器人工作流程](http://media.gusibi.mobi/p88CrkRItlwU7VXo7uihsd9DPV-vSexkuXqKuQ1ZJGlFrFT25AzhvkFh2Aqc6Ajn)\n\n看我们消息逻辑处理代码：\n\n```python\n# -*- coding: utf-8 -*-\nfrom __future__ import unicode_literals\n\nfrom six import StringIO\n\nimport re\nimport xmltodict\nfrom chatterbot.trainers import ListTrainer\n\nfrom sanic import Blueprint\nfrom sanic.views import HTTPMethodView\nfrom sanic.response import text\nfrom sanic.exceptions import ServerError\n\nfrom weixin import WeixinMpAPI\nfrom weixin.reply import TextReply\nfrom weixin.response import WXResponse as _WXResponse\nfrom weixin.lib.WXBizMsgCrypt import WXBizMsgCrypt\n\nfrom momo.settings import Config\nfrom momo.helper import validate_xml, smart_str, get_momo_answer\nfrom momo.media import media_fetch\n\n\nblueprint = Blueprint('weixin', url_prefix='/weixin')\n\nappid = smart_str(Config.WEIXINMP_APPID)\ntoken = smart_str(Config.WEIXINMP_TOKEN)\nencoding_aeskey = smart_str(Config.WEIXINMP_ENCODINGAESKEY)\n\n# 关注后自动返回的文案\nAUTO_REPLY_CONTENT = \"\"\"\nHi，朋友！\n这是我妈四月的公号，我是魔魔，我可以陪你聊天呦！\n我还能\"记账\"，输入\"记账\"会有惊喜呦！\n<a href=\"https://mp.weixin.qq.com/mp/profile_ext?action=home&__biz=MzAwNjI5MjAzNw==&scene=124#wechat_redirect\">历史记录</a>\n\"\"\"\n\n\nclass ReplyContent(object):\n\n    _source = 'value'\n\n    def __init__(self, event, keyword, content=None, momo=True):\n        self.momo = momo\n        self.event = event\n        self.content = content\n        self.keyword = keyword\n        if self.event == 'scan':\n            pass\n\n    @property\n    def value(self):\n        if self.momo:\n            answer = get_momo_answer(self.content)\n            return answer\n        return ''\n\n\nclass WXResponse(_WXResponse):\n\n    auto_reply_content = AUTO_REPLY_CONTENT\n\n    def _subscribe_event_handler(self):\n        # 关注公号后的处理逻辑\n        self.reply_params['content'] = self.auto_reply_content\n        self.reply = TextReply(**self.reply_params).render()\n\n    def _unsubscribe_event_handler(self):\n        # 取关后的处理逻辑，取关我估计会哭吧\n        pass\n\n    def _text_msg_handler(self):\n        # 文字消息处理逻辑 聊天机器人的主要逻辑\n        event_key = 'text'\n        content = self.data.get('Content')\n        reply_content = ReplyContent('text', event_key, content)\n        self.reply_params['content'] = reply_content.value\n        self.reply = TextReply(**self.reply_params).render()\n\n\nclass WXRequestView(HTTPMethodView):\n\n    def _get_args(self, request):\n        params = request.raw_args\n        if not params:\n            raise ServerError(\"invalid params\", status_code=400)\n        args = {\n            'mp_token': Config.WEIXINMP_TOKEN,\n            'signature': params.get('signature'),\n            'timestamp': params.get('timestamp'),\n            'echostr': params.get('echostr'),\n            'nonce': params.get('nonce'),\n        }\n        return args\n\n    def get(self, request):\n        args = self._get_args(request)\n        weixin = WeixinMpAPI(**args)\n        if weixin.validate_signature():\n            return text(args.get('echostr') or 'fail')\n        return text('fail')\n\n    def _get_xml(self, data):\n        post_str = smart_str(data)\n        # 验证xml 格式是否正确\n        validate_xml(StringIO(post_str))\n        return post_str\n\n    def _decrypt_xml(self, params, crypt, xml_str):\n        # 解密消息\n        nonce = params.get('nonce')\n        msg_sign = params.get('msg_signature')\n        timestamp = params.get('timestamp')\n        ret, decryp_xml = crypt.DecryptMsg(xml_str, msg_sign,\n                                           timestamp, nonce)\n        return decryp_xml, nonce\n\n    def _encryp_xml(self, crypt, to_xml, nonce):\n        # 加密消息\n        to_xml = smart_str(to_xml)\n        ret, encrypt_xml = crypt.EncryptMsg(to_xml, nonce)\n        return encrypt_xml\n\n    def post(self, request):\n        # 获取微信服务器发送的请求参数\n        args = self._get_args(request)\n        weixin = WeixinMpAPI(**args)\n        if not weixin.validate_signature(): # 验证参数合法性\n            raise AttributeError(\"Invalid weixin signature\")\n        xml_str = self._get_xml(request.body)  # 获取form data\n        crypt = WXBizMsgCrypt(token, encoding_aeskey, appid) \n        decryp_xml, nonce = self._decrypt_xml(request.raw_args, crypt, xml_str) # 解密\n        xml_dict = xmltodict.parse(decryp_xml)\n        xml = WXResponse(xml_dict)() or 'success' # 使用WXResponse 根据消息获取机器人返回值\n        encryp_xml = self._encryp_xml(crypt, xml, nonce) # 加密消息\n        return text(encryp_xml or xml) # 回应微信请求\n\n\nblueprint.add_route(WXRequestView.as_view(), '/request')\n\n```\n\n可以看到，我处理微信请求返回结果比较简单，也是使用的 python-weixin 包封装的接口，\n主要的处理逻辑是 WXResponse。\n\n这里需要注意的是，如果服务器在5秒内没有响应微信服务器会重试。为了加快响应速度，不要在服务器 将 chatterBot 的 storage adapter 设置为使用 jsondb。\n\n上边这些就是，微信聊天机器人的主要处理逻辑，我们运行服务，示例如下：\n\n![聊天示例图](http://media.gusibi.mobi/gdLue88YMxJcy0hDqcWntqUHl_ekWu99WXe_vbphQy5TetIuESae-M6lEaWw2WqP)\n\n可以看到这里聊天机器人也可以做简单的数学运算和报时，是因为我在上边指定处理逻辑的时候添加了数学模块和时间模块：\n\n```python\nmomo_chat = ChatBot(\n    'Momo',\n    # 指定存储方式 使用mongodb 存储数据\n    storage_adapter='chatterbot.storage.MongoDatabaseAdapter',\n    # 指定 logic adpater 这里我们指定三个\n    logic_adapters=[\n        \"chatterbot.logic.BestMatch\", \n        \"chatterbot.logic.MathematicalEvaluation\",  # 数学模块\n        \"chatterbot.logic.TimeLogicAdapter\",   # 时间模块\n    ],\n    input_adapter='chatterbot.input.VariableInputTypeAdapter',\n    output_adapter='chatterbot.output.OutputAdapter',\n    database='chatterbot',\n    read_only=True\n)\n```\n\n到这里，微信机器人的搭建就完成了，详细代码已经长传到了 [github: https://github.com/gusibi/momo/tree/chatterbot](https://github.com/gusibi/momo/tree/chatterbot)，感兴趣的可以参考一下。\n\n## 参考链接\n\n* [ChatterBot 项目地址：https://github.com/gunthercox/ChatterBot](https://github.com/gunthercox/ChatterBot)\n* [ChatterBot Tutorial：http://chatterbot.readthedocs.io/en/stable/tutorial.html](http://chatterbot.readthedocs.io/en/stable/tutorial.html)\n* [用Python快速实现一个聊天机器人：http://www.jianshu.com/p/d1333fde266f](http://www.jianshu.com/p/d1333fde266f)\n* [基于Python-ChatterBot搭建不同adapter的聊天机器人：https://ask.hellobi.com/blog/guodongwei1991/7626](https://ask.hellobi.com/blog/guodongwei1991/7626)\n* [擁有自動學習的 Python 機器人 - ChatterBot：https://kantai235.github.io/2017/03/16/ChatterBotTeaching/](https://kantai235.github.io/2017/03/16/ChatterBotTeaching/)\n* [使用 ChatterBot构建聊天机器人：https://www.biaodianfu.com/chatterbot.html](https://www.biaodianfu.com/chatterbot.html)\n* [python-weixin sdk: https://github.com/gusibi/python-weixin](https://github.com/gusibi/python-weixin)\n\n## 预告\n\n这里，聊天机器人还是比较简单的只能回复简单的对话，下一篇将要结束如何在公号训练机器人以及一个更实用的功能，如何让公号变成一个博客写作助手。\n\n------\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "微信公号DIY：一小时搭建微信聊天机器人",
        "date": "2017-07-05 15:47:13",
        "tags": [
          "python",
          "tutorial",
          "weixin",
          "公众号"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "weixin_chatbot_step_by_step"
    },
    {
      "content": "\n> 这一篇是Python并发的第四篇，主要介绍进程和线程的定义，Python线程和全局解释器锁以及Python如何使用thread模块处理并发，这篇文章之前发过，但是前几篇介绍到了并发，就顺便再发一下组成一个系列\n\n## 引言&动机\n\n考虑一下这个场景，我们有10000条数据需要处理，处理每条数据需要花费1秒，但读取数据只需要0.1秒，每条数据互不干扰。该如何执行才能花费时间最短呢？\n\n在多线程(MT)编程出现之前，电脑程序的运行由一个执行序列组成，执行序列按顺序在主机的中央处理器(CPU)中运行。无论是任务本身要求顺序执行还是整个程序是由多个子任务组成，程序都是按这种方式执行的。即使子任务相互独立，互相无关(即，一个子任务的结果不影响其它子 任务的结果)时也是这样。\n\nHUGOMORE42\n\n对于上边的问题，如果使用一个执行序列来完成，我们大约需要花费 10000*0.1 + 10000 = 11000 秒。这个时间显然是太长了。\n\n那我们有没有可能在执行计算的同时取数据呢？或者是同时处理几条数据呢？如果可以，这样就能大幅提高任务的效率。这就是多线程编程的目的。\n\n对于本质上就是异步的， 需要有多个并发事务，各个事务的运行顺序可以是不确定的，随机的，不可预测的问题，多线程是最理想的解决方案。这样的任务可以被分成多个执行流，每个流都有一个要完成的目标，然后将得到的结果合并，得到最终的结果。\n\n## 线程和进程\n\n### 什么是进程\n\n进程(有时被称为重量级进程)是程序的一次 执行。每个进程都有自己的地址空间，内存，数据栈以及其它记录其运行轨迹的辅助数据。操作系 统管理在其上运行的所有进程，并为这些进程公平地分配时间。进程也可以通过 fork 和 spawn 操作 来完成其它的任务。不过各个进程有自己的内存空间，数据栈等，所以只能使用进程间通讯(IPC)， 而不能直接共享信息。\n\n### 什么是线程\n\n线程(有时被称为轻量级进程)跟进程有些相似，不同的是，所有的线程运行在同一个进程中， 共享相同的运行环境。它们可以想像成是在主进程或“主线程”中并行运行的“迷你进程”。\n\n线程状态如图\n\n![线程状态如图](http://omuo4kh1k.bkt.clouddn.com/python-thread-status.png)\n\n\n线程有开始，顺序执行和结束三部分。它有一个自己的指令指针，记录自己运行到什么地方。 线程的运行可能被抢占(中断)，或暂时的被挂起(也叫睡眠)，让其它的线程运行，这叫做让步。 一个进程中的各个线程之间共享同一片数据空间，所以线程之间可以比进程之间更方便地共享数据以及相互通讯。\n\n当然，这样的共享并不是完全没有危险的。如果多个线程共同访问同一片数据，则由于数据访 问的顺序不一样，有可能导致数据结果的不一致的问题。这叫做竞态条件(race condition)。\n\n线程一般都是并发执行的，不过在单 CPU 的系统中，真正的并发是不可能的，每个线程会被安排成每次只运行一小会，然后就把 CPU 让出来，让其它的线程去运行。由于有的函数会在完成之前阻塞住，在没有特别为多线程做修改的情 况下，这种“贪婪”的函数会让 CPU 的时间分配有所倾斜。导致各个线程分配到的运行时间可能不 尽相同，不尽公平。\n\n## Python、线程和全局解释器锁\n\n### 全局解释器锁(GIL)\n\n首先需要明确的一点是GIL并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念。就好比C++是一套语言（语法）标准，但是可以用不同的编译器来编译成可执行代码。同样一段代码可以通过CPython，PyPy，Psyco等不同的Python执行环境来执行（其中的JPython就没有GIL）。\n\n那么CPython实现中的GIL又是什么呢？GIL全称Global Interpreter Lock为了避免误导，我们还是来看一下官方给出的解释：\n\n> In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple native threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.)\n\n尽管Python完全支持多线程编程， 但是解释器的C语言实现部分在完全并行执行时并不是线程安全的。 实际上，解释器被一个全局解释器锁保护着，它确保任何时候都只有一个Python线程执行。\n\n在多线程环境中，Python 虚拟机按以下方式执行:\n\n1. 设置GIL\n2. 切换到一个线程去执行\n3. 运行\n  - 指定数量的字节码指令\n  - 线程主动让出控制（可以调用time.sleep(0))\n4. 把线程设置完睡眠状态\n5. 解锁GIL\n6. 再次重复以上步骤\n\n> 对所有面向 I/O 的(会调用内建的操作系统 C 代码的)程序来说，GIL 会在这个 I/O 调用之 前被释放，以允许其它的线程在这个线程等待 I/O 的时候运行。如果某线程并未使用很多 I/O 操作， 它会在自己的时间片内一直占用处理器(和 GIL)。也就是说，I/O 密集型的 Python 程序比计算密集 型的程序更能充分利用多线程环境的好处。\n\n### 退出线程\n\n当一个线程结束计算，它就退出了。线程可以调用 thread.exit()之类的退出函数，也可以使用 Python 退出进程的标准方法，如 sys.exit()或抛出一个 SystemExit 异常等。不过，你不可以直接 “杀掉”(\"kill\")一个线程。\n\n### 在 Python 中使用线程\n\n在 Win32 和 Linux, Solaris, MacOS, \\*BSD 等大多数类 Unix 系统上运行时，Python 支持多线程 编程。Python 使用 POSIX 兼容的线程，即 pthreads。\n\n默认情况下，只要在解释器中\n\n```\n>> import thread\n```\n\n如果没有报错，则说明线程可用。\n\n### Python 的 threading 模块\n\nPython  供了几个用于多线程编程的模块，包括 thread, threading 和 Queue 等。thread 和 threading 模块允许程序员创建和管理线程。thread 模块 供了基本的线程和锁的支持，而 threading  供了更高级别，功能更强的线程管理的功能。Queue 模块允许用户创建一个可以用于多个线程之间 共享数据的队列数据结构。\n\n##### 核心 示:避免使用 thread 模块\n\n出于以下几点考虑，我们不建议您使用 thread 模块。\n\n1. 更高级别的 threading 模块更为先 进，对线程的支持更为完善，而且使用 thread 模块里的属性有可能会与 threading 出现冲突。其次， 低级别的 thread 模块的同步原语很少(实际上只有一个)，而 threading 模块则有很多。\n2. 对于你的进程什么时候应该结束完全没有控制，当主线程结束 时，所有的线程都会被强制结束掉，没有警告也不会有正常的清除工作。我们之前说过，至少 threading 模块能确保重要的子线程退出后进程才退出。\n\n\n## thread 模块\n\n除了产生线程外，thread 模块也提供了基本的同步数 据结构锁对象(lock object，也叫原语锁，简单锁，互斥锁，互斥量，二值信号量)。\n\nthread 模块函数\n\n* start_new_thread(function, args, kwargs=None)：产生一个新的线程，在新线程中用指定的参数和可选的 kwargs 来调用这个函数。\n* allocate_lock()：分配一个 LockType 类型的锁对象\n* exit()：让线程退出\n* acquire(wait=None)：尝试获取锁对象\n* locked()：如果获取了锁对象返回 True，否则返回 False\n* release()：释放锁\n\n下面是一个使用 thread 的例子：\n\n``` python\nimport thread\nfrom time import sleep, time\n\n\ndef loop(num):\n    print('start loop at:', time())\n    sleep(num)\n    print('loop done at:', time())\n\n\ndef loop1(num):\n    print('start loop 1 at:', time())\n    sleep(num)\n    print('loop 1 done at:', time())\n\n\ndef main():\n    print('starting at:', time())\n    thread.start_new_thread(loop, (4,))\n    thread.start_new_thread(loop1, (5,))\n    sleep(6)\n    print('all DONE at:', time())\n\nif __name__ == '__main__':\n    main()\n\n('starting at:', 1489387024.886667)\n('start loop at:', 1489387024.88705)\n('start loop 1 at:', 1489387024.887277)\n('loop done at:', 1489387028.888182)\n('loop 1 done at:', 1489387029.888904)\n('all DONE at:', 1489387030.889918)\n```\n\nstart_new_thread()要求一定要有前两个参数。所以，就算我们想要运行的函数不要参数，也要传一个空的元组。\n为什么要加上sleep(6)这一句呢? 因为，如果我们没有让主线程停下来，那主线程就会运行下一条语句，显示 “all done”，然后就关闭运行着 loop()和 loop1()的两个线程，退出了。\n\n我们有没有更好的办法替换使用sleep() 这种不靠谱的同步方式呢？答案是使用锁，使用了锁，我们就可以在两个线程都退出之后马上退出。\n\n\n``` python\n#! -*- coding: utf-8 -*-\n\nimport thread\nfrom time import sleep, time\n\nloops = [4, 2]\n\ndef loop(nloop, nsec, lock):\n    print('start loop %s at: %s' % (nloop, time()))\n    sleep(nsec)\n    print('loop %s done at: %s' % (nloop, time()))\n    # 每个线程都会被分配一个事先已经获得的锁，在 sleep()的时间到了之后就释放 相应的锁以通知主线程，这个线程已经结束了。\n    lock.release()\n\n\ndef main():\n    print('starting at:', time())\n    locks = []\n    nloops = range(len(loops))\n\n    for i in nloops:\n        # 调用 thread.allocate_lock()函数创建一个锁的列表\n        lock = thread.allocate_lock()\n        # 分别调用各个锁的 acquire()函数获得, 获得锁表示“把锁锁上”\n        lock.acquire()\n        locks.append(lock)\n\n    for i in nloops:\n        # 创建线程，每个线程都用各自的循环号，睡眠时间和锁为参数去调用 loop()函数\n        thread.start_new_thread(loop, (i, loops[i], locks[i]))\n\n    for i in nloops:\n        # 在线程结束的时候，线程要自己去做解锁操作\n        # 当前循环只是坐在那一直等(达到暂停主 线程的目的)，直到两个锁都被解锁为止才继续运行。\n        while locks[i].locked(): pass\n\n    print('all DONE at:', time())\n\nif __name__ == '__main__':\n    main()\n\n```\n\n为什么我们不在创建锁的循环里创建线程呢?有以下几个原因:\n1. 我们想到实现线程的同步，所以要让“所有的马同时冲出栅栏”。\n2. 获取锁要花一些时间，如果你的 线程退出得“太快”，可能会导致还没有获得锁，线程就已经结束了的情况。\n\n## threading 模块\n\nthreading 模块不仅提供了 Thread 类，还提供了各种非常好用的同步机制。\n\n下面是threading 模块里所有的对象：\n\n1. Thread： 表示一个线程的执行的对象\n2. Lock： 锁原语对象(跟 thread 模块里的锁对象相同)\n3. RLock： 可重入锁对象。使单线程可以再次获得已经获得了的锁(递归锁定)。\n4. Condition： 条件变量对象能让一个线程停下来，等待其它线程满足了某个“条件”。 如，状态的改变或值的改变。\n5. Event： 通用的条件变量。多个线程可以等待某个事件的发生，在事件发生后， 所有的线程都会被激活。\n6. Semaphore： 为等待锁的线程 供一个类似“等候室”的结构\n7. BoundedSemaphore： 与 Semaphore 类似，只是它不允许超过初始值\n8. Timer： 与 Thread 相似，只是，它要等待一段时间后才开始运行。\n\n#### 守护线程\n\n另一个避免使用 thread 模块的原因是，它不支持守护线程。当主线程退出时，所有的子线程不 论它们是否还在工作，都会被强行退出。有时，我们并不期望这种行为，这时，就引入了守护线程 的概念\nthreading 模块支持守护线程，它们是这样工作的:守护线程一般是一个等待客户请求的服务器， 如果没有客户 出请求，它就在那等着。如果你设定一个线程为守护线程，就表示你在说这个线程 是不重要的，在进程退出的时候，不用等待这个线程退出。\n如果你的主线程要退出的时候，不用等待那些子线程完成，那就设定这些线程的 daemon 属性。 即，在线程开始(调用 thread.start())之前，调用 setDaemon()函数设定线程的 daemon 标志 (thread.setDaemon(True))就表示这个线程“不重要”\n如果你想要等待子线程完成再退出，那就什么都不用做，或者显式地调用 thread.setDaemon(False)以保证其 daemon 标志为 False。你可以调用 thread.isDaemon()函数来判 断其 daemon 标志的值。新的子线程会继承其父线程的 daemon 标志。整个 Python 会在所有的非守护 线程退出后才会结束,即进程中没有非守护线程存在的时候才结束。\n\n### Thread 类\n\nThread类提供了以下方法:\n\n* run(): 用以表示线程活动的方法。\n* start():启动线程活动。\n* join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。\n* is_alive(): 返回线程是否活动的。\n* name(): 设置/返回线程名。\n* daemon(): 返回/设置线程的 daemon 标志，一定要在调用 start()函数前设置\n\n用 Thread 类，你可以用多种方法来创建线程。我们在这里介绍三种比较相像的方法。\n\n* 创建一个Thread的实例，传给它一个函数\n* 创建一个Thread的实例，传给它一个可调用的类对象\n* 从Thread派生出一个子类，创建一个这个子类的实例\n\n下边是三种不同方式的创建线程的示例：\n\n```python\n#! -*- coding: utf-8 -*-\n\n# 创建一个Thread的实例，传给它一个函数\n\nimport threading\nfrom time import sleep, time\n\nloops = [4, 2]\n\ndef loop(nloop, nsec, lock):\n    print('start loop %s at: %s' % (nloop, time()))\n    sleep(nsec)\n    print('loop %s done at: %s' % (nloop, time()))\n    # 每个线程都会被分配一个事先已经获得的锁，在 sleep()的时间到了之后就释放 相应的锁以通知主线程，这个线程已经结束了。\n\n\ndef main():\n    print('starting at:', time())\n    threads = []\n    nloops = range(len(loops))\n\n    for i in nloops:\n        t = threading.Thread(target=loop, args=(i, loops[i]))\n        threads.append(t)\n\n    for i in nloops:\n        # start threads\n        threads[i].start()\n\n    for i in nloops:\n        # wait for all\n        # join()会等到线程结束，或者在给了 timeout 参数的时候，等到超时为止。\n        # 使用 join()看上去 会比使用一个等待锁释放的无限循环清楚一些(这种锁也被称为\"spinlock\")\n        threads[i].join()  # threads to finish\n\n    print('all DONE at:', time())\n\nif __name__ == '__main__':\n    main()\n```\n与传一个函数很相似的另一个方法是在创建线程的时候，传一个可调用的类的实例供线程启动 的时候执行——这是多线程编程的一个更为面向对象的方法。相对于一个或几个函数来说，由于类 对象里可以使用类的强大的功能，可以保存更多的信息，这种方法更为灵活\n\n```python\n#! -*- coding: utf-8 -*-\n\n# 创建一个 Thread 的实例，传给它一个可调用的类对象\n\nfrom threading import Thread\nfrom time import sleep, time\n\n\nloops = [4, 2]\n\n\nclass ThreadFunc(object):\n\n    def __init__(self, func, args, name=\"\"):\n        self.name = name\n        self.func = func\n        self.args = args\n\n    def __call__(self):\n        # 创建新线程的时候，Thread 对象会调用我们的 ThreadFunc 对象，这时会用到一个特殊函数 __call__()。\n        self.func(*self.args)\n\n\ndef loop(nloop, nsec):\n    print('start loop %s at: %s' % (nloop, time()))\n    sleep(nsec)\n    print('loop %s done at: %s' % (nloop, time()))\n\n\ndef main():\n    print('starting at:', time())\n    threads = []\n    nloops = range(len(loops))\n\n    for i in nloops:\n        t = Thread(target=ThreadFunc(loop, (i, loops[i]), loop.__name__))\n        threads.append(t)\n\n    for i in nloops:\n        # start threads\n        threads[i].start()\n\n    for i in nloops:\n        # wait for all\n        # join()会等到线程结束，或者在给了 timeout 参数的时候，等到超时为止。\n        # 使用 join()看上去 会比使用一个等待锁释放的无限循环清楚一些(这种锁也被称为\"spinlock\")\n        threads[i].join()  # threads to finish\n\n    print('all DONE at:', time())\n\n\nif __name__ == '__main__':\n    main()\n\n```\n\n最后一个例子介绍如何子类化 Thread 类，这与上一个例子中的创建一个可调用的类非常像。使用子类化创建线程(第 29-30 行)使代码看上去更清晰明了。\n\n```python\n#! -*- coding: utf-8 -*-\n\n# 创建一个 Thread 的实例，传给它一个可调用的类对象\n\nfrom threading import Thread\nfrom time import sleep, time\n\n\nloops = [4, 2]\n\n\nclass MyThread(Thread):\n\n    def __init__(self, func, args, name=\"\"):\n        super(MyThread, self).__init__()\n        self.name = name\n        self.func = func\n        self.args = args\n\n    def getResult(self):\n        return self.res\n\n    def run(self):\n        # 创建新线程的时候，Thread 对象会调用我们的 ThreadFunc 对象，这时会用到一个特殊函数 __call__()。\n        print 'starting', self.name, 'at:', time()\n        self.res = self.func(*self.args)\n        print self.name, 'finished at:', time()\n\n\n\ndef loop(nloop, nsec):\n    print('start loop %s at: %s' % (nloop, time()))\n    sleep(nsec)\n    print('loop %s done at: %s' % (nloop, time()))\n\n\ndef main():\n    print('starting at:', time())\n    threads = []\n    nloops = range(len(loops))\n\n    for i in nloops:\n        t = MyThread(loop, (i, loops[i]), loop.__name__)\n        threads.append(t)\n\n    for i in nloops:\n        # start threads\n        threads[i].start()\n\n    for i in nloops:\n        # wait for all\n        # join()会等到线程结束，或者在给了 timeout 参数的时候，等到超时为止。\n        # 使用 join()看上去 会比使用一个等待锁释放的无限循环清楚一些(这种锁也被称为\"spinlock\")\n        threads[i].join()  # threads to finish\n\n    print('all DONE at:', time())\n\n\nif __name__ == '__main__':\n    main()\n\n```\n\n#### 下载国旗的例子\n\n下面，我们接我们之前按之前并发的套路，用实现一下使用 threading 并发下载国旗\n\n```python\n# python3\n\nimport threading\nfrom threading import Thread\n\nfrom flags import save_flag, show, main, get_flag\n\n\nclass MyThread(Thread):\n\n    def __init__(self, func, args, name=\"\"):\n        super(MyThread, self).__init__()\n        self.name = name\n        self.func = func\n        self.args = args\n\n    def getResult(self):\n        return self.res\n\n    def run(self):\n        # 创建新线程的时候，Thread 对象会调用我们的 ThreadFunc 对象，这时会用到一个特殊函数 __call__()。\n        self.res = self.func(*self.args)\n\n\ndef download_one(cc):  # <3>\n    image = get_flag(cc)\n    show(cc)\n    save_flag(image, cc.lower() + '.gif')\n    return cc\n\n\ndef download_many(cc_list):\n    threads = []\n    for cc in cc_list:\n        thread = MyThread(download_one, (cc, ), download_one.__name__)\n        threads.append(thread)\n\n    for thread in threads:\n        # 启动线程\n        thread.start()\n\n    for thread in threads:\n        # wait for all\n        # join()会等到线程结束，或者在给了 timeout 参数的时候，等到超时为止。\n        # 使用 join()看上去 会比使用一个等待锁释放的无限循环清楚一些(这种锁也被称为\"spinlock\")\n        thread.join()\n\n    return len(list(threads))  # <7>\n\n\nif __name__ == '__main__':\n    main(download_many)\n```\n\n执行代码发现和使用协程相比速度基本一致。\n\n除了各种同步对象和线程对象外，threading 模块还 供了一些函数。\n\n* active_count(): 当前活动的线程对象的数量\n* current_thread(): 返回当前线程对象\n* enumerate(): 返回当前活动线程的列表\n* settrace(func): 为所有线程设置一个跟踪函数\n* setprofile(func): 为所有线程设置一个 profile 函数\n\n### Lock & RLock\n\n原语锁定是一个同步原语，状态是锁定或未锁定。两个方法acquire()和release() 用于加锁和释放锁。\nRLock 可重入锁是一个类似于Lock对象的同步原语，但同一个线程可以多次调用。\n\nLock 不支持递归加锁，也就是说即便在同 线程中，也必须等待锁释放。通常建议改  RLock， 它会处理 \"owning thread\" 和 \"recursion level\" 状态，对于同 线程的多次请求锁 为，只累加\n计数器。每次调 release() 将递减该计数器，直到 0 时释放锁，因此 acquire() 和 release() 必须 要成对出现。\n\n```python\n\nfrom time import sleep\nfrom threading import current_thread, Thread\n\nlock = Rlock()\n\ndef show():\n    with lock:\n        print current_thread().name, i\n        sleep(0.1)\n\ndef test():\n    with lock:\n        for i in range(3):\n            show(i)\n\nfor i in range(2):\n    Thread(target=test).start()\n```\n\n### Event\n\n事件用于在线程间通信。一个线程发出一个信号，其他一个或多个线程等待。\nEvent 通过通过 个内部标记来协调多线程运 。 法 wait() 阻塞线程执 ，直到标记为 True。 set() 将标记设为 True，clear() 更改标记为 False。isSet() 用于判断标记状态。\n\n```python\nfrom threading import Event\n\ndef test_event():\n    e = Event()\n    def test():\n        for i in range(5):\n            print 'start wait'\n            e.wait()\n            e.clear()  # 如果不调用clear()，那么标记一直为 True，wait()就不会发生阻塞行为\n            print i\nThread(target=test).start()\nreturn e\n\n\ne = test_event()\n```\n\n### Condition\n\n条件变量和 Lock 参数一样，也是一个，也是一个同步原语，当需要线程关注特定的状态变化或事件的发生时使用这个锁定。\n\n可以认为，除了Lock带有的锁定池外，Condition还包含一个等待池，池中的线程处于状态图中的等待阻塞状态，直到另一个线程调用notify()/notifyAll()通知；得到通知后线程进入锁定池等待锁定。\n\n构造方法：\nCondition([lock/rlock])\n\nCondition 有以下这些方法：\n* acquire([timeout])/release(): 调用关联的锁的相应方法。\n* wait([timeout]): 调用这个方法将使线程进入Condition的等待池等待通知，并释放锁。使用前线程必须已获得锁定，否则将抛出异常。\n* notify(): 调用这个方法将从等待池挑选一个线程并通知，收到通知的线程将自动调用acquire()尝试获得锁定（进入锁定池）；其他线程仍然在等待池中。调用这个方法不会释放锁定。使用前线程必须已获得锁定，否则将抛出异常。\n* notifyAll(): 调用这个方法将通知等待池中所有的线程，这些线程都将进入锁定池尝试获得锁定。调用这个方法不会释放锁定。使用前线程必须已获得锁定，否则将抛出异常。\n\n```python\nfrom threading import Condition, current_thread, Thread\n\ncon = Condition()\n\ndef tc1():\n    with con:\n        for i in range(5):\n            print current_thread().name, i\n            sleep(0.3)\n            if i == 3:\n                con.wait()\n\n\ndef tc2():\n    with con:\n        for i in range(5):\n            print current_thread().name, i\n            sleep(0.1)\n            con.notify()\n\nThread(target=tc1).start()\nThread(target=tc2).start()\n\nThread-1 0\nThread-1 1\nThread-1 2\nThread-1 3    # 让出锁\nThread-2 0\nThread-2 1\nThread-2 2\nThread-2 3\nThread-2 4\nThread-1 4    # 重新获取锁，继续执\n\n```\n\n只有获取锁的线程才能调用 wait() 和 notify()，因此必须在锁释放前调用。\n当 wait() 释放锁后，其他线程也可进入 wait 状态。notifyAll() 激活所有等待线程，让它们去抢锁然后完成后续执行。\n\n\n### 生产者-消费者问题和 Queue 模块\n\n现在我们用一个经典的(生产者消费者)例子来介绍一下 Queue模块。\n\n生产者消费者的场景是： 生产者生产货物，然后把货物放到一个队列之类的数据结构中，生产货物所要花费的时间无法预先确定。消费者消耗生产者生产的货物的时间也是不确定的。\n\n常用的 Queue 模块的属性:\n\n* queue(size): 创建一个大小为size的Queue对象。\n* qsize(): 返回队列的大小(由于在返回的时候，队列可能会被其它线程修改，所以这个值是近似值)\n* empty(): 如果队列为空返回 True，否则返回 False\n* full(): 如果队列已满返回 True，否则返回 False\n* put(item,block=0): 把item放到队列中，如果给了block(不为0)，函数会一直阻塞到队列中有空间为止\n* get(block=0): 从队列中取一个对象，如果给了 block(不为 0)，函数会一直阻塞到队列中有对象为止\n\nQueue 模块可以用来进行线程间通讯，让各个线程之间共享数据。\n\n现在，我们创建一个队列，让 生产者(线程)把新生产的货物放进去供消费者(线程)使用。\n\n```python\n# python2\n#! -*- coding: utf-8 -*-\n\nfrom Queue import Queue\nfrom random import randint\nfrom time import sleep, time\nfrom threading import Thread\n\n\nclass MyThread(Thread):\n\n    def __init__(self, func, args, name=\"\"):\n        super(MyThread, self).__init__()\n        self.name = name\n        self.func = func\n        self.args = args\n\n    def getResult(self):\n        return self.res\n\n    def run(self):\n        # 创建新线程的时候，Thread 对象会调用我们的 ThreadFunc 对象，这时会用到一个特殊函数 __call__()。\n        print 'starting', self.name, 'at:', time()\n        self.res = self.func(*self.args)\n        print self.name, 'finished at:', time()\n\n\n# writeQ()和 readQ()函数分别用来把对象放入队列和消耗队列中的一个对象。在这里我们使用 字符串'xxx'来表示队列中的对象。\ndef writeQ(queue):\n    print 'producing object for Q...'\n    queue.put('xxx', 1)\n    print \"size now\", queue.qsize()\n\n\ndef readQ(queue):\n    queue.get(1)\n    print(\"consumed object from Q... size now\", queue.qsize())\n\n\ndef writer(queue, loops):\n    # writer()函数只做一件事，就是一次往队列中放入一个对象，等待一会，然后再做同样的事\n    for i in range(loops):\n        writeQ(queue)\n        sleep(1)\n\n\ndef reader(queue, loops):\n    # reader()函数只做一件事，就是一次从队列中取出一个对象，等待一会，然后再做同样的事\n    for i in range(loops):\n        readQ(queue)\n        sleep(randint(2, 5))\n\n\n# 设置有多少个线程要被运行\nfuncs = [writer, reader]\nnfuncs = range(len(funcs))\n\n\ndef main():\n    nloops = randint(10, 20)\n    q = Queue(32)\n    threads = []\n\n    for i in nfuncs:\n        t = MyThread(funcs[i], (q, nloops), funcs[i].__name__)\n        threads.append(t)\n\n    for i in nfuncs:\n        threads[i].start()\n\n    for i in nfuncs:\n        threads[i].join()\n        print threads[i].getResult()\n\n    print 'all DONE'\n\n\nif __name__ == '__main__':\n    main()\n```\n\n\n### FAQ\n\n##### 进程与线程。线程与进程的区别是什么?\n\n进程(有时被称为重量级进程)是程序的一次 执行。每个进程都有自己的地址空间，内存，数据栈以及其它记录其运行轨迹的辅助数据。\n线程(有时被称为轻量级进程)跟进程有些相似，不同的是，所有的线程运行在同一个进程中， 共享相同的运行环境。它们可以想像成是在主进程或“主线程”中并行运行的“迷你进程”。\n\n这篇文章很好的解释了 线程和进程的区别，推荐阅读: http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html\n\n##### Python 的线程。在 Python 中，哪一种多线程的程序表现得更好，I/O 密集型的还是计算 密集型的?\n\n由于GIL的缘故，对所有面向 I/O 的(会调用内建的操作系统 C 代码的)程序来说，GIL 会在这个 I/O 调用之 前被释放，以允许其它的线程在这个线程等待 I/O 的时候运行。如果某线程并未使用很多 I/O 操作， 它会在自己的时间片内一直占用处理器(和 GIL)。也就是说，I/O 密集型的 Python 程序比计算密集 型的程序更能充分利用多线程环境的好处。\n\n##### 线程。你认为，多CPU 的系统与一般的系统有什么大的不同?多线程的程序在这种系统上的表现会怎么样?\n\nPython的线程就是C语言的一个pthread，并通过操作系统调度算法进行调度（例如linux是CFS）。为了让各个线程能够平均利用CPU时间，python会计算当前已执行的微代码数量，达到一定阈值后就强制释放GIL。而这时也会触发一次操作系统的线程调度（当然是否真正进行上下文切换由操作系统自主决定）。\n伪代码\n\n```python\nwhile True:\n    acquire GIL\n    for i in 1000:\n        do something\n    release GIL\n    /* Give Operating System a chance to do thread scheduling */\n```\n\n这种模式在只有一个CPU核心的情况下毫无问题。任何一个线程被唤起时都能成功获得到GIL（因为只有释放了GIL才会引发线程调度）。\n但当CPU有多个核心的时候，问题就来了。从伪代码可以看到，从release GIL到acquire GIL之间几乎是没有间隙的。所以当其他在其他核心上的线程被唤醒时，大部分情况下主线程已经又再一次获取到GIL了。这个时候被唤醒执行的线程只能白白的浪费CPU时间，看着另一个线程拿着GIL欢快的执行着。然后达到切换时间后进入待调度状态，再被唤醒，再等待，以此往复恶性循环。\n简单的总结下就是：Python的多线程在多核CPU上，只对于IO密集型计算产生正面效果；而当有至少有一个CPU密集型线程存在，那么多线程效率会由于GIL而大幅下降。\n\n##### 线程池。修改 生成者消费者 的代码，不再是一个生产者和一个消费者，而是可以有任意个 消费者线程(一个线程池)，每个线程可以在任意时刻处理或消耗任意多个产品。\n\n## 参考文章\n\n* [进程与线程的一个简单解释 http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html](http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html)\n* [Python的GIL是什么鬼，多线程性能究竟如何 http://cenalulu.github.io/python/gil-in-python/](http://cenalulu.github.io/python/gil-in-python/)\n* [Python的全局锁问题 http://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p09_dealing_with_gil_stop_worring_about_it.html](http://python3-cookbook.readthedocs.io/zh_CN/latest/c12/p09_dealing_with_gil_stop_worring_about_it.html)\n* [Python线程指南 http://www.cnblogs.com/huxi/archive/2010/06/26/1765808.html](http://www.cnblogs.com/huxi/archive/2010/06/26/1765808.html)\n\n\n|>欢迎关注 | >请我喝芬达|\n------- | -------\n![欢迎关注](http://media.gusibi.mobi/Hy8XHexmzppNKuekLuGxWy8LjdGrQAzZA3mH_e9xltoiYgTFWdvlpZwGWxZESrbK)| ![请我喝芬达](http://media.gusibi.mobi/CO9DwU6ZHnXHD5xuG3GqTsY_IYPl-JdpQrDaOo6tl6PiAGEBDeYFHO7sGQi_VVFc)\n",
      "data": {
        "title": "python并发4：使用thread处理并发",
        "date": "2017-07-02 08:29:39",
        "tags": [
          "python",
          "tutorial",
          "读书笔记",
          "并发"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-threading"
    },
    {
      "content": "\n## 简介\nSanic 是一个和类Flask 的基于Python3.5+的web框架，它编写的代码速度特别快。\n\n除了像Flask 以外，Sanic 还支持以异步请求的方式处理请求。这意味着你可以使用新的 async/await 语法，编写非阻塞的快速的代码。\n\n> 关于 asyncio 包的介绍，请参考之前的一篇文章 [python并发2：使用asyncio处理并发](http://blog.gusibi.site/post/python-asyncio/)\n\nGithub 地址 是 [https://github.com/channelcat/sanic](https://github.com/channelcat/sanic)，感兴趣的可以去贡献代码。\n\n既然它说速度特别快，我们先看下官方提供的 基准测试结果。\n\n## Sanic基准测试\n\n![sanic benchmarks](http://media.gusibi.mobi/Z4kaZYttJBgd10Nl9CxCc9aRv0lpERgpW2tCnnRjHQ7G3Yb0swwrL2qFBORVcRSp)\n\n这个测试的程序运行在 AWS 实例上，系统是Ubuntu，只使用了一个进程。\n\nSanic 的开发者说他们的灵感来自于这篇文章 [uvloop: Blazing fast Python networking](https://magic.io/blog/uvloop-blazing-fast-python-networking/)。\n\n那我们就有必要看下uvloop是个什么库。\n\n## uvloop\n\nuvloop 是 asyncio 默认事件循环的替代品，实现的功能完整，切即插即用。uvloop是用CPython 写的，建于libuv之上。\nuvloop 可以使 asyncio 更快。事实上，它至少比 nodejs、gevent 和其他 Python 异步框架要快两倍 。基于 uvloop 的 asyncio 的速度几乎接近了 Go 程序的速度。\n\n### 安装 uvloop\n\nuvloop 还只能在 *nix 平台 和 Python3.5+以上版本使用。\n使用pip安装：\n```bash\npip install uvloop\n```\n在 asyncio 代码中使用uvloop 也很简单：\n\n```python\nimport asyncio\nimport uvloop\nasyncio.set_event_loop_policy(uvloop.EventLoopPolicy())\n```\n这得代码使得对任何asyncio.get_event_loop() 的调用都将返回一个uvloop实例。\n\n详细的uvloop 介绍可以看下原文：[uvloop: Blazing fast Python networking](https://magic.io/blog/uvloop-blazing-fast-python-networking/)。\n\nuvloop的github地址是[https://github.com/MagicStack/uvloop](https://github.com/MagicStack/uvloop)。\n\n现在我们开始学习Sanic：\n\n## 安装 Sanic \n\n```bash\npip install sanic\n```\n\n### 创建第一个 sanic 代码\n\n```python\nfrom sanic import Sanic\nfrom sanic.response import text\n\napp = Sanic(__name__)\n\n@app.route(\"/\")\nasync def test(request):\n    return text('Hello world!')\n\napp.run(host=\"0.0.0.0\", port=8000, debug=True)\n```\n\n运行代码： `python main.py`, 现在打开浏览器访问 http://0.0.0.0:8000，你会看到 `hello world!`。\n\n如果你熟悉Flask，你会发现，这个语法简直和Flask一模一样。\n\n## 路由（Routing）\n\n路由用于把一个函数绑定到一个 URL。下面是一些基本的例子：\n\n```python\n@app.route('/')\ndef index():\n    return text('Index Page')\n\n@app.route('/hello')\ndef hello():\n    return text('Hello World')\n```\n当然，你还可以动态的变化URL的某些部分，还可以为一个函数指定多个规则。\n\n### 变量规则\n\n通过把 URL 的一部分标记为 <variable_name> 就可以在 URL 中添加变量。标记的 部分会作为关键字参数传递给函数。通过使用 `<converter:variable_name>` ，可以 选择性的加上一个转换器，为变量指定特定的类型，如果传入的类型错误，Sanic会抛出`NotFound`异常。请看下面的例子:\n\n```python\nfrom sanic.response import text\n\n@app.route('/tag/<tag>')\nasync def tag_handler(request, tag):\n    return text('Tag - {}'.format(tag))\n\n@app.route('/number/<integer_arg:int>')\nasync def integer_handler(request, integer_arg):\n    return text('Integer - {}'.format(integer_arg))\n\n@app.route('/number/<number_arg:number>')\nasync def number_handler(request, number_arg):\n    return text('Number - {}'.format(number_arg))\n\n@app.route('/person/<name:[A-z]>')\nasync def person_handler(request, name):\n    return text('Person - {}'.format(name))\n\n@app.route('/folder/<folder_id:[A-z0-9]{0,4}>')\nasync def folder_handler(request, folder_id):\n    return text('Folder - {}'.format(folder_id))\n```\n### HTTP 请求类型\n\n默认情况下，我们定义的URL只支持`GET` 请求，`@app.route`装饰器提供了一个可选参数`methods`，这个参数允许传入所有HTTP 方法。\n例如：\n```python\nfrom sanic.response import text\n\n@app.route('/post', methods=['POST'])\nasync def post_handler(request):\n    return text('POST request - {}'.format(request.json))\n\n@app.route('/get', methods=['GET'])\nasync def get_handler(request):\n    return text('GET request - {}'.format(request.args))\n```\n\n也可以简写为：\n\n```python\nfrom sanic.response import text\n\n@app.post('/post')\nasync def post_handler(request):\n    return text('POST request - {}'.format(request.json))\n\n@app.get('/get')\nasync def get_handler(request):\n    return text('GET request - {}'.format(request.args))\n```\n### add_route 方法\n\n除了`@app.route`装饰器，Sanic 还提供了 `add_route` 方法。\n> `@app.route` 只是包装了 `add_route`方法。\n\n```python\nfrom sanic.response import text\n\n# Define the handler functions\nasync def handler1(request):\n    return text('OK')\n\nasync def handler2(request, name):\n    return text('Folder - {}'.format(name))\n\nasync def person_handler2(request, name):\n    return text('Person - {}'.format(name))\n\n# Add each handler function as a route\napp.add_route(handler1, '/test')\napp.add_route(handler2, '/folder/<name>')\napp.add_route(person_handler2, '/person/<name:[A-z]>', methods=['GET'])\n```\n### URL 构建\n\n如果可以匹配URL，那么Sanic可以生成URL吗？当然可以，url_for() 函数就是用于构建指定函数的URL的。它把函数名称作为第一个参数，其余参数对应URL中的变量，例如：\n```python\n@app.route('/')\nasync def index(request):\n    # generate a URL for the endpoint `post_handler`\n    url = app.url_for('post_handler', post_id=5)\n    # the URL is `/posts/5`, redirect to it\n    return redirect(url)\n\n\n@app.route('/posts/<post_id>')\nasync def post_handler(request, post_id):\n    return text('Post - {}'.format(post_id))\n```\n未定义变量会作为URL的查询参数：\n```python\nurl = app.url_for('post_handler', post_id=5, arg_one='one', arg_two='two')\n# /posts/5?arg_one=one&arg_two=two\n\n# 支持多值参数\nurl = app.url_for('post_handler', post_id=5, arg_one=['one', 'two'])\n# /posts/5?arg_one=one&arg_one=two\n```\n## 使用蓝图（Blueprint）\n\nSanic也提供了和Flask 类似的 Blueprint。\n\nBlueprint有以下用途：\n\n* 把一个应用分解为一套蓝图。这是针对大型应用的理想方案：一个项目可以实例化一个 应用，初始化多个扩展，并注册许多蓝图。\n* 在一个应用的 URL 前缀和（或）子域上注册一个蓝图。 URL 前缀和（或）子域的参数 成为蓝图中所有视图的通用视图参数（缺省情况下）。\n* 使用不同的 URL 规则在应用中多次注册蓝图。\n* 通过蓝图提供模板过滤器、静态文件、模板和其他工具。蓝图不必执行应用或视图 函数。\n\n### blueprint 示例\n\n```python\nfrom sanic import Sanic\nfrom sanic.response import json\nfrom sanic import Blueprint\n\nbp = Blueprint('my_blueprint')\n\n@bp.route('/')\nasync def bp_root(request):\n    return json({'my': 'blueprint'})\n    \napp = Sanic(__name__)\napp.blueprint(bp)\n\napp.run(host='0.0.0.0', port=8000, debug=True)\n```\nSanic 使用 app.blueprint() 方法注册blueprint。\n\n### 使用蓝图注册全局中间件\n\n```python\n@bp.middleware\nasync def print_on_request(request):\n    print(\"I am a spy\")\n\n@bp.middleware('request')\nasync def halt_request(request):\n    return text('I halted the request')\n\n@bp.middleware('response')\nasync def halt_response(request, response):\n    return text('I halted the response')\n```\n\n### 使用蓝图处理异常\n\n```python\n@bp.exception(NotFound)\ndef ignore_404s(request, exception):\n    return text(\"Yep, I totally found the page: {}\".format(request.url))\n```\n\n### 使用蓝图处理静态文件\n\n第一个参数指向当前的Python包\n第二个参数是静态文件的目录\n\n```python\nbp.static('/folder/to/serve', '/web/path')\n```\n\n### 使用url_for\n\n如果要创建页面链接，可以和通常一样使用 url_for() 函数，只是要把蓝图名称作为端点的前缀，并且用一个点（ . ）来 分隔:\n\n```python\n@blueprint_v1.route('/')\nasync def root(request):\n    url = app.url_for('v1.post_handler', post_id=5) # --> '/v1/post/5'\n    return redirect(url)\n\n\n@blueprint_v1.route('/post/<post_id>')\nasync def post_handler(request, post_id):\n    return text('Post {} in Blueprint V1'.format(post_id))\n```\n\n## 操作请求数据\n\n对于web 应用来说对客户端向服务器发送的数据做出相应很重要，在Sanic中由传入的参数 request来提供请求信息。\n\n> <section class=\"caption\">为什么不像Flask 一样提供一个全局变量 request？</section>\n> Flask 是同步请求，每次请求都有一个独立的新线程来处理，这个线程中也只处理这一个请求。而Sanic是基于协程的处理方式，一个线程可以同时处理几个、几十个甚至几百个请求，把request作为全局变量显然会比较难以处理。\n\nRequest 对象常用参数有 \n#### json（any）  json body\n\n```python\nfrom sanic.response import json\n\n@app.route(\"/json\")\ndef post_json(request):\n    return json({ \"received\": True, \"message\": request.json })\n```\n\n\n#### args（dict）  URL请求参数\n?key1=value1&key2=value2  将转变为\n```json\n{'key1': ['value1'], 'key2': ['value2']}\n```\n\n\n#### raw_args（dict） 和args 类似\n?key1=value1&key2=value2  将转变为\n```json\n{'key1': 'value1', 'key2': 'value2'}\n```\n#### form（dict）处理 POST 表单请求，数据是一个字典\n#### body（bytes）处理POST 表单请求，数据是一个字符串\n\n其他参数还有:\n* file\n* ip\n* app\n* url\n* scheme\n* path\n* query_string\n\n详细信息参考文档: [Request Data](http://sanic.readthedocs.io/en/latest/sanic/request_data.html)\n\n## 关于响应\n\nSanic使用response 函数创建响应对象。\n\n* 文本 `response.text('hello world')`\n* html `response.html('<p>hello world</p>')`\n* json `response.json({'hello': 'world'})`\n* file `response.file('/srv/www/hello.txt')`\n* streaming \n\n```python\nfrom sanic import response\n\n@app.route(\"/streaming\")\nasync def index(request):\n    async def streaming_fn(response):\n        response.write('foo')\n        response.write('bar')\n    return response.stream(streaming_fn, content_type='text/plain')\n```\n* redirect `response.file('/json')`\n* raw `response.raw('raw data')`\n* 如果想修改响应的headers可以传入headers 参数\n\n```python\nfrom sanic import response\n\n@app.route('/json')\ndef handle_request(request):\n    return response.json(\n        {'message': 'Hello world!'},\n        headers={'X-Served-By': 'sanic'},\n        status=200\n    )\n```\n## 配置管理\n\n应用总是需要一定的配置的。根据应用环境不同，会需要不同的配置。比如开关调试 模式、设置密钥以及其他依赖于环境的东西。\nSanic 的设计思路是在应用开始时载入配置。你可以在代码中直接硬编码写入配置，也可以使用配置文件。\n\n不管你使用何种方式载入配置，都可以使用 Sanic 的 config 属性来操作配置的值。 Sanic 本身就使用这个对象来保存 一些配置，扩展也可以使用这个对象保存配置。同时这也是你保存配置的地方。\n### 配置入门\nconfig 实质上是一个字典的子类，可以像字典一样操作：\n```python\napp = Sanic('myapp')\napp.config.DB_NAME = 'appdb'\napp.config.DB_USER = 'appuser'\n```\n也可以一次更新多个配置：\n\n```python\ndb_settings = {\n    'DB_HOST': 'localhost',\n    'DB_NAME': 'appdb',\n    'DB_USER': 'appuser'\n}\napp.config.update(db_settings)\n```\n### 从对象导入配置\n```python\nimport myapp.default_settings\n\napp = Sanic('myapp')\napp.config.from_object(myapp.default_settings)\n```\n这里是我写的聊天机器人的真实配置示例：[https://github.com/gusibi/momo/](https://github.com/gusibi/momo/blob/master/app.py#L17)\n\n### 使用配置文件\n如果把配置放在一个单独的文件中会更有用。理想情况下配置文件应当放在应用包的 外面。这样可以在修改配置文件时不影响应用的打包与分发\n常见用法如下:\n```python\napp = Sanic('myapp')\napp.config.from_envvar('MYAPP_SETTINGS')\n```\n首先从 myapp.default_settings 模块载入配置，然后根据 MYAPP_SETTINGS 环境变量所指向的文件的内容重载配置的值。在 启动服务器前，在 Linux 或 OS X 操作系统中，这个环境变量可以在终端中使用 export 命令来设置:\n```bash\n$ export MYAPP_SETTINGS=/path/to/config_file\n$ python myapp.py\n```\n\n## 部署\nSanic 项目还不是特别成熟，现在部署比较简陋。对Gunicorn的支持也不完善。\n详细信息可以 看下这个问题 [Projects built with sanic?](https://github.com/channelcat/sanic/issues/396)\n\n先在说下我的部署方式\n### 使用 supervisord 部署\n\nsupervisord 配置文件： [https://github.com/gusibi/momo/blob/master/supervisord.conf](https://github.com/gusibi/momo/blob/master/supervisord.conf)\n\n启动 方式\n\n```bash\nsupervisord -c supervisor.conf\n```\n\n## 总结\n试用了下Sanic，把之前的一个聊天机器人从Flask 改成了 Sanic。不得不说，如果你有Flask经验，大致看一下Sanic文档就可以直接上手了。\n并且Sanic 的速度比Flask 快很多，只是Sanic配套的包还是太少，用于生产环境有一定的风险。\n\n最后对聊天微信聊天机器人感兴趣的可以看下[https://github.com/gusibi/momo](https://github.com/gusibi/momo)。\n\n## 预告\n\n下一篇将介绍如何使用 Sanic 一步一步创建一个 聊天机器人。\n\n## 参考链接\n* [uvloop: Blazing fast Python networking](https://magic.io/blog/uvloop-blazing-fast-python-networking)\n* [Sanic Githu 地址](https://github.com/channelcat/sanic)\n* [Sanic 文档](http://sanic.readthedocs.io/en/latest/)\n- - - - -\n最后，感谢女朋友支持。\n\n|>欢迎关注 | >请我喝芬达|\n------- | -------\n![欢迎关注](http://media.gusibi.mobi/Hy8XHexmzppNKuekLuGxWy8LjdGrQAzZA3mH_e9xltoiYgTFWdvlpZwGWxZESrbK)| ![请我喝芬达](http://media.gusibi.mobi/CO9DwU6ZHnXHD5xuG3GqTsY_IYPl-JdpQrDaOo6tl6PiAGEBDeYFHO7sGQi_VVFc)\n\n## 彩蛋\n**魔魔是我们家巴哥的名字**\n贴一张魔魔的照片结束本篇文章。\n\n![](http://media.gusibi.mobi/ocViYNLQGTk_wX2aGhazWKH_q2kkpJkxAosa8f8NbLFLBdHt78dEDYRGklBbBT1J)\n\n",
      "data": {
        "title": "python web 框架 Sanci 快速入门",
        "date": "2017-06-25 04:47:34",
        "tags": [
          "python",
          "tutorial",
          "sanic"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "sanic-quickstart"
    },
    {
      "content": "\n最后，感谢女朋友支持。\n\n|>欢迎关注 | >请我喝芬达|\n------- | -------\n![欢迎关注](http://media.gusibi.mobi/Hy8XHexmzppNKuekLuGxWy8LjdGrQAzZA3mH_e9xltoiYgTFWdvlpZwGWxZESrbK)| ![请我喝芬达](http://media.gusibi.mobi/CO9DwU6ZHnXHD5xuG3GqTsY_IYPl-JdpQrDaOo6tl6PiAGEBDeYFHO7sGQi_VVFc)\n",
      "data": {
        "categories": [
          "xxx",
          "xxxx"
        ],
        "date": "2017-06-25 01:41:13",
        "description": "description",
        "permalink": "/post/url-path",
        "tags": [
          "xx",
          "xxxx"
        ],
        "title": "title",
        "published": false,
        "hideInList": false,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-how-to-use-elasticsearch"
    },
    {
      "content": "\n前两篇我们已经介绍了[python 协程的使用](https://gusibi.github.io/post/python-coroutine-1-yield/)和[yield from 的原理](https://gusibi.github.io/post/python-coroutine-yield-from/)，这一篇，我们用一个例子来揭示如何使用协程在单线程中管理并发活动。\n\n## 什么是离散事件仿真\n\nWiki上的定义是：\n\n> 离散事件仿真将系统随时间的变化抽象成一系列的离散时间点上的事件，通过按照事件时间顺序处理事件来演进，是一种事件驱动的仿真世界观。离散事件仿真将系统的变化看做一个事件，因此系统任何的变化都只能是通过处理相应的事件来实现，在两个相邻的事件之间，系统状态维持前一个事件发生后的状态不变。\n\n人话说就是一种把系统建模成一系列事件的仿真系统。在离散事件仿真中，仿真“钟”向前推进的量不是固定的，而是直接推进到下一个事件模型的模拟时间。\n\n假设我们抽象模拟出租车的运营过程，其中一个事件是乘客上车，下一个事件则是乘客下车。不管乘客做了5分钟还是50分钟，一旦下车，仿真钟就会更新，指向此次运营的结束时间。\n\n事件？是不是想到了协程！\n\n协程恰好为实现离散事件仿真提供了合理的抽象。\n\nHUGOMORE42\n\n> 第一门面向对象的语音 Simula 引入协程这个概念就是为了支持仿真。\n> Simpy 是一个实现离散事件仿真的Python包，通过一个协程表示离散事件仿真系统的各个进程。\n\n## 出租车对运营仿真\n\n仿真程序会创建几辆出租车，每辆出租车会拉几个乘客，然后回家。出租车会首先驶离车库，四处徘徊，寻找乘客；拉到乘客后，行程开始；乘客下车后，继续四处徘徊。\n\n徘徊和行程所用的时间使用指数分布生成，我们将时间设为分钟数，以便显示清楚。\n\n完整代码如下：(taxi_sim.py)\n\n```python\n\n#! -*- coding: utf-8 -*-\nimport random\nimport collections\nimport queue\nimport argparse\n\nDEFAULT_NUMBER_OF_TAXIS = 3\nDEFAULT_END_TIME = 180\nSEARCH_DURATION = 5\nTRIP_DURATION = 20\nDEPARTURE_INTERAVAL = 5\n\n\n# time 是事件发生的仿真时间，proc 是出租车进程实例的编号，action是描述活动的字符串\nEvent = collections.namedtuple('Event', 'time proc action')\n\n# 开始 出租车进程\n# 每辆出租车调用一次taxi_process 函数，创建一个生成器对象，表示各辆出租车的运营过程。\ndef taxi_process(ident, trips, start_time=0):\n    '''\n    每次状态变化时向创建事件，把控制权交给仿真器\n    :param ident: 出租车编号\n    :param trips: 出租车回家前的行程数量\n    :param start_time: 离开车库的时间\n    :return: \n    '''\n    time = yield Event(start_time, ident, 'leave garage') # 产出的第一个Event\n    for i in range(trips):  # 每次行程都会执行一遍这个代码块\n        # 产出一个Event实例，表示拉到了乘客 协程在这里暂停 等待下一次send() 激活\n        time = yield Event(time, ident, 'pick up passenger')\n         # 产出一个Event实例，表示乘客下车 协程在这里暂停 等待下一次send() 激活\n        time = yield Event(time, ident, 'drop off passenger')\n    # 指定的行程数量完成后，for 循环结束，最后产出 'going home' 事件。协程最后一次暂停\n    yield Event(time, ident, 'going home')\n    # 协程执行到最后 抛出StopIteration 异常\n\n\ndef compute_duration(previous_action):\n    '''使用指数分布计算操作的耗时'''\n    if previous_action in ['leave garage', 'drop off passenger']:\n        # 新状态是四处徘徊\n        interval = SEARCH_DURATION\n    elif previous_action == 'pick up passenger':\n        # 新状态是开始行程\n        interval = TRIP_DURATION\n    elif previous_action == 'going home':\n        interval = 1\n    else:\n        raise ValueError('Unkonw previous_action: %s' % previous_action)\n    return int(random.expovariate(1/interval)) + 1\n\n\n# 开始仿真\nclass Simulator:\n\n    def __init__(self, procs_map):\n        self.events = queue.PriorityQueue()  # 带优先级的队列 会按时间正向排序\n        self.procs = dict(procs_map) # 从获取的procs_map 参数中创建本地副本，为了不修改用户传入的值\n\n    def run(self, end_time):\n        '''\n        调度并显示事件，直到时间结束\n        :param end_time:  结束时间 只需要指定一个参数\n        :return: \n        '''\n        # 调度各辆出租车的第一个事件\n        for iden, proc in sorted(self.procs.items()):\n            first_event = next(proc)  # 预激协程 并产出一个 Event 对象\n            self.events.put(first_event)  # 把各个事件加到self.events 属性表示的 PriorityQueue对象中\n\n        # 此次仿真的主循环\n        sim_time = 0  # 把 sim_time 归0\n        while sim_time < end_time:\n            if self.events.empty(): # 事件全部完成后退出循环\n                print('*** end of event ***')\n                break\n            current_event = self.events.get() # 获取优先级最高(time 属性最小)的事件\n            sim_time, proc_id, previous_action = current_event # 更新 sim_time\n            print('taxi:', proc_id, proc_id * '  ', current_event)\n            active_proc = self.procs[proc_id]  # 从self.procs 字典中获取表示当前活动的出租车协程\n            next_time = sim_time + compute_duration(previous_action)\n            try:\n                next_event = active_proc.send(next_time)  # 把计算得到的时间发送给出租车协程。协程会产出下一个事件，或者抛出 StopIteration\n            except StopIteration:\n                del self.procs[proc_id]  # 如果有异常 表示已经退出， 删除这个协程\n            else:\n                self.events.put(next_event)  # 如果没有异常，把next_event 加入到队列\n        else:  # 如果超时 则走到这里\n            msg = '*** end of simulation time: {} event pendding ***'\n            print(msg.format(self.events.qsize()))\n\n\n\ndef main(end_time=DEFAULT_END_TIME, num_taxis=DEFAULT_NUMBER_OF_TAXIS,\n         seed=None):\n    '''初始化随机生成器，构建过程，运行仿真程序'''\n    if seed is not None:\n        random.seed(seed)  # 获取可复现的结果\n    # 构建taxis 字典。值是三个参数不同的生成器对象。\n    taxis = {i: taxi_process(i, (i + 1) * 2, i*DEPARTURE_INTERAVAL)\n             for i in range(num_taxis)}\n    sim = Simulator(taxis)\n    sim.run(end_time)\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='Taxi fleet simulator.')\n    parser.add_argument('-e', '--end-time', type=int,\n                        default=DEFAULT_END_TIME,\n                        help='simulation end time; default=%s' % DEFAULT_END_TIME)\n    parser.add_argument('-t', '--taxis', type=int,\n                        default=DEFAULT_NUMBER_OF_TAXIS,\n                        help='number of taxis running; default = %s' % DEFAULT_NUMBER_OF_TAXIS)\n    parser.add_argument('-s', '--seed', type=int, default=None,\n                        help='random generator seed (for testing)')\n\n    args = parser.parse_args()\n    main(args.end_time, args.taxis, args.seed)\n\n```\n\n运行程序，\n\n```sh\n# -s 3 参数设置随机生成器的种子，以便调试的时候随机数不变，输出相同的结果\npython taxi_sim.py -s 3\n```\n\n输出结果如下图\n\n![](http://media.gusibi.mobi/3237874125-5942771d7ee84_articlex.jpeg)\n\n从结果我们可以看出，3辆出租车的行程是交叉进行的。不同颜色的箭头代表不同出租车从乘客上车到乘客下车的跨度。\n\n从结果可以看出：\n\n* 出租车每5隔分钟从车库出发\n* 0 号出租车2分钟后拉到乘客（time=2），1号出租车3分钟后拉到乘客（time=8），2号出租车5分钟后拉到乘客（time=15）\n* 0 号出租车拉了两个乘客\n* 1 号出租车拉了4个乘客\n* 2 号出租车拉了6个乘客\n* 在此次示中，所有排定的事件都在默认的仿真时间内完成\n\n我们先在控制台中调用taxi_process 函数，自己驾驶一辆出租车，示例如下：\n\n```python\nIn [1]: from taxi_sim import taxi_process\n# 创建一个生成器，表示一辆出租车 编号是13 从t=0 开始，有两次行程\nIn [2]: taxi = taxi_process(ident=13, trips=2, start_time=0) \n\nIn [3]: next(taxi) # 预激协程\nOut[3]: Event(time=0, proc=13, action='leave garage')\n\n# 发送当前时间 在控制台中，变量_绑定的是前一个结果\n# _.time + 7 是 0 + 7\nIn [4]: taxi.send(_.time+7) \nOut[4]: Event(time=7, proc=13, action='pick up passenger') # 这个事件有for循环在第一个行程的开头产出\n\n# 发送_.time+12 表示这个乘客用时12分钟\nIn [5]: taxi.send(_.time+12)\nOut[5]: Event(time=19, proc=13, action='drop off passenger')\n\n# 徘徊了29 分钟\nIn [6]: taxi.send(_.time+29)\nOut[6]: Event(time=48, proc=13, action='pick up passenger')\n\n# 乘坐了50分钟\nIn [7]: taxi.send(_.time+50)\nOut[7]: Event(time=98, proc=13, action='drop off passenger')\n\n# 两次行程结束 for 循环结束产出'going home'\nIn [8]: taxi.send(_.time+5)\nOut[8]: Event(time=103, proc=13, action='going home')\n\n# 再发送值，会执行到末尾 协程返回后 抛出 StopIteration 异常\nIn [9]: taxi.send(_.time+10)\n---------------------------------------------------------------------------\nStopIteration                            Traceback (most recent call last)\n<ipython-input-9-d775cc8cc079> in <module>()\n----> 1 taxi.send(_.time+10)\n\nStopIteration:\n```\n\n在这个示例中，我们用控制台模拟仿真主循环。从taxi协程中产出的Event实例中获取 .time 属性，随意加一个数，然后调用send()方法发送两数之和，重新激活协程。\n\n在taxi_sim.py 代码中，出租车协程由 Simulator.run 方法中的主循环驱动。\n\nSimulator 类的主要数据结构如下：\n\nself.events\n\n    PriorityQueue 对象，保存Event实例。元素可以放进PriorityQueue对象中，然后按 item[0](对象的time 属性)依序取出（按从小到大）。\n\nself.procs\n\n    一个字典，把出租车的编号映射到仿真过程的进程（表示出租车生成器的对象）。这个属性会绑定前面所示的taxis字典副本。\n\n> 优先队列是离散事件仿真系统的基础构件：创建事件的顺序不定，放入这种队列后，可以按各个事件排定的顺序取出。\n\n比如，我们把两个事件放入队列：\n\n```python\nEvent(time=14, proc=0, action='pick up passenger')\nEvent(time=10, proc=1, action='pick up passenger')\n```\n\n这个意思是 0号出租车14分拉到一个乘客，1号出租车10分拉到一个乘客。但是主循环获取的第一个事件将是\n\nEvent(time=10, proc=1, action='pick up passenger')\n\n下面我们分析一下仿真系统的主算法--Simulator.run 方法。\n\n1. 迭代表示各辆出租车的进程\n  * 在各辆出租车上调用next()函数，预激协程。\n  * 把各个事件放入Simulator类的self.events属性中。\n2. 满足 sim_time < end_time 条件是，运行仿真系统的主循环。\n  * 检查self.events 属性是否为空；如果为空，跳出循环\n  * 从self.events 中获取当前事件\n  * 显示获取的Event对象\n  * 获取curent_event 的time 属性，更新仿真时间\n  * 把时间发送给current_event 的pro属性标识的协程，产出下一个事件\n  * 把next_event 添加到self.events 队列中，排定 next_event \n\n我们代码中 while 循环有一个else 语句，仿真系统到达结束时间后，代码会执行else中的语句。\n\n这个示例主要是想说明如何在一个主循环中处理事件，以及如何通过发送数据驱动协程，同时解释了如何使用生成器代替线程和回调，实现并发。\n\n> 并发： 多个任务交替执行\n>\n> 并行： 多个任务同时执行\n\n到这里 Python协程系列的三篇文章就结束了。\n\n> 我们会看到，协程做面向事件编程时，会不断把控制权让步给主循环，激活并向前运行其他协程，从而执行各个并发活动。\n>\n> 协程一种协作式多任务：协程显式自主的把控制权让步给中央调度程序。\n>\n> 多线程实现的是抢占式多任务。调度程序可以在任何时刻暂停线程，把控制权交给其他线程\n\n## 前两篇文章\n\n[python 协程1：协程10分钟入门](https://gusibi.github.io/post/python-coroutine-1-yield/)\n[python 协程2：yield from 从入门到精通](https://gusibi.github.io/post/python-coroutine-yield-from/)\n\n再次说明一下，这几篇是《流畅的python》一书的读书笔记，作者提供了大量的扩展阅读，有兴趣的可以看一下。\n\n## 扩展阅读\n\n* [Generator Tricks for Systems Programmers](http://www.dabeaz.com/generators/)\n* [A Curious Course on Coroutines and Concurrency](http://www.dabeaz.com/coroutines/)\n* [Generators: The Final Frontier](http://www.dabeaz.com/finalgenerator/)\n* [greedy algorithm with coroutines](http://seriously.dontusethiscode.com/2013/05/01/greedy-coroutine.html)\n* BinaryTree类、一个简单的XML解析器、和一个任务调度器[Proposal for a yield from statement for Python](http://www.cosc.canterbury.ac.nz/greg.ewing/python/yield-from/yield_from.html)\n* [考虑用协程操作多个函数](http://www.effectivepython.com/2015/03/10/consider-coroutines-to-run-many-functions-concurrently/)\n\n--------------\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "python协程3：用仿真实验学习协程",
        "date": "2017-06-15 11:22:49",
        "tags": [
          "python",
          "tutorial",
          "读书笔记",
          "并发"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-coroutine-3"
    },
    {
      "content": "\n上一篇[python协程1：yield的使用](https://mp.weixin.qq.com/s?__biz=MzAwNjI5MjAzNw==&mid=2655751983&idx=1&sn=e4c093c6e5d6e4e8281d76db7c67eb23)介绍了：\n\n* 生成器作为协程使用时的行为和状态\n* 使用装饰器预激协程\n* 调用方如何使用生成器对象的 .throw(...) 和 .close() 方法控制协程\n\n这一篇将介绍：\n\n* 协程终止时如何返回值\n* yield新句法的用途和语义\n\nHUGOMORE42\n\n## 让协程返回值\n\n先看一个例子：\n这段代码会返回最终均值的结果，每次激活协程时不会产出移动平均值，而是最后一次返回。\n\n```python\n#! -*- coding: utf-8 -*-\n\nfrom collections import namedtuple\n\nResult = namedtuple('Result', 'count average')\n\n\ndef averager():\n    total = 0.0\n    count = 0\n    average = None\n    while True:\n        term = yield\n        if term is None:\n            break  # 为了返回值，协程必须正常终止；这里是退出条件\n        total += term\n        count += 1\n        average = total/count\n    # 返回一个namedtuple，包含count和average两个字段。在python3.3前，如果生成器返回值，会报错\n    return Result(count, average)\n```\n\n我们调用这段代码，结果如下\n\n```python\n>>> coro_avg = averager()\n>>> next(coro_avg)\n>>> coro_avg.send(20) # 并没有返回值\n>>> coro_avg.send(30)\n>>> coro_avg.send(40)\n>>> coro_avg.send(None) # 发送None终止循环，导致协程结束。生成器对象会抛出StopIteration异常。异常对象的value属性保存着返回值。\nTraceback (most recent call last):\n   ...\nStopIteration: Result(count=3, average=30)\n```\n\n> return 表达式的值会传给调用方，*赋值给StopIteration* 异常的一个属性。这样做虽然看着别扭，但为了保留生成器对象耗尽时抛出StopIteration异常的行为，也可以理解。\n\n如果我们想获取协程的返回值，可以这么操作：\n\n```python\n>>> coro_avg = averager()\n>>> next(coro_avg)\n>>> coro_avg.send(20) # 并没有返回值\n>>> coro_avg.send(30)\n>>> coro_avg.send(40)\n>>> try:\n...     coro_avg.send(None)\n... except StopIteration as exc:\n...     result = exc.value\n...\n>>> result\nResult(count=3, average=30)\n\n```\n\n看到这我们会说，这是什么鬼，为什么获取返回值要绕这么一大圈，就没有简单的方法吗？\n\n有的，那就是 *yield from*\n\nyield from 结果会在内部自动捕获StopIteration 异常。这种处理方式与 for 循环处理StopIteration异常的方式一样。\n对于yield from 结构来说，解释器不仅会捕获StopIteration异常，还会把value属性的值变成yield from 表达式的值。\n\n> 在函数外部不能使用yield from（yield也不行）。\n\n既然我们提到了 *yield from* 那yield from 是什么呢？\n\n## yield from\n\nyield from 是 Python3.3 后新加的语言结构。和其他语言的await关键字类似，它表示：*在生成器 gen 中使用 yield from subgen()时，subgen 会获得控制权，把产出的值传个gen的调用方，即调用方可以直接控制subgen。于此同时，gen会阻塞，等待subgen终止。\n\nyield from 可用于简化for循环中的yield表达式。\n\n例如：\n\n```python\ndef gen():\n    for c in 'AB':\n        yield c\n    for i in range(1, 3):\n        yield i\n\nlist(gen())\n['A', 'B', '1', '2']\n```\n\n可以改写为：\n\n```python\ndef gen():\n    yield from 'AB'\n    yield from range(1, 3)\n    \n\nlist(gen())\n['A', 'B', '1', '2']\n```\n\n下面来看一个复杂点的例子：(来自Python cookbook 3 ，github源码地址 [https://github.com/dabeaz/python-cookbook/blob/master/src/4/how_to_flatten_a_nested_sequence/example.py](https://github.com/dabeaz/python-cookbook/blob/master/src/4/how_to_flatten_a_nested_sequence/example.py))\n\n```python\n# Example of flattening a nested sequence using subgenerators\n\nfrom collections import Iterable\n\ndef flatten(items, ignore_types=(str, bytes)):\n    for x in items:\n        if isinstance(x, Iterable) and not isinstance(x, ignore_types):\n            yield from flatten(x) # 这里递归调用，如果x是可迭代对象，继续分解\n        else:\n            yield x\n\nitems = [1, 2, [3, 4, [5, 6], 7], 8]\n\n# Produces 1 2 3 4 5 6 7 8\nfor x in flatten(items):\n    print(x)\n\nitems = ['Dave', 'Paula', ['Thomas', 'Lewis']]\nfor x in flatten(items):\n    print(x)\n```\n\nyield from x 表达式对x对象做的第一件事是，调用 iter(x)，获取迭代器。所以要求x是可迭代对象。\n\nPEP380 的标题是 ”syntax for delegating to subgenerator“(把指责委托给子生成器的句法)。由此我们可以知道，yield from是可以实现嵌套生成器的使用。\n\nyield from 的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，使两者可以直接发送和产出值，还可以直接传入异常，而不用在中间的协程添加异常处理的代码。\n\nyield from 包含几个概念：\n\n* 委派生成器\n\n包含yield from <iterable> 表达式的生成器函数\n\n* 子生成器\n\n从yield from <iterable> 部分获取的生成器。\n\n* 调用方\n\n调用委派生成器的客户端（调用方）代码\n\n这个示意图是 对yield from 的调用过程\n\n![](http://omuo4kh1k.bkt.clouddn.com/z6VQ9oWIy-KOo2eJckn6_FDzRaiZoxdyyvbe-QstGCLw5p5AlJ43coiNPMy23Rup)\n\n委派生成器在 yield from 表达式处暂停时，调用方可以直接把数据发给字生成器，子生成器再把产出的值发送给调用方。子生成器返回之后，解释器会抛出StopIteration异常，并把返回值附加到异常对象上，只是委派生成器恢复。\n\n> 这个图来自于Paul\n Sokolovsky 的 [How Python 3.3 \"yield from\" construct works](http://flupy.org/resources/yield-from.pdf)\n\n 下边这个例子是对yield from 的一个应用：\n\n\n```python\n #! -*- coding: utf-8 -*-\n\nfrom collections import namedtuple\n\n\nResult = namedtuple('Result', 'count average')\n\n\n# 子生成器\n# 这个例子和上边示例中的 averager 协程一样，只不过这里是作为字生成器使用\ndef averager():\n    total = 0.0\n    count = 0\n    average = None\n    while True:\n        # main 函数发送数据到这里 \n        term = yield\n        if term is None: # 终止条件\n            break\n        total += term\n        count += 1\n        average = total/count\n    return Result(count, average) # 返回的Result 会成为grouper函数中yield from表达式的值\n\n\n# 委派生成器\ndef grouper(results, key):\n     # 这个循环每次都会新建一个averager 实例，每个实例都是作为协程使用的生成器对象\n    while True:\n        # grouper 发送的每个值都会经由yield from 处理，通过管道传给averager 实例。grouper会在yield from表达式处暂停，等待averager实例处理客户端发来的值。averager实例运行完毕后，返回的值绑定到results[key] 上。while 循环会不断创建averager实例，处理更多的值。\n        results[key] = yield from averager()\n\n\n# 调用方\ndef main(data):\n    results = {}\n    for key, values in data.items():\n        # group 是调用grouper函数得到的生成器对象，传给grouper 函数的第一个参数是results，用于收集结果；第二个是某个键\n        group = grouper(results, key)\n        next(group)\n        for value in values:\n            # 把各个value传给grouper 传入的值最终到达averager函数中；\n            # grouper并不知道传入的是什么，同时grouper实例在yield from处暂停\n            group.send(value)\n        # 把None传入groupper，传入的值最终到达averager函数中，导致当前实例终止。然后继续创建下一个实例。\n        # 如果没有group.send(None)，那么averager子生成器永远不会终止，委派生成器也永远不会在此激活，也就不会为result[key]赋值\n        group.send(None)\n    report(results)\n\n\n# 输出报告\ndef report(results):\n    for key, result in sorted(results.items()):\n        group, unit = key.split(';')\n        print('{:2} {:5} averaging {:.2f}{}'.format(result.count, group, result.average, unit))\n\n\ndata = {\n    'girls;kg':[40, 41, 42, 43, 44, 54],\n    'girls;m': [1.5, 1.6, 1.8, 1.5, 1.45, 1.6],\n    'boys;kg':[50, 51, 62, 53, 54, 54],\n    'boys;m': [1.6, 1.8, 1.8, 1.7, 1.55, 1.6],\n}\n\nif __name__ == '__main__':\n    main(data)\n```\n\n> 这段代码从一个字典中读取男生和女生的身高和体重。然后把数据传给之前定义的 averager 协程，最后生成一个报告。\n\n执行结果为\n\n```python\n6 boys  averaging 54.00kg\n6 boys  averaging 1.68m\n6 girls averaging 44.00kg\n6 girls averaging 1.58m\n```\n\n这断代码展示了yield from 结构最简单的用法。委派生成器相当于管道，所以可以把任意数量的委派生成器连接在一起---一个委派生成器使用yield from 调用一个子生成器，而那个子生成器本身也是委派生成器，使用yield from调用另一个生成器。最终以一个只是用yield表达式的生成器（或者任意可迭代对象）结束。\n\n## yield from 的意义\n\nPEP380 分6点说明了yield from 的行为。\n\n* 子生成器产出的值都直接传给委派生成器的调用方（客户端代码）\n* 使用send() 方法发给委派生成器的值都直接传给子生成器。如果发送的值是None，那么会调用子生成器的 __next__()方法。如果发送的值不是None，那么会调用子生成器的send()方法。如果调用的方法抛出StopIteration异常，那么委派生成器恢复运行。任何其他异常都会向上冒泡，传给委派生成器。\n* 生成器退出时，生成器（或子生成器）中的return expr 表达式会触发 StopIteration(expr) 异常抛出。\n* yield from表达式的值是子生成器终止时传给StopIteration异常的第一个参数。\n* 传入委派生成器的异常，除了 GeneratorExit 之外都传给子生成器的throw()方法。如果调用throw()方法时抛出 StopIteration 异常，委派生成器恢复运行。StopIteration之外的异常会向上冒泡。传给委派生成器。\n* 如果把 GeneratorExit 异常传入委派生成器，或者在委派生成器上调用close() 方法，那么在子生成器上调用close() 方法，如果他有的话。如果调用close() 方法导致异常抛出，那么异常会向上冒泡，传给委派生成器；否则，委派生成器抛出 GeneratorExit 异常。\n\nyield from的具体语义很难理解，不过我们可以看下Greg Ewing 的伪代码，通过伪代码分析一下：\n\n```python\nRESULT = yield from EXPR\n\n# is semantically equivalent to\n# EXPR 可以是任何可迭代对象，因为获取迭代器_i 使用的是iter()函数。\n_i = iter(EXPR)\ntry:\n    _y = next(_i) # 2 预激字生成器，结果保存在_y 中，作为第一个产出的值\nexcept StopIteration as _e:\n    # 3 如果调用的方法抛出StopIteration异常，获取异常对象的value属性，赋值给_r\n    _r = _e.value\nelse:\n    while 1: # 4 运行这个循环时，委派生成器会阻塞，只能作为调用方和子生成器直接的通道\n        try:\n            _s = yield _y # 5 产出子生成器当前产出的元素；等待调用方发送_s中保存的值。\n        except GeneratorExit as _e:\n            # 6 这一部分是用于关闭委派生成器和子生成器，因为子生成器可以是任意可迭代对象，所以可能没有close() 方法。\n            try:\n                _m = _i.close\n            except AttributeError:\n                pass\n            else:\n                _m()\n            # 如果调用close() 方法导致异常抛出，那么异常会向上冒泡，传给委派生成器；否则，委派生成器抛出 GeneratorExit 异常。\n            raise _e\n        except BaseException as _e: # 7 这一部分处理调用方通过.throw() 方法传入的异常。如果子生成器是迭代器，没有throw()方法，这种情况会导致委派生成器抛出异常\n            _x = sys.exc_info()\n            try:\n                # 传入委派生成器的异常，除了 GeneratorExit 之外都传给子生成器的throw()方法。\n                _m = _i.throw\n            except AttributeError:\n                # 子生成器一迭代器，没有throw()方法， 调用throw()方法时抛出AttributeError异常传给委派生成器\n                raise _e\n            else: # 8\n                try:\n                    _y = _m(*_x)\n                except StopIteration as _e:\n                     # 如果调用throw()方法时抛出 StopIteration 异常，委派生成器恢复运行。\n                     # StopIteration之外的异常会向上冒泡。传给委派生成器。\n                    _r = _e.value\n                    break\n        else: # 9 如果产出值时没有异常\n            try: # 10 尝试让子生成器向前执行\n                if _s is None: \n                    # 11. 如果发送的值是None，那么会调用子生成器的 __next__()方法。\n                    _y = next(_i)\n                else:\n                    # 11. 如果发送的值不是None，那么会调用子生成器的send()方法。\n                    _y = _i.send(_s)\n            except StopIteration as _e: # 12\n                # 2. 如果调用的方法抛出StopIteration异常，获取异常对象的value属性，赋值给_r, 退出循环，委派生成器恢复运行。任何其他异常都会向上冒泡，传给委派生成器。\n                _r = _e.value \n                break\nRESULT = _r #13 返回的结果是 _r 即整个yield from表达式的值\n```\n\n上段代码变量说明:\n\n* _i 迭代器（子生成器）\n* _y 产出的值 （子生成器产出的值）\n* _r 结果 （最终的结果  即整个yield from表达式的值）\n* _s 发送的值 （调用方发给委派生成器的值，这个只会传给子生成器）\n* _e 异常 （异常对象）\n\n我们可以看到在代码的第一个 try 部分 使用 _y = next(_i) 预激了子生成器。这可以看出，上一篇我们使用的用于自动预激的装饰器与yield from 语句不兼容。\n\n除了这段伪代码之外，[PEP380](https://www.python.org/dev/peps/pep-0380/#proposal) 还有个说明：\n\n```python\nIn a generator, the statement\n\nreturn value\n\nis semantically equivalent to\n\nraise StopIteration(value)\n\nexcept that, as currently, the exception cannot be caught by except clauses within the returning generator.\n```\n\n这也就是为什么 yield from 可以使用return 来返回值而 yield 只能使用 try ... except StopIteration ... 来捕获异常的value 值。\n\n```python\n>>> try:\n...     coro_avg.send(None)\n... except StopIteration as exc:\n...     result = exc.value\n...\n>>> result\n```\n\n到这里，我们已经了解了 yield from 的具体细节。下一篇，会分析一个使用协程的经典案例： 仿真编程。这个案例说明了如何使用协程在单线程中管理并发活动。\n\n## 参考文档\n\n* 流畅的python 第16章（这是读书笔记，这是读书笔记）\n* [PEP 380-- Syntax for Delegating to a Subgenerator](https://www.python.org/dev/peps/pep-0380/#proposal)\n* [How Python 3.3 \"yield from\" construct works](http://flupy.org/resources/yield-from.pdf)\n\n----------------\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "title": "python协程2：yield from 从入门到精通",
        "date": "2017-06-14 09:22:49",
        "tags": [
          "python",
          "tutorial",
          "读书笔记"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-coroutine-2"
    },
    {
      "content": "\n\n",
      "data": {
        "permalink": "/post/python-prototype-pattern",
        "title": "python 设计模式 ",
        "author": "goodspeed",
        "tags": [
          "python",
          "设计模式"
        ],
        "date": "2016-12-04 08:22:54",
        "categories": [
          "development",
          "读书笔记",
          "golang"
        ],
        "published": false,
        "hideInList": false,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-prototype-pattern"
    },
    {
      "content": "\n\n## python 数据结构\n\n* Python 的 list 是怎么回事，为什么有近乎无限大小的空间？为什么专门有一个固定长度且不能修改的数据结构 tuple 而不全用 list？\n* list 的 insert 和 append 的费时是一样的吗？\n* Python 的 dict 是怎么回事，为什么可以用字符串数字等等东西来索引？是怎么搜索的？在 dict 中找一个元素，和在 list 里面找一个元素有什么区别？\n* Python 内置的 list, dict, set, ...数据结构，你应该在什么样的场景下使用？\n\nHUGOMORE42\n\nPython中常见的数据结构可以统称为容器（container）。序列（如列表和元组）、映射（如字典）以及集合（set）是三类主要的容器。\n\n### 列表\n\n和字符串一样，列表也是序列式的数据类型，可以通过下标或者切片操作来访问某一个或者某一块连续的元素。\n不同之处：\n1. 列表可以包含不同类型的对象\n2. 列表长度是可变的\n\npython中list并不是我们传统意义上的列表。传统列表--通常也叫做链表（linked list）--通常是由一系列节点来实现的，其每一个节点（尾节点除外）中都持有一个指向下一个节点的引用。\n\n链表的简单实现：\n\n```\n\nclass Node:\n\tdef __init__(self, value, next=None):\n\t\tself.value = value\n\t\tself.next = next\n\n\n>>> L = Node(\"a\", Node(\"b\", Node(\"c\", Node(\"d\"))))\n>>> L.next.next.value\n\n'c'\n\n# 这是一个单向链表。双向链表的各节点中还需持有一个指向前一节点的引用。\n\n# TODO 双向列表的实现\n\n```\n\n但Python中的list则与此有些不同。它不是由若干个独立的节点相互引用而成的，而是一整个单一连续的内存区块--我们通常称之为数组（array）。\n\n\n### 树与图的实现\n\n* 邻接列表及其类似结构\n* 邻接矩阵\n* 树的实现\n\n###\n",
      "data": {
        "permalink": "/post/python-data-structures",
        "title": "Python Data Structures",
        "author": "goodspeed",
        "tags": [
          "python",
          "算法"
        ],
        "date": "2016-10-16 14:03:53",
        "categories": [
          "development",
          "读书笔记",
          "python"
        ],
        "published": false,
        "hideInList": false,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-data-structures"
    },
    {
      "content": "\n##\n\n### \n\n## 参考链接\n\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![扫码关注](http://media.gusibi.mobi/zHqNew3j1brVxSoTkjOerslhnB_ZpchcOXf60lFUxiZ5YtnCHs5HrJNOP14go6Ea)\n\n---------------\n\n### 内推时间\n\n![](http://media.gusibi.mobi/5FzreeM6IYt55JSQMAV63INPIvuPik75FlJAbP1e7Zdlg1WPe6BrHI-q0jkXskGf)",
      "data": {
        "date": "",
        "title": "title",
        "author": "goodspeed",
        "permalink": "/post/url-path",
        "description": "description",
        "tags": [
          "xx",
          "xxxx"
        ],
        "categories": [
          "xxx",
          "xxxx"
        ],
        "published": false,
        "hideInList": false,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-design-pattern-decorator"
    },
    {
      "content": "\n\n最近我们的网站要加微信登录功能，找了python sdk 感觉都不满意，然后就参考instagram python sdk 自己造了轮子。\n\n轮子 github 地址  [python-weixin](https://github.com/gusibi/python-weixin)\n\n### 根据需求选择相应的登录方式\n\n微信现在提供两种登录接入方式\n\n* 移动应用微信登录\n* 网站应用微信登录\n\nHUGOMORE42\n\n*这里我们使用的是网站应用微信登录*\n\n按照 官方流程\n\n1. 注册并通过开放平台开发者资质认证\n\n注册微信开放平台帐号后，在帐号中心中填写开发者资质认证申请，并等待认证通过。\n\n2. 创建网站应用\n\n通过填写网站应用名称、简介和图标，以及各平台下载地址等资料，创建网站应用\n\n3. 接入微信登录\n\n在资源中心查阅网站应用开发文档,开发接入微信登陆功能，让用户可使用微信登录你的网站应用\n\n\n如果已经完成上面的操作，请继续往下看\n\n\n微信网站应用微信登录是基于OAuth2.0协议标准构建的微信OAuth2.0授权登录系统。\n\n微信OAuth2.0授权登录目前支持authorization_code模式，适用于拥有server端的应用授权。该模式整体流程为：\n\n1. 第三方发起微信授权登录请求，微信用户允许授权第三方应用后，微信会拉起应用或重定向到第三方网站，并且带上授权临时票据code参数；\n2. 通过code参数加上AppID和AppSecret等，通过API换取access_token；\n3. 通过access_token进行接口调用，获取用户基本数据资源或帮助用户实现基本操作。\n\n-------\n\n#### 获取access_token 时序图\n\n![获取access_token 时序图](https://res.wx.qq.com/op_res/D0wkkHSbtC6VUSHX4WsjP5ssg5mdnEmXO8NGVGF34dxS9N1WCcq6wvquR4K_Hcut)\n\n\n具体流程请参考官方文档，我们这里只说一下python的实现方法。官方文档地址 [点这里](https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&lang=zh_CN&token=db685a316b7e3933cae42c5ca91d4e024125d1b8&appid=wx6d8c79fb64de6c08)\n\n\n参考python-instagram 我写了一个 [python-weixin] (https://github.com/gusibi/python-weixin)一个微信python SDK\n\n不过现在还只有微信接入、获取用户信息、 刷新refresh_token 等简单功能\n\n-------\n### 安装\n\n#### 方法一 手动安装\n1. 首先 需要把代码clone到本地\n2. python setup.py install\n\n#### 方法二 pip install\n\n```\npip install git+https://github.com/gusibi/python-weixin.git@master\n```\n\n-------\n\n### 使用方式\n\n```python\n\nfrom weixin.client import WeixinAPI\n\nAPP_ID = 'your app id'\nAPP_SECRET = 'your app secret'\nREDIRECT_URI = 'http://your_domain.com/redirect_uri'  # 这里一定要注意 地址一定要加上http/https\n\nscope = (\"snsapi_login\", )\napi = WeixinAPI(appid=APP_ID,\n                app_secret=APP_SECRET,\n                redirect_uri=REDIRECT_URI)\n\nauthorize_url = api.get_authorize_url(scope=scope)\n```\n\n现在将 authorize_url地址(如 http://yoursite.com/login/weixin)在浏览器打开， 将跳转到微信登录页面，使用手机扫码登录后将跳转到\n\nhttp://your_domain.com/redirect_uri?code=CODE&state=STATE 页面\n\n现在我们就可以使用code 来获取登录的 access_token\n\n```python\naccess_token = api.exchange_code_for_access_token(code=code)\n```\n\naccess_token 信息为\n\n```json\n{\n\"access_token\":\"ACCESS_TOKEN\",\n\"expires_in\":7200,\n\"refresh_token\":\"REFRESH_TOKEN\",\n\"openid\":\"OPENID\",\n\"scope\":\"SCOPE\"\n}\n```\n\n|参数\t|说明|\n| ------------- |:-------------|\n|access_token\t|接口调用凭证（有效期目前为2个小时）|\n|expires_in\t|access_token接口调用凭证超时时间，单位（秒）|\n|refresh_token\t|用户刷新access_token（有效期目前为30天）|\n|openid\t|授权用户唯一标识|\n|scope\t|用户授权的作用域，使用逗号（,）分隔|\n\n\n获取access_token后，就可以进行接口调用，有以下前提：\n\n1. access_token有效且未超时；\n2. 微信用户已授权给第三方应用帐号相应接口作用域（scope）。\n\n对于接口作用域（scope），能调用的接口有以下：\n\n| 授权作用域（scope）|接口| 接口说明|\n| ------------- |:------------- |:-----|\n| snsapi_base|/sns/oauth2/access_token\t|通过code换取access_token、refresh_token和已授权scope|\n| snsapi_base| /sns/oauth2/refresh_token\t|刷新或续期access_token使用|\n| snsapi_base| /sns/auth\t|检查access_token有效性|\n| snsapi_userinfo|/sns/userinfo\t|获取用户个人信息|\n\n\n```python\napi = WeixinAPI(appid=APP_ID,\n                app_secret=APP_SECRET,\n                redirect_uri=REDIRECT_URI)\n\n# 刷新或续期access_token使用\nrefresh_token = api.exchange_refresh_token_for_access_token(refresh_token=auth_info['refresh_token'])\n\napi = WeixinAPI(access_token=auth_info['access_token'])\n\n# 获取用户个人信息\nuser = api.user(openid=auth_info['openid'])\n\n# 检查access_token有效性\nv = api.validate_token(openid=auth_info['openid'])\n```\n\n\n现在就微信登录就完成了\n\n-------\n\n下面是用 flask 实现的完整的例子\n\n```python\nfrom flask import Flask\nfrom flask import Markup\nfrom flask import redirect\nfrom flask import request\nfrom flask import jsonify\n\nfrom weixin.client import WeixinAPI\nfrom weixin.oauth2 import OAuth2AuthExchangeError\n\napp = Flask(__name__)\n\nAPP_ID = 'appid'\nAPP_SECRET = 'app secret'\nREDIRECT_URI = 'http://localhost.com/authorization'\n\n\n@app.route(\"/authorization\")\ndef authorization():\n    code = request.args.get('code')\n    api = WeixinAPI(appid=APP_ID,\n                    app_secret=APP_SECRET,\n                    redirect_uri=REDIRECT_URI)\n    auth_info = api.exchange_code_for_access_token(code=code)\n    api = WeixinAPI(access_token=auth_info['access_token'])\n    resp = api.user(openid=auth_info['openid'])\n    return jsonify(resp)\n\n\n@app.route(\"/login\")\ndef login():\n    api = WeixinAPI(appid=APP_ID,\n                    app_secret=APP_SECRET,\n                    redirect_uri=REDIRECT_URI)\n    redirect_uri = api.get_authorize_login_url(scope=(\"snsapi_login\",))\n    return redirect(redirect_uri)\n\n\n@app.route(\"/\")\ndef hello():\n    return Markup('<a href=\"%s\">weixin login!</a>') % '/login'\n\nif __name__ == \"__main__\":\n    app.run(debug=True)\n\n```\n\n#### 参考链接：\n\n* [微信网站应用接入文档](https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&t=resource/res_list&verify=1&lang=zh_CN&token=db685a316b7e3933cae42c5ca91d4e024125d1b8&appid=wx6d8c79fb64de6c08)\n* [网站应用创建地址](https://open.weixin.qq.com/cgi-bin/frame?t=home/web_tmpl&lang=zh_CN)\n* [python-weixin]  (https://github.com/gusibi/python-weixin)\n",
      "data": {
        "title": "网站微信登录－python 实现",
        "date": "2016-09-05 09:59:45",
        "tags": [
          "python",
          "weixin"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-weixin-login"
    },
    {
      "content": "\n## 1. 什么是并发\n\n### 并发和并行什么关系\n\n## 线程与锁模型\n\n### 互斥和内存模型\n\n### 使用python 讲解多线程的互斥和内存模型\n",
      "data": {
        "date": "2016-04-13 14:36:05",
        "title": "七周七并发模型---线程与锁 001",
        "description": "线程与锁-互斥和内存模型",
        "tags": [
          "并发",
          "python"
        ],
        "categories": [
          "读书笔记"
        ],
        "permalink": "/post/seven-concurrentcy-models-thread-and-lock-001",
        "published": false,
        "hideInList": false,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "seven_concurrentcy_models_thread_and_lock_001"
    },
    {
      "content": "\n##\n\n### \n\n## 参考链接\n\n\n------\n\n\n**最后，感谢女朋友支持和包容，比❤️**\n\n也可以在公号输入以下关键字获取历史文章：`公号&小程序` | `设计模式` | `并发&协程`\n\n![](http://media.gusibi.mobi/ah0mqMXMtdJb9Yj03suu-NGEyVRxyEuOIT5bXSv7ip5aqtHkiRjTTl8SMRMv3Qp5)\n",
      "data": {
        "date": "",
        "title": "title",
        "author": "goodspeed",
        "permalink": "/post/url-path",
        "description": "description",
        "tags": [
          "xx",
          "xxxx"
        ],
        "categories": [
          "xxx",
          "xxxx"
        ],
        "published": false,
        "hideInList": false,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "solidity-sample-guide-0x002"
    }
  ],
  "tags": [
    {
      "name": "go",
      "slug": "FwuPbutTv",
      "used": true
    },
    {
      "name": "菜谱",
      "slug": "7Fs1IgCNFG",
      "used": true
    },
    {
      "name": "微服务",
      "slug": "EN0G2etHI",
      "used": true
    },
    {
      "name": "读书笔记",
      "slug": "glQb6dJVjy",
      "used": true
    },
    {
      "name": "Flutter",
      "slug": "j2_8hYGfrO",
      "used": true
    },
    {
      "name": "前端",
      "slug": "3oZfUx_LEv",
      "used": true
    },
    {
      "name": "教程",
      "slug": "pwgh1Pk6jH",
      "used": true
    },
    {
      "name": "tutorial",
      "slug": "dZ-owfp1g-",
      "used": true
    },
    {
      "name": "工具",
      "slug": "ydI7Nu27dS",
      "used": true
    },
    {
      "name": "golang",
      "slug": "h1jl8FQ-xq",
      "used": true
    },
    {
      "name": "python",
      "slug": "GJK-9r_mL4",
      "used": true
    },
    {
      "name": "公众号",
      "slug": "cgMbZVHK_K",
      "used": true
    },
    {
      "name": "DynamoDB",
      "slug": "vcVxmxp3l5",
      "used": true
    },
    {
      "name": "nosql",
      "slug": "rOvUKpmLj1",
      "used": true
    },
    {
      "name": "database",
      "slug": "TSXYO6WF5k",
      "used": true
    },
    {
      "name": "后端",
      "slug": "eo1DNZQqSJ",
      "used": true
    },
    {
      "name": "并发",
      "slug": "RW0o1ban52",
      "used": true
    },
    {
      "name": "restful",
      "slug": "2Lchj1QFpJ",
      "used": true
    },
    {
      "name": "垃圾回收",
      "slug": "0zPWGZjQPcF",
      "used": true
    },
    {
      "name": "算法",
      "slug": "UA8d7APQRBo",
      "used": true
    },
    {
      "name": "xx",
      "slug": "PdnSsFMsSED",
      "used": true
    },
    {
      "name": "xxxx",
      "slug": "IJO993RCN4n",
      "used": true
    },
    {
      "name": "grpc",
      "slug": "EcpvKaZaik0",
      "used": true
    },
    {
      "name": "小程序",
      "slug": "b1TZUgasNVY",
      "used": true
    },
    {
      "name": "weixin",
      "slug": "Q_w_5UsfWI9",
      "used": true
    },
    {
      "name": "development",
      "slug": "T91O6w2BvZT",
      "used": true
    },
    {
      "name": "AWS",
      "slug": "AaHP7VeH3F9",
      "used": true
    },
    {
      "name": "Lambda",
      "slug": "vbjLaAY-vIF",
      "used": true
    },
    {
      "name": "serverless",
      "slug": "r6jdzj9A4Qs",
      "used": true
    },
    {
      "name": "swagger",
      "slug": "pS2KGqpGJbb",
      "used": true
    },
    {
      "name": "css",
      "slug": "lIaqiqSmd_G",
      "used": true
    },
    {
      "name": "html",
      "slug": "w8GRuTJ6yMj",
      "used": true
    },
    {
      "name": "每周分享",
      "slug": "EIIxnocrDtu",
      "used": true
    },
    {
      "name": "redis",
      "slug": "kzWiQsKAWoe",
      "used": true
    },
    {
      "name": "JavaScript",
      "slug": "Ipm7Za2QwaV",
      "used": true
    },
    {
      "name": "设计模式",
      "slug": "2AujKktQOcd",
      "used": true
    },
    {
      "name": "区块链",
      "slug": "2ak9hnAalQN",
      "used": true
    },
    {
      "name": "以太坊",
      "slug": "iPhbGF1dwL9",
      "used": true
    },
    {
      "name": "进程",
      "slug": "2tIM2PZvOTG",
      "used": true
    },
    {
      "name": "sanic",
      "slug": "tHKqIhMy9GJ",
      "used": true
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "首页",
      "openType": "Internal"
    },
    {
      "link": "/archives",
      "name": "归档",
      "openType": "Internal"
    },
    {
      "link": "/tags",
      "name": "标签",
      "openType": "Internal"
    },
    {
      "link": "/post/about",
      "name": "关于",
      "openType": "Internal"
    }
  ]
}